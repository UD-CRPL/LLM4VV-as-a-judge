[
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_update_from.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp teams\" at position 919",
        "issue_id": 0,
        "original_code": "//===---- test_target_update_from.c -------------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks the target update motion clause 'from' by mapping an array \n// to the device with map-type 'to', changing the values of array on the device,\n// and finally using the update 'from' motion clause to assign the value of the \n// list item. Back on the host, measures are taken to ensure the value was properly\n// updated.  \n//===--------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define N 100\n\nint a[N];\nint b[N];\nint c[N];\n\n\n// Test for OpenMP 4.5 target update with to\nint main() {\n  int errors = 0, i = 0, change_flag = 0;\n\n  for (i = 0; i < N; i++) {\n    a[i] = 10;\n    b[i] = 2; \n  }\n\n  // We test for offloading\n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n\n\n#pragma omp target data map(to: a[:N], b[:N]) \n{\n  #pragma omp target\n  {\n    int j = 0;\n    for (j = 0; j < N; j++) {\n      b[j] = (a[j] + b[j]);// b = 12 \n    }\n  } // end target\n\n  #pragma omp target update from(b[:N]) // update b = 12 on host \n\n} //end target-data\n \n  // Checking values of b[N] \n  for (i = 0; i < N; i++) \n    OMPVV_TEST_AND_SET_VERBOSE(errors, (b[i] != 12)); \n\n  #pragma omp target \n  {\n    int j = 0;\n    for (j = 0; j < N; j++) {\n      c[j] = (2* b[j]);// c = 24 \n    }\n  } // end target\n\n  // Checking values of c[N] \n  for (i = 0; i < N; i++) \n    OMPVV_TEST_AND_SET_VERBOSE(errors, (c[i] != 24)); \n    \n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_update_from.c -------------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks the target update motion clause 'from' by mapping an array \n// to the device with map-type 'to', changing the values of array on the device,\n// and finally using the update 'from' motion clause to assign the value of the \n// list item. Back on the host, measures are taken to ensure the value was properly\n// updated.  \n//===--------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define N 100\n\nint a[N];\nint b[N];\nint c[N];\n\n\n// Test for OpenMP 4.5 target update with to\nint main() {\n  int errors = 0, i = 0, change_flag = 0;\n\n  for (i = 0; i < N; i++) {\n    a[i] = 10;\n    b[i] = 2; \n  }\n\n  // We test for offloading\n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n\n\n#pragma omp teams data map(to: a[:N], b[:N]) \n{\n  #pragma omp target\n  {\n    int j = 0;\n    for (j = 0; j < N; j++) {\n      b[j] = (a[j] + b[j]);// b = 12 \n    }\n  } // end target\n\n  #pragma omp target update from(b[:N]) // update b = 12 on host \n\n} //end target-data\n \n  // Checking values of b[N] \n  for (i = 0; i < N; i++) \n    OMPVV_TEST_AND_SET_VERBOSE(errors, (b[i] != 12)); \n\n  #pragma omp target \n  {\n    int j = 0;\n    for (j = 0; j < N; j++) {\n      c[j] = (2* b[j]);// c = 24 \n    }\n  } // end target\n\n  // Checking values of c[N] \n  for (i = 0; i < N; i++) \n    OMPVV_TEST_AND_SET_VERBOSE(errors, (c[i] != 24)); \n    \n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_taskloop_shared.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n    int errors = 0;\n    OMPVV_TEST_OFFLOADING;\n    OMPVV_TEST_AND_SET(errors, taskloop_shared());\n    OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 974",
        "issue_id": 4,
        "original_code": "//===--test_target_taskloop_shared.c ----------------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// Test uses a value within a taskloop & an atomic construct to update the value of\n// s_val. The shared clause ensures that the s_val will be shared between threads,\n// and therefore should be equal to N After the taskloop region.\n//\n////===--------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint taskloop_shared() {\n\n  int errors = 0;\n  int s_val=0;\n\n  #pragma omp target map(tofrom: s_val)\n  {\n    #pragma omp parallel\n    {\n      #pragma omp single\n      #pragma omp taskloop shared(s_val)\n      for (int i = 0; i < N; ++i){\n        #pragma omp atomic update\n        ++s_val; \n      }\n    }\n  }\n  OMPVV_ERROR_IF(s_val != N, \"Value of s_val should be %i, received %i\", N, s_val);\n  OMPVV_TEST_AND_SET(errors, s_val != N);\n  return errors;\n}\n\nint main() {\n    int errors = 0;\n    OMPVV_TEST_OFFLOADING;\n    OMPVV_TEST_AND_SET(errors, taskloop_shared());\n    OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--test_target_taskloop_shared.c ----------------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// Test uses a value within a taskloop & an atomic construct to update the value of\n// s_val. The shared clause ensures that the s_val will be shared between threads,\n// and therefore should be equal to N After the taskloop region.\n//\n////===--------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint taskloop_shared() {\n\n  int errors = 0;\n  int s_val=0;\n\n  #pragma omp target map(tofrom: s_val)\n  {\n    #pragma omp parallel\n    {\n      #pragma omp single\n      #pragma omp taskloop shared(s_val)\n      for (int i = 0; i < N; ++i){\n        #pragma omp atomic update\n        ++s_val; \n      }\n    }\n  }\n  OMPVV_ERROR_IF(s_val != N, \"Value of s_val should be %i, received %i\", N, s_val);\n  OMPVV_TEST_AND_SET(errors, s_val != N);\n  return errors;\n}\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_reduction_bitor.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp atomic\" at position 1355",
        "issue_id": 0,
        "original_code": "//===--- test_target_teams_distribute_reduction_bitor.c----------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the reduction clause on a target teams distribute directive,\n// testing that the variable in the reduction clause is properly reduced using\n// the bitor operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n#define THRESHOLD 1024\n\nint test_bitor() {\n  int a[N];\n  // See the 'and' operator test for an exaplantion of this math.\n  double true_margin = pow(exp(1), log(.5)/N);\n  int errors = 0;\n  int num_teams[N];\n  int num_attempts = 0;\n  int have_true = 0, have_false = 0;\n  srand(1);\n\n  while ((!have_true || !have_false) && (num_attempts < THRESHOLD)) {\n    have_true = 0;\n    have_false = 0;\n    for (int x = 0; x < N; ++x) {\n      for (int y = 0; y < 16; ++y) {\n        if (rand() / (double) RAND_MAX > true_margin) {\n          a[x] += (1 << y);\n          have_true = 1;\n        } else {\n          have_false = 1;\n        }\n      }\n      num_teams[x] = -x;\n    }\n    num_attempts++;\n  }\n\n  OMPVV_WARNING_IF(!have_true, \"No true bits were generated to test\");\n  OMPVV_WARNING_IF(!have_false, \"No false bits were generated to test\");\n\n  unsigned int b = 0;\n\n#pragma omp target teams distribute reduction(|:b) defaultmap(tofrom:scalar)\n  for (int x = 0; x < N; ++x) {\n    num_teams[x] = omp_get_num_teams();\n    b = b | a[x];\n  }\n\n  unsigned int host_b = 0;\n\n  for (int x = 0; x < N; ++x) {\n    host_b = host_b | a[x];\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_teams[x - 1] != num_teams[x], \"Kernel reported differing numbers of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_teams[0] == 1, \"Test operated with one team.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_teams[0] <= 0, \"Test reported invalid number of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, b != host_b);\n  OMPVV_ERROR_IF(host_b != b, \"Bit on device is %d but expected bit from host is %d.\", b, host_b);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_bitor() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_reduction_bitor.c----------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the reduction clause on a target teams distribute directive,\n// testing that the variable in the reduction clause is properly reduced using\n// the bitor operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n#define THRESHOLD 1024\n\nint test_bitor() {\n  int a[N];\n  // See the 'and' operator test for an exaplantion of this math.\n  double true_margin = pow(exp(1), log(.5)/N);\n  int errors = 0;\n  int num_teams[N];\n  int num_attempts = 0;\n  int have_true = 0, have_false = 0;\n  srand(1);\n\n  while ((!have_true || !have_false) && (num_attempts < THRESHOLD)) {\n    have_true = 0;\n    have_false = 0;\n    for (int x = 0; x < N; ++x) {\n      for (int y = 0; y < 16; ++y) {\n        if (rand() / (double) RAND_MAX > true_margin) {\n          a[x] += (1 << y);\n          have_true = 1;\n        } else {\n          have_false = 1;\n        }\n      }\n      num_teams[x] = -x;\n    }\n    num_attempts++;\n  }\n\n  OMPVV_WARNING_IF(!have_true, \"No true bits were generated to test\");\n  OMPVV_WARNING_IF(!have_false, \"No false bits were generated to test\");\n\n  unsigned int b = 0;\n\n#pragma omp atomic teams distribute reduction(|:b) defaultmap(tofrom:scalar)\n  for (int x = 0; x < N; ++x) {\n    num_teams[x] = omp_get_num_teams();\n    b = b | a[x];\n  }\n\n  unsigned int host_b = 0;\n\n  for (int x = 0; x < N; ++x) {\n    host_b = host_b | a[x];\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_teams[x - 1] != num_teams[x], \"Kernel reported differing numbers of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_teams[0] == 1, \"Test operated with one team.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_teams[0] <= 0, \"Test reported invalid number of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, b != host_b);\n  OMPVV_ERROR_IF(host_b != b, \"Bit on device is %d but expected bit from host is %d.\", b, host_b);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_bitor() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_map_local_array.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1130",
        "issue_id": 1,
        "original_code": "//===--- test_target_map_local_array.c --------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// This test will check if an array that is declared and initialized in the host, \n// can be copied over the device, updated there, and then copied back. If this test \n// runs on the host, we will warn that array is not allocated on any device.\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define N 10000\n\nint main() {\n  //define compute array locally\n  int compute_array[N];\n  int sum = 0, errors = 0, result = 0;\n  int i;\n\n  // Host initialization of the array \n  for (i = 0; i < N; i++) \n    compute_array[i] = 0;\n\n  int isOffloading;\n\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n\n  OMPVV_WARNING_IF(!isOffloading, \"This test is running on host, array is not allocated on device\");\n\n#pragma omp target map(tofrom: compute_array[0:N])\n  {\n  \t\n  // Updating the compute_array\n  for (i = 0; i < N; i++)\n      compute_array[i] = i;\n   \n  } // end target\n\n  // Comparing the results\n  for (i = 0; i < N; i++){\n    sum = sum + compute_array[i];    \n    result += i;\n  }\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != sum);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n}\n",
        "error_code": "//===--- test_target_map_local_array.c --------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// This test will check if an array that is declared and initialized in the host, \n// can be copied over the device, updated there, and then copied back. If this test \n// runs on the host, we will warn that array is not allocated on any device.\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define N 10000\n\nint main() {\n  //define compute array locally\n  int compute_array[N];\n  int sum = 0, errors = 0, result = 0;\n  int i;\n\n  // Host initialization of the array \n  for (i = 0; i < N; i++) \n    compute_array[i] = 0;\n\n  int isOffloading;\n\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n\n  OMPVV_WARNING_IF(!isOffloading, \"This test is running on host, array is not allocated on device\");\n\n#pragma omp target map(tofrom: compute_array[0:N])\n  {\n  \t\n  // Updating the compute_array\n  for (i = 0; i < N; i++)\n      compute_array[i] = i;\n   \n  } // end target\n\n  // Comparing the results\n  for (i = 0; i < N; i++)\n    sum = sum + compute_array[i];    \n    result += i;\n  }\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != sum);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_depend_array_section.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 1223",
        "issue_id": 2,
        "original_code": "//===--- test_target_teams_distribute_depend_array_section.c-----------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks if out-out dependency works even if the data in the list\n// is an array section. Both tasks are given the nowait clause to allow\n// for the possibility that they will be incorrectly run out of order. If the\n// two target teams ditribute loops run out of order, the test fails.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_target_teams_distribute_depend_array_section() {\n  int isOffloading = 0;\n  int errors = 0;\n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n    b[x] = 2 * x;\n    c[x] = 0;\n    d[x] = 0;\n  }\n\n#pragma omp target data map(to: a[0:N], b[0:N]) map(alloc: c[0:N]) map(from: d[0:N])\n  {\n#pragma omp target teams distribute nowait depend(out: c[0:N]) map(alloc: a[0:N], b[0:N], c[0:N])\n    for (int x = 0; x < N; ++x) {\n      c[x] = a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(out: c[0:N]) map(alloc: b[0:N], c[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n      d[x] = c[x] + b[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_ERROR_IF(d[x] != 5*x, \"Test of depend clause using array sections did not pass with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n    OMPVV_TEST_AND_SET_VERBOSE(errors, d[x] != 5*x);\n    if (d[x] != 5*x) {\n      break;\n    }\n  }\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  errors += test_target_teams_distribute_depend_array_section();\n  OMPVV_INFOMSG_IF(errors != 0, \"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_depend_array_section.c-----------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks if out-out dependency works even if the data in the list\n// is an array section. Both tasks are given the nowait clause to allow\n// for the possibility that they will be incorrectly run out of order. If the\n// two target teams ditribute loops run out of order, the test fails.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_target_teams_distribute_depend_array_section() {\n  int isOffloading = 0;\n  int errors = 0;\n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n    b[x] = 2 * x;\n    c[x] = 0;\n    d[x] = 0;\n  }\n\n#pragma omp target data map(to: a[0:N], b[0:N]) map(alloc: c[0:N]) map(from: d[0:N])\n  {\n#pragma omp target teams distribute nowait depend(out: c[0:N]) map(alloc: a[0:N], b[0:N], c[0:N])\n    for (int x = 0; x < N; ++x) {\n      c[x] = a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(out: c[0:N]) map(alloc: b[0:N], c[0:N], d[0:N])\n    for (int x = 0; x < N;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1; ++x) {\n      d[x] = c[x] + b[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_ERROR_IF(d[x] != 5*x, \"Test of depend clause using array sections did not pass with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n    OMPVV_TEST_AND_SET_VERBOSE(errors, d[x] != 5*x);\n    if (d[x] != 5*x) {\n      break;\n    }\n  }\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  errors += test_target_teams_distribute_depend_array_section();\n  OMPVV_INFOMSG_IF(errors != 0, \"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_data_map_array_sections.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp for\" at position 1165",
        "issue_id": 0,
        "original_code": "//===--- test_target_data_map_array_sections.c--------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test confirms functionality of the target data map 'from' clause for 1D,\n// 2D, and 3D arrarys that are allocated on the stack. Arrays are first initalized on \n// the host, then allocated on the device and filled with integers, and finally they\n// are copied back to host and checked confirm that correct results return from the\n// device. For each type of array (1D, 2D, 3D), this test provides 3 functions to \n// test data map clause. The 3 forms used for mapping are a[lower:length], a[:length],\n// and a[lower:].\n//\n////===-----------------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nvoid init_1d(int* a);\nvoid init_2d(int a[N][2]);\nvoid init_3d(int a[N][2][2]);\n\n// Test for OpenMP 4.5 target data map with array section [lower:length]\nint test_lower_length_1d() {\n  // array sections of the form a[lower:length] \n  OMPVV_INFOMSG(\"test_lower_length_1d\");\n\n  int errors = 0;\n\n  int a1d[N];\n  init_1d(a1d);\n\n#pragma omp target data map(from: a1d[1:N - 2])\n  {\n#pragma omp target map(alloc: a1d[1:N - 2]) // to avoid default mapping tofrom\n    {\n      for (int i = 1; i < N - 1; ++i)\n        a1d[i] = 1;\n    } // end target\n  } // end target data\n\n  // checking errors\n  for (int i = 0; i < N; ++i) {\n    if (i == 0 || i == N - 1){\n      OMPVV_TEST_AND_SET_VERBOSE(errors, (a1d[i] != 0));\n    }\n    else { \n      OMPVV_TEST_AND_SET_VERBOSE(errors, (a1d[i] != 1)); \n    }\n }\n\n  return errors;\n}\n\n// Test for OpenMP 4.5 target data map with array 2d section [lower:length]\nint test_lower_length_2d() {\n  // array sections of the form a[lower:length]\n  OMPVV_INFOMSG(\"test_lower_length_2d\");\n\n  int errors = 0;\n\n  // stack\n  int a2d[N][2];\n  init_2d(a2d);\n\n  // OpenMP API v 4.5 Nov 2015. 2.15.5.1 map Clause, page 218 line 17: \n  // If a list item is an array section, it must specify contiguous storage.\n#pragma omp target data map(from: a2d[1:N - 2][0:2])\n  {\n#pragma omp target map(alloc: a2d[1:N - 2][0:2]) // to avoid default mapping tofrom\n    {\n      for (int i = 1; i < N - 1; ++i) {\n        a2d[i][0] = 1;\n        a2d[i][1] = 1;\n      }\n    } // end target\n  } // end target data\n\n  // checking errors \n  for (int i = 0; i < N; ++i) {\n    if (i == 0 || i == N - 1){\n      OMPVV_TEST_AND_SET_VERBOSE(errors, a2d[i][0] != 0 && a2d[i][1] != 0);\n    } \n    else {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, a2d[i][0] != 1 && a2d[i][1] != 1);\n   }\n  }\n\n  return errors;\n}\n\n// Test for OpenMP 4.5 target data map with array 3d section [lower:length]\nint test_lower_length_3d() {\n  // array sections of the form a[lower:length] \n  OMPVV_INFOMSG(\"test_lower_length_3d\");\n  // If a list item is an array section, it must specify contiguous storage. \n\n  int errors = 0;\n\n  // stack\n  int a3d[N][2][2];\n  init_3d(a3d);\n  int a3d2[N][2][2];\n  init_3d(a3d2);\n\n  // OpenMP API v 4.5 Nov 2015. 2.15.5.1 map Clause, page 218 line 17: \n  // If a list item is an array section, it must specify contiguous storage.\n#pragma omp target data map(from: a3d[1:N - 2][0:2][0:2])  \\\n        map(from: a3d2[0:N][0:2][0:2])\n  {\n#pragma omp target map(alloc: a3d[1:N - 2][0:2][0:2] ,a3d2[0:N][0:2][0:2]) // to avoid default mapping tofrom\n    {\n      for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < 2; ++j) {\n          if (i > 0 && i < N - 1) {\n            a3d[i][j][0] = 1;\n            a3d[i][j][1] = 1;\n          }\n          a3d2[i][j][0] = 1;\n          a3d2[i][j][1] = 1;\n        }\n      }\n    } // end target\n  } // end target data\n\n  // checking errors\n  for (int i = 0; i < N; ++i) {\n    for (int j = 0; j < 2; ++j) {\n      // a3d\n      if (i == 0 || i == N - 1) {\n        OMPVV_TEST_AND_SET_VERBOSE(errors, a3d[i][j][0] != 0 && a3d[i][j][1] != 0);\n      } \n      else {\n        OMPVV_TEST_AND_SET_VERBOSE(errors, a3d[i][j][0] != 1 && a3d[i][j][1] != 1);\n      }\n      // a3d2\n      OMPVV_TEST_AND_SET_VERBOSE(errors, a3d2[i][j][0] != 1 && a3d2[i][j][1] != 1);\n    }\n  }\n\n  return errors;\n}\n\n// Test for OpenMP 4.5 target data map with array 1d section [:length]\nint test_length_1d() {\n  // array sections of the form a[:length]\n  OMPVV_INFOMSG(\"test_length_1d\");\n\n  int errors = 0;\n\n  int a1d[N];\n  init_1d(a1d);\n\n  // OpenMP API - V4.5 Nov2015. 2.4. Array sections, page 45 line 14: \n  // When the lower-bound is absent it defaults to 0.\n#pragma omp target data map(from: a1d[:N - 2]) \n  {\n#pragma omp target map(alloc: a1d[:N - 2]) // to avoid default mapping tofrom\n    {\n      for (int i = 0; i < N - 2; ++i)\n        a1d[i] = 1;\n    } // end target\n  } // end target data\n\n  // checking errors\n  for (int i = 0; i < N - 2; ++i)\n    OMPVV_TEST_AND_SET_VERBOSE(errors, a1d[i] != 1);\n  // N-2\n  OMPVV_TEST_AND_SET_VERBOSE(errors, a1d[N - 2] != 0);\n  // N-1\n  OMPVV_TEST_AND_SET_VERBOSE(errors, a1d[N - 1] != 0);\n\n  return errors;\n}\n\n// Test for OpenMP 4.5 target data map with array 2d section [:length]\nint test_length_2d() {\n  // array sections of the form a[:length]\n  OMPVV_INFOMSG(\"test_length_2d\");\n\n  int errors = 0;\n\n  int a2d[N][2];\n  init_2d(a2d);\n\n  // OpenMP API - V4.5 Nov2015. 2.4. Array sections, page 45 line 14: \n  // When the lower-bound is absent it defaults to 0.\n  // OpenMP API v 4.5 Nov 2015. 2.15.5.1 map Clause, page 218 line 17:\n  // If a list item is an array section, it must specify contiguous storage.\n#pragma omp target data map(from: a2d[:N - 2][:2])\n  {\n#pragma omp target map(alloc: a2d[:N - 2][:2]) // To avoid default mapping tofrom\n    {\n      for (int i = 0; i < N - 2; ++i) {\n        a2d[i][0] = 1;\n        a2d[i][1] = 1;\n      }\n    } // end target\n  } // end target data\n\n  // checking errors\n  for (int i = 0; i < N - 2; ++i)\n    OMPVV_TEST_AND_SET_VERBOSE(errors, a2d[i][0] != 1 && a2d[i][1] != 1);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, a2d[N - 2][0] != 0 && a2d[N - 2][1] != 0);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, a2d[N - 1][0] != 0 && a2d[N - 1][1] != 0);\n\n  return errors;\n}\n\n// Test for OpenMP 4.5 target data map with array 3d section [:length]\nint test_length_3d() {\n  // array sections of the form a[:length]\n  OMPVV_INFOMSG(\"test_length_3d\");\n\n  int errors = 0;\n\n  int a3d[N][2][2];\n  init_3d(a3d);\n  int a3d2[N][2][2];\n  init_3d(a3d2);\n\n  // OpenMP API - V4.5 Nov2015. 2.4. Array sections, page 45 line 14:\n  // When the lower-bound is absent it defaults to 0.\n  // OpenMP API v 4.5 Nov 2015. 2.15.5.1 map Clause, page 218 line 17:\n  // If a list item is an array section, it must specify contiguous storage.\n#pragma omp target data map(from: a3d[:N - 2][:2][:2])   \\\n        map(from: a3d2[:N][:2][:2])\n  {\n#pragma omp target map(alloc: a3d[:N - 2][:2][:2], a3d2[:N][:2][:2]) // To avoid default mapping tofrom\n    {\n      for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < 2; ++j) {\n          if (i < N - 2) {\n            a3d[i][j][0] = 1;\n            a3d[i][j][1] = 1;\n          }\n          a3d2[i][j][0] = 1;\n          a3d2[i][j][1] = 1;\n        }\n      }\n    } // end target\n  } // end target data\n\n  // checking errors\n  for (int i = 0; i < N; ++i) {\n    for (int j = 0; j < 2; ++j) {\n      if (i >= N - 2) {\n        OMPVV_TEST_AND_SET_VERBOSE(errors, a3d[i][j][0] != 0 && a3d[i][j][1] != 0);\n      } \n      else  \n        OMPVV_TEST_AND_SET_VERBOSE(errors, a3d[i][j][0] != 1 && a3d[i][j][1] != 1)\n      // a3d2\n      OMPVV_TEST_AND_SET_VERBOSE(errors, a3d2[i][j][0] != 1 && a3d2[i][j][1] != 1);\n    }\n  }\n\n  return errors;\n}\n\n// Test for OpenMP 4.5 target data map with array 1d section [lower:]\nint test_lower_1d() {\n  // array sections of the form a[lower:]\n  OMPVV_INFOMSG(\"test_lower_1d\");\n\n  int errors = 0;\n\n  int a1d[N];\n  init_1d(a1d);\n\n  // OpenMP API - V4.5 Nov2015. 2.4. Array sections, page 45 line 13:\n  // When the length is absent, it defaults to the size of the array\n  // dimension minus the lower-bound.\n#pragma omp target data map(from: a1d[1:])\n  {\n#pragma omp target map(alloc: a1d[1:]) // To avoid default mapping tofrom\n    {\n      for (int i = 1; i < N; ++i)\n        a1d[i] = 1;\n    } // end target\n  } // end target data\n\n  // checking errors \n  for (int i = 0; i < N; ++i) {\n    if (i == 0) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, a1d[i] != 0);\n    }\n    else\n      OMPVV_TEST_AND_SET_VERBOSE(errors, a1d[i] != 1);\n  }\n\n  return errors;\n}\n\n// Test for OpenMP 4.5 target data map with array 2d section [lower:]\nint test_lower_2d() {\n  // array sections of the form a[lower:] \n  OMPVV_INFOMSG(\"test_lower_2d\");\n\n  int errors = 0;\n\n  int a2d[N][2];\n  init_2d(a2d);\n\n  // OpenMP API - V4.5 Nov2015. 2.4. Array sections, page 45 line 13: \n  // When the length is absent, it defaults to the size of the array \n  // dimension minus the lower-bound.\n  // OpenMP API v 4.5 Nov 2015. 2.15.5.1 map Clause, page 218 line 17:\n  // If a list item is an array section, it must specify contiguous storage.\n#pragma omp target data map(from: a2d[1:][0:])\n  {\n#pragma omp target map(alloc: a2d[1:][0:]) // To avoid default mapping tofrom\n    {\n      for (int i = 1; i < N; ++i) {\n        a2d[i][0] = 1;\n        a2d[i][1] = 1;\n      }\n    } // end target\n  } // end target data\n\n  // checking errors \n  for (int i = 0; i < N; ++i) {\n    if (i == 0) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, a2d[i][0] != 0 && a2d[i][1] != 0);\n    }\n    else\n      OMPVV_TEST_AND_SET_VERBOSE(errors, a2d[i][0] != 1 && a2d[i][1] != 1)\n  }\n\n  return errors;\n}\n\n// Test for OpenMP 4.5 target data map with array 3d section [lower:]\nint test_lower_3d() {\n  // array sections of the form a[lower:] \n  OMPVV_INFOMSG(\"test_lower_3d\");\n\n  int errors = 0;\n\n  int a3d[N][2][2];\n  init_3d(a3d);\n  int a3d2[N][2][2];\n  init_3d(a3d2);\n\n  // OpenMP API - V4.5 Nov2015. 2.4. Array sections, page 45 line 13: \n  // When the length is absent, it defaults to the size of the array \n  // dimension minus the lower-bound.\n  // OpenMP API v 4.5 Nov 2015. 2.15.5.1 map Clause, page 218 line 17: \n  // If a list item is an array section, it must specify contiguous storage.\n#pragma omp target data map(from: a3d[1:][0:][0:])   \\\n        map(from: a3d2[0:][0:][0:])\n  {\n#pragma omp target map(alloc: a3d[1:][0:][0:], a3d2[0:][0:][0:]) // To avoid default mapping tofrom\n    {\n      for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < 2; ++j) {\n          if (i > 0) {\n            a3d[i][j][0] = 1;\n            a3d[i][j][1] = 1;\n          }\n          a3d2[i][j][0] = 1;\n          a3d2[i][j][1] = 1;\n        }\n      }\n    } // end target\n  } // end target data\n\n  // checking errors \n  for (int i = 0; i < N; ++i) {\n    for (int j = 0; j < 2; ++j) {\n      // a3d\n      if (i == 0) {\n        OMPVV_TEST_AND_SET_VERBOSE(errors, a3d[i][j][0] != 0 && a3d[i][j][1] != 0);\n      } \n      else {\n        OMPVV_TEST_AND_SET_VERBOSE(errors, a3d[i][j][0] != 1 && a3d[i][j][1] != 1);\n      }// a3d2\n      OMPVV_TEST_AND_SET_VERBOSE(errors, a3d2[i][j][0] != 1 && a3d2[i][j][1] != 1);\n    }\n  }\n\n  return errors;\n}\n\nint main() {\n\n  int errors = 0;\n   \n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_lower_length_1d());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_lower_length_2d());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_lower_length_3d());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_length_1d());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_length_2d());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_length_3d());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_lower_1d());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_lower_2d());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_lower_3d());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\nvoid init_1d(int* a) {\n  for (int i = 0; i < N; ++i)\n    a[i] = 0;\n}\n\nvoid init_2d(int a[N][2]) {\n  for (int i = 0; i < N; ++i) {\n    a[i][0] = 0;\n    a[i][1] = 0;\n  }\n}\n\nvoid init_3d(int a[N][2][2]) {\n  for (int i = 0; i < N; ++i)\n    for (int j = 0; j < 2; ++j) {\n      a[i][j][0] = 0;\n      a[i][j][1] = 0;\n    }\n}\n",
        "error_code": "//===--- test_target_data_map_array_sections.c--------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test confirms functionality of the target data map 'from' clause for 1D,\n// 2D, and 3D arrarys that are allocated on the stack. Arrays are first initalized on \n// the host, then allocated on the device and filled with integers, and finally they\n// are copied back to host and checked confirm that correct results return from the\n// device. For each type of array (1D, 2D, 3D), this test provides 3 functions to \n// test data map clause. The 3 forms used for mapping are a[lower:length], a[:length],\n// and a[lower:].\n//\n////===-----------------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nvoid init_1d(int* a);\nvoid init_2d(int a[N][2]);\nvoid init_3d(int a[N][2][2]);\n\n// Test for OpenMP 4.5 target data map with array section [lower:length]\nint test_lower_length_1d() {\n  // array sections of the form a[lower:length] \n  OMPVV_INFOMSG(\"test_lower_length_1d\");\n\n  int errors = 0;\n\n  int a1d[N];\n  init_1d(a1d);\n\n#pragma omp for data map(from: a1d[1:N - 2])\n  {\n#pragma omp target map(alloc: a1d[1:N - 2]) // to avoid default mapping tofrom\n    {\n      for (int i = 1; i < N - 1; ++i)\n        a1d[i] = 1;\n    } // end target\n  } // end target data\n\n  // checking errors\n  for (int i = 0; i < N; ++i) {\n    if (i == 0 || i == N - 1){\n      OMPVV_TEST_AND_SET_VERBOSE(errors, (a1d[i] != 0));\n    }\n    else { \n      OMPVV_TEST_AND_SET_VERBOSE(errors, (a1d[i] != 1)); \n    }\n }\n\n  return errors;\n}\n\n// Test for OpenMP 4.5 target data map with array 2d section [lower:length]\nint test_lower_length_2d() {\n  // array sections of the form a[lower:length]\n  OMPVV_INFOMSG(\"test_lower_length_2d\");\n\n  int errors = 0;\n\n  // stack\n  int a2d[N][2];\n  init_2d(a2d);\n\n  // OpenMP API v 4.5 Nov 2015. 2.15.5.1 map Clause, page 218 line 17: \n  // If a list item is an array section, it must specify contiguous storage.\n#pragma omp target data map(from: a2d[1:N - 2][0:2])\n  {\n#pragma omp target map(alloc: a2d[1:N - 2][0:2]) // to avoid default mapping tofrom\n    {\n      for (int i = 1; i < N - 1; ++i) {\n        a2d[i][0] = 1;\n        a2d[i][1] = 1;\n      }\n    } // end target\n  } // end target data\n\n  // checking errors \n  for (int i = 0; i < N; ++i) {\n    if (i == 0 || i == N - 1){\n      OMPVV_TEST_AND_SET_VERBOSE(errors, a2d[i][0] != 0 && a2d[i][1] != 0);\n    } \n    else {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, a2d[i][0] != 1 && a2d[i][1] != 1);\n   }\n  }\n\n  return errors;\n}\n\n// Test for OpenMP 4.5 target data map with array 3d section [lower:length]\nint test_lower_length_3d() {\n  // array sections of the form a[lower:length] \n  OMPVV_INFOMSG(\"test_lower_length_3d\");\n  // If a list item is an array section, it must specify contiguous storage. \n\n  int errors = 0;\n\n  // stack\n  int a3d[N][2][2];\n  init_3d(a3d);\n  int a3d2[N][2][2];\n  init_3d(a3d2);\n\n  // OpenMP API v 4.5 Nov 2015. 2.15.5.1 map Clause, page 218 line 17: \n  // If a list item is an array section, it must specify contiguous storage.\n#pragma omp target data map(from: a3d[1:N - 2][0:2][0:2])  \\\n        map(from: a3d2[0:N][0:2][0:2])\n  {\n#pragma omp target map(alloc: a3d[1:N - 2][0:2][0:2] ,a3d2[0:N][0:2][0:2]) // to avoid default mapping tofrom\n    {\n      for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < 2; ++j) {\n          if (i > 0 && i < N - 1) {\n            a3d[i][j][0] = 1;\n            a3d[i][j][1] = 1;\n          }\n          a3d2[i][j][0] = 1;\n          a3d2[i][j][1] = 1;\n        }\n      }\n    } // end target\n  } // end target data\n\n  // checking errors\n  for (int i = 0; i < N; ++i) {\n    for (int j = 0; j < 2; ++j) {\n      // a3d\n      if (i == 0 || i == N - 1) {\n        OMPVV_TEST_AND_SET_VERBOSE(errors, a3d[i][j][0] != 0 && a3d[i][j][1] != 0);\n      } \n      else {\n        OMPVV_TEST_AND_SET_VERBOSE(errors, a3d[i][j][0] != 1 && a3d[i][j][1] != 1);\n      }\n      // a3d2\n      OMPVV_TEST_AND_SET_VERBOSE(errors, a3d2[i][j][0] != 1 && a3d2[i][j][1] != 1);\n    }\n  }\n\n  return errors;\n}\n\n// Test for OpenMP 4.5 target data map with array 1d section [:length]\nint test_length_1d() {\n  // array sections of the form a[:length]\n  OMPVV_INFOMSG(\"test_length_1d\");\n\n  int errors = 0;\n\n  int a1d[N];\n  init_1d(a1d);\n\n  // OpenMP API - V4.5 Nov2015. 2.4. Array sections, page 45 line 14: \n  // When the lower-bound is absent it defaults to 0.\n#pragma omp target data map(from: a1d[:N - 2]) \n  {\n#pragma omp target map(alloc: a1d[:N - 2]) // to avoid default mapping tofrom\n    {\n      for (int i = 0; i < N - 2; ++i)\n        a1d[i] = 1;\n    } // end target\n  } // end target data\n\n  // checking errors\n  for (int i = 0; i < N - 2; ++i)\n    OMPVV_TEST_AND_SET_VERBOSE(errors, a1d[i] != 1);\n  // N-2\n  OMPVV_TEST_AND_SET_VERBOSE(errors, a1d[N - 2] != 0);\n  // N-1\n  OMPVV_TEST_AND_SET_VERBOSE(errors, a1d[N - 1] != 0);\n\n  return errors;\n}\n\n// Test for OpenMP 4.5 target data map with array 2d section [:length]\nint test_length_2d() {\n  // array sections of the form a[:length]\n  OMPVV_INFOMSG(\"test_length_2d\");\n\n  int errors = 0;\n\n  int a2d[N][2];\n  init_2d(a2d);\n\n  // OpenMP API - V4.5 Nov2015. 2.4. Array sections, page 45 line 14: \n  // When the lower-bound is absent it defaults to 0.\n  // OpenMP API v 4.5 Nov 2015. 2.15.5.1 map Clause, page 218 line 17:\n  // If a list item is an array section, it must specify contiguous storage.\n#pragma omp target data map(from: a2d[:N - 2][:2])\n  {\n#pragma omp target map(alloc: a2d[:N - 2][:2]) // To avoid default mapping tofrom\n    {\n      for (int i = 0; i < N - 2; ++i) {\n        a2d[i][0] = 1;\n        a2d[i][1] = 1;\n      }\n    } // end target\n  } // end target data\n\n  // checking errors\n  for (int i = 0; i < N - 2; ++i)\n    OMPVV_TEST_AND_SET_VERBOSE(errors, a2d[i][0] != 1 && a2d[i][1] != 1);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, a2d[N - 2][0] != 0 && a2d[N - 2][1] != 0);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, a2d[N - 1][0] != 0 && a2d[N - 1][1] != 0);\n\n  return errors;\n}\n\n// Test for OpenMP 4.5 target data map with array 3d section [:length]\nint test_length_3d() {\n  // array sections of the form a[:length]\n  OMPVV_INFOMSG(\"test_length_3d\");\n\n  int errors = 0;\n\n  int a3d[N][2][2];\n  init_3d(a3d);\n  int a3d2[N][2][2];\n  init_3d(a3d2);\n\n  // OpenMP API - V4.5 Nov2015. 2.4. Array sections, page 45 line 14:\n  // When the lower-bound is absent it defaults to 0.\n  // OpenMP API v 4.5 Nov 2015. 2.15.5.1 map Clause, page 218 line 17:\n  // If a list item is an array section, it must specify contiguous storage.\n#pragma omp target data map(from: a3d[:N - 2][:2][:2])   \\\n        map(from: a3d2[:N][:2][:2])\n  {\n#pragma omp target map(alloc: a3d[:N - 2][:2][:2], a3d2[:N][:2][:2]) // To avoid default mapping tofrom\n    {\n      for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < 2; ++j) {\n          if (i < N - 2) {\n            a3d[i][j][0] = 1;\n            a3d[i][j][1] = 1;\n          }\n          a3d2[i][j][0] = 1;\n          a3d2[i][j][1] = 1;\n        }\n      }\n    } // end target\n  } // end target data\n\n  // checking errors\n  for (int i = 0; i < N; ++i) {\n    for (int j = 0; j < 2; ++j) {\n      if (i >= N - 2) {\n        OMPVV_TEST_AND_SET_VERBOSE(errors, a3d[i][j][0] != 0 && a3d[i][j][1] != 0);\n      } \n      else  \n        OMPVV_TEST_AND_SET_VERBOSE(errors, a3d[i][j][0] != 1 && a3d[i][j][1] != 1)\n      // a3d2\n      OMPVV_TEST_AND_SET_VERBOSE(errors, a3d2[i][j][0] != 1 && a3d2[i][j][1] != 1);\n    }\n  }\n\n  return errors;\n}\n\n// Test for OpenMP 4.5 target data map with array 1d section [lower:]\nint test_lower_1d() {\n  // array sections of the form a[lower:]\n  OMPVV_INFOMSG(\"test_lower_1d\");\n\n  int errors = 0;\n\n  int a1d[N];\n  init_1d(a1d);\n\n  // OpenMP API - V4.5 Nov2015. 2.4. Array sections, page 45 line 13:\n  // When the length is absent, it defaults to the size of the array\n  // dimension minus the lower-bound.\n#pragma omp target data map(from: a1d[1:])\n  {\n#pragma omp target map(alloc: a1d[1:]) // To avoid default mapping tofrom\n    {\n      for (int i = 1; i < N; ++i)\n        a1d[i] = 1;\n    } // end target\n  } // end target data\n\n  // checking errors \n  for (int i = 0; i < N; ++i) {\n    if (i == 0) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, a1d[i] != 0);\n    }\n    else\n      OMPVV_TEST_AND_SET_VERBOSE(errors, a1d[i] != 1);\n  }\n\n  return errors;\n}\n\n// Test for OpenMP 4.5 target data map with array 2d section [lower:]\nint test_lower_2d() {\n  // array sections of the form a[lower:] \n  OMPVV_INFOMSG(\"test_lower_2d\");\n\n  int errors = 0;\n\n  int a2d[N][2];\n  init_2d(a2d);\n\n  // OpenMP API - V4.5 Nov2015. 2.4. Array sections, page 45 line 13: \n  // When the length is absent, it defaults to the size of the array \n  // dimension minus the lower-bound.\n  // OpenMP API v 4.5 Nov 2015. 2.15.5.1 map Clause, page 218 line 17:\n  // If a list item is an array section, it must specify contiguous storage.\n#pragma omp target data map(from: a2d[1:][0:])\n  {\n#pragma omp target map(alloc: a2d[1:][0:]) // To avoid default mapping tofrom\n    {\n      for (int i = 1; i < N; ++i) {\n        a2d[i][0] = 1;\n        a2d[i][1] = 1;\n      }\n    } // end target\n  } // end target data\n\n  // checking errors \n  for (int i = 0; i < N; ++i) {\n    if (i == 0) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, a2d[i][0] != 0 && a2d[i][1] != 0);\n    }\n    else\n      OMPVV_TEST_AND_SET_VERBOSE(errors, a2d[i][0] != 1 && a2d[i][1] != 1)\n  }\n\n  return errors;\n}\n\n// Test for OpenMP 4.5 target data map with array 3d section [lower:]\nint test_lower_3d() {\n  // array sections of the form a[lower:] \n  OMPVV_INFOMSG(\"test_lower_3d\");\n\n  int errors = 0;\n\n  int a3d[N][2][2];\n  init_3d(a3d);\n  int a3d2[N][2][2];\n  init_3d(a3d2);\n\n  // OpenMP API - V4.5 Nov2015. 2.4. Array sections, page 45 line 13: \n  // When the length is absent, it defaults to the size of the array \n  // dimension minus the lower-bound.\n  // OpenMP API v 4.5 Nov 2015. 2.15.5.1 map Clause, page 218 line 17: \n  // If a list item is an array section, it must specify contiguous storage.\n#pragma omp target data map(from: a3d[1:][0:][0:])   \\\n        map(from: a3d2[0:][0:][0:])\n  {\n#pragma omp target map(alloc: a3d[1:][0:][0:], a3d2[0:][0:][0:]) // To avoid default mapping tofrom\n    {\n      for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < 2; ++j) {\n          if (i > 0) {\n            a3d[i][j][0] = 1;\n            a3d[i][j][1] = 1;\n          }\n          a3d2[i][j][0] = 1;\n          a3d2[i][j][1] = 1;\n        }\n      }\n    } // end target\n  } // end target data\n\n  // checking errors \n  for (int i = 0; i < N; ++i) {\n    for (int j = 0; j < 2; ++j) {\n      // a3d\n      if (i == 0) {\n        OMPVV_TEST_AND_SET_VERBOSE(errors, a3d[i][j][0] != 0 && a3d[i][j][1] != 0);\n      } \n      else {\n        OMPVV_TEST_AND_SET_VERBOSE(errors, a3d[i][j][0] != 1 && a3d[i][j][1] != 1);\n      }// a3d2\n      OMPVV_TEST_AND_SET_VERBOSE(errors, a3d2[i][j][0] != 1 && a3d2[i][j][1] != 1);\n    }\n  }\n\n  return errors;\n}\n\nint main() {\n\n  int errors = 0;\n   \n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_lower_length_1d());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_lower_length_2d());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_lower_length_3d());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_length_1d());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_length_2d());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_length_3d());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_lower_1d());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_lower_2d());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_lower_3d());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\nvoid init_1d(int* a) {\n  for (int i = 0; i < N; ++i)\n    a[i] = 0;\n}\n\nvoid init_2d(int a[N][2]) {\n  for (int i = 0; i < N; ++i) {\n    a[i][0] = 0;\n    a[i][1] = 0;\n  }\n}\n\nvoid init_3d(int a[N][2][2]) {\n  for (int i = 0; i < N; ++i)\n    for (int j = 0; j < 2; ++j) {\n      a[i][j][0] = 0;\n      a[i][j][1] = 0;\n    }\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_enter_data_classes_inheritance.cpp",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp declare\" at position 1828",
        "issue_id": 0,
        "original_code": "//===---- test_target_enter_data_classes_inheritance.c - enter data and classes-===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n//\n// This test checks for interoperability between C++ classes and device \n// offloading in the presence of inheritance and templates, and when using \n// target enter and exit data clauses. It considers that 4.5 does not support\n// mapping of attributes directly, as the implicit use of the this-> pointer when \n// using attributes inside the target region is restrictive.\n//\n// The description of the map clause says that the map clause receives a list item:\n//\n// Section 2.15.5.1, page 216, line 17\n//\n// The syntax of the map clause is as follows:\n// map([ [map-type-modifier[,]] map-type : ] list)\n// And the definition of list item is\n//\n// Section 2.1, page 27, line 20\n//\n// A list item is a variable or array section. An extended list item \n// is a list item or a function name.\n//\n// This test creates a base class that, during construction, it maps an \n// attribute through helper \n// variables that remove the direct use to the attributes. And during \n// destruction of the \n//\n// object it maps the data back to the devices. Additionally, there is a modifier \n// method that uses values from the class indirectly through the use of helper references\n// finally there is a synchronization  clause that will obtain the values on demand\n//===----------------------------------------------------------------------------------===//\n//\n//\n\n#include <iostream>\n#include <omp.h>\n#include <cassert>\n#include \"ompvv.h\"\n#include <cmath>\n\n#define N 1000\n\ntemplate<typename T>\nclass Mapper {\nprivate:\n  T* ptr;\n  bool not_mapped;\npublic:\n  Mapper (T* p) : ptr(p) {\n    not_mapped = !omp_target_is_present(ptr, omp_get_default_device());\n    T* solutionPtr = ptr;\n    // maps if target is not present\n#pragma omp target enter data map(to:solutionPtr[0:1]) if(not_mapped)\n  }\n  ~Mapper() {\n    T* solutionPtr = ptr;\n    // unmaps iff this mapper mapped the target\n#pragma omp target exit data map(delete: solutionPtr[0:1]) if(not_mapped)\n    ptr = NULL;\n  }\n};\n\nclass B : public Mapper<B> {\nprotected:\n  int n;\nprivate:\n  double* x;\n  double sumB; \n\npublic:\n  B(int nn) : Mapper<B>(this), n(nn) {\n    x = new double[n];\n    std::fill(x, x+n, 0);\n    // This is a work around to avoid referring to \n    // the class members in the map() clause. see\n    // description\n    double* solutionX = x;\n    int &cpy_n = n;\n#pragma omp target enter data map(to:solutionX[0:n], cpy_n)\n  }\n\n  void modifyB() {\n    double * cpy_x = x; \n    int &cpy_n = n;\n    double &cpy_sumB = sumB;\n#pragma omp target defaultmap(tofrom: scalar)\n    {\n      sumB = 0.0;\n      for (int i = 0; i < cpy_n; ++i) {\n        cpy_x[i] += 1.0;\n        sumB += cpy_x[i];\n      }\n    } \n  }\n\n  void getValuesB(double& b_sum, double* b_array) {\n    double * cpy_x = x;\n    int &cpy_n = n;\n    double &cpy_sum = sumB;\n#pragma omp target defaultmap(tofrom: scalar) map(from: b_array[0:n])\n    {\n      b_sum = cpy_sum;\n      for (int i = 0; i < cpy_n; i++)\n        b_array[i] = cpy_x[i];\n    }\n  }\n\n};\n\nclass A : public Mapper<A>, public B {\nprivate:\n  int sumA; \n  int* y;\n\npublic:\n  A(int s) : Mapper<A>(this), B(s){ \n    y = new int[n];\n    std::fill(y, y+n, 0);\n    int *solutionY = y;\n    int &cpy_n = n;\n    #pragma omp target update to(cpy_n)\n    #pragma omp target enter data map(to:solutionY[0:n])\n  }\n\n  void modifyA() {\n    modifyB();\n    int *cpy_y = y;\n    int &cpy_n = n;\n    int &cpy_sumA = sumA;\n\n#pragma omp target defaultmap(tofrom: scalar)\n    {\n      cpy_sumA = 0;\n      for (int i = 0; i < cpy_n; ++i) {\n        cpy_y[i] += 1;\n        cpy_sumA += cpy_y[i];\n      }\n    }\n  }\n\n  void getValuesA(int &a_sum, int* a_array, double& b_sum, double* b_array) {\n    getValuesB(b_sum, b_array);\n    int* cpy_y = y;\n    int &cpy_n = n;\n    int &cpy_sumA = sumA;\n#pragma omp target defaultmap(tofrom:scalar) map(tofrom: a_array[0:n])\n    {\n      a_sum = cpy_sumA;\n      for (int i = 0; i < cpy_n; i++) {\n        a_array[i] = cpy_y[i];\n      }\n    }\n  }\n  \n};\n\nint test_complex_class() {\n  OMPVV_INFOMSG(\"test_complex_class\");\n\n  int sumY = 0, errors = 0, check_sumY = 0;\n  double sumX = 0.0, check_sumX = 0.0;\n  double * h_array_x = new double[N];\n  int * h_array_y = new int[N];\n\n  // allocation on the device\n  A *obj = new A(N);\n\n  // Each modify adds 1 to the array that is already mappend in the constructor\n  obj->modifyA();\n  obj->modifyA();\n  obj->modifyA();\n  obj->getValuesA(sumY, h_array_y, sumX, h_array_x);\n\n  // checking results\n  for (int i = 0; i < N; ++i) {\n    check_sumY += h_array_y[i];\n    check_sumX += h_array_x[i];\n  }\n\n  delete obj;\n  delete[] h_array_x;\n  delete[] h_array_y;\n  \n  OMPVV_TEST_AND_SET(errors, check_sumY != 3*N);\n  OMPVV_TEST_AND_SET(errors, sumY != 3*N);\n  OMPVV_TEST_AND_SET(errors, std::abs(check_sumX - 3*N) > 0.00001);\n  OMPVV_TEST_AND_SET(errors, std::abs(sumX - 3*N) > 0.00001);\n  OMPVV_ERROR_IF(errors != 0, \"N = %d, sumX = %f, check_sumX = %f, sumY=%d, check_sumY = %d\", N, sumX, check_sumX, sumY, check_sumY);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_complex_class());\n  \n  OMPVV_REPORT_AND_RETURN(errors)\n}\n\n",
        "error_code": "//===---- test_target_enter_data_classes_inheritance.c - enter data and classes-===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n//\n// This test checks for interoperability between C++ classes and device \n// offloading in the presence of inheritance and templates, and when using \n// target enter and exit data clauses. It considers that 4.5 does not support\n// mapping of attributes directly, as the implicit use of the this-> pointer when \n// using attributes inside the target region is restrictive.\n//\n// The description of the map clause says that the map clause receives a list item:\n//\n// Section 2.15.5.1, page 216, line 17\n//\n// The syntax of the map clause is as follows:\n// map([ [map-type-modifier[,]] map-type : ] list)\n// And the definition of list item is\n//\n// Section 2.1, page 27, line 20\n//\n// A list item is a variable or array section. An extended list item \n// is a list item or a function name.\n//\n// This test creates a base class that, during construction, it maps an \n// attribute through helper \n// variables that remove the direct use to the attributes. And during \n// destruction of the \n//\n// object it maps the data back to the devices. Additionally, there is a modifier \n// method that uses values from the class indirectly through the use of helper references\n// finally there is a synchronization  clause that will obtain the values on demand\n//===----------------------------------------------------------------------------------===//\n//\n//\n\n#include <iostream>\n#include <omp.h>\n#include <cassert>\n#include \"ompvv.h\"\n#include <cmath>\n\n#define N 1000\n\ntemplate<typename T>\nclass Mapper {\nprivate:\n  T* ptr;\n  bool not_mapped;\npublic:\n  Mapper (T* p) : ptr(p) {\n    not_mapped = !omp_target_is_present(ptr, omp_get_default_device());\n    T* solutionPtr = ptr;\n    // maps if target is not present\n#pragma omp declare enter data map(to:solutionPtr[0:1]) if(not_mapped)\n  }\n  ~Mapper() {\n    T* solutionPtr = ptr;\n    // unmaps iff this mapper mapped the target\n#pragma omp target exit data map(delete: solutionPtr[0:1]) if(not_mapped)\n    ptr = NULL;\n  }\n};\n\nclass B : public Mapper<B> {\nprotected:\n  int n;\nprivate:\n  double* x;\n  double sumB; \n\npublic:\n  B(int nn) : Mapper<B>(this), n(nn) {\n    x = new double[n];\n    std::fill(x, x+n, 0);\n    // This is a work around to avoid referring to \n    // the class members in the map() clause. see\n    // description\n    double* solutionX = x;\n    int &cpy_n = n;\n#pragma omp target enter data map(to:solutionX[0:n], cpy_n)\n  }\n\n  void modifyB() {\n    double * cpy_x = x; \n    int &cpy_n = n;\n    double &cpy_sumB = sumB;\n#pragma omp target defaultmap(tofrom: scalar)\n    {\n      sumB = 0.0;\n      for (int i = 0; i < cpy_n; ++i) {\n        cpy_x[i] += 1.0;\n        sumB += cpy_x[i];\n      }\n    } \n  }\n\n  void getValuesB(double& b_sum, double* b_array) {\n    double * cpy_x = x;\n    int &cpy_n = n;\n    double &cpy_sum = sumB;\n#pragma omp target defaultmap(tofrom: scalar) map(from: b_array[0:n])\n    {\n      b_sum = cpy_sum;\n      for (int i = 0; i < cpy_n; i++)\n        b_array[i] = cpy_x[i];\n    }\n  }\n\n};\n\nclass A : public Mapper<A>, public B {\nprivate:\n  int sumA; \n  int* y;\n\npublic:\n  A(int s) : Mapper<A>(this), B(s){ \n    y = new int[n];\n    std::fill(y, y+n, 0);\n    int *solutionY = y;\n    int &cpy_n = n;\n    #pragma omp target update to(cpy_n)\n    #pragma omp target enter data map(to:solutionY[0:n])\n  }\n\n  void modifyA() {\n    modifyB();\n    int *cpy_y = y;\n    int &cpy_n = n;\n    int &cpy_sumA = sumA;\n\n#pragma omp target defaultmap(tofrom: scalar)\n    {\n      cpy_sumA = 0;\n      for (int i = 0; i < cpy_n; ++i) {\n        cpy_y[i] += 1;\n        cpy_sumA += cpy_y[i];\n      }\n    }\n  }\n\n  void getValuesA(int &a_sum, int* a_array, double& b_sum, double* b_array) {\n    getValuesB(b_sum, b_array);\n    int* cpy_y = y;\n    int &cpy_n = n;\n    int &cpy_sumA = sumA;\n#pragma omp target defaultmap(tofrom:scalar) map(tofrom: a_array[0:n])\n    {\n      a_sum = cpy_sumA;\n      for (int i = 0; i < cpy_n; i++) {\n        a_array[i] = cpy_y[i];\n      }\n    }\n  }\n  \n};\n\nint test_complex_class() {\n  OMPVV_INFOMSG(\"test_complex_class\");\n\n  int sumY = 0, errors = 0, check_sumY = 0;\n  double sumX = 0.0, check_sumX = 0.0;\n  double * h_array_x = new double[N];\n  int * h_array_y = new int[N];\n\n  // allocation on the device\n  A *obj = new A(N);\n\n  // Each modify adds 1 to the array that is already mappend in the constructor\n  obj->modifyA();\n  obj->modifyA();\n  obj->modifyA();\n  obj->getValuesA(sumY, h_array_y, sumX, h_array_x);\n\n  // checking results\n  for (int i = 0; i < N; ++i) {\n    check_sumY += h_array_y[i];\n    check_sumX += h_array_x[i];\n  }\n\n  delete obj;\n  delete[] h_array_x;\n  delete[] h_array_y;\n  \n  OMPVV_TEST_AND_SET(errors, check_sumY != 3*N);\n  OMPVV_TEST_AND_SET(errors, sumY != 3*N);\n  OMPVV_TEST_AND_SET(errors, std::abs(check_sumX - 3*N) > 0.00001);\n  OMPVV_TEST_AND_SET(errors, std::abs(sumX - 3*N) > 0.00001);\n  OMPVV_ERROR_IF(errors != 0, \"N = %d, sumX = %f, check_sumX = %f, sumY=%d, check_sumY = %d\", N, sumX, check_sumX, sumY, check_sumY);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_complex_class());\n  \n  OMPVV_REPORT_AND_RETURN(errors)\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_parallel_for_num_teams.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp atomic\" at position 995",
        "issue_id": 0,
        "original_code": "//===---- tests_target_teams_distribute_parallel_for_num_teams.c     ------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// Test to check the num_teams clause. This clause changes the upper limit of \n// the number of teams inside the target teams region. \n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define N 1024\n\nint test_target_teams_distribute_parallel_for_num_teams() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_num_teams\");\n \n  int tested_num_teams[] = {1, 10, 100, 10000};\n  int num_teams[N]; // num_teams = 1 is not technically an error\n  int errors = 0;\n  int i, nt;\n\n  int raiseWarningOneTeam = 0;\n\n  // Trying multiple num_teams values from 1 to a large number\n  for (nt = 0; nt < 4; nt++) {\n  \n    OMPVV_INFOMSG(\"Testing for num_teams(%d)\", tested_num_teams[nt]);\n    // Initializing the num_teams array\n    for (i = 0; i < N; i++) {\n      num_teams[i] = -1;\n    }\n#pragma omp target teams distribute parallel for          \\\n  map(tofrom: num_teams) num_teams(tested_num_teams[nt])\n    for (i = 0; i < N; i++) {\n      num_teams[i] = omp_get_num_teams();\n    }\n\n    int raiseWarningDifNum = 0;\n    int prevNumTeams = -1;\n    \n    for (i = 0; i < N; i++) {\n      OMPVV_INFOMSG_IF(prevNumTeams != num_teams[i], \" %d teams reported\", num_teams[i]);\n      prevNumTeams = num_teams[i];\n      // If the number of teams is larger than the specified, this is an error\n      OMPVV_TEST_AND_SET(errors, num_teams[i] <= 0 || num_teams[i] > tested_num_teams[nt]);\n      if (num_teams[i] != tested_num_teams[nt]) \n        raiseWarningDifNum = 1;\n      if (num_teams[i] == 1)\n        raiseWarningOneTeam++; \n    }\n    \n    // We want to raise a warning when the number of teams does not match the desired value. \n    OMPVV_WARNING_IF(raiseWarningDifNum != 0, \"When testing for num_teams(%d), the actual number of teams was different. Not a compliance error with the specs\", tested_num_teams[nt]);  \n  }\n\n  OMPVV_WARNING_IF(raiseWarningOneTeam == 4*N, \"The num_teams clause always resulted in a single team. Although this is complant with the specs, it is not expected\");  \n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_num_teams());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- tests_target_teams_distribute_parallel_for_num_teams.c     ------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// Test to check the num_teams clause. This clause changes the upper limit of \n// the number of teams inside the target teams region. \n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define N 1024\n\nint test_target_teams_distribute_parallel_for_num_teams() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_num_teams\");\n \n  int tested_num_teams[] = {1, 10, 100, 10000};\n  int num_teams[N]; // num_teams = 1 is not technically an error\n  int errors = 0;\n  int i, nt;\n\n  int raiseWarningOneTeam = 0;\n\n  // Trying multiple num_teams values from 1 to a large number\n  for (nt = 0; nt < 4; nt++) {\n  \n    OMPVV_INFOMSG(\"Testing for num_teams(%d)\", tested_num_teams[nt]);\n    // Initializing the num_teams array\n    for (i = 0; i < N; i++) {\n      num_teams[i] = -1;\n    }\n#pragma omp atomic teams distribute parallel for          \\\n  map(tofrom: num_teams) num_teams(tested_num_teams[nt])\n    for (i = 0; i < N; i++) {\n      num_teams[i] = omp_get_num_teams();\n    }\n\n    int raiseWarningDifNum = 0;\n    int prevNumTeams = -1;\n    \n    for (i = 0; i < N; i++) {\n      OMPVV_INFOMSG_IF(prevNumTeams != num_teams[i], \" %d teams reported\", num_teams[i]);\n      prevNumTeams = num_teams[i];\n      // If the number of teams is larger than the specified, this is an error\n      OMPVV_TEST_AND_SET(errors, num_teams[i] <= 0 || num_teams[i] > tested_num_teams[nt]);\n      if (num_teams[i] != tested_num_teams[nt]) \n        raiseWarningDifNum = 1;\n      if (num_teams[i] == 1)\n        raiseWarningOneTeam++; \n    }\n    \n    // We want to raise a warning when the number of teams does not match the desired value. \n    OMPVV_WARNING_IF(raiseWarningDifNum != 0, \"When testing for num_teams(%d), the actual number of teams was different. Not a compliance error with the specs\", tested_num_teams[nt]);  \n  }\n\n  OMPVV_WARNING_IF(raiseWarningOneTeam == 4*N, \"The num_teams clause always resulted in a single team. Although this is complant with the specs, it is not expected\");  \n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_num_teams());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_reduction_subtract.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_subtraction() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\" at position 1645",
        "issue_id": 4,
        "original_code": "//===--- test_target_teams_distribute_reduction_subtract.c----------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the reduction clause on a target teams distribute directive,\n// testing that the variable in the reduction clause is properly reduced using\n// the subtract operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_subtraction() {\n  int a[N];\n  int b[N];\n  int total = 0;\n  int host_total = 0;\n  int errors = 0;\n  int num_teams[N];\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    num_teams[x] = -x;\n  }\n\n#pragma omp target teams distribute reduction(-:total) defaultmap(tofrom:scalar)\n  for (int x = 0; x < N; ++x) {\n    num_teams[x] = omp_get_num_teams();\n    total -= a[x] + b[x];\n  }\n\n  for (int x = 0; x < N; ++x) {\n    host_total -= a[x] + b[x];\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_teams[x - 1] != num_teams[x], \"Kernel reported differing numbers of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_teams[0] == 1, \"Test operated with one team.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_teams[0] <= 0, \"Test reported invalid number of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, host_total != total);\n  OMPVV_ERROR_IF(host_total != total, \"Total on device is %d but expected total from host is %d.\", total, host_total);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_subtraction() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_reduction_subtract.c----------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the reduction clause on a target teams distribute directive,\n// testing that the variable in the reduction clause is properly reduced using\n// the subtract operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_subtraction() {\n  int a[N];\n  int b[N];\n  int total = 0;\n  int host_total = 0;\n  int errors = 0;\n  int num_teams[N];\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    num_teams[x] = -x;\n  }\n\n#pragma omp target teams distribute reduction(-:total) defaultmap(tofrom:scalar)\n  for (int x = 0; x < N; ++x) {\n    num_teams[x] = omp_get_num_teams();\n    total -= a[x] + b[x];\n  }\n\n  for (int x = 0; x < N; ++x) {\n    host_total -= a[x] + b[x];\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_teams[x - 1] != num_teams[x], \"Kernel reported differing numbers of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_teams[0] == 1, \"Test operated with one team.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_teams[0] <= 0, \"Test reported invalid number of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, host_total != total);\n  OMPVV_ERROR_IF(host_total != total, \"Total on device is %d but expected total from host is %d.\", total, host_total);\n\n  return errors;\n}\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_reduction_and.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp declare\" at position 1279",
        "issue_id": 0,
        "original_code": "//===--- test_target_teams_distribute_reduction_and.c------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the reduction clause on a target teams distribute directive,\n// testing that the variable in the reduction clause is properly reduced using\n// the and operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n#define THRESHOLD 512\n\nint test_and() {\n  char a[N];\n      // The below calculation is meant to ensure about half the arrays we will\n      // test will come out to true under the 'and' operator, and the rest false.\n      // For the and operator, a test array that comes out true requires every\n      // entry to be false, which is why this margin is so close to 100%.\n  double false_margin = pow(exp(1), log(.5)/N);\n  int errors = 0;\n  int num_teams[N];\n  int tested_true = 0;\n  int tested_false = 0;\n  int itr_count = 0;\n  srand(1);\n\n  while ((!tested_true || !tested_false) && (itr_count < THRESHOLD)) {\n    for (int x = 0; x < N; ++x) {\n      a[x] = (rand() / (double) (RAND_MAX) < false_margin);\n      num_teams[x] = -x;\n    }\n\n    char result = 1;\n    char host_result = 1;\n\n#pragma omp target teams distribute reduction(&&:result) defaultmap(tofrom:scalar)\n    for (int x = 0; x < N; ++x) {\n      num_teams[x] = omp_get_num_teams();\n      result = result && a[x];\n    }\n\n    for (int x = 0; x < N; ++x) {\n      host_result = host_result && a[x];\n    }\n\n    if (itr_count == 0) {\n      for (int x = 1; x < N; ++x) {\n        OMPVV_WARNING_IF(num_teams[x - 1] != num_teams[x], \"Kernel reported differing numbers of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n      }\n      OMPVV_WARNING_IF(num_teams[0] == 1, \"Test operated with one team.  Reduction clause cannot be tested.\");\n      OMPVV_WARNING_IF(num_teams[0] <= 0, \"Test reported invalid number of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n    }\n\n    OMPVV_TEST_AND_SET_VERBOSE(errors, host_result != result);\n    OMPVV_ERROR_IF(host_result != result, \"Result on device is %d but expected result from host is %d.\", result, host_result);\n\n    if (host_result) {\n      tested_true = 1;\n    } else {\n      tested_false = 1;\n    }\n\n    if (host_result != result) {\n      break;\n    }\n\n    itr_count++;\n  }\n\n  OMPVV_WARNING_IF(!tested_true, \"Did not test a case in which final result was true.\");\n  OMPVV_WARNING_IF(!tested_false, \"Did not test a case in which final result was false.\");\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_and() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_reduction_and.c------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the reduction clause on a target teams distribute directive,\n// testing that the variable in the reduction clause is properly reduced using\n// the and operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n#define THRESHOLD 512\n\nint test_and() {\n  char a[N];\n      // The below calculation is meant to ensure about half the arrays we will\n      // test will come out to true under the 'and' operator, and the rest false.\n      // For the and operator, a test array that comes out true requires every\n      // entry to be false, which is why this margin is so close to 100%.\n  double false_margin = pow(exp(1), log(.5)/N);\n  int errors = 0;\n  int num_teams[N];\n  int tested_true = 0;\n  int tested_false = 0;\n  int itr_count = 0;\n  srand(1);\n\n  while ((!tested_true || !tested_false) && (itr_count < THRESHOLD)) {\n    for (int x = 0; x < N; ++x) {\n      a[x] = (rand() / (double) (RAND_MAX) < false_margin);\n      num_teams[x] = -x;\n    }\n\n    char result = 1;\n    char host_result = 1;\n\n#pragma omp declare teams distribute reduction(&&:result) defaultmap(tofrom:scalar)\n    for (int x = 0; x < N; ++x) {\n      num_teams[x] = omp_get_num_teams();\n      result = result && a[x];\n    }\n\n    for (int x = 0; x < N; ++x) {\n      host_result = host_result && a[x];\n    }\n\n    if (itr_count == 0) {\n      for (int x = 1; x < N; ++x) {\n        OMPVV_WARNING_IF(num_teams[x - 1] != num_teams[x], \"Kernel reported differing numbers of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n      }\n      OMPVV_WARNING_IF(num_teams[0] == 1, \"Test operated with one team.  Reduction clause cannot be tested.\");\n      OMPVV_WARNING_IF(num_teams[0] <= 0, \"Test reported invalid number of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n    }\n\n    OMPVV_TEST_AND_SET_VERBOSE(errors, host_result != result);\n    OMPVV_ERROR_IF(host_result != result, \"Result on device is %d but expected result from host is %d.\", result, host_result);\n\n    if (host_result) {\n      tested_true = 1;\n    } else {\n      tested_false = 1;\n    }\n\n    if (host_result != result) {\n      break;\n    }\n\n    itr_count++;\n  }\n\n  OMPVV_WARNING_IF(!tested_true, \"Did not test a case in which final result was true.\");\n  OMPVV_WARNING_IF(!tested_false, \"Did not test a case in which final result was false.\");\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_and() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_enter_exit_data_map_pointer_translation.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 3604",
        "issue_id": 1,
        "original_code": "//===---- test_target_enter_exit_data_map_pointer_translation.c-------- ===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// According to the OpenMP Specs, if a pointer is used in the mapping of a variable\n// and the pointer points to a host array that is already available in the device,\n// this pointer's address has to be updated with the device address. \n//\n// See page 105, lines 24 throuhg 32. \n//\n// This test check these conditions are valid for target enter exit data clauses \n//\n//===----------------------------------------------------------------------===//\n\n#include \"ompvv.h\"\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 1000\n\nint test_map_same_function() {\n\n  OMPVV_INFOMSG(\"Testing map same function definition\")\n\n  int sum = 0, sum2 = 0, errors = 0;\n\n  // host arrays: heap and stack\n  int *h_array_h = (int *)malloc(N * sizeof(int));\n  int h_array_s[N];\n\n  // Pointers to be used for the translation\n  int *ptr_h_array_h;\n  int *ptr_h_array_s;\n\n#pragma omp target enter data map(alloc:h_array_h[0:N]) map(alloc:h_array_s[0:N])\n\n    ptr_h_array_h = h_array_h;\n    ptr_h_array_s = h_array_s;\n\n    OMPVV_INFOMSG(\"map(ptr) specified full-length array section\")\n#pragma omp target map(ptr_h_array_h[0:N], ptr_h_array_s[0:N])\n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] = 1;\n        ptr_h_array_s[i] = 2;\n      }\n    } // end target\n\n    OMPVV_INFOMSG(\"map(ptr) specified zero-length array section\")\n#pragma omp target map(ptr_h_array_h[:0], ptr_h_array_s[:0])\n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] += 1;\n        ptr_h_array_s[i] += 2;\n      }\n    } // end target\n\n    OMPVV_INFOMSG(\"no map(ptr) Specified\")\n#pragma omp target \n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] += 1;\n        ptr_h_array_s[i] += 2;\n      }\n    } // end target\n#pragma omp target exit data map(from:h_array_h[0:N]) map(from:h_array_s[0:N])\n\n  // checking results\n  for (int i = 0; i < N; ++i) {\n    sum += h_array_h[i];\n    sum2 += h_array_s[i];\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (3*N != sum) || (6*N != sum2));\n\n  free(h_array_h);\n  return errors;\n}\n\nvoid helper_function(int *ptr_h_array_h, int *ptr_h_array_s) {\n\n    OMPVV_INFOMSG(\"map(ptr) specified full-length array section\")\n#pragma omp target map(ptr_h_array_h[0:N], ptr_h_array_s[0:N])\n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] = 1;\n        ptr_h_array_s[i] = 2;\n      }\n    } // end target\n\n    OMPVV_INFOMSG(\"map(ptr) specified zero-length array section\")\n#pragma omp target map(ptr_h_array_h[:0], ptr_h_array_s[:0])\n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] += 1;\n        ptr_h_array_s[i] += 2;\n      }\n    } // end target\n\n    OMPVV_INFOMSG(\"no map(ptr) Specified\")\n#pragma omp target \n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] += 1;\n        ptr_h_array_s[i] += 2;\n      }\n    } // end target\n}\n\nint test_map_different_function() {\n\n  OMPVV_INFOMSG(\"Testing map different function definition\")\n\n  int sum = 0, sum2 = 0, errors = 0;\n\n  // host arrays: heap and stack\n  int *h_array_h = (int *)malloc(N * sizeof(int));\n  int h_array_s[N];\n\n#pragma omp target enter data map(alloc: h_array_h[0:N]) map(alloc: h_array_s[0:N])\n    helper_function(h_array_h, h_array_s);\n#pragma omp target exit data map(from: h_array_h[0:N]) map(from: h_array_s[0:N])\n\n  // checking results\n  for (int i = 0; i < N; ++i) {\n    sum += h_array_h[i];\n    sum2 += h_array_s[i];\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (3*N != sum) || (6*N != sum2));\n\n  free(h_array_h);\n  return errors;\n}\nint main() {\n  OMPVV_TEST_OFFLOADING\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_same_function());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_different_function());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_enter_exit_data_map_pointer_translation.c-------- ===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// According to the OpenMP Specs, if a pointer is used in the mapping of a variable\n// and the pointer points to a host array that is already available in the device,\n// this pointer's address has to be updated with the device address. \n//\n// See page 105, lines 24 throuhg 32. \n//\n// This test check these conditions are valid for target enter exit data clauses \n//\n//===----------------------------------------------------------------------===//\n\n#include \"ompvv.h\"\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 1000\n\nint test_map_same_function() {\n\n  OMPVV_INFOMSG(\"Testing map same function definition\")\n\n  int sum = 0, sum2 = 0, errors = 0;\n\n  // host arrays: heap and stack\n  int *h_array_h = (int *)malloc(N * sizeof(int));\n  int h_array_s[N];\n\n  // Pointers to be used for the translation\n  int *ptr_h_array_h;\n  int *ptr_h_array_s;\n\n#pragma omp target enter data map(alloc:h_array_h[0:N]) map(alloc:h_array_s[0:N])\n\n    ptr_h_array_h = h_array_h;\n    ptr_h_array_s = h_array_s;\n\n    OMPVV_INFOMSG(\"map(ptr) specified full-length array section\")\n#pragma omp target map(ptr_h_array_h[0:N], ptr_h_array_s[0:N])\n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] = 1;\n        ptr_h_array_s[i] = 2;\n      }\n    } // end target\n\n    OMPVV_INFOMSG(\"map(ptr) specified zero-length array section\")\n#pragma omp target map(ptr_h_array_h[:0], ptr_h_array_s[:0])\n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] += 1;\n        ptr_h_array_s[i] += 2;\n      }\n    } // end target\n\n    OMPVV_INFOMSG(\"no map(ptr) Specified\")\n#pragma omp target \n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] += 1;\n        ptr_h_array_s[i] += 2;\n      }\n    } // end target\n#pragma omp target exit data map(from:h_array_h[0:N]) map(from:h_array_s[0:N])\n\n  // checking results\n  for (int i = 0; i < N; ++i) {\n    sum += h_array_h[i];\n    sum2 += h_array_s[i];\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (3*N != sum) || (6*N != sum2));\n\n  free(h_array_h);\n  return errors;\n}\n\nvoid helper_function(int *ptr_h_array_h, int *ptr_h_array_s) {\n\n    OMPVV_INFOMSG(\"map(ptr) specified full-length array section\")\n#pragma omp target map(ptr_h_array_h[0:N], ptr_h_array_s[0:N])\n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] = 1;\n        ptr_h_array_s[i] = 2;\n      }\n    } // end target\n\n    OMPVV_INFOMSG(\"map(ptr) specified zero-length array section\")\n#pragma omp target map(ptr_h_array_h[:0], ptr_h_array_s[:0])\n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] += 1;\n        ptr_h_array_s[i] += 2;\n      }\n    } // end target\n\n    OMPVV_INFOMSG(\"no map(ptr) Specified\")\n#pragma omp target \n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] += 1;\n        ptr_h_array_s[i] += 2;\n      }\n    } // end target\n}\n\nint test_map_different_function() {\n\n  OMPVV_INFOMSG(\"Testing map different function definition\")\n\n  int sum = 0, sum2 = 0, errors = 0;\n\n  // host arrays: heap and stack\n  int *h_array_h = (int *)malloc(N * sizeof(int));\n  int h_array_s[N];\n\n#pragma omp target enter data map(alloc: h_array_h[0:N]) map(alloc: h_array_s[0:N])\n    helper_function(h_array_h, h_array_s);\n#pragma omp target exit data map(from: h_array_h[0:N]) map(from: h_array_s[0:N])\n\n  // checking results\n  for (int i = 0; i < N; ++i) {\n    sum += h_array_h[i];\n    sum2 += h_array_s[i];\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (3*N != sum) || (6*N != sum2));\n\n  free(h_array_h);\n  return errors;\n}\nint main() \n  OMPVV_TEST_OFFLOADING\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_same_function());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_different_function());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_enter_exit_data_classes_simple.cpp",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===--test_targe_enter_exit_data_classes_simple.c - test a simple class ----===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// This test uses target enter data and exit data to map a whole class in the \n// constructor and destructor. It requires the use of helper_ variables since it\n// is not legal to use the \"this\" pointer (implicitely or explicitely) in 4.5. \n//\n// We use a modify method to assign values to the array and we use a method to \n// obtain a copy of the values from the device. The disctintion between methods \n// allows to show that data is mapped and remains mapped in the device memory. \n// This test does not use any inheritance or anything similar, therefore \n// the simple connotation\n//\n// Contrary to the test of target_enter_data, this test checks if during the exit\n// data it successfully copies back the attributes of the object\n//\n////===----------------------------------------------------------------------===//\n\n#include <iostream>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nclass Simple {\n  private:\n    int *h_array;\n    int size;\n    int sum;\n    int *errors; \n\n  public:\n    Simple(int s, int *err) : size(s) { \n      sum = 0;\n      h_array = new int[size];\n\n      // Initialize the array in the host\n      for (int i = 0; i < size; i ++)\n        h_array[i] = i;\n\n      // To obtain the error counter variable that is external\n      errors = err;\n      int * helper_harray = this->h_array;\n      Simple * mySelf = this;\n#pragma omp target enter data map(to: mySelf[0:1])\n#pragma omp target enter data map(to: helper_harray[0:size])\n    }\n\n    ~Simple() { \n      // Modify again to see if changes are copied over\n      int *helper_harray = this->h_array;\n      Simple * mySelf = this;\n#pragma omp target exit data map(from: helper_harray[0:size])\n\n      // checking results that are coming back from the target exit data\n      for (int i = 0; i < N; ++i) {\n        OMPVV_TEST_AND_SET_VERBOSE(*errors, h_array[i] != 3*i);\n      }\n\n#pragma omp target exit data map(from: mySelf[0:1])\n      OMPVV_TEST_AND_SET_VERBOSE(*errors, sum != 3*N*(N-1)/2);\n      delete[] h_array; \n    }\n\n    void modify() {\n      int * helper_harray = this->h_array;\n      int &helper_sum = this->sum;\n      int &helper_size = this->size;\n#pragma omp target defaultmap(tofrom:scalar)\n      {\n        helper_sum = 0;\n        for (int i = 0; i < helper_size; ++i) {\n          helper_harray[i] += i;\n          helper_sum += helper_harray[i];\n        }\n      }\n    }\n\n    void getDeviceAttributes(int * array_copy, int & sum_copy) {\n      int * helper_harray = this->h_array;\n      int &helper_sum = this->sum;\n      int &helper_size = this->size;\n#pragma omp target map(from:array_copy[0:N], sum_copy) defaultmap(tofrom:scalar)\n      {\n        for (int i = 0; i < helper_size; ++i) {\n          array_copy[i] = helper_harray[i];\n        }\n        sum_copy = helper_sum;\n      }\n    }\n};\n\nint test_simple_class() {\n\n  OMPVV_INFOMSG(\"Testing simple class mapping\");\n\n  int sum = 0, errors = 0, h_sum = 0;\n  int* h_array = new int[N];\n\n  // allocation on the device\n  Simple *obj = new Simple(N, &errors);\n\n  obj->modify();\n\n  obj->getDeviceAttributes(h_array, h_sum);\n  \n  // checking results\n  for (int i = 0; i < N; ++i) {\n    sum += h_array[i];\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, N*(N-1) != sum);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, N*(N-1) != h_sum);\n\n  obj->modify();\n  delete obj;\n  delete[] h_array;\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET(errors, test_simple_class());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <iostream>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nshort porxlwdbmv = 244;\nshort vadtficotl = 71;\ndouble ndwaankqyh = 164;\nbyte dxdsljyaiy = 32;\nbyte sumtlagxuk = 220;\ndouble rgzmwxtimq = 100;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    std::cout << \"Sum of \" << num1 << \" and \" << num2 << \" is \" << sum << std::endl;\n    return 0;\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_map.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 710",
        "issue_id": 2,
        "original_code": "//===--- test_target_teams_distribute_map.c----------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the map clause on a target teams distribute clause to test that\n// the indicated data is maped on the target in the fashion that is indicated\n// with the map-type.  Each map-type that is valid in this situation (to, from,\n// alloc, and tofrom) are each used and tested.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main() {\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  int a[N];\n  int b[N];\n  int c[N];\n  int errors= 0;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n    b[x] = 0;\n  }\n\n#pragma omp target enter data map(alloc: b[0:N])\n#pragma omp target teams distribute map(to: a[0:N], b[0:N])\n  for (int x = 0; x < N; ++x) {\n    b[x] = a[x];\n  }\n#pragma omp target exit data map(from: b[0:N])\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, a[x] != b[x]);\n    if (a[x] != b[x]) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < N; ++x) {\n    b[x] = 0;\n  }\n\n#pragma omp target enter data map(to: a[0:N])\n#pragma omp target teams distribute map(from: b[0:N])\n  for (int x = 0; x < N; ++x) {\n    b[x] = a[x];\n  }\n#pragma omp target exit data map(delete: a[0:N])\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, a[x] != b[x]);\n    if (a[x] != b[x]) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < N; ++x) {\n    b[x] = 0;\n    c[x] = 0;\n  }\n\n#pragma omp target enter data map(to: a[0:N]) map(alloc: b[0:N])\n#pragma omp target teams distribute map(alloc: a[0:N], b[0:N], c[0:N])\n  for (int x = 0; x < N; ++x) {\n    c[x] = a[x];\n    b[x] = c[x];\n  }\n#pragma omp target exit data map(delete: a[0:N]) map(from: b[0:N])\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, a[x] != b[x]);\n    if (a[x] != b[x]) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < N; ++x) {\n    b[x] = x;\n  }\n\n#pragma omp target teams distribute map(tofrom: b[0:N], a[0:N])\n  for (int x = 0; x < N; ++x) {\n    b[x] += a[x];\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, b[x] != 2*x);\n    if (b[x] != 2*x) {\n      break;\n    }\n  }\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_map.c----------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the map clause on a target teams distribute clause to test that\n// the indicated data is maped on the target in the fashion that is indicated\n// with the map-type.  Each map-type that is valid in this situation (to, from,\n// alloc, and tofrom) are each used and tested.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main() {\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  int a[N];\n  int b[N];\n  int c[N];yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n  int errors= 0;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n    b[x] = 0;\n  }\n\n#pragma omp target enter data map(alloc: b[0:N])\n#pragma omp target teams distribute map(to: a[0:N], b[0:N])\n  for (int x = 0; x < N; ++x) {\n    b[x] = a[x];\n  }\n#pragma omp target exit data map(from: b[0:N])\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, a[x] != b[x]);\n    if (a[x] != b[x]) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < N; ++x) {\n    b[x] = 0;\n  }\n\n#pragma omp target enter data map(to: a[0:N])\n#pragma omp target teams distribute map(from: b[0:N])\n  for (int x = 0; x < N; ++x) {\n    b[x] = a[x];\n  }\n#pragma omp target exit data map(delete: a[0:N])\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, a[x] != b[x]);\n    if (a[x] != b[x]) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < N; ++x) {\n    b[x] = 0;\n    c[x] = 0;\n  }\n\n#pragma omp target enter data map(to: a[0:N]) map(alloc: b[0:N])\n#pragma omp target teams distribute map(alloc: a[0:N], b[0:N], c[0:N])\n  for (int x = 0; x < N; ++x) {\n    c[x] = a[x];\n    b[x] = c[x];\n  }\n#pragma omp target exit data map(delete: a[0:N]) map(from: b[0:N])\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, a[x] != b[x]);\n    if (a[x] != b[x]) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < N; ++x) {\n    b[x] = x;\n  }\n\n#pragma omp target teams distribute map(tofrom: b[0:N], a[0:N])\n  for (int x = 0; x < N; ++x) {\n    b[x] += a[x];\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, b[x] != 2*x);\n    if (b[x] != 2*x) {\n      break;\n    }\n  }\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_map_zero_length_pointer.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===--- test_target_map_zero_length_pointer.c -----------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// If a pointer is referenced in a target construct, not declared in the target \n// construct, and does not appear in a data-sharing attribute or map clause, it\n// is treated as if it appeared in a map clause as a zero-length array section. \n// This test checks this rule by giving a pointer the address of an array, \n// mapping that array to a device with tofrom map-type, and then changing the \n// values of the array on the device using the pointer. Finally, back on the \n// host the array is checked in order to confirm that values were properly \n// modified through the pointer.\n//\n////===---------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\n//Test non-specified mapping of pointer as a zero-length array in a map clause\nint test_zero_length_pointer() {\n  int compute_array[N];\n  int *p;\n  int sum = 0, result = 0, errors = 0;\n  int i;\n \n  for (i = 0; i < N; i++)\n    compute_array[i] = 0;\n  \n  p = &compute_array[0];\n\n#pragma omp target data map(tofrom: compute_array)\n#pragma omp target\n  {\n  for (i = 0; i < N; i++)\n    p[i] = i;\n  } // end target\n\n  for (i = 0; i < N; i++)\n    sum = sum + compute_array[i];\n\n  for (i = 0; i < N; i++)\n    result += i;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != sum);\n\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n    \n  int isOffloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n \n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_zero_length_pointer());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nint gwuifxcfcd = 206;\nfloat agedanhwvk = 68;\nint iwrmqfrytr = 108;\nbyte bctlwescyu = 169;\nfloat pbnsrypiou = 168;\nlong erulbkielb = 64;\nint rfeiuudwul = 170;\ndouble meqycamrbb = 2;\ndouble skfcpcuxly = 238;\ndouble qbomhmfgyu = 92;\nshort eexeyouehe = 78;\nfloat qpjywevudu = 6;\ndouble sndcnwtkef = 196;\nbyte ovagswgrwo = 128;\nint qrmdmpjpah = 172;\nlong hguipbpqqk = 47;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_taskloop_if.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//--------------------------------------------- test_taskloop_if.c ----------------------------------------//\n//\n// OpenMP API Version 4.5 November 2015\n//\n// This test checks the taskloop directive with the if clause specified.\n// The 'taskloop' construct parallelize loops with independent iterations by creating tasks. \n// It allows for efficient parallel execution of loop iterations by distributing them among multiple threads. \n// The 'if' clause used to check the condition and taskloop will take into consideration only,      \n// if the condition is TRUE.\n//----------------------------------------------------------------------------------------------------------//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define NUM_TASKS 1000\n#define NUM_THREADS 1000\n\n#define M 100\n\n//if all thread ids are same, return 1 else return 0\nint thread_ids_are_same(int a[], int len) {\n\n\tint first = a[0];\n\n\tfor(int i = 1; i < len; i++) {\n\t\tif(first != a[i]) \n\t\t  return 0; //if all the thread ids are not same\n\t}\n\n\treturn 1; //if all the thread ids are same\t\n}\n\nint test_taskloop_if(int THRESHOLD) {\n  \n  int errors = 0;\n  \n  int thread_ids[NUM_TASKS];\n\n  #pragma omp parallel num_threads(NUM_THREADS)\n  {\n  \t#pragma omp single\n    \t{\t\n        \t#pragma omp taskloop if(M == THRESHOLD)\n      \t\tfor (int i = 0; i < NUM_TASKS; i++) {\n\t \t\tthread_ids[i] = omp_get_thread_num();\n      \t\t} \n   \t}\n  } \n  \n  if (M ==  THRESHOLD) {\n    if (thread_ids_are_same(thread_ids, NUM_TASKS) != 0) {\n      errors++; \n    }\n  } else if (M != THRESHOLD) {\n    if (thread_ids_are_same(thread_ids, NUM_TASKS) == 0) {\n      errors++; \n    }\n  }\n\n  return errors;            \n\n}\n\nint main() {\n \n   int errors = 0;\n   \n   int THRESHOLD = 100; //Equal to M\n   OMPVV_TEST_AND_SET_VERBOSE(errors, (test_taskloop_if(THRESHOLD) != 0));\n\n   THRESHOLD = 110; // Not equal to M\n   OMPVV_TEST_AND_SET_VERBOSE(errors, (test_taskloop_if(THRESHOLD) != 0));\n   \n   OMPVV_REPORT_AND_RETURN(errors);\n\n   return 0;\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_if.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp declare\" at position 1527",
        "issue_id": 0,
        "original_code": "//===--- test_target_teams_distribute_if.c-----------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the if clause to specify whether the target teams distribute\n// directve should execute in the device or the hosts through the if clause of the \n// taget directive. The test uses omp_is_initial_device through the different \n// threads, assigning an expected value to a matrix according to 1) offloading is \n// enabled and working, 2) the if clause evaluates to true and the code executes in\n// the offloading device, and 3) the if clause evaluates to false and the code executes\n// in the offloading devices. \n//\n// If not operating on a device, the test has a minimal test\n// of the basic use of the if clause with both a true and a false parameter.\n// However, the execution is identical to that of host operation in both cases.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n#define ATTEMPT_THRESHOLD 70\n#define NUM_ATTEMPTS 100\n\nint test_target_teams_distribute_if() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_if\");\n\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"With offloading off, it is not possible to test if\");\n\n  int a[N];\n  int errors = 0;\n  int attempt = 0;\n  int i;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = 1;\n  }\n\n  for (attempt = 0; attempt < NUM_ATTEMPTS; ++attempt) {\n#pragma omp target teams distribute if(attempt >= ATTEMPT_THRESHOLD) map(tofrom: a)\n    for (i = 0; i < N; ++i) {\n      if (attempt >= ATTEMPT_THRESHOLD) {\n\ta[i] += (isOffloading && omp_is_initial_device() ? 10 : 0); // false -> running on device or not offloading -> add 0\n      } else {\n\ta[i] += (omp_is_initial_device() ? 1 : 100);                // true -> running on host -> add 1\n      }\n    }\n  }\n\n  for (i = 0; i < N; ++i) {\n    OMPVV_TEST_AND_SET(errors, a[i] != (1 + ATTEMPT_THRESHOLD));\n  }\n\n  if (errors) {\n    int sum = 0;\n    for (i = 0; i < N; ++i) {\n      sum += a[i];\n    }\n    if (sum == N*(100*ATTEMPT_THRESHOLD + 1)) {\n      OMPVV_ERROR(\"Error in if. The execution was expected to occur on the host, but it occurred on the device.\");\n    } else if (sum == N*(ATTEMPT_THRESHOLD + 10*(NUM_ATTEMPTS - ATTEMPT_THRESHOLD) + 1)) {\n      OMPVV_ERROR(\"Error in if. The execution was expected to occur on the device, but it occurred on the host.\");\n    } else {\n      OMPVV_ERROR(\"Error in if. The execution occurred inconsistently on the host or on the device.\");\n    }\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_if());\n  \n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_if.c-----------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the if clause to specify whether the target teams distribute\n// directve should execute in the device or the hosts through the if clause of the \n// taget directive. The test uses omp_is_initial_device through the different \n// threads, assigning an expected value to a matrix according to 1) offloading is \n// enabled and working, 2) the if clause evaluates to true and the code executes in\n// the offloading device, and 3) the if clause evaluates to false and the code executes\n// in the offloading devices. \n//\n// If not operating on a device, the test has a minimal test\n// of the basic use of the if clause with both a true and a false parameter.\n// However, the execution is identical to that of host operation in both cases.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n#define ATTEMPT_THRESHOLD 70\n#define NUM_ATTEMPTS 100\n\nint test_target_teams_distribute_if() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_if\");\n\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"With offloading off, it is not possible to test if\");\n\n  int a[N];\n  int errors = 0;\n  int attempt = 0;\n  int i;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = 1;\n  }\n\n  for (attempt = 0; attempt < NUM_ATTEMPTS; ++attempt) {\n#pragma omp declare teams distribute if(attempt >= ATTEMPT_THRESHOLD) map(tofrom: a)\n    for (i = 0; i < N; ++i) {\n      if (attempt >= ATTEMPT_THRESHOLD) {\n\ta[i] += (isOffloading && omp_is_initial_device() ? 10 : 0); // false -> running on device or not offloading -> add 0\n      } else {\n\ta[i] += (omp_is_initial_device() ? 1 : 100);                // true -> running on host -> add 1\n      }\n    }\n  }\n\n  for (i = 0; i < N; ++i) {\n    OMPVV_TEST_AND_SET(errors, a[i] != (1 + ATTEMPT_THRESHOLD));\n  }\n\n  if (errors) {\n    int sum = 0;\n    for (i = 0; i < N; ++i) {\n      sum += a[i];\n    }\n    if (sum == N*(100*ATTEMPT_THRESHOLD + 1)) {\n      OMPVV_ERROR(\"Error in if. The execution was expected to occur on the host, but it occurred on the device.\");\n    } else if (sum == N*(ATTEMPT_THRESHOLD + 10*(NUM_ATTEMPTS - ATTEMPT_THRESHOLD) + 1)) {\n      OMPVV_ERROR(\"Error in if. The execution was expected to occur on the device, but it occurred on the host.\");\n    } else {\n      OMPVV_ERROR(\"Error in if. The execution occurred inconsistently on the host or on the device.\");\n    }\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_if());\n  \n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_parallel_for_map_tofrom.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_map_tofrom());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 1769",
        "issue_id": 4,
        "original_code": "//===---- test_target_teams_distribute_parallel_for_map_tofrom.c - combined consutrct -===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// Testing the map clause with the tofrom map-modifier, for the combined construct\n// target teams distribute parallel for.\n// Scalar mapping has to be divided between to and from. Otherwise there will be \n// data races between the threads that are writting the scalar and those that are reading\n// from it\n//\n//===-----------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define N 2000\n\nint test_target_teams_distribute_parallel_for_map_tofrom() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_map_tofrom\");\n  \n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int scalar_to = 50; //to avoid datarace on the scalar due to read and write in the loop\n  int scalar_from = 50;\n  int errors = 0;\n  int i, j, dev;\n\n\n  // variables initialization\n  scalar_to = 50;\n  scalar_from = 50;\n  for (i = 0; i < N; i++) {\n    a[i] = 1;\n    b[i] = i;\n    c[i] = 2*i;\n    d[i] = 0;\n  }\n\n    // Tests\n#pragma omp target teams distribute parallel for map(tofrom: a, b, c, d, scalar_to, scalar_from)\n  for (j = 0; j < N; ++j) {\n    d[j] += c[j] * (a[j] + b[j] + scalar_to);\n    a[j] = 10;\n    b[j] = 11;\n    c[j] = 12;\n#pragma omp atomic write\n    scalar_from = 13; // This is to avoid data races on a single scalar\n  }\n\n  // Checking the results\n  OMPVV_TEST_AND_SET(errors, scalar_from != 13);\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, a[i] != 10);\n    OMPVV_TEST_AND_SET(errors, b[i] != 11);\n    OMPVV_TEST_AND_SET(errors, c[i] != 12);\n    OMPVV_TEST_AND_SET(errors, d[i] != (1 + i + 50) * 2*i);\n  }\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_map_tofrom());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_teams_distribute_parallel_for_map_tofrom.c - combined consutrct -===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// Testing the map clause with the tofrom map-modifier, for the combined construct\n// target teams distribute parallel for.\n// Scalar mapping has to be divided between to and from. Otherwise there will be \n// data races between the threads that are writting the scalar and those that are reading\n// from it\n//\n//===-----------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define N 2000\n\nint test_target_teams_distribute_parallel_for_map_tofrom() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_map_tofrom\");\n  \n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int scalar_to = 50; //to avoid datarace on the scalar due to read and write in the loop\n  int scalar_from = 50;\n  int errors = 0;\n  int i, j, dev;\n\n\n  // variables initialization\n  scalar_to = 50;\n  scalar_from = 50;\n  for (i = 0; i < N; i++) {\n    a[i] = 1;\n    b[i] = i;\n    c[i] = 2*i;\n    d[i] = 0;\n  }\n\n    // Tests\n#pragma omp target teams distribute parallel for map(tofrom: a, b, c, d, scalar_to, scalar_from)\n  for (j = 0; j < N; ++j) {\n    d[j] += c[j] * (a[j] + b[j] + scalar_to);\n    a[j] = 10;\n    b[j] = 11;\n    c[j] = 12;\n#pragma omp atomic write\n    scalar_from = 13; // This is to avoid data races on a single scalar\n  }\n\n  // Checking the results\n  OMPVV_TEST_AND_SET(errors, scalar_from != 13);\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, a[i] != 10);\n    OMPVV_TEST_AND_SET(errors, b[i] != 11);\n    OMPVV_TEST_AND_SET(errors, c[i] != 12);\n    OMPVV_TEST_AND_SET(errors, d[i] != (1 + i + 50) * 2*i);\n  }\n  return errors;\n}\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_reduction_bitxor.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1650",
        "issue_id": 1,
        "original_code": "//===--- test_target_teams_distribute_reduction_bitxor.c----------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the reduction clause on a target teams distribute directive,\n// testing that the variable in the reduction clause is properly reduced using\n// the bitxor operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_bitxor() {\n  unsigned int a[N];\n  int errors = 0;\n  int num_teams[N];\n  srand(1);\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = (unsigned int) rand() / (double) (RAND_MAX / 2);\n    num_teams[x] = -x;\n  }\n\n  unsigned int b = 0;\n\n#pragma omp target teams distribute reduction(^:b) defaultmap(tofrom:scalar)\n  for (int x = 0; x < N; ++x) {\n    num_teams[x] = omp_get_num_teams();\n    b = (b ^ a[x]);\n  }\n\n  unsigned int host_b = 0;\n\n  for (int x = 0; x < N; ++x) {\n    host_b = (host_b ^ a[x]);\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_teams[x - 1] != num_teams[x], \"Kernel reported differing numbers of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_teams[0] == 1, \"Test operated with one team.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_teams[0] <= 0, \"Test reported invalid number of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, b != host_b);\n  OMPVV_ERROR_IF(host_b != b, \"Bit on device is %d but expected bit from host is %d.\", b, host_b);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_bitxor() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_reduction_bitxor.c----------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the reduction clause on a target teams distribute directive,\n// testing that the variable in the reduction clause is properly reduced using\n// the bitxor operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_bitxor() {\n  unsigned int a[N];\n  int errors = 0;\n  int num_teams[N];\n  srand(1);\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = (unsigned int) rand() / (double) (RAND_MAX / 2);\n    num_teams[x] = -x;\n  }\n\n  unsigned int b = 0;\n\n#pragma omp target teams distribute reduction(^:b) defaultmap(tofrom:scalar)\n  for (int x = 0; x < N; ++x) {\n    num_teams[x] = omp_get_num_teams();\n    b = (b ^ a[x]);\n  }\n\n  unsigned int host_b = 0;\n\n  for (int x = 0; x < N; ++x) {\n    host_b = (host_b ^ a[x]);\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_teams[x - 1] != num_teams[x], \"Kernel reported differing numbers of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_teams[0] == 1, \"Test operated with one team.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_teams[0] <= 0, \"Test reported invalid number of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, b != host_b);\n  OMPVV_ERROR_IF(host_b != b, \"Bit on device is %d but expected bit from host is %d.\", b, host_b);\n\n  return errors;\n}\n\nint main() \n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_bitxor() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_shared.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 2188",
        "issue_id": 1,
        "original_code": "//===--- test_target_teams_distribute_shared.c-------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the shared clause on a target teams distribute directive and\n// tests in a few ways that the variable is shared between the teams.  In the\n// first test, the atomic directive is used to indicate that all operations on\n// the variable should be done atomically.  If the value is the correct value\n// at the end of the region, then all teams operated on the same variable, and\n// the variable was not privatized.\n//\n// The second test, instead of writing to the variable, only reads from the\n// variable.  This tests that the value of the shared variable has not been\n// initialized improperly.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define SIZE 1024\n\nint main() {\n  int is_offloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n  int a[SIZE];\n  int share = 0;\n  int errors = 0;\n  int num_teams;\n\n  for (int x = 0; x < SIZE; ++x) {\n    a[x] = x;\n  }\n\n  // The defaultmap(tofrom:scalar) is used here because the OpenMP 4.5 specification\n  // forbids the use of map and data-sharing clauses on the same list item in the\n  // same construct. See pg. 218, lines 15-16.\n#pragma omp target teams distribute num_teams(OMPVV_NUM_TEAMS_DEVICE) shared(share, num_teams) map(to: a[0:SIZE]) defaultmap(tofrom:scalar)\n  for (int x = 0; x < SIZE; ++x) {\n#pragma omp atomic write\n    num_teams = omp_get_num_teams();\n#pragma omp atomic\n    share = share + a[x];\n  }\n\n  for (int x = 0; x < SIZE; ++x) {\n    share = share - x;\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (share != 0));\n  OMPVV_ERROR_IF(errors != 0, \"The value of share is = %d but expected 0.\", share);\n\n  share = 5;\n\n#pragma omp target data map(tofrom: a[0:SIZE]) map(tofrom: share)\n  {\n#pragma omp target teams distribute num_teams(OMPVV_NUM_TEAMS_DEVICE) shared(share)\n    for (int x = 0; x < SIZE; ++x) {\n      a[x] = a[x] + share;\n    }\n  }\n\n  for (int x = 0; x < SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (a[x] - 5 != x));\n  }\n\n  if (num_teams == 1) {\n    OMPVV_WARNING(\"Test operated on one team, results of default shared test are inconclusive.\");\n  }\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_shared.c-------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the shared clause on a target teams distribute directive and\n// tests in a few ways that the variable is shared between the teams.  In the\n// first test, the atomic directive is used to indicate that all operations on\n// the variable should be done atomically.  If the value is the correct value\n// at the end of the region, then all teams operated on the same variable, and\n// the variable was not privatized.\n//\n// The second test, instead of writing to the variable, only reads from the\n// variable.  This tests that the value of the shared variable has not been\n// initialized improperly.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define SIZE 1024\n\nint main() {\n  int is_offloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n  int a[SIZE];\n  int share = 0;\n  int errors = 0;\n  int num_teams;\n\n  for (int x = 0; x < SIZE; ++x) {\n    a[x] = x;\n  }\n\n  // The defaultmap(tofrom:scalar) is used here because the OpenMP 4.5 specification\n  // forbids the use of map and data-sharing clauses on the same list item in the\n  // same construct. See pg. 218, lines 15-16.\n#pragma omp target teams distribute num_teams(OMPVV_NUM_TEAMS_DEVICE) shared(share, num_teams) map(to: a[0:SIZE]) defaultmap(tofrom:scalar)\n  for (int x = 0; x < SIZE; ++x) {\n#pragma omp atomic write\n    num_teams = omp_get_num_teams();\n#pragma omp atomic\n    share = share + a[x];\n  }\n\n  for (int x = 0; x < SIZE; ++x) {\n    share = share - x;\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (share != 0));\n  OMPVV_ERROR_IF(errors != 0, \"The value of share is = %d but expected 0.\", share);\n\n  share = 5;\n\n#pragma omp target data map(tofrom: a[0:SIZE]) map(tofrom: share)\n  {\n#pragma omp target teams distribute num_teams(OMPVV_NUM_TEAMS_DEVICE) shared(share)\n    for (int x = 0; x < SIZE; ++x) {\n      a[x] = a[x] + share;\n    }\n  }\n\n  for (int x = 0; x < SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (a[x] - 5 != x));\n  }\n\n  if (num_teams == 1) \n    OMPVV_WARNING(\"Test operated on one team, results of default shared test are inconclusive.\");\n  }\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_data_map_to_from.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp flush\" at position 1013",
        "issue_id": 0,
        "original_code": "//===---- test_target_data_map_to_from.c ---------------------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// The test_target_data_map group of tests checks all the possible map-type-modifiers\n// for the target data map clauses. These are: from, to, fromto, alloc, release and \n// delete. There is a a separate c file for each test with the prefix test_target_data_map.\n// This specific test is for both the 'to' and 'from' clause utilized separately. \n//\n//===----------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\n// Test for OpenMP 4.5 target data map(to: ) and map(from:)\nint test_map_to_from() {\n\n  OMPVV_INFOMSG(\"test_map_to_from\");\n\n  int sum = 0, errors = 0;\n  int *h_array_h = (int *)malloc(N * sizeof(int));\n  int *h_array2_h = (int *)malloc(N * sizeof(int));\n\n  for (int i = 0; i < N; ++i) {\n    h_array_h[i] = 1;\n    h_array2_h[i] = 0;\n  }\n\n#pragma omp target data map(to: h_array_h[0:N]) map(from: h_array2_h[0:N])  \n  {\n#pragma omp target \n    {\n      for (int i = 0; i < N; ++i)\n        h_array2_h[i] = h_array_h[i];\n    } // end target \n  } // end target data\n\n  // checking errors \n  for (int i = 0; i < N; ++i)\n    sum += h_array2_h[i];\n\n  free(h_array_h);\n  free(h_array2_h);\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, ((N - sum) != 0));\n\n  return errors;\n}\n\nint main() {\n\n  int errors = 0;\n  \n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_to_from());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_data_map_to_from.c ---------------------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// The test_target_data_map group of tests checks all the possible map-type-modifiers\n// for the target data map clauses. These are: from, to, fromto, alloc, release and \n// delete. There is a a separate c file for each test with the prefix test_target_data_map.\n// This specific test is for both the 'to' and 'from' clause utilized separately. \n//\n//===----------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\n// Test for OpenMP 4.5 target data map(to: ) and map(from:)\nint test_map_to_from() {\n\n  OMPVV_INFOMSG(\"test_map_to_from\");\n\n  int sum = 0, errors = 0;\n  int *h_array_h = (int *)malloc(N * sizeof(int));\n  int *h_array2_h = (int *)malloc(N * sizeof(int));\n\n  for (int i = 0; i < N; ++i) {\n    h_array_h[i] = 1;\n    h_array2_h[i] = 0;\n  }\n\n#pragma omp flush data map(to: h_array_h[0:N]) map(from: h_array2_h[0:N])  \n  {\n#pragma omp target \n    {\n      for (int i = 0; i < N; ++i)\n        h_array2_h[i] = h_array_h[i];\n    } // end target \n  } // end target data\n\n  // checking errors \n  for (int i = 0; i < N; ++i)\n    sum += h_array2_h[i];\n\n  free(h_array_h);\n  free(h_array2_h);\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, ((N - sum) != 0));\n\n  return errors;\n}\n\nint main() {\n\n  int errors = 0;\n  \n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_to_from());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_data_pointer_swap.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1988",
        "issue_id": 1,
        "original_code": "//===--- test_target_data_pointer_swap.c------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test swaps two pointers' values inside a target data region, testing\n// that the map clauses are applied to their original list items. The address\n// used at the entrance to the data region should be the same used at the exit\n// of the region to copy the data back.\n//\n////===---------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_pointer_swap() {\n  int* a = (int *) malloc(N * sizeof(int));\n  int* b = (int *) malloc(N * sizeof(int));\n  int* temp;\n  int is_offloading;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n    b[x] = 0;\n  }\n\n#pragma omp target data map(tofrom: a[0:N]) map(to: b[0:N])\n  {\n#pragma omp target map(alloc: a[0:N], b[0:N])\n    for (int x = 0; x < N; ++x) {\n      b[x] = a[x]*2;\n    }\n    temp = a;\n    a = b;\n    b = temp;\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET(errors, b[x] != x);\n    if (is_offloading) {\n      OMPVV_TEST_AND_SET(errors, a[x] != 0);\n    } else {\n      OMPVV_TEST_AND_SET(errors, a[x] != 2*x);\n    }\n  }\n\n  free(a);\n  free(b);\n\n  return errors;\n}\n\nint test_pointer_swap_with_update() {\n  int* a = (int *) malloc(N * sizeof(int));\n  int* b = (int *) malloc(N * sizeof(int));\n  int* temp;\n  int errors = 0;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n    b[x] = 0;\n  }\n\n#pragma omp target data map(tofrom: a[0:N]) map(to: b[0:N])\n  {\n#pragma omp target map(alloc: a[0:N], b[0:N])\n    for (int x = 0; x < N; ++x) {\n      b[x] = a[x]*2;\n    }\n\n    temp = a;\n    a = b;\n    b = temp;\n\n#pragma omp target update from(a[0:N])\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET(errors, b[x] != x);\n    OMPVV_TEST_AND_SET(errors, a[x] != 2*x);\n  }\n\n  free(a);\n  free(b);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_pointer_swap());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_pointer_swap_with_update());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_data_pointer_swap.c------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test swaps two pointers' values inside a target data region, testing\n// that the map clauses are applied to their original list items. The address\n// used at the entrance to the data region should be the same used at the exit\n// of the region to copy the data back.\n//\n////===---------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_pointer_swap() {\n  int* a = (int *) malloc(N * sizeof(int));\n  int* b = (int *) malloc(N * sizeof(int));\n  int* temp;\n  int is_offloading;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n    b[x] = 0;\n  }\n\n#pragma omp target data map(tofrom: a[0:N]) map(to: b[0:N])\n  {\n#pragma omp target map(alloc: a[0:N], b[0:N])\n    for (int x = 0; x < N; ++x) {\n      b[x] = a[x]*2;\n    }\n    temp = a;\n    a = b;\n    b = temp;\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET(errors, b[x] != x);\n    if (is_offloading) {\n      OMPVV_TEST_AND_SET(errors, a[x] != 0);\n    } else {\n      OMPVV_TEST_AND_SET(errors, a[x] != 2*x);\n    }\n  }\n\n  free(a);\n  free(b);\n\n  return errors;\n}\n\nint test_pointer_swap_with_update() {\n  int* a = (int *) malloc(N * sizeof(int));\n  int* b = (int *) malloc(N * sizeof(int));\n  int* temp;\n  int errors = 0;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n    b[x] = 0;\n  }\n\n#pragma omp target data map(tofrom: a[0:N]) map(to: b[0:N])\n  {\n#pragma omp target map(alloc: a[0:N], b[0:N])\n    for (int x = 0; x < N; ++x) {\n      b[x] = a[x]*2;\n    }\n\n    temp = a;\n    a = b;\n    b = temp;\n\n#pragma omp target update from(a[0:N])\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET(errors, b[x] != x);\n    OMPVV_TEST_AND_SET(errors, a[x] != 2*x);\n  }\n\n  free(a);\n  free(b);\n\n  return errors;\n}\n\nint main() \n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_pointer_swap());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_pointer_swap_with_update());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_and_task_nowait.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 654",
        "issue_id": 2,
        "original_code": "//===-------- test_target_and_task_nowait.c - test task after target offload  ------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks if dependence expressed on target and task \n// regions are honoured in the presense of nowait.\n// This test is motivated by OpenMP usage in QMCPack.\n//\n////===----------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nint test_target_and_task_nowait() {\n  int errors = 0, i;\n  int sum = 0, a = 0;\n\n#pragma omp target map(tofrom: a, sum) depend(out: a) nowait\n  {\n    for (i = 0; i < N; i++) {\n       sum++;\n    }\n    a += 1;\n  }\n\n#pragma omp task depend(in: a) shared(a,errors)\n  {\n     if(a != 1) {\n       errors += 1; \n     }\n  }\n  #pragma omp taskwait\n  if (sum != N) {\n    errors++;\n  }\n  return(errors);\n}\n\nint main() {\n\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_and_task_nowait());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n",
        "error_code": "//===-------- test_target_and_task_nowait.c - test task after target offload  ------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks if dependence expressed on target and task \n// regions are honoured in the presense of nowait.\n// This test is motivated by OpenMP usage in QMCPack.\n//\n////===----------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nint test_target_and_task_nowait() {\n  int errors = 0, i;\n  int sum = 0, a = 0;\n\n#pragma omp target map(tofrom: a, sum) depend(out: a) nowait\n  {\n    for (i = 0; i < N; i++) {\n       sum++;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n    }\n    a += 1;\n  }\n\n#pragma omp task depend(in: a) shared(a,errors)\n  {\n     if(a != 1) {\n       errors += 1; \n     }\n  }\n  #pragma omp taskwait\n  if (sum != N) {\n    errors++;\n  }\n  return(errors);\n}\n\nint main() {\n\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_and_task_nowait());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_taskloop_shared.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//------------------------------------------- test_taskloop_shared.c --------------------------------------//\n//\n// OpenMP API Version 4.5 November 2015\n//\n// This test checks the 'taskloop' directive with the 'shared' clause specified.\n// The 'taskloop' construct parallelize loops with independent iterations by creating tasks. \n// It allows for efficient parallel execution of loop iterations by distributing them among multiple threads. \n// The 'shared' clause ensures that vaiable is shared with all the tasks.  \n//----------------------------------------------------------------------------------------------------------//\n\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define NUM_THREADS 50\n#define NUM_TASKS 1000\n\nint test_taskloop_shared() {\n\n  int errors = 0;\n\n  long int all_thread_sum, real_sum = 0; \n  long int shared_var = 0; //This variable is shared with all the tasks.  \n\n   //get valid sum without openmp\n   for(int i = 0; i < NUM_TASKS; i++) {\n     real_sum = real_sum + i;\n   }\n   \n   #pragma omp parallel num_threads(NUM_THREADS)\n   {\n      #pragma omp single\n      {\n\t#pragma omp taskloop shared(shared_var) \n        for(int i = 0; i < NUM_TASKS; i++) \n\t{\n\t    #pragma omp atomic \n\t    shared_var = shared_var + i;\n\t}\n      }\t   \n   }\n\n   all_thread_sum = shared_var;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, real_sum != all_thread_sum);\n\n   return errors;\n}\n\nint main() {\n  \n  int errors = 0;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, (test_taskloop_shared()) != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n\n  return 0;\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nfloat qmmvcopjoy = 48;\nlong ipkfohrgmr = 50;\nshort obrwowzxtn = 162;\nlong hzpdcxuoce = 208;\nbyte clqfpbqnal = 184;\nlong txfogzgubs = 58;\nlong vwfcivzhvi = 31;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_enter_data_global_array.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 786",
        "issue_id": 1,
        "original_code": "//===--- test_target_enter_data_global_array.c ------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//  \n// This is a test of the target enter data construct with global arrays.\n// The 'to' map-type-modifier is specified on the map clause.\n//\n//===------------------------------------------------------------------------===//\n\n#include \"ompvv.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n\n// Test for OpenMP 4.5 target enter data with global arrays.\n\nint n=10;\nint A[10]={10,10,10,10,10,10,10,10,10,10},B[10];\n\n\nint main (){\n\n int i;\n int errors = 0;\n \n OMPVV_TEST_OFFLOADING;\n\n#pragma omp target enter data map(to: A[:n])\n#pragma omp target map(from: B[:n])\n{\n\n for (i = 0; i < n; i++)\n    B[i] = A[i];\n}\n\n for (i = 0; i < n; i++)\n    if (B[i] != 10){\n     errors += 1;\n   }\n\n#pragma omp target exit data map(release: A[:n])\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_enter_data_global_array.c ------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//  \n// This is a test of the target enter data construct with global arrays.\n// The 'to' map-type-modifier is specified on the map clause.\n//\n//===------------------------------------------------------------------------===//\n\n#include \"ompvv.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n\n// Test for OpenMP 4.5 target enter data with global arrays.\n\nint n=10;\nint A[10]={10,10,10,10,10,10,10,10,10,10},B[10];\n\n\nint main (){\n\n int i;\n int errors = 0;\n \n OMPVV_TEST_OFFLOADING;\n\n#pragma omp target enter data map(to: A[:n])\n#pragma omp target map(from: B[:n])\n{\n\n for (i = 0; i < n; i++)\n    B[i] = A[i];\n}\n\n for (i = 0; i < n; i++)\n    if (B[i] != 10)\n     errors += 1;\n   }\n\n#pragma omp target exit data map(release: A[:n])\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_dist_schedule.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===------ test_target_teams_distribute_dist_schedule.c ------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks that the dist_schedule clause (which must have kind\n// static) correctly causes CHUNK_SIZE iterations to be split among the\n// number of teams the test is run with (in a round-robin fashion in order\n// of the team number) when a chunk size is given. The test also confirms\n// that when no chunk size is given, that each team receives no more than\n// one \"chunk\" of implementation-defined size.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n#define CHUNK_SIZE 64\n\nint test_dist_schedule() {\n  int errors = 0;\n  int num_teams;\n  int a[N];\n  int b[N];\n\n  for (int i = 0; i < N; ++i) {\n    a[i] = -1;\n    b[i] = -1;\n  }\n\n#pragma omp target teams distribute map(from: num_teams) map(tofrom: a[0:N]) dist_schedule(static, CHUNK_SIZE)\n  for (int i = 0; i < N; ++i) {\n    if (omp_get_team_num() == 0) {\n      num_teams = omp_get_num_teams();\n    }\n    a[i] = omp_get_team_num();\n  }\n\n  OMPVV_WARNING_IF(num_teams == 1, \"Cannot test dist_schedule(static, chunk_size) because num_teams was 1.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_teams < 1);\n\n  int counter = -1;\n  for (int i = 0; i < N; ++i) {\n    if (i % CHUNK_SIZE == 0) {\n      counter = (counter + 1) % num_teams;\n    }\n    OMPVV_TEST_AND_SET_VERBOSE(errors, a[i] != counter);\n    OMPVV_ERROR_IF(a[i] != counter, \"Loop iterations were not properly scheduled with specified chunk_size of %d.\", CHUNK_SIZE);\n  }\n\n  num_teams = -1;\n\n#pragma omp target teams distribute map(from: num_teams) map(tofrom: b[0:N]) dist_schedule(static)\n  for (int i = 0; i < N; ++i) {\n    if (omp_get_team_num() == 0) {\n      num_teams = omp_get_num_teams();\n    }\n    b[i] = omp_get_team_num();\n  }\n\n  OMPVV_WARNING_IF(num_teams == 1, \"Cannot test dist_schedule(static, chunk_size) because num_teams was 1.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_teams < 1);\n\n  counter = 1;\n\n  int err_cond = 0;\n  for (int i = 1; i < N; ++i) {\n    err_cond = a[i] < a[i - 1] || a[i] > (a[i - 1] + 1);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, err_cond);\n    OMPVV_ERROR_IF(err_cond, \"Loop iterations were not properly sheduled with unspecified chunk_size.\");\n    if (err_cond) {\n      break;\n    }\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_SHARED_ENVIRONMENT;\n\n  int errors = 0;\n\n  errors = test_dist_schedule();\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nint rikndyxvww = 121;\nshort nqahxksapp = 6;\ndouble knneipdvfv = 176;\nshort jxlxezxott = 181;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_taskloop_lastprivate.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 954",
        "issue_id": 2,
        "original_code": "//-------------------------------- test_taskloop_lastprivate.c ------------------------------------------------//\n//\n// OpenMP API Version 4.5 November 2015\n//\n// This test checks the 'taskloop' directive with the 'lastprivate' clause specified.\n// The 'taskloop' construct parallelize loops with independent iterations by creating tasks. \n// It allows for efficient parallel execution of loop iterations by distributing them among multiple threads. \n// The 'lastprivate' clause ensures that the last value of variable in a loop is available after loop completion.  \n//-------------------------------------------------------------------------------------------------------------//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define NUM_THREADS 1000\n#define NUM_TASKS 1000 \n\nint test_taskloop_lastprivate() {\n    \n    int errors = 0;\n   \n    int val = 100;\n    int task_vals[NUM_TASKS];\n\n    int last_itr = NUM_TASKS - 1;\n    \n    #pragma omp parallel num_threads(NUM_THREADS)\n    {\n        #pragma omp single\n        {\n            #pragma omp taskloop lastprivate(val)\n            for (int i = 0; i < NUM_TASKS; i++) {\n                val = i;\n                task_vals[i] = val; \n            }\n        }\n    }\n   \n    //NOTE: lastprivate_var depends on NUM_TASK and not on Input value\n    //it is the last task iteration which is kept, not the last operation value.\n     OMPVV_TEST_AND_SET_VERBOSE(errors, (task_vals[last_itr] != val));\n\n    return errors;    \n}\n\nint main() {\n   \n    int errors = 0;\n\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (test_taskloop_lastprivate() != 0));\n    OMPVV_REPORT_AND_RETURN(errors);\n    \n    return 0;\n}\n\n",
        "error_code": "//-------------------------------- test_taskloop_lastprivate.c ------------------------------------------------//\n//\n// OpenMP API Version 4.5 November 2015\n//\n// This test checks the 'taskloop' directive with the 'lastprivate' clause specified.\n// The 'taskloop' construct parallelize loops with independent iterations by creating tasks. \n// It allows for efficient parallel execution of loop iterations by distributing them among multiple threads. \n// The 'lastprivate' clause ensures that the last value of variable in a loop is available after loop completion.  \n//-------------------------------------------------------------------------------------------------------------//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define NUM_THREADS 1000\n#define NUM_TASKS 1000 \n\nint test_taskloop_lastprivate() {\n    \n    int errors = 0;\n   \n    int val = 100;\n    int task_vals[NUM_TASKS];\n\n    int last_itr = NUM_TASKS - 1;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n    \n    #pragma omp parallel num_threads(NUM_THREADS)\n    {\n        #pragma omp single\n        {\n            #pragma omp taskloop lastprivate(val)\n            for (int i = 0; i < NUM_TASKS; i++) {\n                val = i;\n                task_vals[i] = val; \n            }\n        }\n    }\n   \n    //NOTE: lastprivate_var depends on NUM_TASK and not on Input value\n    //it is the last task iteration which is kept, not the last operation value.\n     OMPVV_TEST_AND_SET_VERBOSE(errors, (task_vals[last_itr] != val));\n\n    return errors;    \n}\n\nint main() {\n   \n    int errors = 0;\n\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (test_taskloop_lastprivate() != 0));\n    OMPVV_REPORT_AND_RETURN(errors);\n    \n    return 0;\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_data_map_alloc.c",
        "correct": "n",
        "issue": "Removed memory allocation line \"omp_target_alloc\n  // section 3.5.1 omp_target_alloc. OpenMP API Version 4.5 Nov 2015\n  int *d_sum = (int *)omp_target_alloc(sizeof(int), omp_get_default_device());\" at position 921",
        "issue_id": 0,
        "original_code": "//===---- test_target_data_map_alloc.c ---------------------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// The test_target_data_map group of tests checks all the possible map-type-modifiers\n// for the target data map clauses. These are: from, to, tofrom, alloc, release and \n// delete. There is a a separate c file for each test with the prefix test_target_data_map.\n// This specific test is for the 'alloc' clause. \n//\n//===----------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\n// Test for OpenMP 4.5 target data map(alloc:)\nint test_map_alloc() {\n\n  OMPVV_INFOMSG(\"test_map_alloc\");\n\n  int sum = 0, errors = 0;\n  int *h_array_h = (int *)malloc(N*sizeof(int));\n\n  // pointer arithmetic is not supported on the devices for\n  // the device address returned by omp_target_alloc\n  // section 3.5.1 omp_target_alloc. OpenMP API Version 4.5 Nov 2015\n  int *d_sum = (int *)omp_target_alloc(sizeof(int), omp_get_default_device());\n\n  if (d_sum == NULL) {\n    errors = 1;\n    OMPVV_ERROR(\"omp_target_alloc returns NULL, this test is running on host, cannot properly test mapping of variables to device.\");\n    return errors;\n  }\n\n#pragma omp target data map(alloc: h_array_h[0:N])\n  {\n#pragma omp target is_device_ptr(d_sum)\n    {\n      for (int i = 0; i < N; ++i) \n        h_array_h[i] = 1;\n      \n      // checking errors\n      d_sum[0] = 0; \n      for (int i = 0; i < N; ++i)\n        d_sum[0] += h_array_h[i];\n    } // end target\n    omp_target_memcpy(&sum, d_sum, sizeof(int), 0, 0,\n                                  omp_get_initial_device(),\n                                  omp_get_default_device());\n  } // end target data\n  omp_target_free(d_sum, omp_get_default_device());\n\n  free(h_array_h);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (N - sum) != 0);\n\n  return errors;\n}\n\nint main() {\n\n  int errors = 0;\n  \n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_alloc());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n  \n",
        "error_code": "//===---- test_target_data_map_alloc.c ---------------------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// The test_target_data_map group of tests checks all the possible map-type-modifiers\n// for the target data map clauses. These are: from, to, tofrom, alloc, release and \n// delete. There is a a separate c file for each test with the prefix test_target_data_map.\n// This specific test is for the 'alloc' clause. \n//\n//===----------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\n// Test for OpenMP 4.5 target data map(alloc:)\nint test_map_alloc() {\n\n  OMPVV_INFOMSG(\"test_map_alloc\");\n\n  int sum = 0, errors = 0;\n  int *h_array_h = (int *)malloc(N*sizeof(int));\n\n  // pointer arithmetic is not supported on the devices for\n  // the device address returned by \n\n  if (d_sum == NULL) {\n    errors = 1;\n    OMPVV_ERROR(\"omp_target_alloc returns NULL, this test is running on host, cannot properly test mapping of variables to device.\");\n    return errors;\n  }\n\n#pragma omp target data map(alloc: h_array_h[0:N])\n  {\n#pragma omp target is_device_ptr(d_sum)\n    {\n      for (int i = 0; i < N; ++i) \n        h_array_h[i] = 1;\n      \n      // checking errors\n      d_sum[0] = 0; \n      for (int i = 0; i < N; ++i)\n        d_sum[0] += h_array_h[i];\n    } // end target\n    omp_target_memcpy(&sum, d_sum, sizeof(int), 0, 0,\n                                  omp_get_initial_device(),\n                                  omp_get_default_device());\n  } // end target data\n  omp_target_free(d_sum, omp_get_default_device());\n\n  free(h_array_h);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (N - sum) != 0);\n\n  return errors;\n}\n\nint main() {\n\n  int errors = 0;\n  \n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_alloc());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n  \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_enter_exit_data_map_global_array.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  int errors = 0;\n\n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_SHARED_ENVIRONMENT;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_tofrom() != 0);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_delete() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 1632",
        "issue_id": 4,
        "original_code": "//===--- test_target_enter_exit_data_map_global_array.c ---------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test is in two parts. First, the test checks that mapping to on enter\n// followed by mapping from on exit works, by modifying the data on the\n// device. Then, the delete clause is tested by making sure that deleting\n// an array mapped to the device resets its reference count, meaning that\n// modifications made on the host are remapped back in when another map(to)\n// is encountered.\n//\n////===----------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <omp.h>\n\n#define N 10\n\nint A[N] = {0};\nint B[N] = {0};\n\nint test_tofrom() {\n  int errors = 0;\n\n  for (int i = 0; i < N; ++i) {\n    A[i] = 0;\n  }\n\n#pragma omp target enter data map(to: A)\n\n#pragma omp target\n  {\n    for (int i = 0; i < N; i++) {\n      A[i] = N;\n    }\n  }\n\n#pragma omp target exit data map(from: A)\n\n  for (int i = 0; i < N; ++i) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, A[i] != N);\n  }\n\n  return errors;\n}\n\nint test_delete() {\n  int errors = 0;\n\n  for (int i = 0; i < N; ++i) {\n    A[i] = N;\n  }\n\n#pragma omp target data map(tofrom: A) map(from: B)\n  {\n#pragma omp target exit data map(delete: A)\n    for (int i = 0; i < N; ++i) {\n      A[i] = 0;\n    }\n#pragma omp target map(to: A)   // if the delete does not work, this map will not happen.\n    {\n      for (int i = 0; i < N; ++i) {\n        B[i] = A[i];\n      }\n    }\n  }\n\n  for (int i = 0; i < N; ++i) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, B[i] != 0);\n  }\n\n  return errors;\n}\n\nint main () {\n  int errors = 0;\n\n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_SHARED_ENVIRONMENT;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_tofrom() != 0);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_delete() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_enter_exit_data_map_global_array.c ---------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test is in two parts. First, the test checks that mapping to on enter\n// followed by mapping from on exit works, by modifying the data on the\n// device. Then, the delete clause is tested by making sure that deleting\n// an array mapped to the device resets its reference count, meaning that\n// modifications made on the host are remapped back in when another map(to)\n// is encountered.\n//\n////===----------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <omp.h>\n\n#define N 10\n\nint A[N] = {0};\nint B[N] = {0};\n\nint test_tofrom() {\n  int errors = 0;\n\n  for (int i = 0; i < N; ++i) {\n    A[i] = 0;\n  }\n\n#pragma omp target enter data map(to: A)\n\n#pragma omp target\n  {\n    for (int i = 0; i < N; i++) {\n      A[i] = N;\n    }\n  }\n\n#pragma omp target exit data map(from: A)\n\n  for (int i = 0; i < N; ++i) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, A[i] != N);\n  }\n\n  return errors;\n}\n\nint test_delete() {\n  int errors = 0;\n\n  for (int i = 0; i < N; ++i) {\n    A[i] = N;\n  }\n\n#pragma omp target data map(tofrom: A) map(from: B)\n  {\n#pragma omp target exit data map(delete: A)\n    for (int i = 0; i < N; ++i) {\n      A[i] = 0;\n    }\n#pragma omp target map(to: A)   // if the delete does not work, this map will not happen.\n    {\n      for (int i = 0; i < N; ++i) {\n        B[i] = A[i];\n      }\n    }\n  }\n\n  for (int i = 0; i < N; ++i) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, B[i] != 0);\n  }\n\n  return errors;\n}\n\nint main () \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_data_map_tofrom.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1501",
        "issue_id": 1,
        "original_code": "//===---- test_target_data_map_tofrom.c -----------------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// The test_target_data_map group of tests checks all the possible map-type-modifiers\n// for the target data map clauses. These are: from, to, fromto, alloc, release and \n// delete. There is a a separate c file for each test with the prefix test_target_data_map.\n// This tests is specifically for the 'tofrom' clause. \n//\n//===----------------------------------------------------------------------------------===//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\n// Test for OpenMP 4.5 target data map(tofrom: ) \nint test_map_tofrom() {\n\n  OMPVV_INFOMSG(\"test_map_tofrom\");\n\n  int sum = 0, sum2 = 0, errors = 0;\n\n  // host arrays: heap and stack\n  int *h_array_h = (int *)malloc(N * sizeof(int));\n  int h_array_s[N];\n\n  for (int i = 0; i < N; ++i) {\n    h_array_h[i] = 0;\n    h_array_s[i] = 0;\n  }\n\n#pragma omp target data map(tofrom: h_array_h[0:N])    \\\n        map(tofrom : h_array_s[0:N]) \n  {\n#pragma omp target //map //remove map clause?\n    { \n      for (int i = 0; i < N; ++i) {\n        h_array_h[i] += 1;\n        h_array_s[i] += 1;\n      }\n    } // end target\n  } // end target data \n\n   // checking errors \n  for (int i = 0; i < N; ++i) {\n    sum += h_array_h[i];\n    sum2 += h_array_s[i];\n  }\n\n  free(h_array_h);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (N != sum) || (N != sum2));\n\n  return errors;\n}\n\nint main() {\n\n  int errors = 0;\n\n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_tofrom());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_data_map_tofrom.c -----------------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// The test_target_data_map group of tests checks all the possible map-type-modifiers\n// for the target data map clauses. These are: from, to, fromto, alloc, release and \n// delete. There is a a separate c file for each test with the prefix test_target_data_map.\n// This tests is specifically for the 'tofrom' clause. \n//\n//===----------------------------------------------------------------------------------===//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\n// Test for OpenMP 4.5 target data map(tofrom: ) \nint test_map_tofrom() {\n\n  OMPVV_INFOMSG(\"test_map_tofrom\");\n\n  int sum = 0, sum2 = 0, errors = 0;\n\n  // host arrays: heap and stack\n  int *h_array_h = (int *)malloc(N * sizeof(int));\n  int h_array_s[N];\n\n  for (int i = 0; i < N; ++i) {\n    h_array_h[i] = 0;\n    h_array_s[i] = 0;\n  }\n\n#pragma omp target data map(tofrom: h_array_h[0:N])    \\\n        map(tofrom : h_array_s[0:N]) \n  {\n#pragma omp target //map //remove map clause?\n    { \n      for (int i = 0; i < N; ++i) {\n        h_array_h[i] += 1;\n        h_array_s[i] += 1;\n      }\n    } // end target\n  } // end target data \n\n   // checking errors \n  for (int i = 0; i < N; ++i) {\n    sum += h_array_h[i];\n    sum2 += h_array_s[i];\n  }\n\n  free(h_array_h);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (N != sum) || (N != sum2));\n\n  return errors;\n}\n\nint main() \n\n  int errors = 0;\n\n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_tofrom());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_parallel_for_thread_limit.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp parallel\" at position 1341",
        "issue_id": 0,
        "original_code": "//===---- tests_target_teams_distribute_parallel_for_thread_limit.c ---------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// Test to check the thread_limit clause. This clause changes the upper limit of \n// the number of threads inside each of the contention groups created in the teams\n// region. This upper limit is different to the num_threads \n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define N 1024\n\nint test_target_teams_distribute_parallel_for_thread_limit() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_threads_limit\");\n\n  int tested_num_threads[] = {1, 10, 100, 10000};\n  int tested_thread_limit[] = {1, 10, 100, 10000};\n  int num_threads[N];\n  int thread_limit[N];\n  int errors = 0;\n  int i, nt, tl;\n\n  // Trying multiple num_threads and thread_limits\n  // values from 1 to a large number. The number of threads\n  // should never be larger than the thread limit\n  for (nt = 0; nt < 4; nt++) {\n    for (tl = 0; tl < 4; tl++) {\n      OMPVV_INFOMSG(\"Testing thread_limit(%d) num_threads(%d) clauses\", tested_thread_limit[tl], tested_num_threads[nt]);\n      // Initializing the num_threads and thread_limit array\n      for (i = 0; i < N; i++) {\n        num_threads[i] = -1;\n        thread_limit[i] = -1;\n      }\n\n#pragma omp target teams distribute parallel for map(tofrom: num_threads) \\\n        num_threads(tested_num_threads[nt]) thread_limit(tested_thread_limit[tl])\n      for (i = 0; i < N; i++) {\n        num_threads[i] = omp_get_num_threads();\n        thread_limit[i] = omp_get_thread_limit();\n      }\n   \n      int prevThreadLimit = -1;\n      for (i = 0; i < N; i++) {\n        OMPVV_INFOMSG_IF(prevThreadLimit != thread_limit[i], \"  reported thread limit = %d\", thread_limit[i]);\n        prevThreadLimit = thread_limit[i];\n  \n        // If the thread limit is not the one specified or the actual number \n        // of threads is greater than the thread limit, then it is an error\n        OMPVV_TEST_AND_SET_VERBOSE(errors, (thread_limit[i] > tested_thread_limit[tl]) || (thread_limit[i] <= 0));\n        OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads[i] > tested_thread_limit[tl]);\n        // For completeness, if the actual number of threads is grater than the \n        // selected number of threads, then it is an error\n        OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads[i] > tested_num_threads[nt]);\n      }\n    }\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_thread_limit());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- tests_target_teams_distribute_parallel_for_thread_limit.c ---------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// Test to check the thread_limit clause. This clause changes the upper limit of \n// the number of threads inside each of the contention groups created in the teams\n// region. This upper limit is different to the num_threads \n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define N 1024\n\nint test_target_teams_distribute_parallel_for_thread_limit() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_threads_limit\");\n\n  int tested_num_threads[] = {1, 10, 100, 10000};\n  int tested_thread_limit[] = {1, 10, 100, 10000};\n  int num_threads[N];\n  int thread_limit[N];\n  int errors = 0;\n  int i, nt, tl;\n\n  // Trying multiple num_threads and thread_limits\n  // values from 1 to a large number. The number of threads\n  // should never be larger than the thread limit\n  for (nt = 0; nt < 4; nt++) {\n    for (tl = 0; tl < 4; tl++) {\n      OMPVV_INFOMSG(\"Testing thread_limit(%d) num_threads(%d) clauses\", tested_thread_limit[tl], tested_num_threads[nt]);\n      // Initializing the num_threads and thread_limit array\n      for (i = 0; i < N; i++) {\n        num_threads[i] = -1;\n        thread_limit[i] = -1;\n      }\n\n#pragma omp parallel teams distribute parallel for map(tofrom: num_threads) \\\n        num_threads(tested_num_threads[nt]) thread_limit(tested_thread_limit[tl])\n      for (i = 0; i < N; i++) {\n        num_threads[i] = omp_get_num_threads();\n        thread_limit[i] = omp_get_thread_limit();\n      }\n   \n      int prevThreadLimit = -1;\n      for (i = 0; i < N; i++) {\n        OMPVV_INFOMSG_IF(prevThreadLimit != thread_limit[i], \"  reported thread limit = %d\", thread_limit[i]);\n        prevThreadLimit = thread_limit[i];\n  \n        // If the thread limit is not the one specified or the actual number \n        // of threads is greater than the thread limit, then it is an error\n        OMPVV_TEST_AND_SET_VERBOSE(errors, (thread_limit[i] > tested_thread_limit[tl]) || (thread_limit[i] <= 0));\n        OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads[i] > tested_thread_limit[tl]);\n        // For completeness, if the actual number of threads is grater than the \n        // selected number of threads, then it is an error\n        OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads[i] > tested_num_threads[nt]);\n      }\n    }\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_thread_limit());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_map_global_arrays.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1133",
        "issue_id": 1,
        "original_code": "//===--- test_target_map_global_arrays.c ------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// This test will check if an array that is declared and initialized in the host, \n// can be copied over the device, updated there, and then copied back. If this  \n// test runs on the host, we will warn that array is not allocated on any device.\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define N 10000\n\n//define compute_array globally\nint compute_array[N];\n\nint main() {\n  int sum = 0, errors = 0, result = 0;\n  int i;\n \n  // Host initialization of the array \n  for (i = 0; i < N; i++) \n    compute_array[i] = 0;\n\n  int isOffloading;\n  \n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading); \n  \n  OMPVV_WARNING_IF(!isOffloading, \"This test is running on host, array is not allocated on device\");\n\n#pragma omp target map(tofrom: compute_array[0:N])\n  {\n\t\n  // Updating the compute_array\n  for (i = 0; i < N; i++)\n      compute_array[i] = i;\n   \n  } // end target\n\n  // Comparing the results\n  for (i = 0; i < N; i++){\n    sum = sum + compute_array[i];    \n    result += i;\n  }  \n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != sum);\n\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n}\n\n",
        "error_code": "//===--- test_target_map_global_arrays.c ------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// This test will check if an array that is declared and initialized in the host, \n// can be copied over the device, updated there, and then copied back. If this  \n// test runs on the host, we will warn that array is not allocated on any device.\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define N 10000\n\n//define compute_array globally\nint compute_array[N];\n\nint main() {\n  int sum = 0, errors = 0, result = 0;\n  int i;\n \n  // Host initialization of the array \n  for (i = 0; i < N; i++) \n    compute_array[i] = 0;\n\n  int isOffloading;\n  \n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading); \n  \n  OMPVV_WARNING_IF(!isOffloading, \"This test is running on host, array is not allocated on device\");\n\n#pragma omp target map(tofrom: compute_array[0:N])\n  {\n\t\n  // Updating the compute_array\n  for (i = 0; i < N; i++)\n      compute_array[i] = i;\n   \n  } // end target\n\n  // Comparing the results\n  for (i = 0; i < N; i++)\n    sum = sum + compute_array[i];    \n    result += i;\n  }  \n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != sum);\n\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_task_ThrdPrivate.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n      IfTstFailed++;\n  }\" at position 1357",
        "issue_id": 4,
        "original_code": "//===-- test_task_ThrdPrivate.c ------------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// Description\n// 1) The aim of the test case is to verify the functionality\n// of threadprivate construct when used under the influence of task construct\n// FuncABC() functions tests if thread 0 still has updated GlobalVar variable\n// while other threads observed GlobalVar still see 0\n// 2) In the main there is a check to verify GlobalVar is 0. This is because\n// what ever changes happen inside the task block are not reflected outside\n//===----------------------------------------------------------------------===//\n\n\n#include <stdio.h>\n#include <stdbool.h>\n#include <unistd.h>\n#include \"omp.h\"\n#include \"ompvv.h\"\n#define THREADS 64\n\n#define INIT_VAL 9999\n\n\nint IfTstFailed = 0;\n\nint GlobalVar;\n#pragma omp threadprivate(GlobalVar)\n\nvoid FuncABC() {\n  int ThrdId = omp_get_thread_num();\n\n  {\n    if (ThrdId == 0) {\n      if ((GlobalVar != INIT_VAL)) {\n        IfTstFailed++;\n      }\n    } else {\n      if (GlobalVar != 0) {\n        IfTstFailed++;\n      }\n    }\n  }\n}\n\n\nint main() {\n  int errors = 0;\n  omp_set_num_threads(THREADS);\n  GlobalVar = INIT_VAL;\n#pragma omp parallel\n  {\n    int ThrdId = omp_get_thread_num();\n#pragma omp task if(0)\n    {\n      FuncABC();\n      GlobalVar = ThrdId;\n    }\n  }\n\n  if (GlobalVar != 0) {\n      IfTstFailed++;\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (IfTstFailed != 0));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===-- test_task_ThrdPrivate.c ------------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// Description\n// 1) The aim of the test case is to verify the functionality\n// of threadprivate construct when used under the influence of task construct\n// FuncABC() functions tests if thread 0 still has updated GlobalVar variable\n// while other threads observed GlobalVar still see 0\n// 2) In the main there is a check to verify GlobalVar is 0. This is because\n// what ever changes happen inside the task block are not reflected outside\n//===----------------------------------------------------------------------===//\n\n\n#include <stdio.h>\n#include <stdbool.h>\n#include <unistd.h>\n#include \"omp.h\"\n#include \"ompvv.h\"\n#define THREADS 64\n\n#define INIT_VAL 9999\n\n\nint IfTstFailed = 0;\n\nint GlobalVar;\n#pragma omp threadprivate(GlobalVar)\n\nvoid FuncABC() {\n  int ThrdId = omp_get_thread_num();\n\n  {\n    if (ThrdId == 0) {\n      if ((GlobalVar != INIT_VAL)) {\n        IfTstFailed++;\n      }\n    } else {\n      if (GlobalVar != 0) {\n        IfTstFailed++;\n      }\n    }\n  }\n}\n\n\nint main() {\n  int errors = 0;\n  omp_set_num_threads(THREADS);\n  GlobalVar = INIT_VAL;\n#pragma omp parallel\n  {\n    int ThrdId = omp_get_thread_num();\n#pragma omp task if(0)\n    {\n      FuncABC();\n      GlobalVar = ThrdId;\n    }\n  }\n\n  if (GlobalVar != 0) \n  OMPVV_TEST_AND_SET_VERBOSE(errors, (IfTstFailed != 0));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_depend_disjoint_section.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1996",
        "issue_id": 1,
        "original_code": "//===--- test_target_teams_distribute_depend_disjoint_section.c--------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks the out-out dependency of two tasks when the array\n// sections in the depend lists are disjoint (non-overlapping). If no\n// asynchronous behavior can be shown, then the test gives only a warning,\n// since this is still complaint. This test will fail if invalid values\n// are written.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_target_teams_distribute_depend_disjoint_section() {\n  int isOffloading = 0;\n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int async_found = 0;\n  int errors = 0;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n    b[x] = 2*x;\n    c[x] = 0;\n    d[x] = 0;\n  }\n\n#pragma omp target data map(to: a[0:N], b[0:N]) map(tofrom: c[0:N], d[0:N])\n  {\n#pragma omp target teams distribute nowait depend(out: c[0:N/2]) map(alloc: a[0:N], b[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n#pragma omp atomic\n      d[x] += a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(out: c[N/2:N/2]) map(alloc: a[0:N], b[0:N], c[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n#pragma omp atomic\n      c[x] += 2*(a[x] + b[x]) + d[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, c[x] != 6*x && c[x] != 9*x);\n    OMPVV_ERROR_IF(errors, \"Found invalid results, cannot show independence between depend clauses on disjoint array sections.\");\n    if (errors) {\n      break;\n    }\n    if (c[x] == 6*x) {\n      async_found = 1;\n    }\n  }\n\n  OMPVV_INFOMSG_IF(!errors && async_found, \"Found asynchronous behavior between depend clauses on disjoint array sections.\");\n  OMPVV_WARNING_IF(!errors && !async_found, \"Constructs ran in sequence, could not show lack of dependence since nowait had no effect.\");\n\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  errors += test_target_teams_distribute_depend_disjoint_section();\n  OMPVV_INFOMSG_IF(errors != 0, \"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_depend_disjoint_section.c--------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks the out-out dependency of two tasks when the array\n// sections in the depend lists are disjoint (non-overlapping). If no\n// asynchronous behavior can be shown, then the test gives only a warning,\n// since this is still complaint. This test will fail if invalid values\n// are written.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_target_teams_distribute_depend_disjoint_section() {\n  int isOffloading = 0;\n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int async_found = 0;\n  int errors = 0;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n    b[x] = 2*x;\n    c[x] = 0;\n    d[x] = 0;\n  }\n\n#pragma omp target data map(to: a[0:N], b[0:N]) map(tofrom: c[0:N], d[0:N])\n  {\n#pragma omp target teams distribute nowait depend(out: c[0:N/2]) map(alloc: a[0:N], b[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n#pragma omp atomic\n      d[x] += a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(out: c[N/2:N/2]) map(alloc: a[0:N], b[0:N], c[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n#pragma omp atomic\n      c[x] += 2*(a[x] + b[x]) + d[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, c[x] != 6*x && c[x] != 9*x);\n    OMPVV_ERROR_IF(errors, \"Found invalid results, cannot show independence between depend clauses on disjoint array sections.\");\n    if (errors) {\n      break;\n    }\n    if (c[x] == 6*x) {\n      async_found = 1;\n    }\n  }\n\n  OMPVV_INFOMSG_IF(!errors && async_found, \"Found asynchronous behavior between depend clauses on disjoint array sections.\");\n  OMPVV_WARNING_IF(!errors && !async_found, \"Constructs ran in sequence, could not show lack of dependence since nowait had no effect.\");\n\n  return errors;\n}\n\nint main() \n  int errors = 0;\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  errors += test_target_teams_distribute_depend_disjoint_section();\n  OMPVV_INFOMSG_IF(errors != 0, \"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_lastprivate.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n      privatized_array[0] = a[x] + b[x] + c[x];\n      privatized_array[1] = (a[x] + b[x]) * c[x];\n    }\" at position 1846",
        "issue_id": 4,
        "original_code": "//===--- test_target_teams_distribute_lastprivate.c--------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the lastprivate clause to indicate that the privatized value\n// that is passed as the parameter should also be returned with the value that\n// results from the thread that runs the last iteration of the for loop in the\n// target teams distribute directive.  The clause can be used with both scalar\n// and array data types and both situations are tested.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define SIZE 1024\n\nint main() {\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  int a[SIZE];\n  int b[SIZE];\n  int c[SIZE];\n  int privatized = 0;\n  int privatized_array[2];\n  int errors = 0;\n\n  for (int x = 0; x < SIZE; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    c[x] = 0;\n  }\n\n\n#pragma omp target data map(to: a[0:SIZE], b[0:SIZE]) map(tofrom: c[0:SIZE])\n  {\n#pragma omp target teams distribute lastprivate(privatized) map(alloc: a[0:SIZE], b[0:SIZE], c[0:SIZE]) \\\n  defaultmap(tofrom:scalar)\n    for (int x = 0; x < SIZE; ++x) {\n      privatized = a[x] - b[x];\n      c[x] = privatized + b[x];\n    }\n  }\n\n  for (int x = 0; x < SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, c[x] - a[x] != 0);\n    if (c[x] - a[x] != 0) {\n      break;\n    }\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, privatized != a[SIZE - 1] - b[SIZE - 1]);\n\n  for (int x = 0; x < SIZE; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    c[x] = x % 10;\n  }\n\n#pragma omp target data map(to: a[0:SIZE], b[0:SIZE], c[0:SIZE]) map(tofrom: privatized_array[0:2])\n  {\n#pragma omp target teams distribute lastprivate(privatized_array) map(alloc: a[0:SIZE], b[0:SIZE], c[0:SIZE])\n    for (int x = 0; x < SIZE; ++x) {\n      privatized_array[0] = a[x] + b[x] + c[x];\n      privatized_array[1] = (a[x] + b[x]) * c[x];\n    }\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, privatized_array[0] != (a[SIZE - 1] + b[SIZE - 1] + c[SIZE - 1]));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, privatized_array[1] != ((a[SIZE - 1] + b[SIZE - 1]) * c[SIZE - 1]));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_lastprivate.c--------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the lastprivate clause to indicate that the privatized value\n// that is passed as the parameter should also be returned with the value that\n// results from the thread that runs the last iteration of the for loop in the\n// target teams distribute directive.  The clause can be used with both scalar\n// and array data types and both situations are tested.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define SIZE 1024\n\nint main() {\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  int a[SIZE];\n  int b[SIZE];\n  int c[SIZE];\n  int privatized = 0;\n  int privatized_array[2];\n  int errors = 0;\n\n  for (int x = 0; x < SIZE; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    c[x] = 0;\n  }\n\n\n#pragma omp target data map(to: a[0:SIZE], b[0:SIZE]) map(tofrom: c[0:SIZE])\n  {\n#pragma omp target teams distribute lastprivate(privatized) map(alloc: a[0:SIZE], b[0:SIZE], c[0:SIZE]) \\\n  defaultmap(tofrom:scalar)\n    for (int x = 0; x < SIZE; ++x) {\n      privatized = a[x] - b[x];\n      c[x] = privatized + b[x];\n    }\n  }\n\n  for (int x = 0; x < SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, c[x] - a[x] != 0);\n    if (c[x] - a[x] != 0) {\n      break;\n    }\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, privatized != a[SIZE - 1] - b[SIZE - 1]);\n\n  for (int x = 0; x < SIZE; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    c[x] = x % 10;\n  }\n\n#pragma omp target data map(to: a[0:SIZE], b[0:SIZE], c[0:SIZE]) map(tofrom: privatized_array[0:2])\n  {\n#pragma omp target teams distribute lastprivate(privatized_array) map(alloc: a[0:SIZE], b[0:SIZE], c[0:SIZE])\n    for (int x = 0; x < SIZE; ++x) \n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, privatized_array[0] != (a[SIZE - 1] + b[SIZE - 1] + c[SIZE - 1]));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, privatized_array[1] != ((a[SIZE - 1] + b[SIZE - 1]) * c[SIZE - 1]));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_update_devices.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 5105",
        "issue_id": 1,
        "original_code": "//===--- test_target_update_devices.c--------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks if the target update directive works on different devices.\n// We check two different variants.\n// 1. setting up the default device with the API call omp_set_default_device()\n// 2. using the device clause of the target update directive.\n//\n// Testing metodology uses an array that gets mapped into the device at first\n// through target enter data. Then on each iteration we update the array in one\n// device, create a compute region in that device, and then update it back\n// We also record that the compute region is not executed in the host\n// with the omp_is_initial_device() API call. Unfortunately 4.5 has no device\n// number API call.\n//\n////===----------------------------------------------------------------------===//\n\n\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\n/*\n * This test check if update device works well\n * when the omp_set_default_device API call is used\n * to change the default device\n */\nint test_set_default_dev() {\n  OMPVV_INFOMSG(\"test_set_default_dev\");\n\n  // Get number of devices\n  int num_dev = omp_get_num_devices();\n  OMPVV_INFOMSG(\"num_devices: %d\", num_dev);\n\n  int def_dev = omp_get_default_device();\n  OMPVV_INFOMSG(\"initial device: %d\", omp_get_initial_device());\n  OMPVV_INFOMSG(\"default device: %d\", def_dev);\n\n  int sum = 0;\n  int errors = 0;\n  int isHost[num_dev];\n  int h_matrix[N];\n\n  // Mapping the array to all the devices\n  for (int dev = 0; dev < num_dev; ++dev) {\n    omp_set_default_device(dev);\n    // unstructured mapping\n    {\n#pragma omp target enter data map(alloc: h_matrix[0:N])\n        printf(\"\"); // forcing the compiler to not moving out of the scope\n    }\n  }\n\n  // Initialize the array\n  for (int i = 0; i < N; ++i) {\n    h_matrix[i] = 0;\n  }\n\n  // Each device gets updated with the current array version,\n  // one gets added to each element in the array, and then\n  // the host gets the updated version\n  for (int dev = 0; dev < num_dev; ++dev) {\n    omp_set_default_device(dev);\n#pragma omp target update to(h_matrix[0:N])\n    // operation\n#pragma omp target map(alloc: h_matrix[0:N]) map(tofrom: isHost[dev:1]) // map(alloc: ) to avoid target to map the entire matrix h_matrix[:]\n    {\n      // Check on device or host execution\n      isHost[dev] = omp_is_initial_device();\n\n      for (int i = 0; i < N; ++i) {\n        h_matrix[i]++;\n      }\n    }\n#pragma omp target update from(h_matrix[0:N])\n    // unstructured exit\n  }\n\n  // Unmap the matrix\n  for (int dev = 0; dev < num_dev; ++dev) {\n    omp_set_default_device(dev);\n#pragma omp target exit data map(delete: h_matrix[0:N])\n    printf(\"\");\n  }\n\n  // checking results\n  for (int dev = 0; dev < num_dev; ++dev) {\n    OMPVV_INFOMSG(\"device %d ran on the %s\", dev, (isHost[dev])? \"host\" : \"device\");\n  }\n  for (int i = 0; i < N; ++i) {\n    sum += h_matrix[i];\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (num_dev * N != sum));\n\n  omp_set_default_device(def_dev);\n\n  return errors;\n}\n\n/*\n * This test checks if using the device clause in\n * data update works fine\n */\nint test_device() {\n  OMPVV_INFOMSG(\"test_device_clause\");\n\n  // Get number of devices\n  int num_dev = omp_get_num_devices();\n  OMPVV_INFOMSG(\"num_devices: %d\", num_dev);\n\n  int def_dev = omp_get_default_device();\n  OMPVV_INFOMSG(\"initial device: %d\", omp_get_initial_device());\n  OMPVV_INFOMSG(\"default device: %d\", def_dev);\n\n  int sum = 0;\n  int errors = 0;\n  int isHost[num_dev];\n  int h_matrix[N];\n\n  // Mapping the array to all the devices\n  for (int dev = 0; dev < num_dev; ++dev) {\n    // unstructured mapping\n    {\n#pragma omp target enter data map(alloc: h_matrix[0:N]) device(dev)\n        printf(\"\"); // forcing the compiler to not moving out of the scope\n    }\n  }\n\n  // Initialize the array\n  for (int i = 0; i < N; ++i) {\n    h_matrix[i] = 0;\n  }\n\n  // Each device gets updated with the current array version,\n  // one gets added to each element in the array, and then\n  // the host gets the updated version\n  for (int dev = 0; dev < num_dev; ++dev) {\n#pragma omp target update to(h_matrix[0:N]) device(dev)\n    // operation\n#pragma omp target map(alloc: h_matrix[0:N]) map(tofrom: isHost[dev:1]) \\\n    device(dev)// map(alloc: ) to avoid target to map the entire matrix h_matrix[:]\n    {\n      // Check on device or host execution\n      isHost[dev] = omp_is_initial_device();\n\n      for (int i = 0; i < N; ++i) {\n        h_matrix[i]++;\n      }\n    }\n#pragma omp target update from(h_matrix[0:N]) device(dev)\n    // unstructured exit\n  }\n\n  // Unmap the matrix\n  for (int dev = 0; dev < num_dev; ++dev) {\n#pragma omp target exit data map(delete: h_matrix[0:N]) device(dev)\n    printf(\"\");\n  }\n\n  // checking results\n  for (int dev = 0; dev < num_dev; ++dev) {\n    OMPVV_INFOMSG(\"device %d ran on the %s\", dev, (isHost[dev])? \"host\" : \"device\");\n  }\n  for (int i = 0; i < N; ++i) {\n    sum += h_matrix[i];\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (num_dev * N != sum));\n\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET(errors, test_set_default_dev());\n  OMPVV_TEST_AND_SET(errors, test_device());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_update_devices.c--------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks if the target update directive works on different devices.\n// We check two different variants.\n// 1. setting up the default device with the API call omp_set_default_device()\n// 2. using the device clause of the target update directive.\n//\n// Testing metodology uses an array that gets mapped into the device at first\n// through target enter data. Then on each iteration we update the array in one\n// device, create a compute region in that device, and then update it back\n// We also record that the compute region is not executed in the host\n// with the omp_is_initial_device() API call. Unfortunately 4.5 has no device\n// number API call.\n//\n////===----------------------------------------------------------------------===//\n\n\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\n/*\n * This test check if update device works well\n * when the omp_set_default_device API call is used\n * to change the default device\n */\nint test_set_default_dev() {\n  OMPVV_INFOMSG(\"test_set_default_dev\");\n\n  // Get number of devices\n  int num_dev = omp_get_num_devices();\n  OMPVV_INFOMSG(\"num_devices: %d\", num_dev);\n\n  int def_dev = omp_get_default_device();\n  OMPVV_INFOMSG(\"initial device: %d\", omp_get_initial_device());\n  OMPVV_INFOMSG(\"default device: %d\", def_dev);\n\n  int sum = 0;\n  int errors = 0;\n  int isHost[num_dev];\n  int h_matrix[N];\n\n  // Mapping the array to all the devices\n  for (int dev = 0; dev < num_dev; ++dev) {\n    omp_set_default_device(dev);\n    // unstructured mapping\n    {\n#pragma omp target enter data map(alloc: h_matrix[0:N])\n        printf(\"\"); // forcing the compiler to not moving out of the scope\n    }\n  }\n\n  // Initialize the array\n  for (int i = 0; i < N; ++i) {\n    h_matrix[i] = 0;\n  }\n\n  // Each device gets updated with the current array version,\n  // one gets added to each element in the array, and then\n  // the host gets the updated version\n  for (int dev = 0; dev < num_dev; ++dev) {\n    omp_set_default_device(dev);\n#pragma omp target update to(h_matrix[0:N])\n    // operation\n#pragma omp target map(alloc: h_matrix[0:N]) map(tofrom: isHost[dev:1]) // map(alloc: ) to avoid target to map the entire matrix h_matrix[:]\n    {\n      // Check on device or host execution\n      isHost[dev] = omp_is_initial_device();\n\n      for (int i = 0; i < N; ++i) {\n        h_matrix[i]++;\n      }\n    }\n#pragma omp target update from(h_matrix[0:N])\n    // unstructured exit\n  }\n\n  // Unmap the matrix\n  for (int dev = 0; dev < num_dev; ++dev) {\n    omp_set_default_device(dev);\n#pragma omp target exit data map(delete: h_matrix[0:N])\n    printf(\"\");\n  }\n\n  // checking results\n  for (int dev = 0; dev < num_dev; ++dev) {\n    OMPVV_INFOMSG(\"device %d ran on the %s\", dev, (isHost[dev])? \"host\" : \"device\");\n  }\n  for (int i = 0; i < N; ++i) {\n    sum += h_matrix[i];\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (num_dev * N != sum));\n\n  omp_set_default_device(def_dev);\n\n  return errors;\n}\n\n/*\n * This test checks if using the device clause in\n * data update works fine\n */\nint test_device() {\n  OMPVV_INFOMSG(\"test_device_clause\");\n\n  // Get number of devices\n  int num_dev = omp_get_num_devices();\n  OMPVV_INFOMSG(\"num_devices: %d\", num_dev);\n\n  int def_dev = omp_get_default_device();\n  OMPVV_INFOMSG(\"initial device: %d\", omp_get_initial_device());\n  OMPVV_INFOMSG(\"default device: %d\", def_dev);\n\n  int sum = 0;\n  int errors = 0;\n  int isHost[num_dev];\n  int h_matrix[N];\n\n  // Mapping the array to all the devices\n  for (int dev = 0; dev < num_dev; ++dev) {\n    // unstructured mapping\n    {\n#pragma omp target enter data map(alloc: h_matrix[0:N]) device(dev)\n        printf(\"\"); // forcing the compiler to not moving out of the scope\n    }\n  }\n\n  // Initialize the array\n  for (int i = 0; i < N; ++i) {\n    h_matrix[i] = 0;\n  }\n\n  // Each device gets updated with the current array version,\n  // one gets added to each element in the array, and then\n  // the host gets the updated version\n  for (int dev = 0; dev < num_dev; ++dev) {\n#pragma omp target update to(h_matrix[0:N]) device(dev)\n    // operation\n#pragma omp target map(alloc: h_matrix[0:N]) map(tofrom: isHost[dev:1]) \\\n    device(dev)// map(alloc: ) to avoid target to map the entire matrix h_matrix[:]\n    {\n      // Check on device or host execution\n      isHost[dev] = omp_is_initial_device();\n\n      for (int i = 0; i < N; ++i) {\n        h_matrix[i]++;\n      }\n    }\n#pragma omp target update from(h_matrix[0:N]) device(dev)\n    // unstructured exit\n  }\n\n  // Unmap the matrix\n  for (int dev = 0; dev < num_dev; ++dev) {\n#pragma omp target exit data map(delete: h_matrix[0:N]) device(dev)\n    printf(\"\");\n  }\n\n  // checking results\n  for (int dev = 0; dev < num_dev; ++dev) {\n    OMPVV_INFOMSG(\"device %d ran on the %s\", dev, (isHost[dev])? \"host\" : \"device\");\n  }\n  for (int i = 0; i < N; ++i) {\n    sum += h_matrix[i];\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (num_dev * N != sum));\n\n\n  return errors;\n}\n\nint main() \n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET(errors, test_set_default_dev());\n  OMPVV_TEST_AND_SET(errors, test_device());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_simd.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp flush\" at position 1267",
        "issue_id": 0,
        "original_code": "//===---- test_target_simd.c - Using combined construct target simd -===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// SIMD in OpenMP 4.5 does not have any API that allows us to confirm the creation \n// of SIMD lanes, nor the use of SIMD instructions in any architecture. Hence, our\n// tests are limited in that they check that the expected result is created, but\n// assume nothing in how they are mapped into a particular architecture\n//\n// This test creates a regular for loop and uses the combined target simd directive \n// then it checks that the values of the array are as expected\n//===--------------------------------------------------------------------------===//\n//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define ARRAY_SIZE 1024\n\nint test_target_simd() {\n  OMPVV_INFOMSG(\"test_target_simd\");\n  OMPVV_WARNING(\"This test cannot check if actual SIMD extensions at the hardware level\"\n                 \" were used, or of the generated code is different in any way\");\n\n  // Variable for errors counting\n  int errors = 0;\n\n  int a[ARRAY_SIZE];\n  int b[ARRAY_SIZE];\n  int c[ARRAY_SIZE];\n  int i;\n\n  // a and b array initialization\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      a[i] = 1;\n      b[i] = i;\n      c[i] = 2 * i;\n  }\n\n\n#pragma omp target simd map(to: b[0:ARRAY_SIZE], c[0:ARRAY_SIZE]) map(tofrom: a[0:ARRAY_SIZE])\n    for (i = 0; i < ARRAY_SIZE; ++i) {\n        a[i] += b[i] * c[i];\n    }\n\n\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      OMPVV_TEST_AND_SET(errors, (a[i] != 1 + (b[i] * c[i])));\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_simd());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_simd.c - Using combined construct target simd -===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// SIMD in OpenMP 4.5 does not have any API that allows us to confirm the creation \n// of SIMD lanes, nor the use of SIMD instructions in any architecture. Hence, our\n// tests are limited in that they check that the expected result is created, but\n// assume nothing in how they are mapped into a particular architecture\n//\n// This test creates a regular for loop and uses the combined target simd directive \n// then it checks that the values of the array are as expected\n//===--------------------------------------------------------------------------===//\n//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define ARRAY_SIZE 1024\n\nint test_target_simd() {\n  OMPVV_INFOMSG(\"test_target_simd\");\n  OMPVV_WARNING(\"This test cannot check if actual SIMD extensions at the hardware level\"\n                 \" were used, or of the generated code is different in any way\");\n\n  // Variable for errors counting\n  int errors = 0;\n\n  int a[ARRAY_SIZE];\n  int b[ARRAY_SIZE];\n  int c[ARRAY_SIZE];\n  int i;\n\n  // a and b array initialization\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      a[i] = 1;\n      b[i] = i;\n      c[i] = 2 * i;\n  }\n\n\n#pragma omp flush simd map(to: b[0:ARRAY_SIZE], c[0:ARRAY_SIZE]) map(tofrom: a[0:ARRAY_SIZE])\n    for (i = 0; i < ARRAY_SIZE; ++i) {\n        a[i] += b[i] * c[i];\n    }\n\n\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      OMPVV_TEST_AND_SET(errors, (a[i] != 1 + (b[i] * c[i])));\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_simd());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_taskloop_collapse.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp parallel\" with directive \"#pragma omp map\" at position 1137",
        "issue_id": 0,
        "original_code": "//------------------------------------------- test_taskloop_collapse.c --------------------------------------//\n// OpenMP API Version 4.5 September 2015\n//\n// This test checks the 'taskloop' directive with the 'collapse' clause specified.\n// The 'taskloop' construct parallelizes loops with independent iterations by creating tasks. \n// It allows for efficient parallel execution of loop iterations by distributing them among multiple threads. \n// The 'collapse' clause ensures that multiple nested loops into a single loop.      \n//----------------------------------------------------------------------------------------------------------//\n\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define NUM_THREADS 100\n#define NUM_COLLAPSE 2\n\nint test_taskloop_collapse() {\n\n  int errors = 0;\n\n  int size = 200;\n  int a[(size*size)];\n  \n  int sum_without_openmp = 0, sum_with_openmp = 0;\n   \n  for(int i = 0; i < (size*size); i++) {\n   \ta[i] = i;\n   }\n\n   //get valid sum without openmp\n   for(int i = 0; i < (size); i++) {\n\tfor(int j = 0; j < size; j++) {\n\t     sum_without_openmp = sum_without_openmp + (a[i]*a[j]);\n\t}\n   }\n   \n   #pragma omp parallel num_threads(NUM_THREADS)\n   {\n      #pragma omp single\n      {\n\t#pragma omp taskloop collapse(NUM_COLLAPSE)  \n        for(int i = 0; i < size; i++) \n\t{\n\t    for(int j = 0; j < size; j++) \n\t    {\n\t\t    #pragma omp atomic\n\t\t    sum_with_openmp = sum_with_openmp + (a[i]*a[j]); \n            }\n\t}\n      }\t   \n   }\n   \n   OMPVV_TEST_AND_SET_VERBOSE(errors, sum_with_openmp != sum_without_openmp);\n\n   return errors;\n}\n\nint main() {\n  \n  int errors = 0;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, (test_taskloop_collapse()) != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n\n  return 0;\n}\n",
        "error_code": "//------------------------------------------- test_taskloop_collapse.c --------------------------------------//\n// OpenMP API Version 4.5 September 2015\n//\n// This test checks the 'taskloop' directive with the 'collapse' clause specified.\n// The 'taskloop' construct parallelizes loops with independent iterations by creating tasks. \n// It allows for efficient parallel execution of loop iterations by distributing them among multiple threads. \n// The 'collapse' clause ensures that multiple nested loops into a single loop.      \n//----------------------------------------------------------------------------------------------------------//\n\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define NUM_THREADS 100\n#define NUM_COLLAPSE 2\n\nint test_taskloop_collapse() {\n\n  int errors = 0;\n\n  int size = 200;\n  int a[(size*size)];\n  \n  int sum_without_openmp = 0, sum_with_openmp = 0;\n   \n  for(int i = 0; i < (size*size); i++) {\n   \ta[i] = i;\n   }\n\n   //get valid sum without openmp\n   for(int i = 0; i < (size); i++) {\n\tfor(int j = 0; j < size; j++) {\n\t     sum_without_openmp = sum_without_openmp + (a[i]*a[j]);\n\t}\n   }\n   \n   #pragma omp map num_threads(NUM_THREADS)\n   {\n      #pragma omp single\n      {\n\t#pragma omp taskloop collapse(NUM_COLLAPSE)  \n        for(int i = 0; i < size; i++) \n\t{\n\t    for(int j = 0; j < size; j++) \n\t    {\n\t\t    #pragma omp atomic\n\t\t    sum_with_openmp = sum_with_openmp + (a[i]*a[j]); \n            }\n\t}\n      }\t   \n   }\n   \n   OMPVV_TEST_AND_SET_VERBOSE(errors, sum_with_openmp != sum_without_openmp);\n\n   return errors;\n}\n\nint main() {\n  \n  int errors = 0;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, (test_taskloop_collapse()) != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n\n  return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/qmcpack_target_math.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===--- qmcpack_target_math.c --- math lib invocation inside target---------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n//This is a QMCPACK specific test that looks at math library support \n//from within the target region. The array is initialized to FP_ZERO\n//and subsequently pow math function is invoked form the target region.\n//\n////===----------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#include \"ompvv.h\"\n\n#define N 1000\n\nint test_math_lib_inside_target() {\n  OMPVV_INFOMSG(\"test_math_lib_inside_target\");\n\n  double array[N];\n  int errors = 0;\n  \n  // Array initialization\n  for (int i = 0; i < N; ++i) {\n    array[i] = 0.99;\n  }\n  // This is intentional\n  int c99_zero = FP_ZERO;\n  \n#pragma omp target map(tofrom: array[0:N]) \n  for (int i = 0; i < N; ++i) {\n    array[i] = pow((double)i,2.0);\n  }\n\n  for (int i = 0; i < N; ++i) {\n    OMPVV_TEST_AND_SET(errors, (array[i] - pow((double)i,2)) > 0.000009);\n  }\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_math_lib_inside_target());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nshort mqnqhrziik = 238;\ndouble aosmkcnpuf = 167;\nint gtkxxdbqwj = 63;\nlong xwjpxiauvx = 31;\nbyte ulmcfihxbu = 166;\nshort gialrhxoqi = 141;\ndouble ttmtrnorah = 182;\ndouble uyaobeojnl = 251;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_data_if.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  int isOffloading = 0;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"Offloading is off, tests will be inconclusive. No way to tests if\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_data_map_if_nested(isOffloading) != 0);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_data_map_if_simple(isOffloading) != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 6454",
        "issue_id": 4,
        "original_code": "//===---- test_target_data_if.c - check the if clause of target data ------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// The if clause determines if the section should be executed in the host or\n// the device. There are three things to test here:\n// (a) with offloading when 'if' clause evaluates to true then code\n// be executed on the device\n// (b) with offloading when 'if' clause evaluates to false then code should\n// be executed on the host\n// (c) without offloading all the code should be executed on the device\n// The if clause is evaluated on runtime which means that variables could\n// determine this behavior. We use a SIZE_THRESHOLD variable to check if we\n// should execute on the device or the host. Before starting the test we\n// sample offloading to see if it was enabled or not. If the code is executed\n// in the device, the result should be c[i] = a[i] + b[i] = i + 1.\n// If the code is executed on the host the result should be c[i] = -1\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define SIZE 1024\n#define SIZE_THRESHOLD 512\n\nint test_target_data_map_if_nested (int isOffloading){\n  int a[SIZE];\n  int b[SIZE];\n  int c[SIZE];\n  int map_size, i = 0, errors[2] = {0,0}, isHost = -1;\n\n  // a and b array initialization\n  for (i = 0; i < SIZE; i++) {\n    a[i] = 1;\n    b[i] = i;\n  }\n\n  // check multiple sizes.\n  for (map_size = 256; map_size <= SIZE; map_size += 256) {\n    // C initialization\n    for (i = 0; i < map_size; i++) {\n      c[i] = -1;\n    }\n#pragma omp target data if(map_size > SIZE_THRESHOLD) map(to: map_size)  \\\n        map(tofrom: c[0:map_size])                                       \\\n        map(to: a[0:map_size], b[0:map_size])\n    {\n#pragma omp target if(map_size > SIZE_THRESHOLD) map(tofrom: isHost) \\\n        map (alloc: a[0:map_size], b[0:map_size], c[0:map_size]) // avoid default mapping\n      {\n        isHost = omp_is_initial_device();\n        int alpha = (isHost ? 0 : 1);\n        int j = 0;\n        for (j = 0; j < map_size; j++) {\n          // c[j] is zero if executed in the host\n          // c[j] is 1+j if executed on the device\n          c[j] = alpha*(a[j] + b[j]);\n        }\n      } // end target\n    }//end-target data\n\n    // checking results\n    for (i = 0; i < map_size; i++) {\n      if (isOffloading && map_size > SIZE_THRESHOLD) {\n        // Should have executed on the device\n        // if offloading was used\n        // c[i] is zero if it was executed in the host\n        OMPVV_TEST_AND_SET(errors[0], (c[i] != i + 1)); //error when executed on the device\n      } else {\n        // Should have executed in the host\n        // with or without offloading\n        OMPVV_TEST_AND_SET(errors[1], (c[i] != 0));\n      } //end-else\n    }\n  } // end-for map_size\n\n  if (!errors[0] && !errors[1]) {\n    OMPVV_INFOMSG(\"Test nested if passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  } else if (errors[0]==0 && errors[1]!=0) {\n    OMPVV_ERROR(\"Test nested if failed on host with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n  } else if (errors[0]!=0 && errors[1]==0) {\n    OMPVV_ERROR(\"Test nested if failed on device with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n  } else if (errors[0]!=0 && errors[1]!=0) {\n    OMPVV_ERROR(\"Test nested if failed on host and device with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n  }\n\n  return errors[0] + errors[1];\n}\n\nint test_target_data_map_if_simple(int isOffloading){\n  int a[SIZE];\n  int b[SIZE];\n  int c[SIZE];\n  int map_size, i = 0, errors[3] = {0,0,0}, isHost = -1;\n\n  // check multiple sizes.\n  for (map_size = 256; map_size <= SIZE; map_size += 256) {\n    // a, b, and c array initialization\n    for (i = 0; i < SIZE; i++) {\n      a[i] = SIZE - i;\n      b[i] = i;\n      c[i] = -1;\n    }\n#pragma omp target data if(map_size > SIZE_THRESHOLD) map(to: map_size)  \\\n        map(tofrom: c[0:map_size])                             \\\n        map(to: a[0:map_size], b[0:map_size])\n    {\n#pragma omp target map(tofrom: isHost) \\\n        map (alloc: a[0:map_size], b[0:map_size], c[0:map_size]) // avoid default mapping\n      {\n        isHost = omp_is_initial_device();\n        int j = 0;\n        for (j = 0; j < map_size; j++) {\n          // This should be equal to SIZE, if target data\n          // mapped the arrays a and b, otherwise it is\n          // unknown but it is not used either\n          c[j] += (a[j] + b[j] + 1);\n          a[j] = -1; // changing memory content this should not affect original storage\n          b[j] = -1; // changing memory content\n        }\n      } // end target\n\n      // Check that the target region did not exec in the\n      // host as the if should only affect the target data\n      if (isOffloading) {\n        OMPVV_TEST_AND_SET_VERBOSE(errors[0], isHost);\n      }\n    }//end-target data\n\n    // checking results\n    for (i = 0; i < map_size; i++) {\n      if (map_size > SIZE_THRESHOLD || !isOffloading) {\n        // Should have executed in the device if offloading is enabled\n        // If offloading is not enabled or the system is a shared env\n        // between device and host, then the value will modify the original\n        // elements of c.\n        OMPVV_TEST_AND_SET(errors[1], (c[i] != SIZE)); //error when executed on the device\n      } else {\n        // Should have executed in the host\n        // with or without offloading\n        OMPVV_TEST_AND_SET(errors[2], (c[i] != -1));\n      } //end-else\n    }\n  } // end-for map_size\n\n  if (errors[0]) {\n    OMPVV_ERROR(\"Test did not offload to the device. 'If' clause might be affecting the target\"\n                \" offlading as well and it should not \")\n  }\n  if (!errors[0] && !errors[1] && !errors[2]) {\n    OMPVV_INFOMSG(\"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  } else if (errors[1]==0 && errors[2]!=0) {\n    OMPVV_ERROR(\"Test failed for if (false) with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n  } else if (errors[1]!=0 && errors[2]==0) {\n    OMPVV_ERROR(\"Test failed for if (true) with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n  } else if (errors[1]!=0 && errors[2]!=0) {\n    OMPVV_ERROR(\"Test failed for if(true) and if(false) with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n  }\n\n  return errors[0] + errors[1] + errors[2];\n}\n\n// Test for OpenMP 4.5 target data with if\nint main() {\n  int isOffloading = 0;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"Offloading is off, tests will be inconclusive. No way to tests if\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_data_map_if_nested(isOffloading) != 0);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_data_map_if_simple(isOffloading) != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_data_if.c - check the if clause of target data ------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// The if clause determines if the section should be executed in the host or\n// the device. There are three things to test here:\n// (a) with offloading when 'if' clause evaluates to true then code\n// be executed on the device\n// (b) with offloading when 'if' clause evaluates to false then code should\n// be executed on the host\n// (c) without offloading all the code should be executed on the device\n// The if clause is evaluated on runtime which means that variables could\n// determine this behavior. We use a SIZE_THRESHOLD variable to check if we\n// should execute on the device or the host. Before starting the test we\n// sample offloading to see if it was enabled or not. If the code is executed\n// in the device, the result should be c[i] = a[i] + b[i] = i + 1.\n// If the code is executed on the host the result should be c[i] = -1\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define SIZE 1024\n#define SIZE_THRESHOLD 512\n\nint test_target_data_map_if_nested (int isOffloading){\n  int a[SIZE];\n  int b[SIZE];\n  int c[SIZE];\n  int map_size, i = 0, errors[2] = {0,0}, isHost = -1;\n\n  // a and b array initialization\n  for (i = 0; i < SIZE; i++) {\n    a[i] = 1;\n    b[i] = i;\n  }\n\n  // check multiple sizes.\n  for (map_size = 256; map_size <= SIZE; map_size += 256) {\n    // C initialization\n    for (i = 0; i < map_size; i++) {\n      c[i] = -1;\n    }\n#pragma omp target data if(map_size > SIZE_THRESHOLD) map(to: map_size)  \\\n        map(tofrom: c[0:map_size])                                       \\\n        map(to: a[0:map_size], b[0:map_size])\n    {\n#pragma omp target if(map_size > SIZE_THRESHOLD) map(tofrom: isHost) \\\n        map (alloc: a[0:map_size], b[0:map_size], c[0:map_size]) // avoid default mapping\n      {\n        isHost = omp_is_initial_device();\n        int alpha = (isHost ? 0 : 1);\n        int j = 0;\n        for (j = 0; j < map_size; j++) {\n          // c[j] is zero if executed in the host\n          // c[j] is 1+j if executed on the device\n          c[j] = alpha*(a[j] + b[j]);\n        }\n      } // end target\n    }//end-target data\n\n    // checking results\n    for (i = 0; i < map_size; i++) {\n      if (isOffloading && map_size > SIZE_THRESHOLD) {\n        // Should have executed on the device\n        // if offloading was used\n        // c[i] is zero if it was executed in the host\n        OMPVV_TEST_AND_SET(errors[0], (c[i] != i + 1)); //error when executed on the device\n      } else {\n        // Should have executed in the host\n        // with or without offloading\n        OMPVV_TEST_AND_SET(errors[1], (c[i] != 0));\n      } //end-else\n    }\n  } // end-for map_size\n\n  if (!errors[0] && !errors[1]) {\n    OMPVV_INFOMSG(\"Test nested if passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  } else if (errors[0]==0 && errors[1]!=0) {\n    OMPVV_ERROR(\"Test nested if failed on host with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n  } else if (errors[0]!=0 && errors[1]==0) {\n    OMPVV_ERROR(\"Test nested if failed on device with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n  } else if (errors[0]!=0 && errors[1]!=0) {\n    OMPVV_ERROR(\"Test nested if failed on host and device with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n  }\n\n  return errors[0] + errors[1];\n}\n\nint test_target_data_map_if_simple(int isOffloading){\n  int a[SIZE];\n  int b[SIZE];\n  int c[SIZE];\n  int map_size, i = 0, errors[3] = {0,0,0}, isHost = -1;\n\n  // check multiple sizes.\n  for (map_size = 256; map_size <= SIZE; map_size += 256) {\n    // a, b, and c array initialization\n    for (i = 0; i < SIZE; i++) {\n      a[i] = SIZE - i;\n      b[i] = i;\n      c[i] = -1;\n    }\n#pragma omp target data if(map_size > SIZE_THRESHOLD) map(to: map_size)  \\\n        map(tofrom: c[0:map_size])                             \\\n        map(to: a[0:map_size], b[0:map_size])\n    {\n#pragma omp target map(tofrom: isHost) \\\n        map (alloc: a[0:map_size], b[0:map_size], c[0:map_size]) // avoid default mapping\n      {\n        isHost = omp_is_initial_device();\n        int j = 0;\n        for (j = 0; j < map_size; j++) {\n          // This should be equal to SIZE, if target data\n          // mapped the arrays a and b, otherwise it is\n          // unknown but it is not used either\n          c[j] += (a[j] + b[j] + 1);\n          a[j] = -1; // changing memory content this should not affect original storage\n          b[j] = -1; // changing memory content\n        }\n      } // end target\n\n      // Check that the target region did not exec in the\n      // host as the if should only affect the target data\n      if (isOffloading) {\n        OMPVV_TEST_AND_SET_VERBOSE(errors[0], isHost);\n      }\n    }//end-target data\n\n    // checking results\n    for (i = 0; i < map_size; i++) {\n      if (map_size > SIZE_THRESHOLD || !isOffloading) {\n        // Should have executed in the device if offloading is enabled\n        // If offloading is not enabled or the system is a shared env\n        // between device and host, then the value will modify the original\n        // elements of c.\n        OMPVV_TEST_AND_SET(errors[1], (c[i] != SIZE)); //error when executed on the device\n      } else {\n        // Should have executed in the host\n        // with or without offloading\n        OMPVV_TEST_AND_SET(errors[2], (c[i] != -1));\n      } //end-else\n    }\n  } // end-for map_size\n\n  if (errors[0]) {\n    OMPVV_ERROR(\"Test did not offload to the device. 'If' clause might be affecting the target\"\n                \" offlading as well and it should not \")\n  }\n  if (!errors[0] && !errors[1] && !errors[2]) {\n    OMPVV_INFOMSG(\"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  } else if (errors[1]==0 && errors[2]!=0) {\n    OMPVV_ERROR(\"Test failed for if (false) with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n  } else if (errors[1]!=0 && errors[2]==0) {\n    OMPVV_ERROR(\"Test failed for if (true) with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n  } else if (errors[1]!=0 && errors[2]!=0) {\n    OMPVV_ERROR(\"Test failed for if(true) and if(false) with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n  }\n\n  return errors[0] + errors[1] + errors[2];\n}\n\n// Test for OpenMP 4.5 target data with if\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_depend_list.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp declare\" at position 828",
        "issue_id": 0,
        "original_code": "//===--- test_target_teams_distribute_depend_list.c---------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks for dependency between multiple out-dependent tasks by\n// checking order-dependent results from pairs of possibly asynchronous loops\n// The test fails if any required dependency is broken.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_target_teams_distribute_depend_list() {\n  int isOffloading = 0;\n  int errors = 0;\n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int e[N];\n  int f[N];\n  int g[N];\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n    b[x] = 2 * x;\n    c[x] = 0;\n    d[x] = 0;\n    e[x] = 0;\n    f[x] = 0;\n    g[x] = 0;\n  }\n\n#pragma omp target data map(to: a[0:N], b[0:N]) map(alloc: c[0:N], d[0:N], e[0:N]) map(from: f[0:N], g[0:N])\n  {\n#pragma omp target teams distribute nowait depend(out: c) map(alloc: a[0:N], b[0:N], c[0:N])\n    for (int x = 0; x < N; ++x) {\n      c[x] = a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(out: d) map(alloc: a[0:N], b[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n      d[x] = a[x] + b[x] + x;\n    }\n#pragma omp target teams distribute nowait depend(out: c, d, e) map(alloc: c[0:N], d[0:N], e[0:N])\n    for (int x = 0; x < N; ++x) {\n      e[x] = c[x] + d[x];\n    }\n#pragma omp target teams distribute nowait depend(out: e) map(alloc: a[0:N], e[0:N], f[0:N])\n    for (int x = 0; x < N; ++x) {\n      f[x] = e[x] + a[x];\n    }\n#pragma omp target teams distribute nowait depend(out: e) map(alloc: b[0:N], e[0:N], g[0:N])\n    for (int x = 0; x < N; ++x) {\n      g[x] = e[x] + b[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_ERROR_IF(f[x] != 8*x || g[x] != 9*x, \"Test of depend clause using multiple dependencies did not pass with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n    OMPVV_TEST_AND_SET_VERBOSE(errors, f[x] != 8*x || g[x] != 9*x);\n  }\n\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  errors += test_target_teams_distribute_depend_list();\n  OMPVV_INFOMSG_IF(errors != 0, \"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_depend_list.c---------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks for dependency between multiple out-dependent tasks by\n// checking order-dependent results from pairs of possibly asynchronous loops\n// The test fails if any required dependency is broken.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_target_teams_distribute_depend_list() {\n  int isOffloading = 0;\n  int errors = 0;\n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int e[N];\n  int f[N];\n  int g[N];\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n    b[x] = 2 * x;\n    c[x] = 0;\n    d[x] = 0;\n    e[x] = 0;\n    f[x] = 0;\n    g[x] = 0;\n  }\n\n#pragma omp declare data map(to: a[0:N], b[0:N]) map(alloc: c[0:N], d[0:N], e[0:N]) map(from: f[0:N], g[0:N])\n  {\n#pragma omp target teams distribute nowait depend(out: c) map(alloc: a[0:N], b[0:N], c[0:N])\n    for (int x = 0; x < N; ++x) {\n      c[x] = a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(out: d) map(alloc: a[0:N], b[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n      d[x] = a[x] + b[x] + x;\n    }\n#pragma omp target teams distribute nowait depend(out: c, d, e) map(alloc: c[0:N], d[0:N], e[0:N])\n    for (int x = 0; x < N; ++x) {\n      e[x] = c[x] + d[x];\n    }\n#pragma omp target teams distribute nowait depend(out: e) map(alloc: a[0:N], e[0:N], f[0:N])\n    for (int x = 0; x < N; ++x) {\n      f[x] = e[x] + a[x];\n    }\n#pragma omp target teams distribute nowait depend(out: e) map(alloc: b[0:N], e[0:N], g[0:N])\n    for (int x = 0; x < N; ++x) {\n      g[x] = e[x] + b[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_ERROR_IF(f[x] != 8*x || g[x] != 9*x, \"Test of depend clause using multiple dependencies did not pass with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n    OMPVV_TEST_AND_SET_VERBOSE(errors, f[x] != 8*x || g[x] != 9*x);\n  }\n\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  errors += test_target_teams_distribute_depend_list();\n  OMPVV_INFOMSG_IF(errors != 0, \"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_default_none.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp single\" at position 901",
        "issue_id": 0,
        "original_code": "//===--- test_target_teams_distribute_default_none.c-------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This tests uses the default(none) clause on a target teams distribute test.\n// The test aims to validate that all values will not have default data sharing\n// attributes.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main() {\n  int is_offloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n  OMPVV_WARNING(\"Test only uses default(none) clause and does not guarantee that the default(none) is enforced.\");\n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int privatized;\n  int num_teams;\n  int share = 0;\n  int x;\n  int errors = 0;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    c[x] = 2*x;\n    d[x] = 0;\n  }\n\n#pragma omp target data map(from: d[0:N], num_teams) map(to: a[0:N], b[0:N], c[0:N])\n  {\n#pragma omp target teams distribute default(none) shared(a, b, c, d, num_teams) private(x, privatized) num_teams(OMPVV_NUM_TEAMS_DEVICE)\n    for (x = 0; x < N; ++x) {\n      privatized = 0;\n      for (int y = 0; y < a[x] + b[x]; ++y) {\n        privatized++;\n      }\n      d[x] = c[x] * privatized;\n      if (omp_get_team_num() == 0) {\n        num_teams = omp_get_num_teams();\n      }\n    }\n  }\n\n  OMPVV_WARNING_IF(num_teams == 1, \"The number of teams was 1. This is not a specification error but we could not guarantee parallelism of teams.\");\n\n  for (x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (d[x] != (1 + x)*2*x));\n    if (d[x] != (1 + x)*2*x) {\n      break;\n    }\n  }\n\n#pragma omp target data map(from: num_teams) map(to: b[0:N])\n  {\n#pragma omp target teams distribute default(none) private(x) shared(share, b, num_teams) defaultmap(tofrom:scalar) num_teams(OMPVV_NUM_TEAMS_DEVICE)\n    for (x = 0; x < N; ++x) {\n#pragma omp atomic update\n      share = share + b[x];\n      if (omp_get_team_num() == 0) {\n        num_teams = omp_get_num_teams();\n      }\n    }\n  }\n\n  OMPVV_WARNING_IF(num_teams == 1, \"The number of teams was 1. This is not a specification error but we could not guarantee parallelism of teams.\");\n\n  for (int x = 0; x < N; ++x) {\n    share = share - x;\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (share != 0));\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_default_none.c-------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This tests uses the default(none) clause on a target teams distribute test.\n// The test aims to validate that all values will not have default data sharing\n// attributes.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main() {\n  int is_offloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n  OMPVV_WARNING(\"Test only uses default(none) clause and does not guarantee that the default(none) is enforced.\");\n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int privatized;\n  int num_teams;\n  int share = 0;\n  int x;\n  int errors = 0;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    c[x] = 2*x;\n    d[x] = 0;\n  }\n\n#pragma omp single data map(from: d[0:N], num_teams) map(to: a[0:N], b[0:N], c[0:N])\n  {\n#pragma omp target teams distribute default(none) shared(a, b, c, d, num_teams) private(x, privatized) num_teams(OMPVV_NUM_TEAMS_DEVICE)\n    for (x = 0; x < N; ++x) {\n      privatized = 0;\n      for (int y = 0; y < a[x] + b[x]; ++y) {\n        privatized++;\n      }\n      d[x] = c[x] * privatized;\n      if (omp_get_team_num() == 0) {\n        num_teams = omp_get_num_teams();\n      }\n    }\n  }\n\n  OMPVV_WARNING_IF(num_teams == 1, \"The number of teams was 1. This is not a specification error but we could not guarantee parallelism of teams.\");\n\n  for (x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (d[x] != (1 + x)*2*x));\n    if (d[x] != (1 + x)*2*x) {\n      break;\n    }\n  }\n\n#pragma omp target data map(from: num_teams) map(to: b[0:N])\n  {\n#pragma omp target teams distribute default(none) private(x) shared(share, b, num_teams) defaultmap(tofrom:scalar) num_teams(OMPVV_NUM_TEAMS_DEVICE)\n    for (x = 0; x < N; ++x) {\n#pragma omp atomic update\n      share = share + b[x];\n      if (omp_get_team_num() == 0) {\n        num_teams = omp_get_num_teams();\n      }\n    }\n  }\n\n  OMPVV_WARNING_IF(num_teams == 1, \"The number of teams was 1. This is not a specification error but we could not guarantee parallelism of teams.\");\n\n  for (int x = 0; x < N; ++x) {\n    share = share - x;\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (share != 0));\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_data_map_to.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 2903",
        "issue_id": 2,
        "original_code": "//===---- test_target_data_map_to.c ---------------------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// The test_target_data_map group of tests checks all the possible map-type-modifiers\n// for the target data map clauses. These are: from, to, fromto, alloc, release and \n// delete. There is a a separate c file for each test with the prefix test_target_data_map.\n// This specific test is for the 'to' clause. \n//\n//===----------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n// Test for OpenMP 4.5 target data map(to: ) \nint test_map_to() {\n\n  OMPVV_INFOMSG(\"test_map_to\");\n\n  int sum = 0, sum2 = 0, errors = 0;\n  \n  // host arrays: heap and stack\n  int *h_array_h = (int *)malloc(N*sizeof(int));\n  int *h_array2_h = (int *)malloc(N*sizeof(int));\n  int h_array_s[N];\n  int h_array2_s[N];\n\n  // initializing arrays \n  for (int i = 0; i < N; ++i) {\n    h_array_h[i] = 1;\n    h_array_s[i] = 1;\n    h_array2_h[i] = 0;\n    h_array2_s[i] = 0;\n  }\n\n  // device arrays to get the data from the device\n  // pointer arithmetic is not supported on the devices for\n  // the device address returned by omp_target_alloc\n  // section 3.5.1 omp_target_alloc. OpenMP API Version 4.5 Nov 2015\n  int *d_array =\n      (int *)omp_target_alloc(N*sizeof(int), omp_get_default_device());\n  int *d_array2 =\n      (int *)omp_target_alloc(N*sizeof(int), omp_get_default_device());\n\n  if (d_array == NULL || d_array2 == NULL ) {\n    errors = 1;\n    OMPVV_ERROR(\"omp_target_alloc returns NULL, this test is running on host, cannot properly test mapping of variables to device.\");\n    return errors;\n  }\n\n#pragma omp target data map(to: h_array_h[0:N])  \\\n        map(to: h_array_s[0:N]) \n  {\n#pragma omp target is_device_ptr(d_array, d_array2)\n    {\n      for (int i = 0; i < N; ++i) {\n        d_array[i] = h_array_h[i];\n        d_array2[i] = h_array_s[i];\n      }\n    } // end target\n  } // end target data\n\n  // copy from d to h\n  omp_target_memcpy(h_array2_h, d_array, N*sizeof(int), 0, 0,\n                    omp_get_initial_device(), omp_get_default_device());\n  omp_target_memcpy(h_array2_s, d_array2, N*sizeof(int), 0, 0,\n                    omp_get_initial_device(), omp_get_default_device());\n  // deallocating device arrays \n  omp_target_free(d_array, omp_get_default_device());\n  omp_target_free(d_array2, omp_get_default_device());\n\n  // checking errors\n  for (int i = 0; i < N; ++i) {\n    sum += h_array2_h[i];\n    sum2 += h_array2_s[i];\n  }\n\n  free(h_array_h);\n  free(h_array2_h);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (N != sum) || (N != sum2));\n\n  return errors;\n}\n\nint main() {\n\n  int errors = 0;\n  \n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_to());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n",
        "error_code": "//===---- test_target_data_map_to.c ---------------------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// The test_target_data_map group of tests checks all the possible map-type-modifiers\n// for the target data map clauses. These are: from, to, fromto, alloc, release and \n// delete. There is a a separate c file for each test with the prefix test_target_data_map.\n// This specific test is for the 'to' clause. \n//\n//===----------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n// Test for OpenMP 4.5 target data map(to: ) \nint test_map_to() {\n\n  OMPVV_INFOMSG(\"test_map_to\");\n\n  int sum = 0, sum2 = 0, errors = 0;\n  \n  // host arrays: heap and stack\n  int *h_array_h = (int *)malloc(N*sizeof(int));\n  int *h_array2_h = (int *)malloc(N*sizeof(int));\n  int h_array_s[N];\n  int h_array2_s[N];\n\n  // initializing arrays \n  for (int i = 0; i < N; ++i) {\n    h_array_h[i] = 1;\n    h_array_s[i] = 1;\n    h_array2_h[i] = 0;\n    h_array2_s[i] = 0;\n  }\n\n  // device arrays to get the data from the device\n  // pointer arithmetic is not supported on the devices for\n  // the device address returned by omp_target_alloc\n  // section 3.5.1 omp_target_alloc. OpenMP API Version 4.5 Nov 2015\n  int *d_array =\n      (int *)omp_target_alloc(N*sizeof(int), omp_get_default_device());\n  int *d_array2 =\n      (int *)omp_target_alloc(N*sizeof(int), omp_get_default_device());\n\n  if (d_array == NULL || d_array2 == NULL ) {\n    errors = 1;\n    OMPVV_ERROR(\"omp_target_alloc returns NULL, this test is running on host, cannot properly test mapping of variables to device.\");\n    return errors;\n  }\n\n#pragma omp target data map(to: h_array_h[0:N])  \\\n        map(to: h_array_s[0:N]) \n  {\n#pragma omp target is_device_ptr(d_array, d_array2)\n    {\n      for (int i = 0; i < N; ++i) {\n        d_array[i] = h_array_h[i];\n        d_array2[i] = h_array_s[i];\n      }\n    } // end target\n  } // end target data\n\n  // copy from d to h\n  omp_target_memcpy(h_array2_h, d_array, N*sizeof(int), 0, 0,\n                    omp_get_initial_device(), omp_get_default_device());\n  omp_target_memcpy(h_array2_s, d_array2, N*sizeof(int), 0, 0,\n                    omp_get_initial_device(), omp_get_default_device());\n  // deallocating device arrays \n  omp_target_free(d_array, omp_get_default_device());\n  omp_target_free(d_array2, omp_get_default_device());\n\n  // checking errors\n  for (int i = 0; i < N; ++i) {\n    sum += h_array2_h[i];\n    sum2 += h_array2_s[i];\n  }\n\n  free(h_array_h);\n  free(h_array2_h);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (N != sum) || (N != sum2));\n\n  return errors;\n}\n\nint main() {\n\n  int errors = 0;\n  \n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_to());\n  OMPVV_REPORT_AND_RETURN(errors);yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_enter_data_classes_simple.cpp",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_simple_class());\n  \n  OMPVV_REPORT_AND_RETURN(errors)\n}\" at position 3807",
        "issue_id": 4,
        "original_code": "//===---- test_target_enter_data_classes_simple.c -- target enter data with classes===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n//\n// This test checks for interoperability between C++ classes and device offloading through the use of \n// target enter and exit data clauses. It considers that 4.5 does not support\n// mapping of attributes directly, as the implicit use of the this-> pointer when \n// using attributes inside the target region is restrictive.\n//\n// The description of the map clause says that the map clause receives a list item:\n//\n// Section 2.15.5.1, page 216, line 17\n//\n// The syntax of the map clause is as follows:\n// map([ [map-type-modifier[,]] map-type : ] list)\n// And the definition of list item is\n//\n// Section 2.1, page 27, line 20\n//\n// A list item is a variable or array section. An extended list item is a list item or a function name.\n//\n// This test creates a class that, during construction, it maps an attribute through helper \n// variables that remove the direct use to the attributes. And during destruction of the \n// object it maps the data back to the devices. Additionally, there is a modifier \n// method that uses values from the class indirectly through the use of helper references\n// finally there is a synchronization  clause that will obtain the values on demand\n//===----------------------------------------------------------------------------------===//\n//\n//\n\n#include <iostream>\n#include <omp.h>\n#include <cassert>\n#include \"ompvv.h\"\n#include <cmath>\n\n#define N 1000\n\nclass Simple {\nprivate:\n  int *d_array;\n  int size;\n  int sum;\n\npublic:\n  // Constructor. Maps the data into the device\n  Simple(int s) : size(s) { \n    this->sum = 0;\n    this->d_array = new int[size];\n    // Initialize array \n    std::fill(d_array, d_array+size, 0);\n\n    // Removing the direct use of attributes to avoid problems\n    // with 4.5 specifications \n    int* helper = d_array;\n    int &hs = size;\n    int &hsum = sum;\n#pragma omp target enter data map(to: helper[0:hs]) map(to: hs) map(to:hsum)\n  }\n\n  // Destructor, removes the data from the device\n  ~Simple() { \n    // Removing the direct use of attributes to avoid problems\n    // with 4.5 specifications \n    int* helper = d_array;\n    int &hs = size;\n    int &hsum = sum;\n#pragma omp target exit data map(delete: helper[0:hs]) map(delete: hs) map(delete: hsum)\n    delete[] d_array; \n  }\n  \n  // Modify the device data directly\n  void modify() {\n    // Removing the direct use of attributes to avoid problems\n    // with 4.5 specifications \n    int *helper = d_array;\n    int &hsize = size;\n    int &hsum = sum;\n#pragma omp target map(alloc:hsum, hsize) \n    {\n      hsum = 0;\n      for (int i = 0; i < hsize; ++i) {\n        helper[i] += 1;\n        hsum += helper[i];\n      }\n    }\n  }\n\n  // Get the values from the device through a second array\n  void getValues(int &h_sum, int* h_array) {\n    int* helper = d_array;\n    int &hsize = size;\n    int &help_sum = sum;\n#pragma omp target map(from: h_array[0:hsize]) map(alloc: help_sum, hsize) map(from:h_sum)\n    {\n      h_sum = help_sum;\n      for (int i = 0; i < hsize; i++)\n        h_array[i] = helper[i];\n    }\n  }\n};\n\nint test_simple_class() {\n  \n  OMPVV_INFOMSG(\"Testing enter exit data with a simple class\");\n  int errors = 0, h_sum = 0, sum = 0;\n  int* h_array = new int[N];\n\n  // allocation on the device\n  Simple *obj = new Simple(N);\n\n  obj->modify();\n  obj->modify();\n  obj->modify();\n  obj->getValues(h_sum, h_array);\n\n  // checking results\n  for (int i = 0; i < N; ++i) {\n    sum += h_array[i];\n  }\n\n  delete obj;\n  delete[] h_array;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, (3*N != sum));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (3*N != h_sum));\n  OMPVV_ERROR_IF(errors != 0, \"N = %d, sum = %d, h_sum = %d\", N, sum, h_sum);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_simple_class());\n  \n  OMPVV_REPORT_AND_RETURN(errors)\n}\n\n",
        "error_code": "//===---- test_target_enter_data_classes_simple.c -- target enter data with classes===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n//\n// This test checks for interoperability between C++ classes and device offloading through the use of \n// target enter and exit data clauses. It considers that 4.5 does not support\n// mapping of attributes directly, as the implicit use of the this-> pointer when \n// using attributes inside the target region is restrictive.\n//\n// The description of the map clause says that the map clause receives a list item:\n//\n// Section 2.15.5.1, page 216, line 17\n//\n// The syntax of the map clause is as follows:\n// map([ [map-type-modifier[,]] map-type : ] list)\n// And the definition of list item is\n//\n// Section 2.1, page 27, line 20\n//\n// A list item is a variable or array section. An extended list item is a list item or a function name.\n//\n// This test creates a class that, during construction, it maps an attribute through helper \n// variables that remove the direct use to the attributes. And during destruction of the \n// object it maps the data back to the devices. Additionally, there is a modifier \n// method that uses values from the class indirectly through the use of helper references\n// finally there is a synchronization  clause that will obtain the values on demand\n//===----------------------------------------------------------------------------------===//\n//\n//\n\n#include <iostream>\n#include <omp.h>\n#include <cassert>\n#include \"ompvv.h\"\n#include <cmath>\n\n#define N 1000\n\nclass Simple {\nprivate:\n  int *d_array;\n  int size;\n  int sum;\n\npublic:\n  // Constructor. Maps the data into the device\n  Simple(int s) : size(s) { \n    this->sum = 0;\n    this->d_array = new int[size];\n    // Initialize array \n    std::fill(d_array, d_array+size, 0);\n\n    // Removing the direct use of attributes to avoid problems\n    // with 4.5 specifications \n    int* helper = d_array;\n    int &hs = size;\n    int &hsum = sum;\n#pragma omp target enter data map(to: helper[0:hs]) map(to: hs) map(to:hsum)\n  }\n\n  // Destructor, removes the data from the device\n  ~Simple() { \n    // Removing the direct use of attributes to avoid problems\n    // with 4.5 specifications \n    int* helper = d_array;\n    int &hs = size;\n    int &hsum = sum;\n#pragma omp target exit data map(delete: helper[0:hs]) map(delete: hs) map(delete: hsum)\n    delete[] d_array; \n  }\n  \n  // Modify the device data directly\n  void modify() {\n    // Removing the direct use of attributes to avoid problems\n    // with 4.5 specifications \n    int *helper = d_array;\n    int &hsize = size;\n    int &hsum = sum;\n#pragma omp target map(alloc:hsum, hsize) \n    {\n      hsum = 0;\n      for (int i = 0; i < hsize; ++i) {\n        helper[i] += 1;\n        hsum += helper[i];\n      }\n    }\n  }\n\n  // Get the values from the device through a second array\n  void getValues(int &h_sum, int* h_array) {\n    int* helper = d_array;\n    int &hsize = size;\n    int &help_sum = sum;\n#pragma omp target map(from: h_array[0:hsize]) map(alloc: help_sum, hsize) map(from:h_sum)\n    {\n      h_sum = help_sum;\n      for (int i = 0; i < hsize; i++)\n        h_array[i] = helper[i];\n    }\n  }\n};\n\nint test_simple_class() {\n  \n  OMPVV_INFOMSG(\"Testing enter exit data with a simple class\");\n  int errors = 0, h_sum = 0, sum = 0;\n  int* h_array = new int[N];\n\n  // allocation on the device\n  Simple *obj = new Simple(N);\n\n  obj->modify();\n  obj->modify();\n  obj->modify();\n  obj->getValues(h_sum, h_array);\n\n  // checking results\n  for (int i = 0; i < N; ++i) {\n    sum += h_array[i];\n  }\n\n  delete obj;\n  delete[] h_array;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, (3*N != sum));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (3*N != h_sum));\n  OMPVV_ERROR_IF(errors != 0, \"N = %d, sum = %d, h_sum = %d\", N, sum, h_sum);\n\n  return errors;\n}\n\nint main() \n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_update_if.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 2314",
        "issue_id": 1,
        "original_code": "//===---- test_target_update_if.c - check the if clause of target update ------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// The if clause determines if the section should be updated on  \n// the device. There are two scenarios to test here: \n// (a) with offloading when 'if' clause evaluates to true then \n// associated data is updated depending on the motion clause.\n// (b) with offloading when 'if' clause evaluates to false \n// then there is no update\n// The if clause is evaluated on runtime which means that variables could\n// determine this behavior. \n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define N 100\n\nint a[N];\nint b[N];\nint c[N];\nint count, toggle=0;\n\nint init_b(){\n  if(toggle % 2){\n    int i;\n    for (i = 0; i < N; i++) {\n      b[i] = b[i] * 2; \n    }\n    toggle++;\n    return 1;\n  }\n  else{\n    toggle++;\n    return 0;\n  }\n}\n  \n// Test for OpenMP 4.5 target update with if\nint main() {\n  int errors[2]={0,0}, i = 0, report_errors = 0, change_flag = 0;\n\n  for (i = 0; i < N; i++) {\n    a[i] = 10;\n  }\n\n  // We test for offloading\n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading); \n  \n  if (!is_offloading)\n  OMPVV_WARNING(\"It is not possible to test conditional data transfers \"\n                 \"if the environment is shared or offloading is off. Not testing \"\n                 \"anything\");\n    \n  for(count = 0; count < 4; count++){\n    for (i = 0; i < N; i++) {\n      b[i] = 2; \n      c[i] = 0;\n  }\n#pragma omp target data map(to: a[:N], b[:N]) map(tofrom: c)\n{\n  #pragma omp target \n  {\n        int j = 0;\n        for (j = 0; j < N; j++) {\n          c[j] = (a[j] + b[j]);//c=12 \n        }\n  } // end target\n\n  change_flag = init_b();\n  #pragma omp target update if (change_flag) to(b[:N]) //update b=4 for all odd iterations\n\n  #pragma omp target //default mapping is tofrom on b and c\n  {\n        int j = 0;\n        for (j = 0; j < N; j++) {\n          c[j] = (c[j] + b[j]);//if b is updated c=16 else c=14\n        }\n  } // end target\n\n}// end target-data\n\n    // checking results \n  if (change_flag) {\n    for (i = 0; i < N; i++) {\n        if (c[i] != 16) {\n          errors[0] += 1;\n        }\n    }\n  }\n  else {\n    for (i = 0; i < N; i++) {\n        if (c[i] != 14) {\n          errors[1] += 1;\n        }\n    }\n  }\n}//end for\n\n  OMPVV_TEST_AND_SET_VERBOSE(report_errors, errors[0] > 0);\n  OMPVV_INFOMSG_IF(errors[0] > 0, \"Target update test when if clause is true failed\");\n  OMPVV_TEST_AND_SET_VERBOSE(report_errors, errors[1] > 0);\n  OMPVV_INFOMSG_IF(errors[1] > 0,  \"Target update test when if clause is false failed\");\n\n  OMPVV_REPORT_AND_RETURN(report_errors);\n}\n",
        "error_code": "//===---- test_target_update_if.c - check the if clause of target update ------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// The if clause determines if the section should be updated on  \n// the device. There are two scenarios to test here: \n// (a) with offloading when 'if' clause evaluates to true then \n// associated data is updated depending on the motion clause.\n// (b) with offloading when 'if' clause evaluates to false \n// then there is no update\n// The if clause is evaluated on runtime which means that variables could\n// determine this behavior. \n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define N 100\n\nint a[N];\nint b[N];\nint c[N];\nint count, toggle=0;\n\nint init_b(){\n  if(toggle % 2){\n    int i;\n    for (i = 0; i < N; i++) {\n      b[i] = b[i] * 2; \n    }\n    toggle++;\n    return 1;\n  }\n  else{\n    toggle++;\n    return 0;\n  }\n}\n  \n// Test for OpenMP 4.5 target update with if\nint main() {\n  int errors[2]={0,0}, i = 0, report_errors = 0, change_flag = 0;\n\n  for (i = 0; i < N; i++) {\n    a[i] = 10;\n  }\n\n  // We test for offloading\n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading); \n  \n  if (!is_offloading)\n  OMPVV_WARNING(\"It is not possible to test conditional data transfers \"\n                 \"if the environment is shared or offloading is off. Not testing \"\n                 \"anything\");\n    \n  for(count = 0; count < 4; count++){\n    for (i = 0; i < N; i++) {\n      b[i] = 2; \n      c[i] = 0;\n  }\n#pragma omp target data map(to: a[:N], b[:N]) map(tofrom: c)\n{\n  #pragma omp target \n  {\n        int j = 0;\n        for (j = 0; j < N; j++) {\n          c[j] = (a[j] + b[j]);//c=12 \n        }\n  } // end target\n\n  change_flag = init_b();\n  #pragma omp target update if (change_flag) to(b[:N]) //update b=4 for all odd iterations\n\n  #pragma omp target //default mapping is tofrom on b and c\n  {\n        int j = 0;\n        for (j = 0; j < N; j++) {\n          c[j] = (c[j] + b[j]);//if b is updated c=16 else c=14\n        }\n  } // end target\n\n}// end target-data\n\n    // checking results \n  if (change_flag) {\n    for (i = 0; i < N; i++) {\n        if (c[i] != 16) {\n          errors[0] += 1;\n        }\n    }\n  }\n  else {\n    for (i = 0; i < N; i++) {\n        if (c[i] != 14) \n          errors[1] += 1;\n        }\n    }\n  }\n}//end for\n\n  OMPVV_TEST_AND_SET_VERBOSE(report_errors, errors[0] > 0);\n  OMPVV_INFOMSG_IF(errors[0] > 0, \"Target update test when if clause is true failed\");\n  OMPVV_TEST_AND_SET_VERBOSE(report_errors, errors[1] > 0);\n  OMPVV_INFOMSG_IF(errors[1] > 0,  \"Target update test when if clause is false failed\");\n\n  OMPVV_REPORT_AND_RETURN(report_errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 915",
        "issue_id": 2,
        "original_code": "//===--- test_target_teams_distribute.c--------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the target teams distribute directive and tests to validate\n// that computation inside the region executes properly.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main() {\n  int a[N];\n  int b[N];\n  int num_teams[N];\n  int errors = 0;\n  int is_offloading;\n\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n  OMPVV_TEST_SHARED_ENVIRONMENT\n\n  // a and b array initialization\n  for (int x = 0; x < N; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    num_teams[x] = -1;\n  }\n\n#pragma omp target teams distribute map(tofrom: a[0:N], num_teams[0:N]) map(to: b[0:N])\n  for (int x = 0; x < N; ++x) {\n    num_teams[x] = omp_get_num_teams();\n    a[x] += b[x];\n  }\n\n  if (num_teams[0] == 1) {\n    OMPVV_WARNING(\"Test operated with one team.  Parallelism of teams distribute can't be guaranteed.\");\n  } else if (num_teams[0] < 1) {\n    OMPVV_ERROR(\"omp_get_num_teams() reported a value below one.\");\n  }\n\n  for (int x = 1; x < N; ++x) {\n    if (num_teams[x] != num_teams[x - 1]) {\n      OMPVV_ERROR(\"Test reported an inconsistent number of teams between loop iterations.\");\n      errors++;\n    }\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (a[x] != 1 + b[x]));\n    if (a[x] != 1 + b[x]){\n      errors++;\n      break;\n    }\n  }\n\n  OMPVV_INFOMSG_IF(!errors, \"Test passed with %d teams.\", num_teams[0]);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute.c--------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the target teams distribute directive and tests to validate\n// that computation inside the region executes properly.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main() {\n  int a[N];\n  int b[N];\n  int num_teams[N];\n  int errors = 0;\n  int is_offloading;\n\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n  OMPVV_TEST_SHARED_ENVIRONMENT\n\n  // a and b array initialization\n  for (int x = 0; x < N; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    num_teams[x] = -1;\n  }\n\n#pragma omp target teams distribute map(tofrom: a[0:N], num_teams[0:N]) map(to: b[0:N])\n  for (int x = 0; x < N; ++x) {\n    num_teams[x] = omp_get_num_teams();\n    a[x] += b[x];yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n  }\n\n  if (num_teams[0] == 1) {\n    OMPVV_WARNING(\"Test operated with one team.  Parallelism of teams distribute can't be guaranteed.\");\n  } else if (num_teams[0] < 1) {\n    OMPVV_ERROR(\"omp_get_num_teams() reported a value below one.\");\n  }\n\n  for (int x = 1; x < N; ++x) {\n    if (num_teams[x] != num_teams[x - 1]) {\n      OMPVV_ERROR(\"Test reported an inconsistent number of teams between loop iterations.\");\n      errors++;\n    }\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (a[x] != 1 + b[x]));\n    if (a[x] != 1 + b[x]){\n      errors++;\n      break;\n    }\n  }\n\n  OMPVV_INFOMSG_IF(!errors, \"Test passed with %d teams.\", num_teams[0]);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_collapse.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 1576",
        "issue_id": 2,
        "original_code": "//===--- test_target_teams_distribute_collapse.c--------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the collapse clause and tests that for loops out of the scope\n// of the collapsed loops are not parallelized.  This test tests using one and\n// two collapsed loops.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define ARRAY_SIZE 128 //Array Size of 128 uses 16MB target memory and\n                       //scales n^3 in test_collapse2()\n\nint test_collapse1() {\n\n  int * a_mem = (int *)malloc(ARRAY_SIZE*ARRAY_SIZE*sizeof(int));\n  int * b_mem = (int *)malloc(ARRAY_SIZE*(ARRAY_SIZE+1)*sizeof(int));\n  int (*a)[ARRAY_SIZE] = (int (*)[ARRAY_SIZE])a_mem;\n  int (*b)[ARRAY_SIZE + 1] = (int (*)[ARRAY_SIZE+1])b_mem;\n  int errors = 0;\n\n  // a and b array initialization\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    b[x][0] = 0;\n    for (int y = 0; y < ARRAY_SIZE; ++y) {\n      a[x][y] = x + y;\n      b[x][y+1] = 0;\n    }\n  }\n\n#pragma omp target teams distribute map(to: a[0:ARRAY_SIZE][0:ARRAY_SIZE]) map(tofrom: b[0:ARRAY_SIZE][0:ARRAY_SIZE+1]) collapse(1) num_teams(OMPVV_NUM_TEAMS_DEVICE)\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    for (int y = 0; y < ARRAY_SIZE; ++y) {\n      b[x][y + 1] = b[x][y] + a[x][y];\n    }\n  }\n\n  int temp_total;\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    temp_total = 0;\n    for (int y = 0; y < ARRAY_SIZE+1; ++y) {\n      OMPVV_TEST_AND_SET(errors, ((temp_total - b[x][y]) != 0));\n      if (y != ARRAY_SIZE) {\n        temp_total = temp_total + a[x][y];\n      }\n    }\n  }\n\n  free (a_mem);\n  free (b_mem);\n  return errors;\n}\n\nint test_collapse2() {\n  int * a_mem = (int *)malloc(ARRAY_SIZE*ARRAY_SIZE*ARRAY_SIZE*sizeof(int));\n  int * b_mem = (int *)malloc(ARRAY_SIZE*ARRAY_SIZE*(ARRAY_SIZE+1)*sizeof(int));\n  int (*a)[ARRAY_SIZE][ARRAY_SIZE] = (int (*)[ARRAY_SIZE][ARRAY_SIZE])a_mem;\n  int (*b)[ARRAY_SIZE][ARRAY_SIZE + 1] = (int (*)[ARRAY_SIZE][ARRAY_SIZE+1])b_mem;\n  int errors = 0;\n  int num_teams = 0;\n\n  // a and b array initialization\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    for (int y = 0; y < ARRAY_SIZE; ++y) {\n      b[x][y][0] = 0;\n      for (int z = 0; z < ARRAY_SIZE; ++z) {\n        a[x][y][z] = x + y + z;\n        b[x][y][z+1] = 0;\n      }\n    }\n  }\n\n#pragma omp target teams distribute map(to: a[0:ARRAY_SIZE][0:ARRAY_SIZE][0:ARRAY_SIZE]) map(tofrom: b[0:ARRAY_SIZE][0:ARRAY_SIZE][0:ARRAY_SIZE+1], num_teams) collapse(2) num_teams(OMPVV_NUM_TEAMS_DEVICE)\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    for (int y = 0; y < ARRAY_SIZE; ++y) {\n      for (int z = 0; z < ARRAY_SIZE; ++z) {\n        if (omp_get_team_num() == 0) {\n          num_teams = omp_get_num_teams();\n        }\n        b[x][y][z + 1] = b[x][y][z] + a[x][y][z];\n      }\n    }\n  }\n\n  int temp_total;\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    for (int y = 0; y < ARRAY_SIZE; ++y) {\n      temp_total = 0;\n      for (int z = 0; z < ARRAY_SIZE + 1; ++z) {\n        OMPVV_TEST_AND_SET(errors, ((temp_total - b[x][y][z]) != 0));\n        if (z != ARRAY_SIZE) {\n          temp_total = temp_total + a[x][y][z];\n        }\n      }\n    }\n  }\n\n  if (num_teams == 1) {\n    OMPVV_WARNING(\"Test operated with one team.  Parallelism of teams distribute can't be guaranteed.\");\n  }\n\n  free (a_mem);\n  free (b_mem);\n  return errors;\n}\n\nint main() {\n  \n  //Check for offloading\n  OMPVV_TEST_OFFLOADING;  \n\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_collapse1() != 0);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_collapse2() != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n\n}\n",
        "error_code": "//===--- test_target_teams_distribute_collapse.c--------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the collapse clause and tests that for loops out of the scope\n// of the collapsed loops are not parallelized.  This test tests using one and\n// two collapsed loops.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define ARRAY_SIZE 128 //Array Size of 128 uses 16MB target memory and\n                       //scales n^3 in test_collapse2()\n\nint test_collapse1() {\n\n  int * a_mem = (int *)malloc(ARRAY_SIZE*ARRAY_SIZE*sizeof(int));\n  int * b_mem = (int *)malloc(ARRAY_SIZE*(ARRAY_SIZE+1)*sizeof(int));\n  int (*a)[ARRAY_SIZE] = (int (*)[ARRAY_SIZE])a_mem;\n  int (*b)[ARRAY_SIZE + 1] = (int (*)[ARRAY_SIZE+1])b_mem;\n  int errors = 0;\n\n  // a and b array initialization\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    b[x][0] = 0;\n    for (int y = 0; y < ARRAY_SIZE; ++y) {\n      a[x][y] = x + y;\n      b[x][y+1] = 0;\n    }\n  }\n\n#pragma omp target teams distribute map(to: a[0:ARRAY_SIZE][0:ARRAY_SIZE]) map(tofrom: b[0:ARRAY_SIZE][0:ARRAY_SIZE+1]) collapse(1) num_teams(OMPVV_NUM_TEAMS_DEVICE)\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    for (int y = 0; y < ARRAY_SIZE; ++y) {\n      b[x][y + 1] = b[x][y] + a[x][y];\n    }\n  }\n\n  int temp_total;\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    temp_total = 0;\n    for (int y = 0; y < ARRAY_SIZE+1; ++y) {\n      OMPVV_TEST_AND_SET(errors, ((temp_total - b[x][y]) != 0));yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n      if (y != ARRAY_SIZE) {\n        temp_total = temp_total + a[x][y];\n      }\n    }\n  }\n\n  free (a_mem);\n  free (b_mem);\n  return errors;\n}\n\nint test_collapse2() {\n  int * a_mem = (int *)malloc(ARRAY_SIZE*ARRAY_SIZE*ARRAY_SIZE*sizeof(int));\n  int * b_mem = (int *)malloc(ARRAY_SIZE*ARRAY_SIZE*(ARRAY_SIZE+1)*sizeof(int));\n  int (*a)[ARRAY_SIZE][ARRAY_SIZE] = (int (*)[ARRAY_SIZE][ARRAY_SIZE])a_mem;\n  int (*b)[ARRAY_SIZE][ARRAY_SIZE + 1] = (int (*)[ARRAY_SIZE][ARRAY_SIZE+1])b_mem;\n  int errors = 0;\n  int num_teams = 0;\n\n  // a and b array initialization\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    for (int y = 0; y < ARRAY_SIZE; ++y) {\n      b[x][y][0] = 0;\n      for (int z = 0; z < ARRAY_SIZE; ++z) {\n        a[x][y][z] = x + y + z;\n        b[x][y][z+1] = 0;\n      }\n    }\n  }\n\n#pragma omp target teams distribute map(to: a[0:ARRAY_SIZE][0:ARRAY_SIZE][0:ARRAY_SIZE]) map(tofrom: b[0:ARRAY_SIZE][0:ARRAY_SIZE][0:ARRAY_SIZE+1], num_teams) collapse(2) num_teams(OMPVV_NUM_TEAMS_DEVICE)\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    for (int y = 0; y < ARRAY_SIZE; ++y) {\n      for (int z = 0; z < ARRAY_SIZE; ++z) {\n        if (omp_get_team_num() == 0) {\n          num_teams = omp_get_num_teams();\n        }\n        b[x][y][z + 1] = b[x][y][z] + a[x][y][z];\n      }\n    }\n  }\n\n  int temp_total;\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    for (int y = 0; y < ARRAY_SIZE; ++y) {\n      temp_total = 0;\n      for (int z = 0; z < ARRAY_SIZE + 1; ++z) {\n        OMPVV_TEST_AND_SET(errors, ((temp_total - b[x][y][z]) != 0));\n        if (z != ARRAY_SIZE) {\n          temp_total = temp_total + a[x][y][z];\n        }\n      }\n    }\n  }\n\n  if (num_teams == 1) {\n    OMPVV_WARNING(\"Test operated with one team.  Parallelism of teams distribute can't be guaranteed.\");\n  }\n\n  free (a_mem);\n  free (b_mem);\n  return errors;\n}\n\nint main() {\n  \n  //Check for offloading\n  OMPVV_TEST_OFFLOADING;  \n\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_collapse1() != 0);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_collapse2() != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_simd_safelen.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp master\" at position 1168",
        "issue_id": 0,
        "original_code": "//===---- test_target_simd_safelen.c - simd directive clause safelen   -===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// This test checks for the use of the safelen clause which prevents parallelization\n// over SIMD lanes that goes behond the contant value passed to the clause. This\n// is due to th possible iteration dependecies usually larger than 1. Regardless of \n// the SIMD len in hardware, the passed parameter should allow any possitive integer\n//===--------------------------------------------------------------------------===//\n//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define ARRAY_SIZE 1024\n\nint test_target_simd_safelen() {\n  OMPVV_INFOMSG(\"test_target_simd_safelen\");\n  OMPVV_WARNING(\"This test cannot check if actual SIMD extensions at the hardware level\" \\\n                 \" were used, or of the generated code is different in any way\");\n\n  // Variable for errors counting\n  int errors = 0;\n\n  int A[ARRAY_SIZE];\n  int A_host[ARRAY_SIZE];\n  int i, len;\n\n  // a and b array initialization\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      A[i] = 1;\n      A_host[i] = 1;\n  }\n\n  // Test safelen of 1 5 8 13 16 100 128\n#pragma omp target simd safelen(1) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 1; i < ARRAY_SIZE; ++i) {\n      A[i-1] += A[i]; \n  }\n\n#pragma omp target simd safelen(5) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 5; i < ARRAY_SIZE; ++i) {\n      A[i-5] += A[i]; \n  }\n\n#pragma omp target simd safelen(8) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 8; i < ARRAY_SIZE; ++i) {\n      A[i-8] += A[i]; \n  }\n\n#pragma omp target simd safelen(13) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 13; i < ARRAY_SIZE; ++i) {\n      A[i-13] += A[i]; \n  }\n\n#pragma omp target simd safelen(16) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 16; i < ARRAY_SIZE; ++i) {\n      A[i-16] += A[i]; \n  }\n\n#pragma omp target simd safelen(100) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 100; i < ARRAY_SIZE; ++i) {\n      A[i-100] += A[i]; \n  }\n\n#pragma omp target simd safelen(128) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 128; i < ARRAY_SIZE; ++i) {\n      A[i-128] += A[i]; \n  }\n\n\n  // Get the resultiong values form the CPU without any omp region\n  for (i = 1; i < ARRAY_SIZE; ++i) {\n      A_host[i-1] += A_host[i]; \n  }\n\n  for (i = 5; i < ARRAY_SIZE; ++i) {\n      A_host[i-5] += A_host[i]; \n  }\n\n  for (i = 8; i < ARRAY_SIZE; ++i) {\n      A_host[i-8] += A_host[i]; \n  }\n\n  for (i = 13; i < ARRAY_SIZE; ++i) {\n      A_host[i-13] += A_host[i]; \n  }\n\n  for (i = 16; i < ARRAY_SIZE; ++i) {\n      A_host[i-16] += A_host[i]; \n  }\n\n  for (i = 100; i < ARRAY_SIZE; ++i) {\n      A_host[i-100] += A_host[i]; \n  }\n\n  for (i = 128; i < ARRAY_SIZE; ++i) {\n      A_host[i-128] += A_host[i]; \n  }\n\n  // Check the results\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      OMPVV_TEST_AND_SET(errors, (A[i] != A_host[i]));\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_simd_safelen());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_simd_safelen.c - simd directive clause safelen   -===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// This test checks for the use of the safelen clause which prevents parallelization\n// over SIMD lanes that goes behond the contant value passed to the clause. This\n// is due to th possible iteration dependecies usually larger than 1. Regardless of \n// the SIMD len in hardware, the passed parameter should allow any possitive integer\n//===--------------------------------------------------------------------------===//\n//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define ARRAY_SIZE 1024\n\nint test_target_simd_safelen() {\n  OMPVV_INFOMSG(\"test_target_simd_safelen\");\n  OMPVV_WARNING(\"This test cannot check if actual SIMD extensions at the hardware level\" \\\n                 \" were used, or of the generated code is different in any way\");\n\n  // Variable for errors counting\n  int errors = 0;\n\n  int A[ARRAY_SIZE];\n  int A_host[ARRAY_SIZE];\n  int i, len;\n\n  // a and b array initialization\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      A[i] = 1;\n      A_host[i] = 1;\n  }\n\n  // Test safelen of 1 5 8 13 16 100 128\n#pragma omp master simd safelen(1) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 1; i < ARRAY_SIZE; ++i) {\n      A[i-1] += A[i]; \n  }\n\n#pragma omp target simd safelen(5) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 5; i < ARRAY_SIZE; ++i) {\n      A[i-5] += A[i]; \n  }\n\n#pragma omp target simd safelen(8) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 8; i < ARRAY_SIZE; ++i) {\n      A[i-8] += A[i]; \n  }\n\n#pragma omp target simd safelen(13) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 13; i < ARRAY_SIZE; ++i) {\n      A[i-13] += A[i]; \n  }\n\n#pragma omp target simd safelen(16) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 16; i < ARRAY_SIZE; ++i) {\n      A[i-16] += A[i]; \n  }\n\n#pragma omp target simd safelen(100) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 100; i < ARRAY_SIZE; ++i) {\n      A[i-100] += A[i]; \n  }\n\n#pragma omp target simd safelen(128) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 128; i < ARRAY_SIZE; ++i) {\n      A[i-128] += A[i]; \n  }\n\n\n  // Get the resultiong values form the CPU without any omp region\n  for (i = 1; i < ARRAY_SIZE; ++i) {\n      A_host[i-1] += A_host[i]; \n  }\n\n  for (i = 5; i < ARRAY_SIZE; ++i) {\n      A_host[i-5] += A_host[i]; \n  }\n\n  for (i = 8; i < ARRAY_SIZE; ++i) {\n      A_host[i-8] += A_host[i]; \n  }\n\n  for (i = 13; i < ARRAY_SIZE; ++i) {\n      A_host[i-13] += A_host[i]; \n  }\n\n  for (i = 16; i < ARRAY_SIZE; ++i) {\n      A_host[i-16] += A_host[i]; \n  }\n\n  for (i = 100; i < ARRAY_SIZE; ++i) {\n      A_host[i-100] += A_host[i]; \n  }\n\n  for (i = 128; i < ARRAY_SIZE; ++i) {\n      A_host[i-128] += A_host[i]; \n  }\n\n  // Check the results\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      OMPVV_TEST_AND_SET(errors, (A[i] != A_host[i]));\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_simd_safelen());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_depend_in_out.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 2045",
        "issue_id": 1,
        "original_code": "//===--- test_target_teams_distribute_depend_in_out.c-------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks in-out and in-inout dependency by checking order-dependent\n// results from pairs of possibly asynchronous loops. The test fails if either \n// in-out or in-inout dependency is broken.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_target_teams_distribute_depend_in_out() {\n  int isOffloading = 0;\n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int errors = 0;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n    b[x] = 2 * x;\n    c[x] = 0;\n    d[x] = 0;\n  }\n\n#pragma omp target data map(to: a[0:N], b[0:N]) map(alloc: c[0:N]) map(from: d[0:N])\n  {\n#pragma omp target teams distribute nowait depend(in: c) map(alloc: a[0:N], b[0:N], c[0:N])\n    for (int x = 0; x < N; ++x) {\n      c[x] = a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(out: c) map(alloc: b[0:N], c[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n      d[x] = c[x] + b[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, d[x] != 5*x);\n    OMPVV_ERROR_IF(d[x] != 5*x, \"Test of depend(out) task becoming dependent on depend(in) task failed.\");\n  }\n\n#pragma omp target data map(to: a[0:N], b[0:N]) map(alloc: c[0:N]) map(from: d[0:N])\n  {\n#pragma omp target teams distribute nowait depend(in: c) map(alloc: a[0:N], b[0:N], c[0:N])\n    for (int x = 0; x < N; ++x) {\n      c[x] = a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(inout: c) map(alloc: a[0:N], c[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n      d[x] = c[x] + a[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, d[x] != 4*x);\n    OMPVV_ERROR_IF(d[x] != 4*x, \"Test of depend(inout) task becoming dependent on depend(in) task failed.\");\n  }\n\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  errors += test_target_teams_distribute_depend_in_out();\n  OMPVV_INFOMSG_IF(errors != 0, \"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_depend_in_out.c-------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks in-out and in-inout dependency by checking order-dependent\n// results from pairs of possibly asynchronous loops. The test fails if either \n// in-out or in-inout dependency is broken.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_target_teams_distribute_depend_in_out() {\n  int isOffloading = 0;\n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int errors = 0;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n    b[x] = 2 * x;\n    c[x] = 0;\n    d[x] = 0;\n  }\n\n#pragma omp target data map(to: a[0:N], b[0:N]) map(alloc: c[0:N]) map(from: d[0:N])\n  {\n#pragma omp target teams distribute nowait depend(in: c) map(alloc: a[0:N], b[0:N], c[0:N])\n    for (int x = 0; x < N; ++x) {\n      c[x] = a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(out: c) map(alloc: b[0:N], c[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n      d[x] = c[x] + b[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, d[x] != 5*x);\n    OMPVV_ERROR_IF(d[x] != 5*x, \"Test of depend(out) task becoming dependent on depend(in) task failed.\");\n  }\n\n#pragma omp target data map(to: a[0:N], b[0:N]) map(alloc: c[0:N]) map(from: d[0:N])\n  {\n#pragma omp target teams distribute nowait depend(in: c) map(alloc: a[0:N], b[0:N], c[0:N])\n    for (int x = 0; x < N; ++x) {\n      c[x] = a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(inout: c) map(alloc: a[0:N], c[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n      d[x] = c[x] + a[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, d[x] != 4*x);\n    OMPVV_ERROR_IF(d[x] != 4*x, \"Test of depend(inout) task becoming dependent on depend(in) task failed.\");\n  }\n\n  return errors;\n}\n\nint main() \n  int errors = 0;\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  errors += test_target_teams_distribute_depend_in_out();\n  OMPVV_INFOMSG_IF(errors != 0, \"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_enter_exit_data_struct.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp parallel\" at position 1184",
        "issue_id": 0,
        "original_code": "//===---- test_target_enter_exit_data_struct.c ----------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks functionality of target enter data and target exit data using\n// a struct and a typedef that each have multiple data memebers of different type \n// and length. The functions test_typedef() and test_struct() are both copying \n// structures to the device, altering public member values, copying them back\n// and checking to see that values are properly updated. \n//\n////===--------------------------------------------------------------------------===//\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\n// Test for OpenMP 4.5 target enter and target exit using a struct.\nint test_struct() {\n   \n  OMPVV_INFOMSG(\"Running test_struct()\");\n    \n  int errors = 0;\n  int* pointers[6];\n\n  struct {\n    int a; // firstprivate\n    int b[N]; // tofrom:b[0:N]\n    int *p; // tofrom:p[0:0]\n  } single, array[5];\n\n  single.p = (int*) malloc(5 * sizeof(int));\n  pointers[0] = single.p;\n\n  for (int i = 0; i < 5; ++i) {\n    array[i].p = (int*) malloc(5 * sizeof(int));\n    pointers[i + 1] = array[i].p;\n  }\n\n#pragma omp target enter data map(to: single) map(to: array[0:5])\n\n#pragma omp target map(alloc: single) map(alloc: array[0:5])\n{\n  single.a = 1;\n  for (int i = 0; i < N; ++i)\n    single.b[i] = 1;\n      \n  for (int i = 0; i < 5; ++i) {\n    array[i].a = 1;\n    for (int j = 0; j < N; ++j)\n      array[i].b[j] = 1;\n  }\n} //end target map\n\n#pragma omp target exit data map(from: single) map(from: array[0:5])\n\n  // Checking results\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (single.a != 1)); \n  for (int i = 0; i < N; ++i)\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (single.b[i] != 1));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (pointers[0] != single.p));\n  for (int i = 0; i < 5; ++i) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (array[i].a != 1)); \n    for (int j = 0; j < N; ++j)\n      OMPVV_TEST_AND_SET_VERBOSE(errors, (array[i].b[j] != 1));\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (pointers[i + 1] != array[i].p));\n  }\n\n  free(single.p);\n  for (int i = 0; i < 5; ++i) {\n    free(array[i].p);\n  }\n  \n  return errors;\n}\n\n// Test for OpenMP 4.5 target enter and target exit using a typedef struct.\nint test_typedef() {\n    \n  OMPVV_INFOMSG(\"Running test_typedef()\");\n    \n  int errors = 0;\n  int* pointers[6];\n\n  typedef struct {\n    int a;\n    int b[N];\n    int *p;\n  } test_struct;\n \n  test_struct single, array[5];\n\n  single.p = (int*) malloc(5 * sizeof(int));\n  pointers[0] = single.p;\n\n  for (int i = 0; i < 5; ++i) {\n    array[i].p = (int*) malloc(5 * sizeof(int));\n    pointers[i + 1] = array[i].p;\n  }\n\n#pragma omp target enter data map(to: single) map(to: array[0:5])\n\n#pragma omp target map(alloc: single) map(alloc: array[0:5])\n{\n  single.a = 1;\n  for (int i = 0; i < N; ++i)\n    single.b[i] = 1;\n      \n  for (int i = 0; i < 5; ++i) {\n    array[i].a = 1;\n    for (int j = 0; j < N; ++j)\n      array[i].b[j] = 1;\n  }\n} //end target map\n\n#pragma omp target exit data map(from: single) map(from: array[0:5])\n\n  // Checking results\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (single.a != 1)); \n  for (int i = 0; i < N; ++i)\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (single.b[i] != 1));\n  errors |= (pointers[0] != single.p);\n  for (int i = 0; i < 5; ++i) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (array[i].a != 1)); \n    for (int j = 0; j < N; ++j)\n      OMPVV_TEST_AND_SET_VERBOSE(errors, (array[i].b[j] != 1));\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (pointers[i + 1] != array[i].p));\n  }\n  \n  free(single.p);\n  for (int i = 0; i < 5; ++i) {\n    free(array[i].p);\n  }\n   return errors;\n}\n\nint main () {\n  \n  // Check that offloading is enabled\n  int isOffloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  \n  int errors = 0;\n  errors += test_struct();\n  errors += test_typedef();\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_enter_exit_data_struct.c ----------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks functionality of target enter data and target exit data using\n// a struct and a typedef that each have multiple data memebers of different type \n// and length. The functions test_typedef() and test_struct() are both copying \n// structures to the device, altering public member values, copying them back\n// and checking to see that values are properly updated. \n//\n////===--------------------------------------------------------------------------===//\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\n// Test for OpenMP 4.5 target enter and target exit using a struct.\nint test_struct() {\n   \n  OMPVV_INFOMSG(\"Running test_struct()\");\n    \n  int errors = 0;\n  int* pointers[6];\n\n  struct {\n    int a; // firstprivate\n    int b[N]; // tofrom:b[0:N]\n    int *p; // tofrom:p[0:0]\n  } single, array[5];\n\n  single.p = (int*) malloc(5 * sizeof(int));\n  pointers[0] = single.p;\n\n  for (int i = 0; i < 5; ++i) {\n    array[i].p = (int*) malloc(5 * sizeof(int));\n    pointers[i + 1] = array[i].p;\n  }\n\n#pragma omp parallel enter data map(to: single) map(to: array[0:5])\n\n#pragma omp target map(alloc: single) map(alloc: array[0:5])\n{\n  single.a = 1;\n  for (int i = 0; i < N; ++i)\n    single.b[i] = 1;\n      \n  for (int i = 0; i < 5; ++i) {\n    array[i].a = 1;\n    for (int j = 0; j < N; ++j)\n      array[i].b[j] = 1;\n  }\n} //end target map\n\n#pragma omp target exit data map(from: single) map(from: array[0:5])\n\n  // Checking results\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (single.a != 1)); \n  for (int i = 0; i < N; ++i)\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (single.b[i] != 1));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (pointers[0] != single.p));\n  for (int i = 0; i < 5; ++i) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (array[i].a != 1)); \n    for (int j = 0; j < N; ++j)\n      OMPVV_TEST_AND_SET_VERBOSE(errors, (array[i].b[j] != 1));\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (pointers[i + 1] != array[i].p));\n  }\n\n  free(single.p);\n  for (int i = 0; i < 5; ++i) {\n    free(array[i].p);\n  }\n  \n  return errors;\n}\n\n// Test for OpenMP 4.5 target enter and target exit using a typedef struct.\nint test_typedef() {\n    \n  OMPVV_INFOMSG(\"Running test_typedef()\");\n    \n  int errors = 0;\n  int* pointers[6];\n\n  typedef struct {\n    int a;\n    int b[N];\n    int *p;\n  } test_struct;\n \n  test_struct single, array[5];\n\n  single.p = (int*) malloc(5 * sizeof(int));\n  pointers[0] = single.p;\n\n  for (int i = 0; i < 5; ++i) {\n    array[i].p = (int*) malloc(5 * sizeof(int));\n    pointers[i + 1] = array[i].p;\n  }\n\n#pragma omp target enter data map(to: single) map(to: array[0:5])\n\n#pragma omp target map(alloc: single) map(alloc: array[0:5])\n{\n  single.a = 1;\n  for (int i = 0; i < N; ++i)\n    single.b[i] = 1;\n      \n  for (int i = 0; i < 5; ++i) {\n    array[i].a = 1;\n    for (int j = 0; j < N; ++j)\n      array[i].b[j] = 1;\n  }\n} //end target map\n\n#pragma omp target exit data map(from: single) map(from: array[0:5])\n\n  // Checking results\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (single.a != 1)); \n  for (int i = 0; i < N; ++i)\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (single.b[i] != 1));\n  errors |= (pointers[0] != single.p);\n  for (int i = 0; i < 5; ++i) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (array[i].a != 1)); \n    for (int j = 0; j < N; ++j)\n      OMPVV_TEST_AND_SET_VERBOSE(errors, (array[i].b[j] != 1));\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (pointers[i + 1] != array[i].p));\n  }\n  \n  free(single.p);\n  for (int i = 0; i < 5; ++i) {\n    free(array[i].p);\n  }\n   return errors;\n}\n\nint main () {\n  \n  // Check that offloading is enabled\n  int isOffloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  \n  int errors = 0;\n  errors += test_struct();\n  errors += test_typedef();\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_data_map_classes.cpp",
        "correct": "n",
        "issue": "Removed opening bracket at position 3010",
        "issue_id": 1,
        "original_code": "//===---- test_target_data_map_classes.cpp -----------------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// This test checks the mapping of c++ objects on both the stack and heap. The 'new'\n// operater is utilized in the case where memory allocation is on heap. Objects are first \n// initalized on the host and then mapped to device. Inside the target region, the object's \n// array data member, which was also mapped to device, is modified through the device array\n// pointer. After target region, we swap back to the host array pointer to verify that the \n// host array was properly updated.\n//\n//===-------------------------------------------------------------------------------------===//\n\n#include <iostream>\n#include <omp.h>\n#include \"ompvv.h\"\n\nusing namespace std;\n\n#define N 1000\n\nclass A {\n\npublic:\n  // breaks encapsulation\n  int *h_array;\n  int size;\n  int sum;\n\n  A(int *array, const int s) : h_array(array), size(s) { sum = 0; }\n\n  // TODO: Add virtual once supported \n  ~A() { h_array = NULL; }\n};\n\n// Test for OpenMP 4.5 target data mapping objects in the heap\nint test_map_tofrom_class_heap() {\n\n  OMPVV_INFOMSG(\"test_map_tofrom_class_heap\");\n\n  int sum = 0, errors = 0;\n\n  int *array = new int[N];\n  A *obj = new A(array, N);\n\n  // mapping an object + array: it is shallow copy thus \n  // pointers are not translated automatically\n#pragma omp target data map(from: array[0:N]) map(tofrom: obj[0:1])\n  {\n#pragma omp target\n    {\n      // assign device array ptr to device obj \n      int *tmp_h_array = obj->h_array;\n      obj->h_array = array;\n      int tmp = 0;\n      for (int i = 0; i < N; ++i) {\n        obj->h_array[i] = 1;\n        tmp += 1;\n      }\n      // swap array device ptr to host ptr \n      obj->h_array = tmp_h_array;\n\n      obj->sum = tmp;\n    } // end target\n  } // end target data\n\n  // checking results \n  for (int i = 0; i < N; ++i)\n    sum += obj->h_array[i];\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (N != sum) || (N != obj->sum));\n\n  delete obj;\n  delete[] array;\n\n  return errors;\n}\n\n// Test for OpenMP 4.5 target data mapping objects on the stack\nint test_map_tofrom_class_stack() {\n\n  OMPVV_INFOMSG(\"test_map_tofrom_class_stack\");\n\n  int sum = 0, errors = 0;\n\n  int array[N];\n  A obj(array, N);\n\n  // mapping an object + array: it is shallow copy thus \n  // pointers are not translated automatically\n#pragma omp target data map(from: array[0:N]) map(tofrom: obj)\n  {\n#pragma omp target\n    {\n      // assign device array ptr to device obj \n      int *tmp_h_array = obj.h_array;\n      obj.h_array = array;\n      int tmp = 0;\n      for (int i = 0; i < N; ++i) {\n        obj.h_array[i] = 1;\n        tmp += 1;\n      }\n      // swap array device ptr to host ptr \n      obj.h_array = tmp_h_array;\n\n      obj.sum = tmp;\n    } // end target\n  } // end target data\n\n  // checking results \n  for (int i = 0; i < N; ++i)\n    sum += obj.h_array[i];\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (N != sum) || (N != obj.sum));\n\n  return errors;\n}\n\nint main() {\n\n  int errors = 0;\n  \n  OMPVV_TEST_OFFLOADING;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_tofrom_class_heap());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_tofrom_class_stack());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_data_map_classes.cpp -----------------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// This test checks the mapping of c++ objects on both the stack and heap. The 'new'\n// operater is utilized in the case where memory allocation is on heap. Objects are first \n// initalized on the host and then mapped to device. Inside the target region, the object's \n// array data member, which was also mapped to device, is modified through the device array\n// pointer. After target region, we swap back to the host array pointer to verify that the \n// host array was properly updated.\n//\n//===-------------------------------------------------------------------------------------===//\n\n#include <iostream>\n#include <omp.h>\n#include \"ompvv.h\"\n\nusing namespace std;\n\n#define N 1000\n\nclass A {\n\npublic:\n  // breaks encapsulation\n  int *h_array;\n  int size;\n  int sum;\n\n  A(int *array, const int s) : h_array(array), size(s) { sum = 0; }\n\n  // TODO: Add virtual once supported \n  ~A() { h_array = NULL; }\n};\n\n// Test for OpenMP 4.5 target data mapping objects in the heap\nint test_map_tofrom_class_heap() {\n\n  OMPVV_INFOMSG(\"test_map_tofrom_class_heap\");\n\n  int sum = 0, errors = 0;\n\n  int *array = new int[N];\n  A *obj = new A(array, N);\n\n  // mapping an object + array: it is shallow copy thus \n  // pointers are not translated automatically\n#pragma omp target data map(from: array[0:N]) map(tofrom: obj[0:1])\n  {\n#pragma omp target\n    {\n      // assign device array ptr to device obj \n      int *tmp_h_array = obj->h_array;\n      obj->h_array = array;\n      int tmp = 0;\n      for (int i = 0; i < N; ++i) {\n        obj->h_array[i] = 1;\n        tmp += 1;\n      }\n      // swap array device ptr to host ptr \n      obj->h_array = tmp_h_array;\n\n      obj->sum = tmp;\n    } // end target\n  } // end target data\n\n  // checking results \n  for (int i = 0; i < N; ++i)\n    sum += obj->h_array[i];\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (N != sum) || (N != obj->sum));\n\n  delete obj;\n  delete[] array;\n\n  return errors;\n}\n\n// Test for OpenMP 4.5 target data mapping objects on the stack\nint test_map_tofrom_class_stack() {\n\n  OMPVV_INFOMSG(\"test_map_tofrom_class_stack\");\n\n  int sum = 0, errors = 0;\n\n  int array[N];\n  A obj(array, N);\n\n  // mapping an object + array: it is shallow copy thus \n  // pointers are not translated automatically\n#pragma omp target data map(from: array[0:N]) map(tofrom: obj)\n  {\n#pragma omp target\n    {\n      // assign device array ptr to device obj \n      int *tmp_h_array = obj.h_array;\n      obj.h_array = array;\n      int tmp = 0;\n      for (int i = 0; i < N; ++i) {\n        obj.h_array[i] = 1;\n        tmp += 1;\n      }\n      // swap array device ptr to host ptr \n      obj.h_array = tmp_h_array;\n\n      obj.sum = tmp;\n    } // end target\n  } // end target data\n\n  // checking results \n  for (int i = 0; i < N; ++i)\n    sum += obj.h_array[i];\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (N != sum) || (N != obj.sum));\n\n  return errors;\n}\n\nint main() \n\n  int errors = 0;\n  \n  OMPVV_TEST_OFFLOADING;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_tofrom_class_heap());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_tofrom_class_stack());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_declare_target_end_declare_target.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 605",
        "issue_id": 2,
        "original_code": "//===------ test_declare_target_end_declare_target.c ----------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// The test verifies that the variable and function enclosed between declare \n// target and end declare target are available inside the target region.\n// Updates using the enclosed function are made inside the target region and\n// results are verified on the host.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp declare target\nint aint = 10;\nvoid compute_array(int a[N], int b[N], int c[N]) {\n  for (int i = 0; i < N; i++) {\n    a[i] = b[i]*c[i] + aint * i;\n  }\n  return;\n}\n#pragma omp end declare target\n\nint test_declare_target() {\n\n  OMPVV_INFOMSG(\"test_declare_target_end_declare_target\");\n\n  int errors = 0;\n  int x[N];\n  int y[N];\n  int z[N];\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 0;\n    y[i] = 1;\n    z[i] = i;\n  }\n\n#pragma omp target map(tofrom: x) map(to:y, z)\n  {\n    compute_array(x, y, z);\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != (y[i] * z[i] + 10 * i));\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_declare_target() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===------ test_declare_target_end_declare_target.c ----------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// The test verifies that the variable and function enclosed between declare \n// target and end declare target are available inside the target region.\n// Updates using the enclosed function are made inside the target region and\n// results are verified on the host.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp declare target\nint aint = 10;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\nvoid compute_array(int a[N], int b[N], int c[N]) {\n  for (int i = 0; i < N; i++) {\n    a[i] = b[i]*c[i] + aint * i;\n  }\n  return;\n}\n#pragma omp end declare target\n\nint test_declare_target() {\n\n  OMPVV_INFOMSG(\"test_declare_target_end_declare_target\");\n\n  int errors = 0;\n  int x[N];\n  int y[N];\n  int z[N];\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 0;\n    y[i] = 1;\n    z[i] = i;\n  }\n\n#pragma omp target map(tofrom: x) map(to:y, z)\n  {\n    compute_array(x, y, z);\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != (y[i] * z[i] + 10 * i));\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_declare_target() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_depend_unused_data.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1668",
        "issue_id": 1,
        "original_code": "//===--- test_target_teams_distribute_depend_unused_data.c-------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks if out-out dependency works even if the data in the list\n// is unused by either task. Both tasks are given the nowait clause to allow\n// for the possibility that they will be incorrectly run out of order. If the\n// two target teams ditribute loops run out of order, the test fails.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_target_teams_distribute_depend_unused_data() {\n  int isOffloading = 0;\n  int errors = 0;\n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int random_data[1];\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n    b[x] = 2 * x;\n    c[x] = 0;\n    d[x] = 0;\n  }\n\n#pragma omp target data map(to: a[0:N], b[0:N]) map(alloc: c[0:N], random_data[0:1]) map(from: d[0:N])\n  {\n#pragma omp target teams distribute nowait depend(out: random_data) map(alloc: a[0:N], b[0:N], c[0:N])\n    for (int x = 0; x < N; ++x) {\n      c[x] = a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(out: random_data) map(alloc: b[0:N], c[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n      d[x] = c[x] + b[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n      OMPVV_ERROR_IF(d[x] != 5*x, \"Test of depend clause using array sections did not pass with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n      OMPVV_TEST_AND_SET_VERBOSE(errors, d[x] != 5*x);\n      if (d[x] != 5*x) {\n        break;\n      }\n  }\n\n  return errors;\n}\n\n\nint main() {\n  int errors = 0;\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  errors += test_target_teams_distribute_depend_unused_data();\n  OMPVV_INFOMSG_IF(errors != 0, \"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_depend_unused_data.c-------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks if out-out dependency works even if the data in the list\n// is unused by either task. Both tasks are given the nowait clause to allow\n// for the possibility that they will be incorrectly run out of order. If the\n// two target teams ditribute loops run out of order, the test fails.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_target_teams_distribute_depend_unused_data() {\n  int isOffloading = 0;\n  int errors = 0;\n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int random_data[1];\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n    b[x] = 2 * x;\n    c[x] = 0;\n    d[x] = 0;\n  }\n\n#pragma omp target data map(to: a[0:N], b[0:N]) map(alloc: c[0:N], random_data[0:1]) map(from: d[0:N])\n  {\n#pragma omp target teams distribute nowait depend(out: random_data) map(alloc: a[0:N], b[0:N], c[0:N])\n    for (int x = 0; x < N; ++x) {\n      c[x] = a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(out: random_data) map(alloc: b[0:N], c[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n      d[x] = c[x] + b[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n      OMPVV_ERROR_IF(d[x] != 5*x, \"Test of depend clause using array sections did not pass with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n      OMPVV_TEST_AND_SET_VERBOSE(errors, d[x] != 5*x);\n      if (d[x] != 5*x) {\n        break;\n      }\n  }\n\n  return errors;\n}\n\n\nint main() \n  int errors = 0;\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  errors += test_target_teams_distribute_depend_unused_data();\n  OMPVV_INFOMSG_IF(errors != 0, \"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_depend_out_in.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp single\" at position 745",
        "issue_id": 0,
        "original_code": "//===--- test_target_teams_distribute_depend_out_in.c------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks out-in and inout-in dependency by checking order-dependent\n// results from pairs of possibly asynchronous loops. The test fails if either \n// out-in or inout-in dependency is broken.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_target_teams_distribute_depend_out_in() {\n  int isOffloading = 0;\n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int errors = 0;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n    b[x] = 2 * x;\n    c[x] = 0;\n    d[x] = 0;\n  }\n\n#pragma omp target data map(to: a[0:N], b[0:N]) map(alloc: c[0:N]) map(from: d[0:N])\n  {\n#pragma omp target teams distribute nowait depend(out: c) map(alloc: a[0:N], b[0:N], c[0:N])\n    for (int x = 0; x < N; ++x) {\n      c[x] = a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(in: c) map(alloc: b[0:N], c[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n      d[x] = c[x] + b[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, d[x] != 5*x);\n    OMPVV_ERROR_IF(d[x] != 5*x, \"Test of depend(out) task becoming dependent on depend(in) task failed.\");\n  }\n\n#pragma omp target data map(to: a[0:N], b[0:N]) map(alloc: c[0:N]) map(from: d[0:N])\n  {\n#pragma omp target teams distribute nowait depend(inout: c) map(alloc: a[0:N], b[0:N], c[0:N])\n    for (int x = 0; x < N; ++x) {\n      c[x] = a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(in: c) map(alloc: a[0:N], c[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n      d[x] = c[x] + a[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, d[x] != 4*x);\n    OMPVV_ERROR_IF(d[x] != 4*x, \"Test of depend(inout) task becoming dependent on depend(in) task failed.\");\n  }\n\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  errors += test_target_teams_distribute_depend_out_in();\n  OMPVV_INFOMSG_IF(errors != 0, \"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_depend_out_in.c------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks out-in and inout-in dependency by checking order-dependent\n// results from pairs of possibly asynchronous loops. The test fails if either \n// out-in or inout-in dependency is broken.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_target_teams_distribute_depend_out_in() {\n  int isOffloading = 0;\n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int errors = 0;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n    b[x] = 2 * x;\n    c[x] = 0;\n    d[x] = 0;\n  }\n\n#pragma omp single data map(to: a[0:N], b[0:N]) map(alloc: c[0:N]) map(from: d[0:N])\n  {\n#pragma omp target teams distribute nowait depend(out: c) map(alloc: a[0:N], b[0:N], c[0:N])\n    for (int x = 0; x < N; ++x) {\n      c[x] = a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(in: c) map(alloc: b[0:N], c[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n      d[x] = c[x] + b[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, d[x] != 5*x);\n    OMPVV_ERROR_IF(d[x] != 5*x, \"Test of depend(out) task becoming dependent on depend(in) task failed.\");\n  }\n\n#pragma omp target data map(to: a[0:N], b[0:N]) map(alloc: c[0:N]) map(from: d[0:N])\n  {\n#pragma omp target teams distribute nowait depend(inout: c) map(alloc: a[0:N], b[0:N], c[0:N])\n    for (int x = 0; x < N; ++x) {\n      c[x] = a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(in: c) map(alloc: a[0:N], c[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n      d[x] = c[x] + a[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, d[x] != 4*x);\n    OMPVV_ERROR_IF(d[x] != 4*x, \"Test of depend(inout) task becoming dependent on depend(in) task failed.\");\n  }\n\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  errors += test_target_teams_distribute_depend_out_in();\n  OMPVV_INFOMSG_IF(errors != 0, \"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_parallel_for_private.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp atomic\" at position 1153",
        "issue_id": 0,
        "original_code": "//===---- test_target_teams_distribute_parallel_for_private.c - combined consutrct -===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test check for a private variable within a pragma omp target teams distribute\n// parallel for. We use a private variable within a for loop and asign it every iteration\n// hoping that we won't get into data races. We do this multiple times to improve\n// test\n// we assign a large number of threads and teams to try to increase parallelism and\n// contention on the privatized variable\n//\n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define N 1024\n\nint test_target_teams_distribute_parallel_for_private() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_devices\");\n\n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int privatized = 10;\n  int num_teams[N];\n  int num_threads[N];\n  int errors = 0;\n  int i, j;\n\n  // array initialization\n  for (i = 0; i < N; i++) {\n    a[i] = 1;\n    b[i] = i;\n    c[i] = 2*i;\n    d[i] = 0;\n    num_teams[i] = -1;\n    num_threads[i] = -1;\n  }\n\n  // check multiple sizes.\n#pragma omp target data map(to: a[0:N], b[0:N], c[0:N]) map(from: d[0:N])\n  {\n#pragma omp target teams distribute parallel for private(privatized, i) num_threads(OMPVV_NUM_THREADS_DEVICE) num_teams(OMPVV_NUM_TEAMS_DEVICE)\n    for (j = 0; j < N; ++j) {\n      num_teams[j] = omp_get_num_teams();\n      num_threads[j] = omp_get_num_threads();\n\n      privatized = 0;\n      for (i = 0; i < a[j] + b[j]; ++i) {\n        privatized++;\n      }\n      d[j] = c[j] * privatized;\n    }\n  }\n\n  int warning_threads = 0;\n  int warning_teams = 0;\n\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, d[i] != (1 + i)*2*i);\n    warning_teams += num_teams[i];\n    warning_threads += num_threads[i];\n  }\n\n  OMPVV_WARNING_IF(warning_teams == N, \"There was a single team across the target region. Privatization cannot be tested at the teams level\");\n  OMPVV_WARNING_IF(warning_threads == N, \"All the parallel regions ran with a single thread. Privatization cannot be tested at the thread level\");\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_private());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_teams_distribute_parallel_for_private.c - combined consutrct -===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test check for a private variable within a pragma omp target teams distribute\n// parallel for. We use a private variable within a for loop and asign it every iteration\n// hoping that we won't get into data races. We do this multiple times to improve\n// test\n// we assign a large number of threads and teams to try to increase parallelism and\n// contention on the privatized variable\n//\n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define N 1024\n\nint test_target_teams_distribute_parallel_for_private() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_devices\");\n\n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int privatized = 10;\n  int num_teams[N];\n  int num_threads[N];\n  int errors = 0;\n  int i, j;\n\n  // array initialization\n  for (i = 0; i < N; i++) {\n    a[i] = 1;\n    b[i] = i;\n    c[i] = 2*i;\n    d[i] = 0;\n    num_teams[i] = -1;\n    num_threads[i] = -1;\n  }\n\n  // check multiple sizes.\n#pragma omp atomic data map(to: a[0:N], b[0:N], c[0:N]) map(from: d[0:N])\n  {\n#pragma omp target teams distribute parallel for private(privatized, i) num_threads(OMPVV_NUM_THREADS_DEVICE) num_teams(OMPVV_NUM_TEAMS_DEVICE)\n    for (j = 0; j < N; ++j) {\n      num_teams[j] = omp_get_num_teams();\n      num_threads[j] = omp_get_num_threads();\n\n      privatized = 0;\n      for (i = 0; i < a[j] + b[j]; ++i) {\n        privatized++;\n      }\n      d[j] = c[j] * privatized;\n    }\n  }\n\n  int warning_threads = 0;\n  int warning_teams = 0;\n\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, d[i] != (1 + i)*2*i);\n    warning_teams += num_teams[i];\n    warning_threads += num_threads[i];\n  }\n\n  OMPVV_WARNING_IF(warning_teams == N, \"There was a single team across the target region. Privatization cannot be tested at the teams level\");\n  OMPVV_WARNING_IF(warning_threads == N, \"All the parallel regions ran with a single thread. Privatization cannot be tested at the thread level\");\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_private());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_reduction_max.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1735",
        "issue_id": 1,
        "original_code": "//===--- test_target_teams_distribute_reduction_max.c------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the reduction clause on a target teams distribute directive,\n// testing that the variable in the reduction clause is properly reduced using\n// the max operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_max() {\n  int a[N];\n  int b[N];\n  int errors = 0;\n  int num_teams[N];\n  srand(1);\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = (int) rand() / (double)(RAND_MAX / 100);\n    b[x] = (int) rand() / (double)(RAND_MAX / 100);\n    num_teams[x] = -x;\n  }\n\n  int result = 0;\n\n#pragma omp target teams distribute reduction(max:result) defaultmap(tofrom:scalar)\n  for (int x = 0; x < N; ++x) {\n    result = fmax(a[x] + b[x], result);\n    num_teams[x] = omp_get_num_teams();\n  }\n\n  int host_max = 0;\n\n  for (int x = 0; x < N; ++x) {\n    host_max = fmax(host_max, a[x] + b[x]);\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_teams[x - 1] != num_teams[x], \"Kernel reported differing numbers of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_teams[0] == 1, \"Test operated with one team.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_teams[0] <= 0, \"Test reported invalid number of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != host_max);\n  OMPVV_ERROR_IF(host_max != result, \"Max on device is %d but expected max from host is %d.\", result, host_max);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_max() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_reduction_max.c------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the reduction clause on a target teams distribute directive,\n// testing that the variable in the reduction clause is properly reduced using\n// the max operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_max() {\n  int a[N];\n  int b[N];\n  int errors = 0;\n  int num_teams[N];\n  srand(1);\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = (int) rand() / (double)(RAND_MAX / 100);\n    b[x] = (int) rand() / (double)(RAND_MAX / 100);\n    num_teams[x] = -x;\n  }\n\n  int result = 0;\n\n#pragma omp target teams distribute reduction(max:result) defaultmap(tofrom:scalar)\n  for (int x = 0; x < N; ++x) {\n    result = fmax(a[x] + b[x], result);\n    num_teams[x] = omp_get_num_teams();\n  }\n\n  int host_max = 0;\n\n  for (int x = 0; x < N; ++x) {\n    host_max = fmax(host_max, a[x] + b[x]);\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_teams[x - 1] != num_teams[x], \"Kernel reported differing numbers of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_teams[0] == 1, \"Test operated with one team.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_teams[0] <= 0, \"Test reported invalid number of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != host_max);\n  OMPVV_ERROR_IF(host_max != result, \"Max on device is %d but expected max from host is %d.\", result, host_max);\n\n  return errors;\n}\n\nint main() \n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_max() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_data_map_from.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n\n  int errors = 0;\n  \n  //Check for offloading\n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_from());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 1377",
        "issue_id": 4,
        "original_code": "//===---- test_target_data_map_from.c -----------------------------------------------------===//\n//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// The test_target_data_map group of tests checks all the possible map-type-modifiers \n// for the target data map clauses. These are: from, to, fromto, alloc, release and delete.\n// There is a separate c file for each test with the prefix test_target_data_map.\n// This specific test is for mapping 'from'.\n//\n//===--------------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\n// Test for OpenMP 4.5 target data map(from: )\nint test_map_from() {\n\n  OMPVV_INFOMSG(\"test_map_from\");\n\n  int sum = 0, sum2 = 0, errors = 0;\n\n  // host arrays: heap and stack\n  int *h_array_h = (int *)malloc(N * sizeof(int));\n  int h_array_s[N];\n\n#pragma omp target data map(from: h_array_h[0:N])  \\\n        map(from: h_array_s[0:N])\n  {\n#pragma omp target\n    {\n      for (int i = 0; i < N; ++i) {\n        h_array_h[i] = 1;\n        h_array_s[i] = 2;\n      }\n    } // end target\n  } // end target data\n\n  // checking results\n  for (int i = 0; i < N; ++i) {\n    sum += h_array_h[i];\n    sum2 += h_array_s[i];\n  }\n  \n  free(h_array_h);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (N != sum) || (2*N != sum2));\n\n  return errors;\n}\n\n\nint main() {\n\n  int errors = 0;\n  \n  //Check for offloading\n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_from());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_data_map_from.c -----------------------------------------------------===//\n//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// The test_target_data_map group of tests checks all the possible map-type-modifiers \n// for the target data map clauses. These are: from, to, fromto, alloc, release and delete.\n// There is a separate c file for each test with the prefix test_target_data_map.\n// This specific test is for mapping 'from'.\n//\n//===--------------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\n// Test for OpenMP 4.5 target data map(from: )\nint test_map_from() {\n\n  OMPVV_INFOMSG(\"test_map_from\");\n\n  int sum = 0, sum2 = 0, errors = 0;\n\n  // host arrays: heap and stack\n  int *h_array_h = (int *)malloc(N * sizeof(int));\n  int h_array_s[N];\n\n#pragma omp target data map(from: h_array_h[0:N])  \\\n        map(from: h_array_s[0:N])\n  {\n#pragma omp target\n    {\n      for (int i = 0; i < N; ++i) {\n        h_array_h[i] = 1;\n        h_array_s[i] = 2;\n      }\n    } // end target\n  } // end target data\n\n  // checking results\n  for (int i = 0; i < N; ++i) {\n    sum += h_array_h[i];\n    sum2 += h_array_s[i];\n  }\n  \n  free(h_array_h);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (N != sum) || (2*N != sum2));\n\n  return errors;\n}\n\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_task_target.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp task\" with directive \"#pragma omp single\" at position 609",
        "issue_id": 0,
        "original_code": "//===-------- test_task_target.c - test task with target offload  ------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks target regions inside of tasks. With offloading support \n// the tasks are executed on the device. The results do not change if the \n// test is executed on the host. Output will indicate if the test passed and\n// where (host/device).\n//\n////===----------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nint test_task_target() {\n  int a[N], b[N], c[N];\n  int errors = 0, i;\n\n#pragma omp task shared(a) private(i)\n#pragma omp target map(from: a)\n#pragma omp parallel for\n  for (i = 0; i < N; i++)\n    a[i] = i;\n   \n#pragma omp task shared(b) private(i)\n#pragma omp target map(from: b)\n#pragma omp parallel for\n  for (i = 0; i < N; i++)\n    b[i] = 10;\n\n#pragma omp taskwait\n\n#pragma omp task shared(c) private(i)\n#pragma omp target map(from: c) map(to:a,b)\n#pragma omp parallel for\n  for (i = 0; i < N; i++)\n    c[i] = a[i] + b[i];\n\n#pragma omp taskwait\n\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, (c[i] != i + 10));\n  }\n  return(errors);\n}\n\nint main() {\n\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_task_target());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===-------- test_task_target.c - test task with target offload  ------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks target regions inside of tasks. With offloading support \n// the tasks are executed on the device. The results do not change if the \n// test is executed on the host. Output will indicate if the test passed and\n// where (host/device).\n//\n////===----------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nint test_task_target() {\n  int a[N], b[N], c[N];\n  int errors = 0, i;\n\n#pragma omp single shared(a) private(i)\n#pragma omp target map(from: a)\n#pragma omp parallel for\n  for (i = 0; i < N; i++)\n    a[i] = i;\n   \n#pragma omp task shared(b) private(i)\n#pragma omp target map(from: b)\n#pragma omp parallel for\n  for (i = 0; i < N; i++)\n    b[i] = 10;\n\n#pragma omp taskwait\n\n#pragma omp task shared(c) private(i)\n#pragma omp target map(from: c) map(to:a,b)\n#pragma omp parallel for\n  for (i = 0; i < N; i++)\n    c[i] = a[i] + b[i];\n\n#pragma omp taskwait\n\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, (c[i] != i + 10));\n  }\n  return(errors);\n}\n\nint main() {\n\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_task_target());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_declare_target_to_extended_list.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===------ test_declare_target_to_extended_list.c  ----------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks the second valid format of declare target directive with the \n// to clause. The extended list allows for mappable variables and function names \n// to be listed. If a list item of a to clause is a variable then the original \n// variable is mapped to a corresponding variable in the device data environment \n// of all devices as if it had appeared in a map clause with the map-type to on \n// the implicit target data construct for each device.\n// Updates using the enclosed function are made inside the target region and\n// results are verified on the host.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint aint = 10;\n\n#pragma omp declare target to(aint)\n\nvoid compute_array(int a[N], int b[N], int c[N]) {\n  for (int i = 0; i < N; i++) {\n    a[i] = b[i]*c[i] + aint * i;\n  }\n  return;\n}\n \n#pragma omp declare target to(compute_array)\n\nint test_declare_target() {\n\n  OMPVV_INFOMSG(\"test_declare_target_to_extended_list\");\n\n  int errors = 0;\n  int x[N];\n  int y[N];\n  int z[N];\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 0;\n    y[i] = 1;\n    z[i] = i;\n  }\n\n#pragma omp target map(from: x) map(to:y, z)\n  {\n    compute_array(x, y, z);\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != (y[i] * z[i] + 10 * i));\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_declare_target() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nint muedbitcsl = 233;\nint xgrsfslzta = 139;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_depend_out_out.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 3844",
        "issue_id": 1,
        "original_code": "//===--- test_target_teams_distribute_depend_out_out.c------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks for dependency between all combinations of out and inout\n// by checking order-dependent results from pairs of possibly asynchronous\n// loops. The test fails if any required dependency is broken.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_target_teams_distribute_depend_out_out() {\n  int isOffloading = 0;\n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int out_out_errors = 0;\n  int inout_out_errors = 0;\n  int out_inout_errors = 0;\n  int inout_inout_errors = 0;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n    b[x] = 2 * x;\n    c[x] = 0;\n    d[x] = 0;\n  }\n\n#pragma omp target data map(to: a[0:N], b[0:N]) map(alloc: c[0:N]) map(from: d[0:N])\n  {\n#pragma omp target teams distribute nowait depend(out: c) map(alloc: a[0:N], b[0:N], c[0:N])\n    for (int x = 0; x < N; ++x) {\n      c[x] = a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(out: c) map(alloc: b[0:N], c[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n      d[x] = c[x] + b[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(out_out_errors, d[x] != 5*x);\n  }\n\n#pragma omp target data map(to: a[0:N], b[0:N]) map(alloc: c[0:N]) map(from: d[0:N])\n  {\n#pragma omp target teams distribute nowait depend(out: c) map(alloc: a[0:N], b[0:N], c[0:N])\n    for (int x = 0; x < N; ++x) {\n      c[x] = a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(inout: c) map(alloc: a[0:N], c[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n      d[x] = c[x] + a[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(out_inout_errors, d[x] != 4*x);\n  }\n\n#pragma omp target data map(to: a[0:N], b[0:N]) map(alloc: c[0:N]) map(from: d[0:N])\n  {\n#pragma omp target teams distribute nowait depend(inout: c) map(alloc: a[0:N], b[0:N], c[0:N])\n    for (int x = 0; x < N; ++x) {\n      c[x] = a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(out: c) map(alloc: b[0:N], c[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n      d[x] = c[x] + b[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(inout_out_errors, d[x] != 5*x);\n  }\n\n#pragma omp target data map(to: a[0:N], b[0:N]) map(alloc: c[0:N]) map(from: d[0:N])\n  {\n#pragma omp target teams distribute nowait depend(inout: c) map(alloc: a[0:N], b[0:N], c[0:N])\n    for (int x = 0; x < N; ++x) {\n      c[x] = a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(inout: c) map(alloc: a[0:N], c[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n      d[x] = c[x] + a[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(inout_inout_errors, d[x] != 4*x);\n  }\n\n  OMPVV_ERROR_IF(out_out_errors == 1, \"Test of depend(out) task becoming dependent task of depend(out) task did not pass with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  OMPVV_ERROR_IF(inout_out_errors == 1, \"Test of depend(out) task becoming dependent task of depend(inout) task did not pass with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  OMPVV_ERROR_IF(out_inout_errors == 1, \"Test of depend(inout) task becoming dependent task of depend(out) task did not pass with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  OMPVV_ERROR_IF(inout_inout_errors == 1, \"Test of depend(inout) task becoming dependent task of depend(inout) task did not pass with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n\n  return inout_inout_errors + inout_out_errors + out_inout_errors + out_out_errors;\n}\n\nint main() {\n  int errors = 0;\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  errors += test_target_teams_distribute_depend_out_out();\n  OMPVV_INFOMSG_IF(errors != 0, \"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_depend_out_out.c------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks for dependency between all combinations of out and inout\n// by checking order-dependent results from pairs of possibly asynchronous\n// loops. The test fails if any required dependency is broken.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_target_teams_distribute_depend_out_out() {\n  int isOffloading = 0;\n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int out_out_errors = 0;\n  int inout_out_errors = 0;\n  int out_inout_errors = 0;\n  int inout_inout_errors = 0;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n    b[x] = 2 * x;\n    c[x] = 0;\n    d[x] = 0;\n  }\n\n#pragma omp target data map(to: a[0:N], b[0:N]) map(alloc: c[0:N]) map(from: d[0:N])\n  {\n#pragma omp target teams distribute nowait depend(out: c) map(alloc: a[0:N], b[0:N], c[0:N])\n    for (int x = 0; x < N; ++x) {\n      c[x] = a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(out: c) map(alloc: b[0:N], c[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n      d[x] = c[x] + b[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(out_out_errors, d[x] != 5*x);\n  }\n\n#pragma omp target data map(to: a[0:N], b[0:N]) map(alloc: c[0:N]) map(from: d[0:N])\n  {\n#pragma omp target teams distribute nowait depend(out: c) map(alloc: a[0:N], b[0:N], c[0:N])\n    for (int x = 0; x < N; ++x) {\n      c[x] = a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(inout: c) map(alloc: a[0:N], c[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n      d[x] = c[x] + a[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(out_inout_errors, d[x] != 4*x);\n  }\n\n#pragma omp target data map(to: a[0:N], b[0:N]) map(alloc: c[0:N]) map(from: d[0:N])\n  {\n#pragma omp target teams distribute nowait depend(inout: c) map(alloc: a[0:N], b[0:N], c[0:N])\n    for (int x = 0; x < N; ++x) {\n      c[x] = a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(out: c) map(alloc: b[0:N], c[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n      d[x] = c[x] + b[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(inout_out_errors, d[x] != 5*x);\n  }\n\n#pragma omp target data map(to: a[0:N], b[0:N]) map(alloc: c[0:N]) map(from: d[0:N])\n  {\n#pragma omp target teams distribute nowait depend(inout: c) map(alloc: a[0:N], b[0:N], c[0:N])\n    for (int x = 0; x < N; ++x) {\n      c[x] = a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(inout: c) map(alloc: a[0:N], c[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n      d[x] = c[x] + a[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(inout_inout_errors, d[x] != 4*x);\n  }\n\n  OMPVV_ERROR_IF(out_out_errors == 1, \"Test of depend(out) task becoming dependent task of depend(out) task did not pass with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  OMPVV_ERROR_IF(inout_out_errors == 1, \"Test of depend(out) task becoming dependent task of depend(inout) task did not pass with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  OMPVV_ERROR_IF(out_inout_errors == 1, \"Test of depend(inout) task becoming dependent task of depend(out) task did not pass with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  OMPVV_ERROR_IF(inout_inout_errors == 1, \"Test of depend(inout) task becoming dependent task of depend(inout) task did not pass with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n\n  return inout_inout_errors + inout_out_errors + out_inout_errors + out_out_errors;\n}\n\nint main() \n  int errors = 0;\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  errors += test_target_teams_distribute_depend_out_out();\n  OMPVV_INFOMSG_IF(errors != 0, \"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_enter_data_if.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp single\" at position 1962",
        "issue_id": 0,
        "original_code": "//===---- test_target_enter_data_if.c - check the if clause of target data ------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// This test verifies the conditional data movement of the target enter data\n// directive through the if clause. There are two options:\n// 1. The if condition evaluates to true, in which case the data a[i] = 1 and \n// b[i] = i will be copied over to the device. Since there is alreay a and b\n// mapped in the target enter data, then the target region should not map the \n// a and b arrays. \n//\n// 2. The if condition evaluates to false. After the target enter data directive\n// we modify the values of the host to be 0. In which case the target region will\n// be in charge of the data movement and a[i] = 0 and b[i] = 0\n//\n// The target region will do c[i] = a[i] which will be either i + 1 or 0, \n// depending on the result of if. \n//\n// this test only gets executed if there is offloading and no shared memory\n// Shared memory devices would not work in this case\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define SIZE_THRESHOLD 512\n#define ARRAY_SIZE 1024\n\n// Test for OpenMP 4.5 target enter data with if\nint main() {\n  int a[ARRAY_SIZE];\n  int b[ARRAY_SIZE];\n  int c[ARRAY_SIZE];\n  int size, i = 0, errors = 0, isOffloading = 0, isSharedMemory = 0;\n\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading)\n  OMPVV_TEST_AND_SET_SHARED_ENVIRONMENT(isSharedMemory)\n\n  if (!isOffloading || isSharedMemory) {\n    OMPVV_WARNING(\"It is not possible to test conditional data transfers \"\n                  \"if the environment is shared or offloading is off. Not testing \"\n                  \"anything\")\n    OMPVV_REPORT_AND_RETURN(0);\n  }\n\n  // check multiple sizes. \n  for (size = 256; size <= ARRAY_SIZE; size += 256) {\n    // a,b and c arrays initialization\n    for (i = 0; i < size; i++) {\n      a[i] = 1;\n      b[i] = i;\n      c[i] = -1;\n    }\n#pragma omp target enter data if(size > SIZE_THRESHOLD) map(to: size) \\\n    map (to: a[0:size], b[0:size])\n           \n    // a, b arrays host side modification\n    for (i = 0; i < size; i++) {\n      a[i] = 0;\n      b[i] = 0;\n    }\n\n    // if a and b were mapped already by the target enter data then \n    // the tofrom should be a noop\n#pragma omp target map(tofrom: a[0:size], b[0:size], c[0:size])\n{\n        int j = 0;\n        for (j = 0; j < size; j++) {\n          // c[j] is zero if executed in the host\n          // c[j] is 1+j if executed on the device\n          c[j] = a[j] + b[j];\n        }\n} // end target\n\n    // checking results \n    for (i = 0; i < size; i++) {\n      if (size > SIZE_THRESHOLD) {\n        OMPVV_TEST_AND_SET_VERBOSE(errors, c[i] != i + 1)\n      } else {\n        OMPVV_TEST_AND_SET_VERBOSE(errors, c[i] != 0)\n      } //end-else \n    }\n    // This is not part of the test but it is necessary to avoid conflicts\n    #pragma omp target exit data if(size > SIZE_THRESHOLD) map(delete: a[0:size], b[0:size])\n  } // end-for size\n\n  OMPVV_REPORT_AND_RETURN(errors)\n\n}\n",
        "error_code": "//===---- test_target_enter_data_if.c - check the if clause of target data ------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// This test verifies the conditional data movement of the target enter data\n// directive through the if clause. There are two options:\n// 1. The if condition evaluates to true, in which case the data a[i] = 1 and \n// b[i] = i will be copied over to the device. Since there is alreay a and b\n// mapped in the target enter data, then the target region should not map the \n// a and b arrays. \n//\n// 2. The if condition evaluates to false. After the target enter data directive\n// we modify the values of the host to be 0. In which case the target region will\n// be in charge of the data movement and a[i] = 0 and b[i] = 0\n//\n// The target region will do c[i] = a[i] which will be either i + 1 or 0, \n// depending on the result of if. \n//\n// this test only gets executed if there is offloading and no shared memory\n// Shared memory devices would not work in this case\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define SIZE_THRESHOLD 512\n#define ARRAY_SIZE 1024\n\n// Test for OpenMP 4.5 target enter data with if\nint main() {\n  int a[ARRAY_SIZE];\n  int b[ARRAY_SIZE];\n  int c[ARRAY_SIZE];\n  int size, i = 0, errors = 0, isOffloading = 0, isSharedMemory = 0;\n\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading)\n  OMPVV_TEST_AND_SET_SHARED_ENVIRONMENT(isSharedMemory)\n\n  if (!isOffloading || isSharedMemory) {\n    OMPVV_WARNING(\"It is not possible to test conditional data transfers \"\n                  \"if the environment is shared or offloading is off. Not testing \"\n                  \"anything\")\n    OMPVV_REPORT_AND_RETURN(0);\n  }\n\n  // check multiple sizes. \n  for (size = 256; size <= ARRAY_SIZE; size += 256) {\n    // a,b and c arrays initialization\n    for (i = 0; i < size; i++) {\n      a[i] = 1;\n      b[i] = i;\n      c[i] = -1;\n    }\n#pragma omp single enter data if(size > SIZE_THRESHOLD) map(to: size) \\\n    map (to: a[0:size], b[0:size])\n           \n    // a, b arrays host side modification\n    for (i = 0; i < size; i++) {\n      a[i] = 0;\n      b[i] = 0;\n    }\n\n    // if a and b were mapped already by the target enter data then \n    // the tofrom should be a noop\n#pragma omp target map(tofrom: a[0:size], b[0:size], c[0:size])\n{\n        int j = 0;\n        for (j = 0; j < size; j++) {\n          // c[j] is zero if executed in the host\n          // c[j] is 1+j if executed on the device\n          c[j] = a[j] + b[j];\n        }\n} // end target\n\n    // checking results \n    for (i = 0; i < size; i++) {\n      if (size > SIZE_THRESHOLD) {\n        OMPVV_TEST_AND_SET_VERBOSE(errors, c[i] != i + 1)\n      } else {\n        OMPVV_TEST_AND_SET_VERBOSE(errors, c[i] != 0)\n      } //end-else \n    }\n    // This is not part of the test but it is necessary to avoid conflicts\n    #pragma omp target exit data if(size > SIZE_THRESHOLD) map(delete: a[0:size], b[0:size])\n  } // end-for size\n\n  OMPVV_REPORT_AND_RETURN(errors)\n\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/reduction_separated_directives.cpp",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===---- reduction_separated_directives.cpp ------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks the behavior of a reduction clause with separated target teams\n// parallel for directives by comparing the results to those from atomic-protected\n// writes without a reduction. This test comes from the aomp development repo, see\n// https://github.com/ROCm-Developer-Tools/aomp/issues/51.\n//\n//===----------------------------------------------------------------------------------===//\n\n#include <cstdio>\n#include \"omp.h\"\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main()\n{\n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_SHARED_ENVIRONMENT;\n\n  int errors = 0;\n  int counts_atomic = 0;\n  int counts_reduction = 0;\n\n#pragma omp target teams map(from: counts_atomic)\n  {\n    int counts_team = 0;\n#pragma omp parallel\n    {\n#pragma omp for\n      for (int i = 0; i < N; ++i)\n#pragma omp atomic\n        counts_team += 1;\n    }\n    if (omp_get_team_num() == 0) {\n      counts_atomic = counts_team;\n    }\n  }\n\n#pragma omp target teams map(from: counts_reduction)\n  {\n    int counts_team = 0;\n#pragma omp parallel\n    {\n#pragma omp for reduction(+: counts_team)\n      for (int i = 0; i < N; ++i)\n        counts_team += 1;\n    }\n    if (omp_get_team_num() == 0) {\n      counts_reduction = counts_team;\n    }\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, counts_atomic != N);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, counts_reduction != N);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <iostream>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nint lbliiwhpev = 84;\nint feeuqcgzdo = 149;\ndouble exoqzvaaxg = 62;\ndouble ullsqwjvck = 107;\nint wdwvpjjsti = 186;\ndouble ikrbrdccyn = 168;\nlong nqxdorfaqa = 190;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    std::cout << \"Sum of \" << num1 << \" and \" << num2 << \" is \" << sum << std::endl;\n    return 0;\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_data_map_pointer_translation.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp parallel\" at position 960",
        "issue_id": 0,
        "original_code": "//===---- test_target_data_map_array_translation.c - pointer to already mapped array-===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// According to the OpenMP Specs, if a pointer is used in the mapping of a variable\n// and the pointer points to a host array that is already available in the device,\n// this pointer's address has to be updated with the device address. \n//\n// See page 105, lines 24 through 32.\n//\n// This test check these conditions are valid\n//\n//===----------------------------------------------------------------------===//\n\n#include \"ompvv.h\"\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 1000\n\nint test_map_same_function() {\n\n  OMPVV_INFOMSG(\"Testing map same function definition\")\n\n  int sum = 0, sum2 = 0, errors = 0;\n\n  // host arrays: heap and stack\n  int *h_array_h = (int *)malloc(N * sizeof(int));\n  int h_array_s[N];\n\n  // Pointers to be used for the translation\n  int *ptr_h_array_h;\n  int *ptr_h_array_s;\n\n#pragma omp target data map(h_array_h[0:N]) map(h_array_s[0:N])\n  {\n    // Multiple tests at once.\n\n    ptr_h_array_h = h_array_h;\n    ptr_h_array_s = h_array_s;\n\n    OMPVV_INFOMSG(\"map(ptr) specified full-length array section\")\n#pragma omp target map(ptr_h_array_h[0:N], ptr_h_array_s[0:N])\n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] = 1;\n        ptr_h_array_s[i] = 2;\n      }\n    } // end target\n\n    OMPVV_INFOMSG(\"map(ptr) specified zero-length array section\")\n#pragma omp target map(ptr_h_array_h[:0], ptr_h_array_s[:0])\n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] += 1;\n        ptr_h_array_s[i] += 2;\n      }\n    } // end target\n\n    OMPVV_INFOMSG(\"no map(ptr) Specified\")\n#pragma omp target \n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] += 1;\n        ptr_h_array_s[i] += 2;\n      }\n    } // end target\n\n  } // end target data\n\n  // checking results\n  for (int i = 0; i < N; ++i) {\n    sum += h_array_h[i];\n    sum2 += h_array_s[i];\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (3*N != sum) || (6*N != sum2));\n\n  free(h_array_h);\n  return errors;\n}\n\nvoid helper_function(int *ptr_h_array_h, int *ptr_h_array_s) {\n\n    OMPVV_INFOMSG(\"map(ptr) specified full-length array section\")\n#pragma omp target map(ptr_h_array_h[0:N], ptr_h_array_s[0:N])\n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] = 1;\n        ptr_h_array_s[i] = 2;\n      }\n    } // end target\n\n    OMPVV_INFOMSG(\"map(ptr) specified zero-length array section\")\n#pragma omp target map(ptr_h_array_h[:0], ptr_h_array_s[:0])\n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] += 1;\n        ptr_h_array_s[i] += 2;\n      }\n    } // end target\n\n    OMPVV_INFOMSG(\"no map(ptr) Specified\")\n#pragma omp target \n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] += 1;\n        ptr_h_array_s[i] += 2;\n      }\n    } // end target\n}\n\nint test_map_different_function() {\n\n  OMPVV_INFOMSG(\"Testing map different function definition\")\n\n  int sum = 0, sum2 = 0, errors = 0;\n\n  // host arrays: heap and stack\n  int *h_array_h = (int *)malloc(N * sizeof(int));\n  int h_array_s[N];\n\n#pragma omp target data map(h_array_h[0:N]) map(h_array_s[0:N])\n  {\n    // Multiple tests at once.\n    helper_function(h_array_h, h_array_s);\n\n  } // end target data\n\n  // checking results\n  for (int i = 0; i < N; ++i) {\n    sum += h_array_h[i];\n    sum2 += h_array_s[i];\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (3*N != sum) || (6*N != sum2));\n\n  free(h_array_h);\n  return errors;\n}\nint main() {\n  OMPVV_TEST_OFFLOADING\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_same_function());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_different_function());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_data_map_array_translation.c - pointer to already mapped array-===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// According to the OpenMP Specs, if a pointer is used in the mapping of a variable\n// and the pointer points to a host array that is already available in the device,\n// this pointer's address has to be updated with the device address. \n//\n// See page 105, lines 24 through 32.\n//\n// This test check these conditions are valid\n//\n//===----------------------------------------------------------------------===//\n\n#include \"ompvv.h\"\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 1000\n\nint test_map_same_function() {\n\n  OMPVV_INFOMSG(\"Testing map same function definition\")\n\n  int sum = 0, sum2 = 0, errors = 0;\n\n  // host arrays: heap and stack\n  int *h_array_h = (int *)malloc(N * sizeof(int));\n  int h_array_s[N];\n\n  // Pointers to be used for the translation\n  int *ptr_h_array_h;\n  int *ptr_h_array_s;\n\n#pragma omp parallel data map(h_array_h[0:N]) map(h_array_s[0:N])\n  {\n    // Multiple tests at once.\n\n    ptr_h_array_h = h_array_h;\n    ptr_h_array_s = h_array_s;\n\n    OMPVV_INFOMSG(\"map(ptr) specified full-length array section\")\n#pragma omp target map(ptr_h_array_h[0:N], ptr_h_array_s[0:N])\n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] = 1;\n        ptr_h_array_s[i] = 2;\n      }\n    } // end target\n\n    OMPVV_INFOMSG(\"map(ptr) specified zero-length array section\")\n#pragma omp target map(ptr_h_array_h[:0], ptr_h_array_s[:0])\n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] += 1;\n        ptr_h_array_s[i] += 2;\n      }\n    } // end target\n\n    OMPVV_INFOMSG(\"no map(ptr) Specified\")\n#pragma omp target \n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] += 1;\n        ptr_h_array_s[i] += 2;\n      }\n    } // end target\n\n  } // end target data\n\n  // checking results\n  for (int i = 0; i < N; ++i) {\n    sum += h_array_h[i];\n    sum2 += h_array_s[i];\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (3*N != sum) || (6*N != sum2));\n\n  free(h_array_h);\n  return errors;\n}\n\nvoid helper_function(int *ptr_h_array_h, int *ptr_h_array_s) {\n\n    OMPVV_INFOMSG(\"map(ptr) specified full-length array section\")\n#pragma omp target map(ptr_h_array_h[0:N], ptr_h_array_s[0:N])\n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] = 1;\n        ptr_h_array_s[i] = 2;\n      }\n    } // end target\n\n    OMPVV_INFOMSG(\"map(ptr) specified zero-length array section\")\n#pragma omp target map(ptr_h_array_h[:0], ptr_h_array_s[:0])\n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] += 1;\n        ptr_h_array_s[i] += 2;\n      }\n    } // end target\n\n    OMPVV_INFOMSG(\"no map(ptr) Specified\")\n#pragma omp target \n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] += 1;\n        ptr_h_array_s[i] += 2;\n      }\n    } // end target\n}\n\nint test_map_different_function() {\n\n  OMPVV_INFOMSG(\"Testing map different function definition\")\n\n  int sum = 0, sum2 = 0, errors = 0;\n\n  // host arrays: heap and stack\n  int *h_array_h = (int *)malloc(N * sizeof(int));\n  int h_array_s[N];\n\n#pragma omp target data map(h_array_h[0:N]) map(h_array_s[0:N])\n  {\n    // Multiple tests at once.\n    helper_function(h_array_h, h_array_s);\n\n  } // end target data\n\n  // checking results\n  for (int i = 0; i < N; ++i) {\n    sum += h_array_h[i];\n    sum2 += h_array_s[i];\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (3*N != sum) || (6*N != sum2));\n\n  free(h_array_h);\n  return errors;\n}\nint main() {\n  OMPVV_TEST_OFFLOADING\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_same_function());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_different_function());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_update_depend.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp flush\" at position 1112",
        "issue_id": 0,
        "original_code": "//===--- test_target_update_depend.c ----------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This is a test of the target update construct with the depend clause.\n// The test_async_between_hosts_tasks() functions additionatly tests if\n// the target enter data and exit data constructs work properly with the\n// depend clause. Bits are used for each task in order to determine where\n// failure occurs. \n//\n////===----------------------------------------------------------------------===//\n\n\n\n\n\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include \"ompvv.h\"\n\n#define N 1000\n#define HOST_TASK1_BIT 0x1\n#define HOST_TASK2_BIT 0x2\n#define DEVICE_TASK1_BIT 0x4\n#define HOST_TASK3_BIT 0x8\n#define ALL_TASKS_BITS 0xF\n\nint test_async_between_hosts_tasks() {\n  OMPVV_INFOMSG(\"test_async_between_hosts_tasks\");\n\n  int errors = 0;\n  bool isHost = true;\n  int sum = 0.0;\n  int* h_array = (int *) malloc(N * sizeof(int));\n  int* in_1 = (int *) malloc(N * sizeof(int));\n  int* in_2 = (int *) malloc(N * sizeof(int));\n\n\n// We allocate the arrays in the device\n#pragma omp target enter data map(alloc: h_array[0:N], in_1[0:N], in_2[0:N]) depend(out: h_array, in_1, in_2)\n\n  // host task 1\n#pragma omp task depend(out: in_1) shared(in_1)\n  {\n    for (int i = 0; i < N; ++i) {\n      in_1[i] = HOST_TASK1_BIT; // 0b01\n    }\n  }\n\n  // host task 2\n#pragma omp task depend(out: in_2) shared(in_2)\n  {\n    for (int i = 0; i < N; ++i) {\n      in_2[i] = HOST_TASK2_BIT; // 0b10\n    }\n  }\n\n // Testing the update to\n#pragma omp target update depend(in: in_1, in_2) depend(out: in_1, in_2) to(in_1[0:N], in_2[0:N])\n\n\n  // Device task waiting for update\n#pragma omp task shared (isHost, h_array, in_1, in_2) depend(inout: h_array) depend(in: in_1) depend(in: in_2)\n  {\n#pragma omp target map(tofrom: isHost) map(alloc: in_1[0:N]) map(alloc: in_2[0:N]) map(alloc: h_array[0:N])\n    {\n      isHost = omp_is_initial_device();\n      for (int i = 0; i < N; ++i) {\n        h_array[i] = DEVICE_TASK1_BIT | in_1[i] | in_2[i]; // Expected = 0b111\n      }\n    }\n  }\n \n // Testing the update from \n#pragma omp target update depend(inout: h_array) from(h_array[0:N])\n\n  // host task 3\n#pragma omp task depend(in: h_array) shared(sum, h_array)\n  {\n    // checking results\n    for (int i = 0; i < N; ++i) {\n      // Identify which task was problematic\n      h_array[i] |= HOST_TASK3_BIT;\n      sum += (h_array[i] & ALL_TASKS_BITS); // AND with 0b111 should produce sum\n    }\n  }\n#pragma omp taskwait\n\n  // Garbage collection\n#pragma omp target exit data map(delete: h_array[0:N], in_1[0:N], in_2[0:N])\n\n  // We verify all the tasks without a task\n  int h_task1 = 0;\n  int h_task2 = 0;\n  int h_task3 = 0;\n  int d_task1 = 0;\n  for (int i = 0; i < N; ++i) {\n    h_task1 |= !(h_array[i] & HOST_TASK1_BIT);\n    h_task2 |= !(h_array[i] & HOST_TASK2_BIT);\n    h_task3 |= !(h_array[i] & HOST_TASK3_BIT);\n    d_task1 |= !(h_array[i] & DEVICE_TASK1_BIT);\n  }\n  OMPVV_ERROR_IF(h_task1 != 0, \"Error in host task 1\");\n  OMPVV_ERROR_IF(h_task2 != 0, \"Error in host task 2\");\n  OMPVV_ERROR_IF(h_task3 != 0, \"Error in host task 3\");\n  OMPVV_ERROR_IF(d_task1 != 0, \"Error in device task 1\");\n\n  OMPVV_TEST_AND_SET(errors, (N * ALL_TASKS_BITS != sum));\n  OMPVV_INFOMSG(\"Test test_async_between_task_target ran on the %s\", (isHost ? \"host\" : \"device\"));\n \n  free(h_array);\n  free(in_1);\n  free(in_2);\n\n  return errors;\n}\n\n/*\n * Test if it is possible to:\n * 3. use nowait for async\n */\nint test_async_between_host_and_device() {\n  OMPVV_INFOMSG(\"test_async_between_host_and_device\");\n  \n  int errors = 0;\n  bool isHost = true;\n  int sum = 0.0;\n  int* h_array = (int *) malloc(N * sizeof(int));\n  int* in_1 = (int *) malloc(N * sizeof(int));\n  int* in_2 = (int *) malloc(N * sizeof(int));\n\n\n// We allocate the arrays in the device\n#pragma omp target enter data map(alloc: h_array[0:N], in_1[0:N], in_2[0:N]) depend(out: h_array, in_1, in_2)\n\n  // host task 1\n#pragma omp task depend(out: in_1) shared(in_1)\n  {\n    for (int i = 0; i < N; ++i) {\n      in_1[i] = HOST_TASK1_BIT; // 0b01\n    }\n  }\n\n  // host task 2\n#pragma omp task depend(out: in_2) shared(in_2)\n  {\n    for (int i = 0; i < N; ++i) {\n      in_2[i] = HOST_TASK2_BIT; // 0b10\n    }\n  }\n\n // Testing the update to\n#pragma omp target update depend(inout: in_1, in_2) to(in_1[0:N], in_2[0:N])\n\n\n  // Device task waiting for update\n#pragma omp target depend(inout: h_array) depend(in: in_1) depend(in: in_2) \\\n    map(tofrom: isHost) map(alloc: in_1[0:N]) map(alloc: in_2[0:N]) map(alloc: h_array[0:N])\n  {\n    isHost = omp_is_initial_device();\n    for (int i = 0; i < N; ++i) {\n      h_array[i] = DEVICE_TASK1_BIT | in_1[i] | in_2[i]; // Expected = 0b111\n    }\n  }\n \n // Testing the update from \n#pragma omp target update depend(inout: h_array) from(h_array[0:N])\n\n  // host task 3\n#pragma omp task depend(in: h_array) shared(sum, h_array)\n  {\n    // checking results\n    for (int i = 0; i < N; ++i) {\n      // Identify which task was problematic\n      h_array[i] |= HOST_TASK3_BIT;\n      sum += (h_array[i] & ALL_TASKS_BITS); // AND with 0b111 should produce sum\n    }\n  }\n#pragma omp taskwait\n\n  // Garbage collection\n#pragma omp target exit data map(delete: h_array[0:N], in_1[0:N], in_2[0:N])\n\n  // We verify all the tasks without a task\n  int h_task1 = 0;\n  int h_task2 = 0;\n  int h_task3 = 0;\n  int d_task1 = 0;\n  for (int i = 0; i < N; ++i) {\n    h_task1 |= !(h_array[i] & HOST_TASK1_BIT);\n    h_task2 |= !(h_array[i] & HOST_TASK2_BIT);\n    h_task3 |= !(h_array[i] & HOST_TASK3_BIT);\n    d_task1 |= !(h_array[i] & DEVICE_TASK1_BIT);\n  }\n  OMPVV_ERROR_IF(h_task1 != 0, \"Error in host task 1\");\n  OMPVV_ERROR_IF(h_task2 != 0, \"Error in host task 2\");\n  OMPVV_ERROR_IF(h_task3 != 0, \"Error in host task 3\");\n  OMPVV_ERROR_IF(d_task1 != 0, \"Error in device task 1\");\n\n  OMPVV_TEST_AND_SET(errors, (N * ALL_TASKS_BITS != sum));\n  OMPVV_INFOMSG(\"Test test_async_between_task_target ran on the %s\", (isHost ? \"host\" : \"device\"));\n \n  free(h_array);\n  free(in_1);\n  free(in_2);\n\n  return errors;\n}\n\nint main(){\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET(errors, test_async_between_hosts_tasks());\n  OMPVV_TEST_AND_SET(errors, test_async_between_host_and_device());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_update_depend.c ----------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This is a test of the target update construct with the depend clause.\n// The test_async_between_hosts_tasks() functions additionatly tests if\n// the target enter data and exit data constructs work properly with the\n// depend clause. Bits are used for each task in order to determine where\n// failure occurs. \n//\n////===----------------------------------------------------------------------===//\n\n\n\n\n\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include \"ompvv.h\"\n\n#define N 1000\n#define HOST_TASK1_BIT 0x1\n#define HOST_TASK2_BIT 0x2\n#define DEVICE_TASK1_BIT 0x4\n#define HOST_TASK3_BIT 0x8\n#define ALL_TASKS_BITS 0xF\n\nint test_async_between_hosts_tasks() {\n  OMPVV_INFOMSG(\"test_async_between_hosts_tasks\");\n\n  int errors = 0;\n  bool isHost = true;\n  int sum = 0.0;\n  int* h_array = (int *) malloc(N * sizeof(int));\n  int* in_1 = (int *) malloc(N * sizeof(int));\n  int* in_2 = (int *) malloc(N * sizeof(int));\n\n\n// We allocate the arrays in the device\n#pragma omp flush enter data map(alloc: h_array[0:N], in_1[0:N], in_2[0:N]) depend(out: h_array, in_1, in_2)\n\n  // host task 1\n#pragma omp task depend(out: in_1) shared(in_1)\n  {\n    for (int i = 0; i < N; ++i) {\n      in_1[i] = HOST_TASK1_BIT; // 0b01\n    }\n  }\n\n  // host task 2\n#pragma omp task depend(out: in_2) shared(in_2)\n  {\n    for (int i = 0; i < N; ++i) {\n      in_2[i] = HOST_TASK2_BIT; // 0b10\n    }\n  }\n\n // Testing the update to\n#pragma omp target update depend(in: in_1, in_2) depend(out: in_1, in_2) to(in_1[0:N], in_2[0:N])\n\n\n  // Device task waiting for update\n#pragma omp task shared (isHost, h_array, in_1, in_2) depend(inout: h_array) depend(in: in_1) depend(in: in_2)\n  {\n#pragma omp target map(tofrom: isHost) map(alloc: in_1[0:N]) map(alloc: in_2[0:N]) map(alloc: h_array[0:N])\n    {\n      isHost = omp_is_initial_device();\n      for (int i = 0; i < N; ++i) {\n        h_array[i] = DEVICE_TASK1_BIT | in_1[i] | in_2[i]; // Expected = 0b111\n      }\n    }\n  }\n \n // Testing the update from \n#pragma omp target update depend(inout: h_array) from(h_array[0:N])\n\n  // host task 3\n#pragma omp task depend(in: h_array) shared(sum, h_array)\n  {\n    // checking results\n    for (int i = 0; i < N; ++i) {\n      // Identify which task was problematic\n      h_array[i] |= HOST_TASK3_BIT;\n      sum += (h_array[i] & ALL_TASKS_BITS); // AND with 0b111 should produce sum\n    }\n  }\n#pragma omp taskwait\n\n  // Garbage collection\n#pragma omp target exit data map(delete: h_array[0:N], in_1[0:N], in_2[0:N])\n\n  // We verify all the tasks without a task\n  int h_task1 = 0;\n  int h_task2 = 0;\n  int h_task3 = 0;\n  int d_task1 = 0;\n  for (int i = 0; i < N; ++i) {\n    h_task1 |= !(h_array[i] & HOST_TASK1_BIT);\n    h_task2 |= !(h_array[i] & HOST_TASK2_BIT);\n    h_task3 |= !(h_array[i] & HOST_TASK3_BIT);\n    d_task1 |= !(h_array[i] & DEVICE_TASK1_BIT);\n  }\n  OMPVV_ERROR_IF(h_task1 != 0, \"Error in host task 1\");\n  OMPVV_ERROR_IF(h_task2 != 0, \"Error in host task 2\");\n  OMPVV_ERROR_IF(h_task3 != 0, \"Error in host task 3\");\n  OMPVV_ERROR_IF(d_task1 != 0, \"Error in device task 1\");\n\n  OMPVV_TEST_AND_SET(errors, (N * ALL_TASKS_BITS != sum));\n  OMPVV_INFOMSG(\"Test test_async_between_task_target ran on the %s\", (isHost ? \"host\" : \"device\"));\n \n  free(h_array);\n  free(in_1);\n  free(in_2);\n\n  return errors;\n}\n\n/*\n * Test if it is possible to:\n * 3. use nowait for async\n */\nint test_async_between_host_and_device() {\n  OMPVV_INFOMSG(\"test_async_between_host_and_device\");\n  \n  int errors = 0;\n  bool isHost = true;\n  int sum = 0.0;\n  int* h_array = (int *) malloc(N * sizeof(int));\n  int* in_1 = (int *) malloc(N * sizeof(int));\n  int* in_2 = (int *) malloc(N * sizeof(int));\n\n\n// We allocate the arrays in the device\n#pragma omp target enter data map(alloc: h_array[0:N], in_1[0:N], in_2[0:N]) depend(out: h_array, in_1, in_2)\n\n  // host task 1\n#pragma omp task depend(out: in_1) shared(in_1)\n  {\n    for (int i = 0; i < N; ++i) {\n      in_1[i] = HOST_TASK1_BIT; // 0b01\n    }\n  }\n\n  // host task 2\n#pragma omp task depend(out: in_2) shared(in_2)\n  {\n    for (int i = 0; i < N; ++i) {\n      in_2[i] = HOST_TASK2_BIT; // 0b10\n    }\n  }\n\n // Testing the update to\n#pragma omp target update depend(inout: in_1, in_2) to(in_1[0:N], in_2[0:N])\n\n\n  // Device task waiting for update\n#pragma omp target depend(inout: h_array) depend(in: in_1) depend(in: in_2) \\\n    map(tofrom: isHost) map(alloc: in_1[0:N]) map(alloc: in_2[0:N]) map(alloc: h_array[0:N])\n  {\n    isHost = omp_is_initial_device();\n    for (int i = 0; i < N; ++i) {\n      h_array[i] = DEVICE_TASK1_BIT | in_1[i] | in_2[i]; // Expected = 0b111\n    }\n  }\n \n // Testing the update from \n#pragma omp target update depend(inout: h_array) from(h_array[0:N])\n\n  // host task 3\n#pragma omp task depend(in: h_array) shared(sum, h_array)\n  {\n    // checking results\n    for (int i = 0; i < N; ++i) {\n      // Identify which task was problematic\n      h_array[i] |= HOST_TASK3_BIT;\n      sum += (h_array[i] & ALL_TASKS_BITS); // AND with 0b111 should produce sum\n    }\n  }\n#pragma omp taskwait\n\n  // Garbage collection\n#pragma omp target exit data map(delete: h_array[0:N], in_1[0:N], in_2[0:N])\n\n  // We verify all the tasks without a task\n  int h_task1 = 0;\n  int h_task2 = 0;\n  int h_task3 = 0;\n  int d_task1 = 0;\n  for (int i = 0; i < N; ++i) {\n    h_task1 |= !(h_array[i] & HOST_TASK1_BIT);\n    h_task2 |= !(h_array[i] & HOST_TASK2_BIT);\n    h_task3 |= !(h_array[i] & HOST_TASK3_BIT);\n    d_task1 |= !(h_array[i] & DEVICE_TASK1_BIT);\n  }\n  OMPVV_ERROR_IF(h_task1 != 0, \"Error in host task 1\");\n  OMPVV_ERROR_IF(h_task2 != 0, \"Error in host task 2\");\n  OMPVV_ERROR_IF(h_task3 != 0, \"Error in host task 3\");\n  OMPVV_ERROR_IF(d_task1 != 0, \"Error in device task 1\");\n\n  OMPVV_TEST_AND_SET(errors, (N * ALL_TASKS_BITS != sum));\n  OMPVV_INFOMSG(\"Test test_async_between_task_target ran on the %s\", (isHost ? \"host\" : \"device\"));\n \n  free(h_array);\n  free(in_1);\n  free(in_2);\n\n  return errors;\n}\n\nint main(){\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET(errors, test_async_between_hosts_tasks());\n  OMPVV_TEST_AND_SET(errors, test_async_between_host_and_device());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_map_pointer_no_map_type_modifier.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp map\" at position 1035",
        "issue_id": 0,
        "original_code": "//===--- test_target_map_pointer_no_map_type_modifier.c -----------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// When map-type-modifier (e.g. to, from and tofrom) are not specified, the \n// default behavior should be tofrom. This test checks if this is the case by\n// creating an array and a pointer to the array. The array and pointer are mapped\n// to the device. The mapped pointer should point to the device array when used\n// inside the omp target region. The array is then changed through the pointer.\n// Array is mapped as tofrom, while pointer is mapped with default value.  \n// \n////===------------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\n// Test that maptype of non-scalar pointer in map clause defaults to tofrom \nint test_default_tofrom() {\n  int compute_array[N];\n  int *p;\t\n  int sum = 0, result = 0, errors = 0;\n  int i;\n \n  for (i = 0; i < N; i++) \n    compute_array[i] = 0;\n  \n  p = &compute_array[0];\n\n#pragma omp target map(p[0:N])\n  {\n    for (i = 0; i < N; i++)\n      p[i] = i;\n  } // end target\n\n  for (i = 0; i < N; i++)\n    sum = sum + compute_array[i];    \n\n  for (i = 0; i < N; i++)\n    result += i;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != sum);\n  \n  return errors; \n}\n\nint main() {\n  int errors = 0;\n    \n  int isOffloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_default_tofrom());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_map_pointer_no_map_type_modifier.c -----------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// When map-type-modifier (e.g. to, from and tofrom) are not specified, the \n// default behavior should be tofrom. This test checks if this is the case by\n// creating an array and a pointer to the array. The array and pointer are mapped\n// to the device. The mapped pointer should point to the device array when used\n// inside the omp target region. The array is then changed through the pointer.\n// Array is mapped as tofrom, while pointer is mapped with default value.  \n// \n////===------------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\n// Test that maptype of non-scalar pointer in map clause defaults to tofrom \nint test_default_tofrom() {\n  int compute_array[N];\n  int *p;\t\n  int sum = 0, result = 0, errors = 0;\n  int i;\n \n  for (i = 0; i < N; i++) \n    compute_array[i] = 0;\n  \n  p = &compute_array[0];\n\n#pragma omp map map(p[0:N])\n  {\n    for (i = 0; i < N; i++)\n      p[i] = i;\n  } // end target\n\n  for (i = 0; i < N; i++)\n    sum = sum + compute_array[i];    \n\n  for (i = 0; i < N; i++)\n    result += i;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != sum);\n  \n  return errors; \n}\n\nint main() {\n  int errors = 0;\n    \n  int isOffloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_default_tofrom());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_map_scalar_no_map_type_modifier.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1454",
        "issue_id": 1,
        "original_code": "//===--- test_target_map_scalar_no_map_type_modifier.c ----------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// When map-type-modifier (e.g. to, from and tofrom) is not specified, the \n// default behavior should be tofrom. This test checks if this is satisfied with\n// a simple integer value. An array is created an initialized to zero in the host\n// then changed in the device with a scalar value. An additional simple test \n// function also checks from behavior by changing scalar value on device.\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\" \n\n#define N 1000\n\nint test_scalar_to() {\n\n  int compute_array[N];\n  int asclr = 12, sum = 0, result = 0, errors = 0;\n  int i;\n\n  // Array initialization\n  for (i = 0; i < N; i++) \n    compute_array[i] = 0;\n\n#pragma omp target map(from: compute_array) map(asclr)\n  {\n  for (i = 0; i < N; i++)\n    compute_array[i] = i + asclr;\n \n  } // end target\n\n  for (i = 0; i < N; i++)\n    sum = sum + compute_array[i];    \n  \n  for (i = 0; i < N; i++)\n    result += i + asclr;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result!= sum);  \n\n  return errors;\n}\n\nint test_scalar_from() {\n\n  int new_scalar = 25;\n  int errors = 0;\n\n#pragma omp target map(new_scalar)\n  {\n  //Change scalar value on device\n  new_scalar = 27;\n\n  }\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, new_scalar!=27);\n  \n  return errors;\t\n}\n\nint main() {\n  \n  int errors = 0;\n\n  //Test Offloading\n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n  OMPVV_WARNING_IF(!is_offloading, \"This test in running on host, asclr is not copied over to the device\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_scalar_to());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_scalar_from());  \n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_map_scalar_no_map_type_modifier.c ----------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// When map-type-modifier (e.g. to, from and tofrom) is not specified, the \n// default behavior should be tofrom. This test checks if this is satisfied with\n// a simple integer value. An array is created an initialized to zero in the host\n// then changed in the device with a scalar value. An additional simple test \n// function also checks from behavior by changing scalar value on device.\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\" \n\n#define N 1000\n\nint test_scalar_to() {\n\n  int compute_array[N];\n  int asclr = 12, sum = 0, result = 0, errors = 0;\n  int i;\n\n  // Array initialization\n  for (i = 0; i < N; i++) \n    compute_array[i] = 0;\n\n#pragma omp target map(from: compute_array) map(asclr)\n  {\n  for (i = 0; i < N; i++)\n    compute_array[i] = i + asclr;\n \n  } // end target\n\n  for (i = 0; i < N; i++)\n    sum = sum + compute_array[i];    \n  \n  for (i = 0; i < N; i++)\n    result += i + asclr;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result!= sum);  \n\n  return errors;\n}\n\nint test_scalar_from() {\n\n  int new_scalar = 25;\n  int errors = 0;\n\n#pragma omp target map(new_scalar)\n  {\n  //Change scalar value on device\n  new_scalar = 27;\n\n  }\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, new_scalar!=27);\n  \n  return errors;\t\n}\n\nint main() \n  \n  int errors = 0;\n\n  //Test Offloading\n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n  OMPVV_WARNING_IF(!is_offloading, \"This test in running on host, asclr is not copied over to the device\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_scalar_to());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_scalar_from());  \n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/mmm_target_parallel_for_simd.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 1496",
        "issue_id": 2,
        "original_code": "//===--- mmm_target_parallel_for_simd.c--- MM on a target parallel for simd--===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n//  DESCRIPTION:  \n//    OpenMp Example - Matrix Multiply - C Version\n//    Demonstrates a matrix multiply using OpenMP. Threads share row iterations\n//  \n//  Last modified by Jose M Monsalve Diaz, December 25, 2019\n//\n////===----------------------------------------------------------------------===//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/time.h>\n#include \"ompvv.h\"\n\n#define rowA 500        \n#define colA 500        \n#define colB 500        \n\n\nint main (int argc, char *argv[]) \n{\n  OMPVV_TEST_OFFLOADING;\n  int tid, nthreads, i, j, k;\n  int\t*a = (int*) malloc(sizeof(int) * rowA * colA);           // matrix A to be multiplied\n  int\t*b = (int*) malloc(sizeof(int) * colA * colB);           // matrix B to be multiplied \n  int\t*c = (int*) malloc(sizeof(int) * rowA * colB);           // result matrix C \n\n  // Initialize matrices\n  for (i = 0; i < rowA; i++)\n    for (j = 0; j < colA; j++)\n      a[i*rowA+j] = 10; // i+j;\n  for (i = 0; i < colA; i++)\n    for (j = 0; j < colB; j++)\n      b[i*colA+j] = 50; //i*j;\n  for (i = 0; i < rowA; i++)\n    for (j = 0; j < colB; j++)\n      c[i*rowA+j] = 0;\n\n  int DimA = rowA*colA;\n  int DimB = colB*colA;\n  int DimC = rowA*colA;\n\n#pragma omp target map(to: a[0:DimA], b[0:DimB]) map(from: c[0:DimC])\n  {\n#pragma omp teams distribute parallel for simd collapse(2) private(k)\n    for (i = 0; i < rowA; i++)\n      for(j = 0; j < colB; j++)\n        for(k = 0; k < colA; k++)\n          c[i*rowA+j] = a[i*rowA+j] * b[k*colA+j];\n  }//end-target\n\n  // Check results\n  int error = 0;\n  for (i = 0; i < rowA; i++)\n  {\n    for (j = 0; j < colB; j++) {\n      OMPVV_TEST_AND_SET(error, 500 != c[i*rowA+j]);\n      OMPVV_ERROR_IF(500 != c[i*rowA+j], \"Error: [%d][%d] should be 500 is %d\",i,j,c[i*rowA+j]);\n    }\n  }\n  free(a);\n  free(b);\n  free(c);\n\n  OMPVV_REPORT_AND_RETURN(error);\n}\n\n",
        "error_code": "//===--- mmm_target_parallel_for_simd.c--- MM on a target parallel for simd--===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n//  DESCRIPTION:  \n//    OpenMp Example - Matrix Multiply - C Version\n//    Demonstrates a matrix multiply using OpenMP. Threads share row iterations\n//  \n//  Last modified by Jose M Monsalve Diaz, December 25, 2019\n//\n////===----------------------------------------------------------------------===//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/time.h>\n#include \"ompvv.h\"\n\n#define rowA 500        \n#define colA 500        \n#define colB 500        \n\n\nint main (int argc, char *argv[]) \n{\n  OMPVV_TEST_OFFLOADING;\n  int tid, nthreads, i, j, k;\n  int\t*a = (int*) malloc(sizeof(int) * rowA * colA);           // matrix A to be multiplied\n  int\t*b = (int*) malloc(sizeof(int) * colA * colB);           // matrix B to be multiplied \n  int\t*c = (int*) malloc(sizeof(int) * rowA * colB);           // result matrix C \n\n  // Initialize matrices\n  for (i = 0; i < rowA; i++)\n    for (j = 0; j < colA; j++)\n      a[i*rowA+j] = 10; // i+j;\n  for (i = 0; i < colA; i++)\n    for (j = 0; j < colB; j++)\n      b[i*colA+j] = 50; //i*j;\n  for (i = 0; i < rowA; i++)\n    for (j = 0; j < colB; j++)\n      c[i*rowA+j] = 0;\n\n  int DimA = rowA*colA;\n  int DimB = colB*colA;\n  int DimC = rowA*colA;\n\n#pragma omp target map(to: a[0:DimA], b[0:DimB]) map(from: c[0:DimC])\n  {\n#pragma omp teams distribute parallel for simd collapse(2) private(k)\n    for (i = 0; i < rowA;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1; i++)\n      for(j = 0; j < colB; j++)\n        for(k = 0; k < colA; k++)\n          c[i*rowA+j] = a[i*rowA+j] * b[k*colA+j];\n  }//end-target\n\n  // Check results\n  int error = 0;\n  for (i = 0; i < rowA; i++)\n  {\n    for (j = 0; j < colB; j++) {\n      OMPVV_TEST_AND_SET(error, 500 != c[i*rowA+j]);\n      OMPVV_ERROR_IF(500 != c[i*rowA+j], \"Error: [%d][%d] should be 500 is %d\",i,j,c[i*rowA+j]);\n    }\n  }\n  free(a);\n  free(b);\n  free(c);\n\n  OMPVV_REPORT_AND_RETURN(error);\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_parallel_for_dist_schedule.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===-test_target_teams_distribute_parallel_for_dist_schedule.c-===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// testing the combined construct target teams distribute parallel for\n// This test will check if dist_schedule(static, 4) taking effect\n//\n//===---------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\nint arr[32] = {0};\nint chunked = 1;\n\nint Dist_ScheduleStatic() {\n  int ErrCount = 0;\nint num_teams, num_threads;\n\n#pragma omp target teams distribute parallel for num_teams(2)\\\n        thread_limit(4)  map(tofrom: num_teams, num_threads)\\\n        dist_schedule(static, 4)\n  for (int i = 0; i < 32; ++i) {\n    if(omp_get_team_num()==0 && omp_get_thread_num() == 0){\n      num_teams = omp_get_num_teams();\n      num_threads = omp_get_num_threads();\n    }\n    arr[i] = omp_get_team_num();\n  }\n\n  if ((num_teams > OMPVV_NUM_TEAMS_DEVICE) || (num_threads > OMPVV_NUM_THREADS_DEVICE)) {\n    ErrCount += 1;\n  }\n  if(num_teams == 1){\n    OMPVV_WARNING(\"Only 1 team was created, the feature cannot be tested.\");\n    return ErrCount;\n  }\n  \n  for(int i=0; i<32; i+=4){\n    int temp = arr[i];\n    for(int j=1; j< 4;j++)\n      if(arr[i+j] != temp){\n        chunked = 0;\n        break;\n      }\n    if(chunked == 0) {\n      ErrCount++;\n      OMPVV_WARNING(\"The given iterations were not scheduled according to the static chunks requested\");\n      break;\n    }\n  }\n\n  return ErrCount;\n}\n\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, Dist_ScheduleStatic() != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nbyte xcibdimyxg = 195;\ndouble khgfuanumu = 230;\ndouble ambmtczriv = 42;\nfloat zjtigwegkl = 45;\nlong zhqrekfxaf = 4;\nlong lunzeylkcf = 178;\nbyte aeseberhwv = 209;\ndouble khaqnrsrxz = 43;\nbyte jxrejihbmm = 93;\nfloat lalafrhmsk = 105;\nlong lzckrgqruk = 141;\nlong nytmrxtcur = 118;\nlong jjqnjsskqq = 89;\nshort clmzeenyhm = 218;\nlong eiiezxngej = 211;\nint xidpbfttfk = 18;\nfloat svrdiaroro = 196;\nlong apufabtgdk = 228;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_parallel_for_devices.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp teams\" at position 1066",
        "issue_id": 0,
        "original_code": "//===---- test_target_teams_distribute_parallel_for_devices.c - combined consutrct -===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// Testing for multiple devices checking if it is possible to send work and data \n// to different devices with the device clause used with omp target teams distribute \n// parallel for \n//\n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define SIZE_N 1024\n\nint test_target_teams_distribute_parallel_for_devices() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_devices\");\n  \n  int num_dev = omp_get_num_devices();\n  int a[SIZE_N];\n  // Allocate num_devices + 1 to avoid zero-sized VLA if num_devices == 0\n  int isHost[num_dev+1];\n  int errors = 0;\n  int i, dev;\n\n  OMPVV_WARNING_IF(num_dev <= 1, \"Testing devices clause without multiple devices\");\n  \n  OMPVV_INFOMSG(\"Num of devices = %d\", num_dev);\n\n  // a array initialization\n  for (i = 0; i < SIZE_N; i++) {\n    a[i] = 1;\n  }\n\n  for (dev = 0; dev < num_dev; ++dev) {\n#pragma omp target enter data map(to: a[0:SIZE_N]) device(dev)\n  }\n\n  for (dev = 0; dev < num_dev; ++dev) {\n    // check multiple devices \n#pragma omp target teams distribute parallel for device(dev) map(tofrom: isHost)\n    for (i = 0; i < SIZE_N; i++) {\n      if (omp_get_team_num() == 0 && omp_get_thread_num() == 0) {\n        isHost[dev] = omp_is_initial_device();// Checking if running on a device\n      }\n      a[i] += dev;\n    }\n  }\n\n  for (dev = 0; dev < num_dev; ++dev) {\n#pragma omp target exit data map(from: a[0:SIZE_N]) device(dev)\n    OMPVV_INFOMSG(\"Device %d ran on the %s\", dev, isHost[dev] ? \"host\" : \"device\");\n    OMPVV_TEST_AND_SET(errors, isHost[dev] && dev != omp_get_initial_device());\n    for (i = 0; i < SIZE_N; i++) {\n      OMPVV_TEST_AND_SET(errors, a[i] != 1 + dev);\n    }\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_devices());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_teams_distribute_parallel_for_devices.c - combined consutrct -===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// Testing for multiple devices checking if it is possible to send work and data \n// to different devices with the device clause used with omp target teams distribute \n// parallel for \n//\n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define SIZE_N 1024\n\nint test_target_teams_distribute_parallel_for_devices() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_devices\");\n  \n  int num_dev = omp_get_num_devices();\n  int a[SIZE_N];\n  // Allocate num_devices + 1 to avoid zero-sized VLA if num_devices == 0\n  int isHost[num_dev+1];\n  int errors = 0;\n  int i, dev;\n\n  OMPVV_WARNING_IF(num_dev <= 1, \"Testing devices clause without multiple devices\");\n  \n  OMPVV_INFOMSG(\"Num of devices = %d\", num_dev);\n\n  // a array initialization\n  for (i = 0; i < SIZE_N; i++) {\n    a[i] = 1;\n  }\n\n  for (dev = 0; dev < num_dev; ++dev) {\n#pragma omp teams enter data map(to: a[0:SIZE_N]) device(dev)\n  }\n\n  for (dev = 0; dev < num_dev; ++dev) {\n    // check multiple devices \n#pragma omp target teams distribute parallel for device(dev) map(tofrom: isHost)\n    for (i = 0; i < SIZE_N; i++) {\n      if (omp_get_team_num() == 0 && omp_get_thread_num() == 0) {\n        isHost[dev] = omp_is_initial_device();// Checking if running on a device\n      }\n      a[i] += dev;\n    }\n  }\n\n  for (dev = 0; dev < num_dev; ++dev) {\n#pragma omp target exit data map(from: a[0:SIZE_N]) device(dev)\n    OMPVV_INFOMSG(\"Device %d ran on the %s\", dev, isHost[dev] ? \"host\" : \"device\");\n    OMPVV_TEST_AND_SET(errors, isHost[dev] && dev != omp_get_initial_device());\n    for (i = 0; i < SIZE_N; i++) {\n      OMPVV_TEST_AND_SET(errors, a[i] != 1 + dev);\n    }\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_devices());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_reduction_min.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_min() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\" at position 1761",
        "issue_id": 4,
        "original_code": "//===--- test_target_teams_distribute_reduction_min.c----------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the reduction clause on a target teams distribute directive,\n// testing that the variable in the reduction clause is properly reduced using\n// the min operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_min() {\n  int a[N];\n  int b[N];\n  int errors = 0;\n  int num_teams[N];\n  srand(1);\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = (int) rand() / (double) (RAND_MAX / 100);\n    b[x] = (int) rand() / (double) (RAND_MAX / 100);\n    num_teams[x] = -x;\n  }\n\n  int result = a[0] + b[0];\n\n#pragma omp target teams distribute reduction(min:result) defaultmap(tofrom:scalar)\n  for (int x = 0; x < N; ++x) {\n    num_teams[x] = omp_get_num_teams();\n    result = fmin(result, a[x] + b[x]);\n  }\n\n  int host_min = a[0] + b[0];\n\n  for (int x = 0; x < N; ++x) {\n    host_min = fmin(host_min, a[x] + b[x]);\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_teams[x - 1] != num_teams[x], \"Kernel reported differing numbers of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_teams[0] == 1, \"Test operated with one team.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_teams[0] <= 0, \"Test reported invalid number of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, host_min != result);\n  OMPVV_ERROR_IF(host_min != result, \"Min on device is %d but expected min from host is %d.\", result, host_min);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_min() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_reduction_min.c----------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the reduction clause on a target teams distribute directive,\n// testing that the variable in the reduction clause is properly reduced using\n// the min operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_min() {\n  int a[N];\n  int b[N];\n  int errors = 0;\n  int num_teams[N];\n  srand(1);\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = (int) rand() / (double) (RAND_MAX / 100);\n    b[x] = (int) rand() / (double) (RAND_MAX / 100);\n    num_teams[x] = -x;\n  }\n\n  int result = a[0] + b[0];\n\n#pragma omp target teams distribute reduction(min:result) defaultmap(tofrom:scalar)\n  for (int x = 0; x < N; ++x) {\n    num_teams[x] = omp_get_num_teams();\n    result = fmin(result, a[x] + b[x]);\n  }\n\n  int host_min = a[0] + b[0];\n\n  for (int x = 0; x < N; ++x) {\n    host_min = fmin(host_min, a[x] + b[x]);\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_teams[x - 1] != num_teams[x], \"Kernel reported differing numbers of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_teams[0] == 1, \"Test operated with one team.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_teams[0] <= 0, \"Test reported invalid number of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, host_min != result);\n  OMPVV_ERROR_IF(host_min != result, \"Min on device is %d but expected min from host is %d.\", result, host_min);\n\n  return errors;\n}\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_enter_data_malloced_array.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1762",
        "issue_id": 1,
        "original_code": "//===---- test_target_enter_data_malloced_array.c -------------------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// Tests for target enter data with heap allocated arrays. The test begins by creating\n// a pointer to a block of memory that is of size n*sizeof(int) and is allocated using malloc(). \n// A check is made to ensure that the pointer is not null, variable x is set equal to the dereferenced \n// pointer and is filled with int value 10. Global array B[10] is filled with int value 0. \n// The values of x[n] are mapped onto the device using enter data map, and values in array B[10]\n// are set equal to values of x[n] to ensure that values of x[n] were properly mapped to device.\n// Back on the host, a final check is made to confirm values of array B[10] are all integer 10.\n// \n//===----------------------------------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n\n// global variables\nint n=10, B[10];\nint *x;\n\n\nvoid init(int **A) {\n  int i;\n  *A = (int *) malloc(n*sizeof(int));\n  if (NULL == *A){ \n    OMPVV_ERROR(\"This Test Has Failed, disregard other messages, array A is not properly allocated\");\n    exit(-1);\n  }\n  x = *A;\n  for (i = 0; i < n; i++){\n    x[i] = 10;\n    B[i] = 0;\n}\n \n\n#pragma omp target enter data map(to:x[:n])//Note:Mapping *A[:n] is incorrect as OpenMP doesn't support arbitrary expressions\n}\n\nint main () {\n\n//check offloading\n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n  int i, errors = 0;\n  int *A;\n  init(&A);\n\n#pragma omp target map(to: n) map(tofrom: B)\n{\n  for (i = 0; i < n; i++)\n    B[i] = x[i];\n}\n\n// finalize();\n  for (i = 0; i < n; i++)\n    if (B[i] != 10) {\n     errors += 1;\n   }\n \n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (errors != 0));\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_enter_data_malloced_array.c -------------------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// Tests for target enter data with heap allocated arrays. The test begins by creating\n// a pointer to a block of memory that is of size n*sizeof(int) and is allocated using malloc(). \n// A check is made to ensure that the pointer is not null, variable x is set equal to the dereferenced \n// pointer and is filled with int value 10. Global array B[10] is filled with int value 0. \n// The values of x[n] are mapped onto the device using enter data map, and values in array B[10]\n// are set equal to values of x[n] to ensure that values of x[n] were properly mapped to device.\n// Back on the host, a final check is made to confirm values of array B[10] are all integer 10.\n// \n//===----------------------------------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n\n// global variables\nint n=10, B[10];\nint *x;\n\n\nvoid init(int **A) {\n  int i;\n  *A = (int *) malloc(n*sizeof(int));\n  if (NULL == *A){ \n    OMPVV_ERROR(\"This Test Has Failed, disregard other messages, array A is not properly allocated\");\n    exit(-1);\n  }\n  x = *A;\n  for (i = 0; i < n; i++){\n    x[i] = 10;\n    B[i] = 0;\n}\n \n\n#pragma omp target enter data map(to:x[:n])//Note:Mapping *A[:n] is incorrect as OpenMP doesn't support arbitrary expressions\n}\n\nint main () {\n\n//check offloading\n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n  int i, errors = 0;\n  int *A;\n  init(&A);\n\n#pragma omp target map(to: n) map(tofrom: B)\n{\n  for (i = 0; i < n; i++)\n    B[i] = x[i];\n}\n\n// finalize();\n  for (i = 0; i < n; i++)\n    if (B[i] != 10) \n     errors += 1;\n   }\n \n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (errors != 0));\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/gemv_target.cpp",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 1116",
        "issue_id": 2,
        "original_code": "//===-- gemv_target.cpp - General Matrix Vector Multiplication target -------===!\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// Taken from the suggestions of the QMCPack team. This test has a simple\n// target region that performs a GEMV\n//!===----------------------------------------------------------------------===!\n#include <chrono>\n#include <string>\n#include <cmath>\n#include \"ompvv.h\"\n#include \"omp.h\"\n\n#define N 8192\n\nclass Timer\n{\n  const std::chrono::time_point<std::chrono::system_clock> start;\n  const std::string name;\n\npublic:\n  Timer(const std::string& name_in): start(std::chrono::system_clock::now()), name(name_in) {};\n  ~Timer()\n  {\n    auto end = std::chrono::system_clock::now();\n    OMPVV_INFOMSG(\"Function %s takes %lf us \",name.c_str(), std::chrono::duration_cast<std::chrono::duration<double, std::micro>>(end - start).count());\n  }\n};\n\ntemplate <typename T>\nvoid gemv(int n, T alpha, const T*  A, const T*  V, T*  Vout)\n{\n  #pragma omp target map(to:A[:n*n], V[:n]) map(from:Vout[:n])\n  for(int row=0; row<n; row++)\n  {\n    T sum = T(0);\n    const T * A_row = A+row*n;\n    for(int col=0; col<n; col++) {\n      sum += A_row[col]*V[col];\n    }\n    Vout[row] = sum*alpha;\n  }\n}\n\ntemplate <class T>\nT* allocate(size_t n)\n{\n  T* ptr = new T[n];\n  std::fill_n(ptr, n, T(1));\n  return ptr;\n}\n\ntemplate <class T>\nvoid deallocate(T* ptr, size_t n)\n{\n  delete[] ptr;\n}\n\nint main()\n{\n  OMPVV_TEST_OFFLOADING;\n  auto* A = allocate<float>(N*N);\n  auto* V = allocate<float>(N);\n  auto* Vout = allocate<float>(N);\n  int errors = 0;\n\n  {\n    Timer local(\"GEMV\");\n    gemv(N, 1.0f, A, V, Vout);\n  }\n\n  for(int i=0; i<N; i++)\n  {\n    OMPVV_TEST_AND_SET(errors, std::abs(Vout[i]-N) > 0.0001);\n    OMPVV_ERROR_IF(std::abs(Vout[i]-N) > 0.0001, \"Error for Vout[%d] = %f, Should be %d\", i, Vout[i], N);\n  }\n\n  deallocate(A, N*N);\n  deallocate(V, N);\n  deallocate(Vout, N);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===-- gemv_target.cpp - General Matrix Vector Multiplication target -------===!\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// Taken from the suggestions of the QMCPack team. This test has a simple\n// target region that performs a GEMV\n//!===----------------------------------------------------------------------===!\n#include <chrono>\n#include <string>\n#include <cmath>\n#include \"ompvv.h\"\n#include \"omp.h\"\n\n#define N 8192\n\nclass Timer\n{\n  const std::chrono::time_point<std::chrono::system_clock> start;\n  const std::string name;\n\npublic:\n  Timer(const std::string& name_in): start(std::chrono::system_clock::now()), name(name_in) {};\n  ~Timer()\n  {\n    auto end = std::chrono::system_clock::now();\n    OMPVV_INFOMSG(\"Function %s takes %lf us \",name.c_str(), std::chrono::duration_cast<std::chrono::duration<double, std::micro>>(end - start).count());\n  }\n};\n\ntemplate <typename T>\nvoid gemv(int n, T alpha, const T*  A, const T*  V, T*  Vout)\n{\n  #pragma omp target map(to:A[:n*n], V[:n]) map(from:Vout[:n])\n  for(int row=0; row<n; row++)\n  {\n    T sum = T(0);\n    const T * A_row = A+row*n;\n    for(int col=0; col<n;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1; col++) {\n      sum += A_row[col]*V[col];\n    }\n    Vout[row] = sum*alpha;\n  }\n}\n\ntemplate <class T>\nT* allocate(size_t n)\n{\n  T* ptr = new T[n];\n  std::fill_n(ptr, n, T(1));\n  return ptr;\n}\n\ntemplate <class T>\nvoid deallocate(T* ptr, size_t n)\n{\n  delete[] ptr;\n}\n\nint main()\n{\n  OMPVV_TEST_OFFLOADING;\n  auto* A = allocate<float>(N*N);\n  auto* V = allocate<float>(N);\n  auto* Vout = allocate<float>(N);\n  int errors = 0;\n\n  {\n    Timer local(\"GEMV\");\n    gemv(N, 1.0f, A, V, Vout);\n  }\n\n  for(int i=0; i<N; i++)\n  {\n    OMPVV_TEST_AND_SET(errors, std::abs(Vout[i]-N) > 0.0001);\n    OMPVV_ERROR_IF(std::abs(Vout[i]-N) > 0.0001, \"Error for Vout[%d] = %f, Should be %d\", i, Vout[i], N);\n  }\n\n  deallocate(A, N*N);\n  deallocate(V, N);\n  deallocate(Vout, N);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_if.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp declare\" at position 1846",
        "issue_id": 0,
        "original_code": "//===---- test_target_if.c -  --------------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// The if clause determines if the section should be executed in the host or \n// the device. There are three things to test here: \n// (a) with offloading when 'if' clause evaluates to true then code\n// be executed on the device \n// (b) with offloading when 'if' clause evaluates to false then code should\n// be executed on the host\n// (c) without offloading all the code should be executed on the device\n// The if clause is evaluated on runtime which means that variables could\n// determine this behavior. We use a SIZE_THRESHOLD variable to check if we \n// should execute on the device or the host. Before starting the test we \n// sample offloading to see if it was enabled or not. If the code is executed\n// in the device, the result should be c[i] = a[i] + b[i] = i + 1. \n// If the code is executed on the host the result should be c[i] = -1\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\" \n\n#define SIZE_THRESHOLD 512\n\n// Test for OpenMP 4.5 target data with if\nint main() {\n  int isOffloading = 0; \n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  \n  if (!isOffloading)\n  OMPVV_WARNING(\"It is not possible to test conditional data transfers \"\n                 \"if the environment is shared or offloading is off. Not testing \"\n                 \"anything\")\n  int a[1024];\n  int b[1024];\n  int c[1024];\n  int size, i = 0, errors[2] = {0,0}, isHost = -1;\n\n  // a and b array initialization\n  for (i = 0; i < 1024; i++) {\n    a[i] = 1;\n    b[i] = i;\n  }\n\n  // check multiple sizes. \n  for (size = 256; size <= 1024; size += 256) {\n    // C initialization\n    for (i = 0; i < size; i++) {\n      c[i] = -1;\n    }\n#pragma omp target if(size > SIZE_THRESHOLD) map(to: size)  \\\n        map(tofrom: c[0:size])                                       \\\n        map(to: a[0:size], b[0:size])  map(tofrom: isHost)\n    {\n      isHost = omp_is_initial_device();\n      int alpha = (isHost ? 0 : 1);\n      int j = 0;\n      for (j = 0; j < size; j++) {\n        // c[j] is zero if executed in the host\n        // c[j] is 1+j if executed on the device\n        c[j] = alpha*(a[j] + b[j]);\n      }\n    } // end target\n\n    // checking results \n    for (i = 0; i < size; i++) {\n      if (isOffloading && size > SIZE_THRESHOLD) {\n        // Should have executed on the device\n        // if offloading was used\n        // c[i] is zero if it was executed in the host\n        OMPVV_TEST_AND_SET(errors[0], (c[i] != i + 1));//error when executed on the device\n      } else {\n        // Should have executed in the host\n        // with or without offloading\n        OMPVV_TEST_AND_SET(errors[1], (c[i] != 0));\n      } //end-else \n    }\n  } // end-for size\n\n  if (!errors[0] && !errors[1]) {\n    OMPVV_INFOMSG(\"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  } else if (errors[0]==0 && errors[1]!=0) {\n    OMPVV_ERROR(\"Test failed on host with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n  } else if (errors[0]!=0 && errors[1]==0) {\n    OMPVV_ERROR(\"Test failed on device with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n  } else if (errors[0]!=0 && errors[1]!=0) {\n    OMPVV_ERROR(\"Test failed on host and device with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n  }\n  \n  OMPVV_REPORT_AND_RETURN((errors[0] + errors[1]));\n}\n",
        "error_code": "//===---- test_target_if.c -  --------------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// The if clause determines if the section should be executed in the host or \n// the device. There are three things to test here: \n// (a) with offloading when 'if' clause evaluates to true then code\n// be executed on the device \n// (b) with offloading when 'if' clause evaluates to false then code should\n// be executed on the host\n// (c) without offloading all the code should be executed on the device\n// The if clause is evaluated on runtime which means that variables could\n// determine this behavior. We use a SIZE_THRESHOLD variable to check if we \n// should execute on the device or the host. Before starting the test we \n// sample offloading to see if it was enabled or not. If the code is executed\n// in the device, the result should be c[i] = a[i] + b[i] = i + 1. \n// If the code is executed on the host the result should be c[i] = -1\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\" \n\n#define SIZE_THRESHOLD 512\n\n// Test for OpenMP 4.5 target data with if\nint main() {\n  int isOffloading = 0; \n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  \n  if (!isOffloading)\n  OMPVV_WARNING(\"It is not possible to test conditional data transfers \"\n                 \"if the environment is shared or offloading is off. Not testing \"\n                 \"anything\")\n  int a[1024];\n  int b[1024];\n  int c[1024];\n  int size, i = 0, errors[2] = {0,0}, isHost = -1;\n\n  // a and b array initialization\n  for (i = 0; i < 1024; i++) {\n    a[i] = 1;\n    b[i] = i;\n  }\n\n  // check multiple sizes. \n  for (size = 256; size <= 1024; size += 256) {\n    // C initialization\n    for (i = 0; i < size; i++) {\n      c[i] = -1;\n    }\n#pragma omp declare if(size > SIZE_THRESHOLD) map(to: size)  \\\n        map(tofrom: c[0:size])                                       \\\n        map(to: a[0:size], b[0:size])  map(tofrom: isHost)\n    {\n      isHost = omp_is_initial_device();\n      int alpha = (isHost ? 0 : 1);\n      int j = 0;\n      for (j = 0; j < size; j++) {\n        // c[j] is zero if executed in the host\n        // c[j] is 1+j if executed on the device\n        c[j] = alpha*(a[j] + b[j]);\n      }\n    } // end target\n\n    // checking results \n    for (i = 0; i < size; i++) {\n      if (isOffloading && size > SIZE_THRESHOLD) {\n        // Should have executed on the device\n        // if offloading was used\n        // c[i] is zero if it was executed in the host\n        OMPVV_TEST_AND_SET(errors[0], (c[i] != i + 1));//error when executed on the device\n      } else {\n        // Should have executed in the host\n        // with or without offloading\n        OMPVV_TEST_AND_SET(errors[1], (c[i] != 0));\n      } //end-else \n    }\n  } // end-for size\n\n  if (!errors[0] && !errors[1]) {\n    OMPVV_INFOMSG(\"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  } else if (errors[0]==0 && errors[1]!=0) {\n    OMPVV_ERROR(\"Test failed on host with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n  } else if (errors[0]!=0 && errors[1]==0) {\n    OMPVV_ERROR(\"Test failed on device with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n  } else if (errors[0]!=0 && errors[1]!=0) {\n    OMPVV_ERROR(\"Test failed on host and device with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n  }\n  \n  OMPVV_REPORT_AND_RETURN((errors[0] + errors[1]));\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_data_map_devices.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp cancel\" at position 1438",
        "issue_id": 0,
        "original_code": "//===--- test_target_data_map_devices.c--- target data map to multiple dev--===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n//  This test checks for data mapping on multiple devices when using the target\n//  data directive. It makes sure that data mapping is happening on each device\n//  through the use of omp_set_default_device as well as the device() clause\n//\n//  Since OpenMP 4.5 does not have an API call to obtain the current device, \n//  this test does not guarantee that the execution devices are different. \n//  \n//  Last modified by Jose M Monsalve Diaz, December 25, 2019\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\n// Test for OpenMP 4.5 target data to multiple devices using API\nint test_map_set_default_dev() {\n  OMPVV_INFOMSG(\"test_set_default_device\");\n\n  // Get number of devices\n  int num_dev = omp_get_num_devices();\n  OMPVV_INFOMSG(\"num_devices: %d\", num_dev);\n\n  int def_dev = omp_get_default_device();\n  OMPVV_INFOMSG(\"initial device: %d\", omp_get_initial_device());\n  OMPVV_INFOMSG(\"default device: %d\", def_dev);\n\n  // Allocate num_devices + 1 to avoid zero-sized VLA if num_devices == 0\n  int sum[num_dev+1], errors = 0;\n  int* h_matrix = (int*) malloc(num_dev * N * sizeof(int));\n\n  for (int dev = 0; dev < num_dev; ++dev) {\n    omp_set_default_device(dev);\n#pragma omp target data map(from: h_matrix[dev*N:N])\n    {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, dev != omp_get_default_device());\n#pragma omp target map(alloc: h_matrix[dev*N:N])\n      {\n        for (int i = 0; i < N; ++i)\n          h_matrix[dev*N + i] = dev;\n      } // end target\n    } // end target data\n  }\n\n  // checking results \n  for (int dev = 0; dev < num_dev; ++dev) {\n    sum[dev] = h_matrix[dev*N + 0];\n    for (int i = 1; i < N; ++i)\n      sum[dev] += h_matrix[dev*N + i];\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (dev * N != sum[dev]));\n  }\n\n  omp_set_default_device(def_dev);\n  free(h_matrix);\n  return errors;\n}\n\n// Test for OpenMP 4.5 target data to multiple devices using directives\nint test_map_device() {\n\n  OMPVV_INFOMSG(\"test_map_device\");\n\n  // Get number of devices \n  int num_dev = omp_get_num_devices();\n  OMPVV_INFOMSG(\"num_devices: %d\", num_dev);\n\n  OMPVV_INFOMSG(\"initial device: %d\", omp_get_initial_device());\n  OMPVV_INFOMSG(\"default device: %d\", omp_get_default_device());\n\n  // Allocate num_devices + 1 to avoid zero-sized VLA if num_devices == 0\n  int sum[num_dev+1], errors = 0;\n  int* h_matrix = (int*) malloc(num_dev * N * sizeof(int));\n\n  for (int dev = 0; dev < num_dev; ++dev) {\n#pragma omp target data map(from: h_matrix[dev*N:N]) device(dev)\n    {\n#pragma omp target map(alloc: h_matrix[dev*N:N]) device(dev)\n      {\n        for (int i = 0; i < N; ++i)\n          h_matrix[dev*N + i] = dev;\n      } // end target\n    } // end target data\n  }\n\n  // checking results \n  errors = 0;\n  for (int dev = 0; dev < num_dev; ++dev) {\n    sum[dev] = h_matrix[dev*N + 0];\n    for (int i = 1; i < N; ++i)\n      sum[dev] += h_matrix[dev*N + i];\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (dev * N != sum[dev]));\n  }\n\n  free(h_matrix);\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_set_default_dev());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_device());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_data_map_devices.c--- target data map to multiple dev--===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n//  This test checks for data mapping on multiple devices when using the target\n//  data directive. It makes sure that data mapping is happening on each device\n//  through the use of omp_set_default_device as well as the device() clause\n//\n//  Since OpenMP 4.5 does not have an API call to obtain the current device, \n//  this test does not guarantee that the execution devices are different. \n//  \n//  Last modified by Jose M Monsalve Diaz, December 25, 2019\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\n// Test for OpenMP 4.5 target data to multiple devices using API\nint test_map_set_default_dev() {\n  OMPVV_INFOMSG(\"test_set_default_device\");\n\n  // Get number of devices\n  int num_dev = omp_get_num_devices();\n  OMPVV_INFOMSG(\"num_devices: %d\", num_dev);\n\n  int def_dev = omp_get_default_device();\n  OMPVV_INFOMSG(\"initial device: %d\", omp_get_initial_device());\n  OMPVV_INFOMSG(\"default device: %d\", def_dev);\n\n  // Allocate num_devices + 1 to avoid zero-sized VLA if num_devices == 0\n  int sum[num_dev+1], errors = 0;\n  int* h_matrix = (int*) malloc(num_dev * N * sizeof(int));\n\n  for (int dev = 0; dev < num_dev; ++dev) {\n    omp_set_default_device(dev);\n#pragma omp cancel data map(from: h_matrix[dev*N:N])\n    {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, dev != omp_get_default_device());\n#pragma omp target map(alloc: h_matrix[dev*N:N])\n      {\n        for (int i = 0; i < N; ++i)\n          h_matrix[dev*N + i] = dev;\n      } // end target\n    } // end target data\n  }\n\n  // checking results \n  for (int dev = 0; dev < num_dev; ++dev) {\n    sum[dev] = h_matrix[dev*N + 0];\n    for (int i = 1; i < N; ++i)\n      sum[dev] += h_matrix[dev*N + i];\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (dev * N != sum[dev]));\n  }\n\n  omp_set_default_device(def_dev);\n  free(h_matrix);\n  return errors;\n}\n\n// Test for OpenMP 4.5 target data to multiple devices using directives\nint test_map_device() {\n\n  OMPVV_INFOMSG(\"test_map_device\");\n\n  // Get number of devices \n  int num_dev = omp_get_num_devices();\n  OMPVV_INFOMSG(\"num_devices: %d\", num_dev);\n\n  OMPVV_INFOMSG(\"initial device: %d\", omp_get_initial_device());\n  OMPVV_INFOMSG(\"default device: %d\", omp_get_default_device());\n\n  // Allocate num_devices + 1 to avoid zero-sized VLA if num_devices == 0\n  int sum[num_dev+1], errors = 0;\n  int* h_matrix = (int*) malloc(num_dev * N * sizeof(int));\n\n  for (int dev = 0; dev < num_dev; ++dev) {\n#pragma omp target data map(from: h_matrix[dev*N:N]) device(dev)\n    {\n#pragma omp target map(alloc: h_matrix[dev*N:N]) device(dev)\n      {\n        for (int i = 0; i < N; ++i)\n          h_matrix[dev*N + i] = dev;\n      } // end target\n    } // end target data\n  }\n\n  // checking results \n  errors = 0;\n  for (int dev = 0; dev < num_dev; ++dev) {\n    sum[dev] = h_matrix[dev*N + 0];\n    for (int i = 1; i < N; ++i)\n      sum[dev] += h_matrix[dev*N + i];\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (dev * N != sum[dev]));\n  }\n\n  free(h_matrix);\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_set_default_dev());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_device());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_enter_exit_data_map_malloced_array.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  int errors = 0;\n\n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_tofrom());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_delete());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 1795",
        "issue_id": 4,
        "original_code": "//===--- test_target_enter_exit_data_map_malloced_array.c -------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n// \n// This tests the mapping of a pointer to and from the device using target \n// enter data map and target exit data map. Additionally, this test checks\n// that the use of the delete map-type-modifier on a target data construct\n// with a map clause is supported.\n//\n////===----------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 10\n\nint *x;\nint *y;\n\nint test_tofrom() {\n  int i, errors = 0;\n  int *A;\n\n  A = (int *) malloc(N*sizeof(int));\n  if (NULL == A) {\n    OMPVV_ERROR(\"Malloc returned NULL.\");\n    exit(-1);\n  }\n\n  for (i = 0; i < N; ++i) {\n    A[i] = 0;\n  }\n\n  x = A;\n\n#pragma omp target enter data map(to: x[:N])\n\n#pragma omp target\n  {\n    for (i = 0; i < N; i++) {\n      x[i] = N;\n    }\n  }\n\n#pragma omp target exit data map(from: x[:N])\n\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, A[i] != N);\n  }\n  free(A);\n  return errors;\n}\n\nint test_delete() {\n  int i, errors = 0;\n  int *A, *B;\n\n  A = (int *) malloc(N*sizeof(int));\n  B = (int *) malloc(N*sizeof(int));\n  if (NULL == A || NULL == B) {\n    OMPVV_ERROR(\"Malloc returned NULL.\");\n    exit(-1);\n  }\n\n  for (i = 0; i < N; ++i) {\n    A[i] = N;\n  }\n\n  x = A;\n  y = B;\n\n#pragma omp target data map(tofrom: x[:N]) map(from: y[:N])\n  {\n#pragma omp target exit data map(delete: x[:N])\n    for (i = 0; i < N; ++i) {\n      x[i] = 0;\n    }\n#pragma omp target map(to: x[:N])\n    {\n      for (i = 0; i < N; i++) {\n        y[i] = x[i];\n      }\n    }\n  }\n\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, B[i] != 0);\n  }\n  free(A);\n  free(B);\n\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n\n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_tofrom());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_delete());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_enter_exit_data_map_malloced_array.c -------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n// \n// This tests the mapping of a pointer to and from the device using target \n// enter data map and target exit data map. Additionally, this test checks\n// that the use of the delete map-type-modifier on a target data construct\n// with a map clause is supported.\n//\n////===----------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 10\n\nint *x;\nint *y;\n\nint test_tofrom() {\n  int i, errors = 0;\n  int *A;\n\n  A = (int *) malloc(N*sizeof(int));\n  if (NULL == A) {\n    OMPVV_ERROR(\"Malloc returned NULL.\");\n    exit(-1);\n  }\n\n  for (i = 0; i < N; ++i) {\n    A[i] = 0;\n  }\n\n  x = A;\n\n#pragma omp target enter data map(to: x[:N])\n\n#pragma omp target\n  {\n    for (i = 0; i < N; i++) {\n      x[i] = N;\n    }\n  }\n\n#pragma omp target exit data map(from: x[:N])\n\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, A[i] != N);\n  }\n  free(A);\n  return errors;\n}\n\nint test_delete() {\n  int i, errors = 0;\n  int *A, *B;\n\n  A = (int *) malloc(N*sizeof(int));\n  B = (int *) malloc(N*sizeof(int));\n  if (NULL == A || NULL == B) {\n    OMPVV_ERROR(\"Malloc returned NULL.\");\n    exit(-1);\n  }\n\n  for (i = 0; i < N; ++i) {\n    A[i] = N;\n  }\n\n  x = A;\n  y = B;\n\n#pragma omp target data map(tofrom: x[:N]) map(from: y[:N])\n  {\n#pragma omp target exit data map(delete: x[:N])\n    for (i = 0; i < N; ++i) {\n      x[i] = 0;\n    }\n#pragma omp target map(to: x[:N])\n    {\n      for (i = 0; i < N; i++) {\n        y[i] = x[i];\n      }\n    }\n  }\n\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, B[i] != 0);\n  }\n  free(A);\n  free(B);\n\n  return errors;\n}\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_device.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1641",
        "issue_id": 1,
        "original_code": "//===--- test_target_map_devices.c --- target map to multiple devces ---------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n//  This test checks for data mapping on multiple devices when using the target\n//  directive. It makes sure that data mapping is happening on each device\n//  through the use of omp_set_default_device as well as the device() clause\n//\n//  Since OpenMP 4.5 does not have an API call to obtain the current device, \n//  this test does not guarantee that the execution devices are different. \n//  \n//  Last modified by Jose M Monsalve Diaz, December 25, 2019\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nint test_target_device_clause() {\n  OMPVV_INFOMSG(\"test_target_device_clause\");\n\n  // Get number of devices\n  int num_dev = omp_get_num_devices();\n  OMPVV_INFOMSG(\"num_devices tested = %d\", num_dev);\n  \n  int array[N];\n  int errors = 0;\n  \n  // Array initialization\n  for (int i = 0; i < N; ++i) {\n    array[i] = -1;\n  }\n\n  // Map the same array to multiple devices. initialize with device number\n  for (int dev = 0; dev < num_dev; ++dev) {\n#pragma omp target data map(tofrom: array[0:N]) device(dev)\n    { \n    #pragma omp target map(alloc: array[0:N]) device(dev)\n      {\n        for (int i = 0; i < N; ++i) {\n          array[i] += dev + 1;\n        }\n      } // end of omp target \n    } // end of omp target data\n    for (int i = 0; i < N; ++i) {\n      OMPVV_TEST_AND_SET(errors, array[i] != dev);\n      array[i] = -1;\n    }\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_device_clause());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_map_devices.c --- target map to multiple devces ---------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n//  This test checks for data mapping on multiple devices when using the target\n//  directive. It makes sure that data mapping is happening on each device\n//  through the use of omp_set_default_device as well as the device() clause\n//\n//  Since OpenMP 4.5 does not have an API call to obtain the current device, \n//  this test does not guarantee that the execution devices are different. \n//  \n//  Last modified by Jose M Monsalve Diaz, December 25, 2019\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nint test_target_device_clause() {\n  OMPVV_INFOMSG(\"test_target_device_clause\");\n\n  // Get number of devices\n  int num_dev = omp_get_num_devices();\n  OMPVV_INFOMSG(\"num_devices tested = %d\", num_dev);\n  \n  int array[N];\n  int errors = 0;\n  \n  // Array initialization\n  for (int i = 0; i < N; ++i) {\n    array[i] = -1;\n  }\n\n  // Map the same array to multiple devices. initialize with device number\n  for (int dev = 0; dev < num_dev; ++dev) {\n#pragma omp target data map(tofrom: array[0:N]) device(dev)\n    { \n    #pragma omp target map(alloc: array[0:N]) device(dev)\n      {\n        for (int i = 0; i < N; ++i) {\n          array[i] += dev + 1;\n        }\n      } // end of omp target \n    } // end of omp target data\n    for (int i = 0; i < N; ++i) {\n      OMPVV_TEST_AND_SET(errors, array[i] != dev);\n      array[i] = -1;\n    }\n  }\n\n  return errors;\n}\n\nint main() \n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_device_clause());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_parallel_for_defaultmap.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===---- test_target_teams_distribute_parallel_for_defaultmap.c - combined consutrct -===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// Testing defaultmap of different scalar values. We check when it is off and when it is\n// on. The first one should not copy values back from the device of scalars. The second\n// should copy the values back even if they are not mapped explicitly.\n//\n//===----------------------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define ITERATIONS 10000\n\nint test_defaultmap_on() {\n  OMPVV_INFOMSG(\"test_defaultmap_on\");\n\n  int errors = 0;\n  int i;\n\n  // we try with all the scalars\n  char scalar_char = 'a';\n  char scalar_char_cpy[ITERATIONS];\n  short scalar_short = 10;\n  short scalar_short_cpy[ITERATIONS];\n  int scalar_int = 11;\n  int scalar_int_cpy[ITERATIONS];\n  float scalar_float = 5.5f;\n  float scalar_float_cpy[ITERATIONS];\n  double scalar_double = 10.45;\n  double scalar_double_cpy[ITERATIONS];\n  enum { VAL1 = 1, VAL2, VAL3, VAL4} scalar_enum = VAL1, scalar_enum_cpy[ITERATIONS];\n\n\n  // Testing the to behavior of the tofrom we use an array to avoid data\n  // races and check that all threads get the value\n#pragma omp target teams distribute parallel for defaultmap(tofrom: scalar)\n  for (i = 0; i < ITERATIONS; ++i) {\n    scalar_char_cpy[i] = scalar_char;\n    scalar_short_cpy[i] = scalar_short;\n    scalar_int_cpy[i] = scalar_int;\n    scalar_float_cpy[i] = scalar_float;\n    scalar_double_cpy[i] = scalar_double;\n    scalar_enum_cpy[i] = scalar_enum;\n  } // end of omp target\n\n  for (i = 0; i < ITERATIONS; ++i) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_char_cpy[i] != 'a');\n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_short_cpy[i] != 10);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_int_cpy[i] != 11);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(scalar_float_cpy[i] - 5.5f) > 0.0001);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(scalar_double_cpy[i] - 10.45) > 0.00001);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_enum_cpy[i] != VAL1);\n  }\n\n  // Map the same array to multiple devices. initialize with device number\n#pragma omp target teams distribute parallel for defaultmap(tofrom: scalar)\n  for (i = 0; i < ITERATIONS; ++i) {\n    if (omp_get_team_num() == 0) {\n      if (omp_get_thread_num() == 0) {\n        scalar_char = 'b';\n        scalar_short = 20;\n        scalar_int = 33;\n        scalar_float = 6.5f;\n        scalar_double = 20.45;\n        scalar_enum = VAL4;\n      }\n    }\n  } // end of omp target\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_char != 'b');\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_short != 20);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_int != 33);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(scalar_float - 6.5f) > 0.0001);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(scalar_double - 20.45) > 0.00001);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_enum != VAL4);\n\n  return errors;\n}\n\nint test_defaultmap_off() {\n  OMPVV_INFOMSG(\"test_defaultmap_off\");\n\n  int errors = 0;\n  int i;\n\n  // we try with all the scalars\n  char scalar_char = 'a';\n  char scalar_char_cpy[ITERATIONS];\n  short scalar_short = 10;\n  short scalar_short_cpy[ITERATIONS];\n  int scalar_int = 11;\n  int scalar_int_cpy[ITERATIONS];\n  float scalar_float = 5.5f;\n  float scalar_float_cpy[ITERATIONS];\n  double scalar_double = 10.45;\n  double scalar_double_cpy[ITERATIONS];\n  enum { VAL1 = 1, VAL2, VAL3, VAL4} scalar_enum = VAL1, scalar_enum_cpy[ITERATIONS];\n\n  // Testing the copy behavior of the firstprivatization. we use an array to avoid data\n  // races and check that all threads get the value\n#pragma omp target teams distribute parallel for \n  for (i = 0; i < ITERATIONS; ++i) {\n    scalar_char_cpy[i] = scalar_char;\n    scalar_short_cpy[i] = scalar_short;\n    scalar_int_cpy[i] = scalar_int;\n    scalar_float_cpy[i] = scalar_float;\n    scalar_double_cpy[i] = scalar_double;\n    scalar_enum_cpy[i] = scalar_enum;\n  } // end of omp target\n\n  for (i = 0; i < ITERATIONS; ++i) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_char_cpy[i] != 'a');\n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_short_cpy[i] != 10);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_int_cpy[i] != 11);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(scalar_float_cpy[i] - 5.5f) > 0.0001);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(scalar_double_cpy[i] - 10.45) > 0.00001);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_enum_cpy[i] != VAL1);\n  }\n  \n#pragma omp target teams distribute parallel for\n  for (i = 0; i < 1; ++i) {\n      scalar_char = 'b';\n      scalar_short = 20;\n      scalar_int = 33;\n      scalar_float = 6.5f;\n      scalar_double = 20.45;\n      scalar_enum = VAL4;\n  } // end of omp target\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_char != 'a');\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_short != 10);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_int != 11);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(scalar_float - 5.5f) > 0.0001);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(scalar_double - 10.45) > 0.0001);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_enum != VAL1);\n\n  return errors;\n}\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_defaultmap_on());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_defaultmap_off());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nbyte ojoblpkmet = 18;\ndouble bzzqlydggh = 151;\ndouble cebgvyeafa = 156;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_reduction_multiply.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp declare\" at position 792",
        "issue_id": 0,
        "original_code": "//===--- test_target_teams_distribute_reduction_multiply.c-------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the reduction clause on a target teams distribute directive,\n// testing that the variable in the reduction clause is properly reduced using\n// the multiply operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_multiply() {\n  int a[N];\n  int errors = 0;\n  int num_teams[N];\n  srand(1);\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = 1 + (int) rand() / (double) RAND_MAX;\n    num_teams[x] = -x;\n  }\n\n  int result = 1;\n  int host_result;\n\n  for (int x = 0; x < N; x = x + 16) {\n    result = 1;\n#pragma omp target teams distribute reduction(*:result) defaultmap(tofrom:scalar)\n    for (int y = 0; y < 16; ++y) {\n      result *= a[x + y];\n      num_teams[x + y] = omp_get_num_teams();\n    }\n    host_result = 1;\n    for (int y = 0; y < 16; ++y) {\n      host_result *= a[x + y];\n    }\n    OMPVV_TEST_AND_SET_VERBOSE(errors, host_result != result);\n    OMPVV_INFOMSG_IF(host_result != result, \"Device result is %d and host result is %d.\", result, host_result);\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_teams[x - 1] != num_teams[x], \"Kernel reported differing numbers of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_teams[0] == 1, \"Test operated with one team.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_teams[0] <= 0, \"Test reported invalid number of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_multiply() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_reduction_multiply.c-------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the reduction clause on a target teams distribute directive,\n// testing that the variable in the reduction clause is properly reduced using\n// the multiply operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_multiply() {\n  int a[N];\n  int errors = 0;\n  int num_teams[N];\n  srand(1);\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = 1 + (int) rand() / (double) RAND_MAX;\n    num_teams[x] = -x;\n  }\n\n  int result = 1;\n  int host_result;\n\n  for (int x = 0; x < N; x = x + 16) {\n    result = 1;\n#pragma omp declare teams distribute reduction(*:result) defaultmap(tofrom:scalar)\n    for (int y = 0; y < 16; ++y) {\n      result *= a[x + y];\n      num_teams[x + y] = omp_get_num_teams();\n    }\n    host_result = 1;\n    for (int y = 0; y < 16; ++y) {\n      host_result *= a[x + y];\n    }\n    OMPVV_TEST_AND_SET_VERBOSE(errors, host_result != result);\n    OMPVV_INFOMSG_IF(host_result != result, \"Device result is %d and host result is %d.\", result, host_result);\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_teams[x - 1] != num_teams[x], \"Kernel reported differing numbers of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_teams[0] == 1, \"Test operated with one team.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_teams[0] <= 0, \"Test reported invalid number of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_multiply() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_enter_data_struct.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 4741",
        "issue_id": 2,
        "original_code": "//===--- test_target_enter_data_struct.c ------------------------------------===//\n//\n// This test checks that the target enter data construct with a map clause \n// can be used to map a struct variable or a typedef variable to the device. \n// Once the struct variable or typedef variable is mapped onto device, another \n// struct variable or typedef variable is mapped back to host using target \n// construct with map clause and map-type-modifier tofrom. \n//\n//===------------------------------------------------------------------------===//\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1000\n#define ARRAY_SIZE 5\nint test_struct() {\n\n  OMPVV_INFOMSG(\"test_struct\");\n\n  int errors = 0, isHost = -1;\n  int* pointers[ARRAY_SIZE + 1];\n\n  struct {\n    int a; // firstprivate\n    int b[N]; // tofrom:b[0:N]\n    int *p; // tofrom:p[0:0]\n  } single, array[ARRAY_SIZE], singleCopy, arrayCopy[ARRAY_SIZE];\n\n  // single initialization on host. Using map(to)\n  single.p = (int*) malloc(ARRAY_SIZE * sizeof(int));\n  pointers[0] = single.p;\n  single.a = 1;\n  for (int i = 0; i < N; ++i)\n    single.b[i] = i;\n\n  // Array initialization on host. Using map(to)\n  for (int i = 0; i < ARRAY_SIZE; ++i) {\n    array[i].p = (int*) malloc(ARRAY_SIZE * sizeof(int));\n    pointers[i + 1] = array[i].p;\n    array[i].a = 1;\n    for (int j = 0; j < N; ++j)\n      array[i].b[j] = j;\n  }\n\n  // unstructured mapping\n  {\n#pragma omp target enter data map(to: single) map(to: array[0:ARRAY_SIZE])\n    printf(\"\"); // forcing the compiler to not moving out of the scope\n  }\n  // operation\n#pragma omp target map(from: singleCopy) map(from: arrayCopy[0:ARRAY_SIZE]) map(tofrom: isHost)\\\n  map(alloc: single, array[0:ARRAY_SIZE])\n  {\n    isHost = omp_is_initial_device();\n\n    singleCopy.a = single.a;\n    singleCopy.p = single.p;\n    for (int i = 0; i < N; ++i)\n      singleCopy.b[i] = single.b[i];\n\n    for (int i = 0; i < ARRAY_SIZE; ++i) {\n      arrayCopy[i].a = array[i].a;\n      arrayCopy[i].p = array[i].p;\n      for (int j = 0; j < N; ++j)\n        arrayCopy[i].b[j] = array[i].b[j];\n    }\n  }\n\n  // checking results\n  OMPVV_TEST_AND_SET(errors, (singleCopy.a != single.a)); \n  for (int i = 0; i < N; ++i)\n    OMPVV_TEST_AND_SET(errors, (singleCopy.b[i] != single.b[i]));\n  OMPVV_TEST_AND_SET(errors, (pointers[0] != singleCopy.p));\n  for (int i = 0; i < ARRAY_SIZE; ++i) {\n    OMPVV_TEST_AND_SET(errors, (arrayCopy[i].a != array[i].a)); \n    for (int j = 0; j < N; ++j)\n      OMPVV_TEST_AND_SET(errors, (arrayCopy[i].b[j] != array[i].b[j]));\n    OMPVV_TEST_AND_SET(errors, (pointers[i + 1] != arrayCopy[i].p));\n  }\n\n  // This is outside of the testing. Even thoug we want to test enter data only, there is no way\n  // to do garbage collection without target exit data\n#pragma omp target exit data map(delete: single, array[0:ARRAY_SIZE])\n\n  free(single.p);\n  for (int i = 0; i < ARRAY_SIZE; ++i) {\n    free(array[i].p);\n  }\n  return errors;\n}\n\nint test_typedef() {\n\n  OMPVV_INFOMSG(\"test_typedef\");\n\n  int errors = 0, isHost = -1;\n  int* pointers[ARRAY_SIZE + 1];\n\n  typedef struct /* __attribute__((packed)) */{\n    int a;\n    int b[N];\n    int *p;\n  } test_struct;\n\n  test_struct single, array[ARRAY_SIZE], singleCopy, arrayCopy[ARRAY_SIZE];\n\n  // single initialization on host. Using map(to)\n  single.p = (int*) malloc(ARRAY_SIZE * sizeof(int));\n  pointers[0] = single.p;\n  single.a = 1;\n  for (int i = 0; i < N; ++i)\n    single.b[i] = i;\n\n  for (int i = 0; i < ARRAY_SIZE; ++i) {\n    array[i].p = (int*) malloc(ARRAY_SIZE * sizeof(int));\n    pointers[i + 1] = array[i].p;\n    array[i].a = 1;\n    for (int j = 0; j < N; ++j)\n      array[i].b[j] = j;\n  }\n\n  // unstructured mapping\n  {\n#pragma omp target enter data map(to: single) map(to: array[0:ARRAY_SIZE])\n    printf(\"\"); // forcing the compiler to not moving out of the scope\n  }\n  // operation\n#pragma omp target map(from: singleCopy) map(from: arrayCopy[0:ARRAY_SIZE]) map(tofrom: isHost) \\\n  map(alloc: single, array[0:ARRAY_SIZE])\n  {\n    isHost = omp_is_initial_device();\n    singleCopy.a = single.a;\n    singleCopy.p = single.p;\n    for (int i = 0; i < N; ++i)\n      singleCopy.b[i] = single.b[i];\n\n    for (int i = 0; i < ARRAY_SIZE; ++i) {\n      arrayCopy[i].a = array[i].a;\n      arrayCopy[i].p = array[i].p;\n\n      for (int j = 0; j < N; ++j)\n        arrayCopy[i].b[j] = array[i].b[j]; \n    }\n  }\n\n  // checking results\n  OMPVV_TEST_AND_SET(errors, (singleCopy.a != single.a));\n  for (int i = 0; i < N; ++i)\n    OMPVV_TEST_AND_SET(errors, (singleCopy.b[i] != single.b[i]));\n  OMPVV_TEST_AND_SET(errors, (pointers[0] != singleCopy.p));\n  for (int i = 0; i < ARRAY_SIZE; ++i) {\n    OMPVV_TEST_AND_SET(errors, (arrayCopy[i].a != array[i].a)); \n    for (int j = 0; j < N; ++j)\n      OMPVV_TEST_AND_SET(errors, (arrayCopy[i].b[j] != array[i].b[j]));\n    OMPVV_TEST_AND_SET(errors, (pointers[i + 1] != arrayCopy[i].p));\n  }\n\n  // This is outside of the testing. Even thoug we want to test enter data only, there is no way\n  // to do garbage collection without target exit data\n#pragma omp target exit data map(delete: single, array[0:ARRAY_SIZE])\n\n  free(single.p);\n  for (int i = 0; i < ARRAY_SIZE; ++i) {\n    free(array[i].p);\n  }\n  return errors;\n}\n\nint main () {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET(errors, test_struct());\n  OMPVV_TEST_AND_SET(errors, test_typedef());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_enter_data_struct.c ------------------------------------===//\n//\n// This test checks that the target enter data construct with a map clause \n// can be used to map a struct variable or a typedef variable to the device. \n// Once the struct variable or typedef variable is mapped onto device, another \n// struct variable or typedef variable is mapped back to host using target \n// construct with map clause and map-type-modifier tofrom. \n//\n//===------------------------------------------------------------------------===//\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1000\n#define ARRAY_SIZE 5\nint test_struct() {\n\n  OMPVV_INFOMSG(\"test_struct\");\n\n  int errors = 0, isHost = -1;\n  int* pointers[ARRAY_SIZE + 1];\n\n  struct {\n    int a; // firstprivate\n    int b[N]; // tofrom:b[0:N]\n    int *p; // tofrom:p[0:0]\n  } single, array[ARRAY_SIZE], singleCopy, arrayCopy[ARRAY_SIZE];\n\n  // single initialization on host. Using map(to)\n  single.p = (int*) malloc(ARRAY_SIZE * sizeof(int));\n  pointers[0] = single.p;\n  single.a = 1;\n  for (int i = 0; i < N; ++i)\n    single.b[i] = i;\n\n  // Array initialization on host. Using map(to)\n  for (int i = 0; i < ARRAY_SIZE; ++i) {\n    array[i].p = (int*) malloc(ARRAY_SIZE * sizeof(int));\n    pointers[i + 1] = array[i].p;\n    array[i].a = 1;\n    for (int j = 0; j < N; ++j)\n      array[i].b[j] = j;\n  }\n\n  // unstructured mapping\n  {\n#pragma omp target enter data map(to: single) map(to: array[0:ARRAY_SIZE])\n    printf(\"\"); // forcing the compiler to not moving out of the scope\n  }\n  // operation\n#pragma omp target map(from: singleCopy) map(from: arrayCopy[0:ARRAY_SIZE]) map(tofrom: isHost)\\\n  map(alloc: single, array[0:ARRAY_SIZE])\n  {\n    isHost = omp_is_initial_device();\n\n    singleCopy.a = single.a;\n    singleCopy.p = single.p;\n    for (int i = 0; i < N; ++i)\n      singleCopy.b[i] = single.b[i];\n\n    for (int i = 0; i < ARRAY_SIZE; ++i) {\n      arrayCopy[i].a = array[i].a;\n      arrayCopy[i].p = array[i].p;\n      for (int j = 0; j < N; ++j)\n        arrayCopy[i].b[j] = array[i].b[j];\n    }\n  }\n\n  // checking results\n  OMPVV_TEST_AND_SET(errors, (singleCopy.a != single.a)); \n  for (int i = 0; i < N; ++i)\n    OMPVV_TEST_AND_SET(errors, (singleCopy.b[i] != single.b[i]));\n  OMPVV_TEST_AND_SET(errors, (pointers[0] != singleCopy.p));\n  for (int i = 0; i < ARRAY_SIZE; ++i) {\n    OMPVV_TEST_AND_SET(errors, (arrayCopy[i].a != array[i].a)); \n    for (int j = 0; j < N; ++j)\n      OMPVV_TEST_AND_SET(errors, (arrayCopy[i].b[j] != array[i].b[j]));\n    OMPVV_TEST_AND_SET(errors, (pointers[i + 1] != arrayCopy[i].p));\n  }\n\n  // This is outside of the testing. Even thoug we want to test enter data only, there is no way\n  // to do garbage collection without target exit data\n#pragma omp target exit data map(delete: single, array[0:ARRAY_SIZE])\n\n  free(single.p);\n  for (int i = 0; i < ARRAY_SIZE; ++i) {\n    free(array[i].p);\n  }\n  return errors;\n}\n\nint test_typedef() {\n\n  OMPVV_INFOMSG(\"test_typedef\");\n\n  int errors = 0, isHost = -1;\n  int* pointers[ARRAY_SIZE + 1];\n\n  typedef struct /* __attribute__((packed)) */{\n    int a;\n    int b[N];\n    int *p;\n  } test_struct;\n\n  test_struct single, array[ARRAY_SIZE], singleCopy, arrayCopy[ARRAY_SIZE];\n\n  // single initialization on host. Using map(to)\n  single.p = (int*) malloc(ARRAY_SIZE * sizeof(int));\n  pointers[0] = single.p;\n  single.a = 1;\n  for (int i = 0; i < N; ++i)\n    single.b[i] = i;\n\n  for (int i = 0; i < ARRAY_SIZE; ++i) {\n    array[i].p = (int*) malloc(ARRAY_SIZE * sizeof(int));\n    pointers[i + 1] = array[i].p;\n    array[i].a = 1;\n    for (int j = 0; j < N; ++j)\n      array[i].b[j] = j;\n  }\n\n  // unstructured mapping\n  {\n#pragma omp target enter data map(to: single) map(to: array[0:ARRAY_SIZE])\n    printf(\"\"); // forcing the compiler to not moving out of the scope\n  }\n  // operation\n#pragma omp target map(from: singleCopy) map(from: arrayCopy[0:ARRAY_SIZE]) map(tofrom: isHost) \\\n  map(alloc: single, array[0:ARRAY_SIZE])\n  {\n    isHost = omp_is_initial_device();\n    singleCopy.a = single.a;\n    singleCopy.p = single.p;\n    for (int i = 0; i < N; ++i)\n      singleCopy.b[i] = single.b[i];\n\n    for (int i = 0; i < ARRAY_SIZE; ++i) {\n      arrayCopy[i].a = array[i].a;\n      arrayCopy[i].p = array[i].p;\n\n      for (int j = 0; j < N; ++j)\n        arrayCopy[i].b[j] = array[i].b[j]; \n    }\n  }\n\n  // checking results\n  OMPVV_TEST_AND_SET(errors, (singleCopy.a != single.a));\n  for (int i = 0; i < N; ++i)\n    OMPVV_TEST_AND_SET(errors, (singleCopy.b[i] != single.b[i]));\n  OMPVV_TEST_AND_SET(errors, (pointers[0] != singleCopy.p));\n  for (int i = 0; i < ARRAY_SIZE; ++i) {\n    OMPVV_TEST_AND_SET(errors, (arrayCopy[i].a != array[i].a));yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1; \n    for (int j = 0; j < N; ++j)\n      OMPVV_TEST_AND_SET(errors, (arrayCopy[i].b[j] != array[i].b[j]));\n    OMPVV_TEST_AND_SET(errors, (pointers[i + 1] != arrayCopy[i].p));\n  }\n\n  // This is outside of the testing. Even thoug we want to test enter data only, there is no way\n  // to do garbage collection without target exit data\n#pragma omp target exit data map(delete: single, array[0:ARRAY_SIZE])\n\n  free(single.p);\n  for (int i = 0; i < ARRAY_SIZE; ++i) {\n    free(array[i].p);\n  }\n  return errors;\n}\n\nint main () {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET(errors, test_struct());\n  OMPVV_TEST_AND_SET(errors, test_typedef());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_map_classes_default.cpp",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 2487",
        "issue_id": 2,
        "original_code": "//===---test_target_map_classes_default.cpp ---------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// This test focuses on the mapping of classes into the device. There are 2 \n// definition of clases. A, and B. A contains an array and its size, while B\n// has an static double and a virtual method. This test consist of 2 parts\n// explicit default mapping of the array and static variable mapping. The\n// explicit test has a map clause that does not use a map-type-modifier for\n// the array. It should be mapped as tofrom. (OpenMP 4.5 requires that it is\n// not mapped as member variable, hence, a pointer to it used.)\n// The static variable mapping test if an static variable will be copied\n// and map over to the device.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <cmath>\n\n#define N 1000\n\nclass A {\n\nprivate:\n  int h_array[N];\n  int size;\n\npublic:\n  A(const int s) : size(s) {\n    for (int i = 0; i < N; i++) {\n      h_array[i] = 0;\n    }\n  }\n\n  void modifyExplicit() {\n    int * theArray = this->h_array;\n    int theSize = size;\n    // It is not possible to do this-> since it is an\n    // expression and it is not supported by 4.5\n#pragma omp target map(theArray[0:N]) map(theSize) \n    {\n      for (int i = 0; i < theSize; ++i)\n          theArray[i] += 1;\n    } // end target\n  }\n\n  int* getArray() {\n    return &h_array[0];\n  }\n};\n\nclass B {\npublic:\n  static double VAR;\n  B() {}\n\n  ~B() {}\n\n#pragma omp declare target \n  static int staticMethod() {\n      return 1;\n  }\n#pragma omp end declare target \n};\n\ndouble B::VAR = 1.0;\n\nint test_explicit() {\n\n  OMPVV_INFOMSG(\"Explicit mapping test\");\n  int sum = 0, errors = 0;\n\n  A *obj = new A(N);\n\n  obj->modifyExplicit();\n\n  // checking results\n  int* h_array = obj->getArray();\n  for (int i = 0; i < N; ++i)\n    sum += h_array[i];\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, N != sum);\n\n  delete obj;\n\n  return errors;\n}\n\nint test_static () {\n\n  OMPVV_INFOMSG(\"Testing accessing a static variable\");\n\n  int errors = 0;\n  double res = 0.0;\n  \n#pragma omp target map(tofrom: res)\n  {\n    res = B::VAR;\n  } // end target\n\n  // checking results\n  OMPVV_TEST_AND_SET_VERBOSE(errors, std::abs(res - 1.0) > 0.0001)\n\n  return errors;\n}\n\nint test_static_method () {\n  OMPVV_INFOMSG(\"Testing static methods on the device\");\n\n  int errors = 0;\n  int value = 0;\n\n#pragma omp target map(tofrom: value) \n  {\n    value = B::staticMethod();\n  } // end target\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, std::abs(value - 1.0) > 0.0001);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_static_method() != 0);\n  OMPVV_TEST_AND_SET_VERBOSE(errors,  test_static() != 0);\n  OMPVV_TEST_AND_SET_VERBOSE(errors,  test_explicit() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---test_target_map_classes_default.cpp ---------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// This test focuses on the mapping of classes into the device. There are 2 \n// definition of clases. A, and B. A contains an array and its size, while B\n// has an static double and a virtual method. This test consist of 2 parts\n// explicit default mapping of the array and static variable mapping. The\n// explicit test has a map clause that does not use a map-type-modifier for\n// the array. It should be mapped as tofrom. (OpenMP 4.5 requires that it is\n// not mapped as member variable, hence, a pointer to it used.)\n// The static variable mapping test if an static variable will be copied\n// and map over to the device.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <cmath>\n\n#define N 1000\n\nclass A {\n\nprivate:\n  int h_array[N];\n  int size;\n\npublic:\n  A(const int s) : size(s) {\n    for (int i = 0; i < N; i++) {\n      h_array[i] = 0;\n    }\n  }\n\n  void modifyExplicit() {\n    int * theArray = this->h_array;\n    int theSize = size;\n    // It is not possible to do this-> since it is an\n    // expression and it is not supported by 4.5\n#pragma omp target map(theArray[0:N]) map(theSize) \n    {\n      for (int i = 0; i < theSize; ++i)\n          theArray[i] += 1;\n    } // end target\n  }\n\n  int* getArray() {\n    return &h_array[0];\n  }\n};\n\nclass B {\npublic:\n  static double VAR;\n  B() {}\n\n  ~B() {}\n\n#pragma omp declare target \n  static int staticMethod() {\n      return 1;\n  }\n#pragma omp end declare target \n};\n\ndouble B::VAR = 1.0;\n\nint test_explicit() {\n\n  OMPVV_INFOMSG(\"Explicit mapping test\");\n  int sum = 0, errors = 0;\n\n  A *obj = new A(N);\n\n  obj->modifyExplicit();\n\n  // checking results\n  int* h_array = obj->getArray();\n  for (int i = 0; i < N; ++i)\n    sum += h_array[i];\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, N != sum);\n\n  delete obj;\n\n  return errors;\n}\n\nint test_static () {\n\n  OMPVV_INFOMSG(\"Testing accessing a static variable\");\n\n  int errors = 0;\n  double res = 0.0;\n  \n#pragma omp target map(tofrom: res)\n  {\n    res = B::VAR;\n  } // end target\n\n  // checking results\n  OMPVV_TEST_AND_SET_VERBOSE(errors, std::abs(res - 1.0) > 0.0001)\n\n  return errors;\n}\n\nint test_static_method () {\n  OMPVV_INFOMSG(\"Testing static methods on the device\");\n\n  int errors = 0;\n  int value = 0;\n\n#pragma omp target map(tofrom: value) \n  {\n    value = B::staticMethod();yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n  } // end target\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, std::abs(value - 1.0) > 0.0001);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_static_method() != 0);\n  OMPVV_TEST_AND_SET_VERBOSE(errors,  test_static() != 0);\n  OMPVV_TEST_AND_SET_VERBOSE(errors,  test_explicit() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_parallel_for_reduction.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 1281",
        "issue_id": 2,
        "original_code": "//===----  test_target_teams_distribute_parallel_for_reduction.c--===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// testing the combined construct target teams distribute parallel for\n//\n//===---------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N_Els 1024\n\nint ReductionPlus() {\n  int ErrCount = 0;\n  int Arr[N_Els];\n  for (int i = 0; i < N_Els; ++i) {\n    Arr[i] = i + 1;\n  }\n  int Total = 0;\n\n#pragma omp target teams distribute parallel for reduction(+:Total)\n  for (int i = 0; i < N_Els; ++i) {\n    Total += Arr[i];\n  }\n  if (Total != (N_Els * ((N_Els) + 1)/2)) {\n    ErrCount++;\n  }\n  return ErrCount;\n}\n\nint ArrayReduction() {\n  int ErrCount = 0;\n  int Arr[N_Els][N_Els];\n  for (int j = 0; j < N_Els; ++j) {\n    for (int i = 0; i < N_Els; ++i) {\n      Arr[j][i] = i + 1;\n    }\n  }\n  int Total[N_Els];\n  for (int i = 0; i < N_Els; ++i) {\n    Total[i] = 0; \n  }\n  int i, j;\n#pragma omp target teams distribute parallel for reduction(+:Total[0:N_Els]) private(j)\n  for (i = 0; i < N_Els; ++i) {\n    for (j = 0; j < N_Els; ++j) {\n      Total[i] += Arr[i][j];\n    }\n  }\n\n  for (int i = 0; i < N_Els; ++i) {\n    if (Total[i] != (N_Els * (N_Els + 1)/2)) {\n      ErrCount++;\n    }\n  }\n  return ErrCount;\n}\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, ReductionPlus() != 0);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, ArrayReduction() != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===----  test_target_teams_distribute_parallel_for_reduction.c--===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// testing the combined construct target teams distribute parallel for\n//\n//===---------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N_Els 1024\n\nint ReductionPlus() {\n  int ErrCount = 0;\n  int Arr[N_Els];\n  for (int i = 0; i < N_Els; ++i) {\n    Arr[i] = i + 1;\n  }\n  int Total = 0;\n\n#pragma omp target teams distribute parallel for reduction(+:Total)\n  for (int i = 0; i < N_Els; ++i) {\n    Total += Arr[i];\n  }\n  if (Total != (N_Els * ((N_Els) + 1)/2)) {\n    ErrCount++;\n  }\n  return ErrCount;\n}\n\nint ArrayReduction() {\n  int ErrCount = 0;\n  int Arr[N_Els][N_Els];\n  for (int j = 0; j < N_Els; ++j) {\n    for (int i = 0; i < N_Els; ++i) {\n      Arr[j][i] = i + 1;\n    }\n  }\n  int Total[N_Els];\n  for (int i = 0; i < N_Els; ++i) {\n    Total[i] = 0; \n  }\n  int i, j;\n#pragma omp target teams distribute parallel for reduction(+:Total[0:N_Els]) private(j)\n  for (i = 0; i < N_Els; ++i) {\n    for (j = 0; j < N_Els; ++j) {\n      Total[i] += Arr[i][j];\n    }\n  }\n\n  for (int i = 0; i < N_Els; ++i) {\n    if (Total[i] != (N_Els * (N_Els + 1)/2)) {\n      ErrCount++;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n    }\n  }\n  return ErrCount;\n}\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, ReductionPlus() != 0);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, ArrayReduction() != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_parallel_for_if_parallel_modifier.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 5178",
        "issue_id": 1,
        "original_code": "//===---- test_target_teams_distribute_parallel_for_if_parallel_modifier.c ------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n// \n// In this test we want to try to check if the if clause is working \n// when used with the combined construct target teams distribute parallel for\n// and the parallel modifier is specified.\n// To do this we check if offloading is working, if it is not, it won't be\n// possible for us to tell if the test passed or not, since it depends on \n// offloading capabilities. \n//\n// The if has a directive-name-modifier that specifies to which directive the \n// if applies to (either both directives, to the target or to the parallel). \n// we create three test, one for no directive, another one for the target directive\n// and another one for the parallel directive \n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define ATTEMPT_THRESHOLD 70\n#define NUM_ATTEMPTS 100\n#define N 1024\n\nvoid checkPreconditions() {\n  // We test if offloading is enable, and if \n  // the number of threads is not 1. Having \n  // the number of threads equal to 1 is legal, but \n  // we won't be able to test if the if is \n  // affecting this or not\n\n  // Testing for offloading\n  int isOffloading = 0;\n  int i;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"With offloading off, it is not possible to test that if(parallel:) is not affecting the target offloading\");\n\n  // Testing for number of threads\n  int init_num_threads_dev[N], init_num_threads_host[N];\n  // init_num_threads_dev and init_num_threads_host arrays initialization\n  for (i = 0; i < N; i++) {\n    init_num_threads_dev[i] = 0;\n    init_num_threads_host[i] = 0;\n  }\n\n  // Get the init_num_threads for host and device. If it is 1, then we \n  // cannot test the if parallel \n  // See section 2.5.1 of the ref manual\n#pragma omp target teams distribute parallel for num_threads(OMPVV_NUM_THREADS_DEVICE)\n  for (i = 0; i < N; i++) {\n    init_num_threads_dev[i] = omp_get_num_threads();\n  }\n\n#pragma omp parallel for num_threads(OMPVV_NUM_THREADS_DEVICE)\n  for (i = 0; i < N; i++) {\n    init_num_threads_host[i] = omp_get_num_threads();\n  }\n  \n  // We check that not all the values are 1. This would make the test of if parallel\n  // not possible. \n  int raiseWarningDevice = 0, raiseWarningHost = 0;\n  for (i = 0; i < N; i++) {\n    if (init_num_threads_dev[i] > 1 ) {\n      raiseWarningDevice +=  1;\n    }\n    if ( init_num_threads_host[i] > 1) {\n      raiseWarningHost += 1;\n    }\n  }\n  OMPVV_WARNING_IF(raiseWarningDevice == 0, \"Initial number of threads in device was 1. It is not possible to test the if for the parallel directive\");\n  OMPVV_WARNING_IF(raiseWarningHost == 0, \"Initial number of threads in host was 1. It is not possible to test the if for parallel\");\n\n}\n\n\nint test_target_teams_distribute_if_parallel_modifier() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_if_parallel_modifier\");\n  \n  int a[N];\n  int warning[N] ; // num_threads = 1 is not technically an error\n  int attempt = 0;\n  int errors = 0;\n  int i;\n  \n  checkPreconditions();\n  // Initialize a and warning\n  for (i = 0; i < N; i++) {\n    a[i] = 0;\n    warning[i] = 0;\n  }\n\n  // We iterates NUM_ATTEMPTS times. When the iteration value is >= ATTEMPT_THRESHOLD the \n  // number of threads is expected to be greater than 1, (although if it is not, this is \n  // not an error, just warning)\n  // If the iteration variable attempt < ATTEMPT_THRESHOLD, the if condition evaluates \n  // to false, and then the number of threads should be 1. Regardless of the value of \n  // the condition the execution should always occur in the device. \n  // We check that when we are never executing on the host, and we check that when the \n  // condition evaluates to false, the number of threads is always 1. We also raise a \n  // warning if the number of threads is 1 when the condition evaluates to true. \n  for (attempt = 0; attempt < NUM_ATTEMPTS; ++attempt) {\n#pragma omp target teams distribute parallel for if(parallel: attempt >= ATTEMPT_THRESHOLD)\\\n    map(tofrom: a, warning) num_threads(OMPVV_NUM_THREADS_DEVICE)\n    for (i = 0; i < N; i++) {\n      if (omp_is_initial_device())\n        a[i] += 10; // This +10 should not happen\n\n      if (attempt >= ATTEMPT_THRESHOLD) {\n        // This is not an error, but we should mention it\n        if (omp_get_num_threads() == 1) {\n          warning[i] += 1;\n        }\n      } else {\n        a[i] += (omp_get_num_threads() != 1) ? 10 : 1;  \n      }\n    }\n  }\n\n  int raiseWarning = 0;\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, a[i] != ATTEMPT_THRESHOLD);\n    if (warning[i] != 0) {\n      raiseWarning++;\n    }\n  }\n\n  OMPVV_WARNING_IF(raiseWarning == N * (NUM_ATTEMPTS - ATTEMPT_THRESHOLD), \"The number of threads was 1 when a number > 1 was expected. if(parallel:true). Not a compliance error in the specs\");\n  OMPVV_ERROR_IF(errors, \"error in if(parallel: modifier). Possible causes are: the execution occurred in the host even though it should not affect the target region. The number of threads was > 1 when if(false).\");\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_if_parallel_modifier());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_teams_distribute_parallel_for_if_parallel_modifier.c ------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n// \n// In this test we want to try to check if the if clause is working \n// when used with the combined construct target teams distribute parallel for\n// and the parallel modifier is specified.\n// To do this we check if offloading is working, if it is not, it won't be\n// possible for us to tell if the test passed or not, since it depends on \n// offloading capabilities. \n//\n// The if has a directive-name-modifier that specifies to which directive the \n// if applies to (either both directives, to the target or to the parallel). \n// we create three test, one for no directive, another one for the target directive\n// and another one for the parallel directive \n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define ATTEMPT_THRESHOLD 70\n#define NUM_ATTEMPTS 100\n#define N 1024\n\nvoid checkPreconditions() {\n  // We test if offloading is enable, and if \n  // the number of threads is not 1. Having \n  // the number of threads equal to 1 is legal, but \n  // we won't be able to test if the if is \n  // affecting this or not\n\n  // Testing for offloading\n  int isOffloading = 0;\n  int i;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"With offloading off, it is not possible to test that if(parallel:) is not affecting the target offloading\");\n\n  // Testing for number of threads\n  int init_num_threads_dev[N], init_num_threads_host[N];\n  // init_num_threads_dev and init_num_threads_host arrays initialization\n  for (i = 0; i < N; i++) {\n    init_num_threads_dev[i] = 0;\n    init_num_threads_host[i] = 0;\n  }\n\n  // Get the init_num_threads for host and device. If it is 1, then we \n  // cannot test the if parallel \n  // See section 2.5.1 of the ref manual\n#pragma omp target teams distribute parallel for num_threads(OMPVV_NUM_THREADS_DEVICE)\n  for (i = 0; i < N; i++) {\n    init_num_threads_dev[i] = omp_get_num_threads();\n  }\n\n#pragma omp parallel for num_threads(OMPVV_NUM_THREADS_DEVICE)\n  for (i = 0; i < N; i++) {\n    init_num_threads_host[i] = omp_get_num_threads();\n  }\n  \n  // We check that not all the values are 1. This would make the test of if parallel\n  // not possible. \n  int raiseWarningDevice = 0, raiseWarningHost = 0;\n  for (i = 0; i < N; i++) {\n    if (init_num_threads_dev[i] > 1 ) {\n      raiseWarningDevice +=  1;\n    }\n    if ( init_num_threads_host[i] > 1) {\n      raiseWarningHost += 1;\n    }\n  }\n  OMPVV_WARNING_IF(raiseWarningDevice == 0, \"Initial number of threads in device was 1. It is not possible to test the if for the parallel directive\");\n  OMPVV_WARNING_IF(raiseWarningHost == 0, \"Initial number of threads in host was 1. It is not possible to test the if for parallel\");\n\n}\n\n\nint test_target_teams_distribute_if_parallel_modifier() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_if_parallel_modifier\");\n  \n  int a[N];\n  int warning[N] ; // num_threads = 1 is not technically an error\n  int attempt = 0;\n  int errors = 0;\n  int i;\n  \n  checkPreconditions();\n  // Initialize a and warning\n  for (i = 0; i < N; i++) {\n    a[i] = 0;\n    warning[i] = 0;\n  }\n\n  // We iterates NUM_ATTEMPTS times. When the iteration value is >= ATTEMPT_THRESHOLD the \n  // number of threads is expected to be greater than 1, (although if it is not, this is \n  // not an error, just warning)\n  // If the iteration variable attempt < ATTEMPT_THRESHOLD, the if condition evaluates \n  // to false, and then the number of threads should be 1. Regardless of the value of \n  // the condition the execution should always occur in the device. \n  // We check that when we are never executing on the host, and we check that when the \n  // condition evaluates to false, the number of threads is always 1. We also raise a \n  // warning if the number of threads is 1 when the condition evaluates to true. \n  for (attempt = 0; attempt < NUM_ATTEMPTS; ++attempt) {\n#pragma omp target teams distribute parallel for if(parallel: attempt >= ATTEMPT_THRESHOLD)\\\n    map(tofrom: a, warning) num_threads(OMPVV_NUM_THREADS_DEVICE)\n    for (i = 0; i < N; i++) {\n      if (omp_is_initial_device())\n        a[i] += 10; // This +10 should not happen\n\n      if (attempt >= ATTEMPT_THRESHOLD) {\n        // This is not an error, but we should mention it\n        if (omp_get_num_threads() == 1) {\n          warning[i] += 1;\n        }\n      } else {\n        a[i] += (omp_get_num_threads() != 1) ? 10 : 1;  \n      }\n    }\n  }\n\n  int raiseWarning = 0;\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, a[i] != ATTEMPT_THRESHOLD);\n    if (warning[i] != 0) {\n      raiseWarning++;\n    }\n  }\n\n  OMPVV_WARNING_IF(raiseWarning == N * (NUM_ATTEMPTS - ATTEMPT_THRESHOLD), \"The number of threads was 1 when a number > 1 was expected. if(parallel:true). Not a compliance error in the specs\");\n  OMPVV_ERROR_IF(errors, \"error in if(parallel: modifier). Possible causes are: the execution occurred in the host even though it should not affect the target region. The number of threads was > 1 when if(false).\");\n\n  return errors;\n}\n\nint main() \n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_if_parallel_modifier());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_defaultmap.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp declare\" at position 1591",
        "issue_id": 0,
        "original_code": "//===--- test_target_teams_distribute_defaultmap.c---------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the defaultmap clause on a target teams distribute directive.\n// This tests the following scalars: char, short, int, float, double, and enum.\n// Both using the clause defaultmap(tofrom:scalar) is used. When it is used,\n// the test tests the to nature by setting arrays to the value.  Then it is also\n// tested that, as opposed to the default action on scalars which is to first-\n// privatize them, they are shared and returned to the host.\n//\n// It also tests the default operation of treating scalars without the defaultmap\n// clause.  The test first tests the privatization of the firstprivatized\n// scalars and then separately tests the proper initialization of them separately\n//\n////===----------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define ARRAY_SIZE 1024\nenum enum_type { VAL1 = 1, VAL2, VAL3, VAL4};\n\nint test_defaultmap_on() {\n  OMPVV_INFOMSG(\"test_defaultmap_on\");\n\n  int errors = 0;\n\n  // we try with all the scalars\n  char scalar_char = 'a';\n  char char_array[ARRAY_SIZE];\n  short scalar_short = 10;\n  short short_array[ARRAY_SIZE];\n  int scalar_int = 11;\n  int int_array[ARRAY_SIZE];\n  float scalar_float = 5.5f;\n  float float_array[ARRAY_SIZE];\n  double scalar_double = 10.45;\n  double double_array[ARRAY_SIZE];\n  enum enum_type scalar_enum = VAL1;\n  enum enum_type enum_array[ARRAY_SIZE];\n\n#pragma omp target teams distribute defaultmap(tofrom: scalar) map(from: char_array[0:ARRAY_SIZE], \\\n                                                                   short_array[0:ARRAY_SIZE], \\\n                                                                   int_array[0:ARRAY_SIZE], \\\n                                                                   float_array[0:ARRAY_SIZE], \\\n                                                                   double_array[0:ARRAY_SIZE], \\\n                                                                   enum_array[0:ARRAY_SIZE])\n  for (int x = 0; x < ARRAY_SIZE; ++x){\n    char_array[x] = scalar_char;\n    short_array[x] = scalar_short;\n    int_array[x] = scalar_int;\n    float_array[x] = scalar_float;\n    double_array[x] = scalar_double;\n    enum_array[x] = scalar_enum;\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x){\n    OMPVV_TEST_AND_SET_VERBOSE(errors, char_array[x] != 'a');\n    if (char_array[x] != 1){\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x){\n    OMPVV_TEST_AND_SET_VERBOSE(errors, short_array[x] != 10);\n    if (short_array[x] != 2){\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x){\n    OMPVV_TEST_AND_SET_VERBOSE(errors, int_array[x] != 11);\n    if (int_array[x] != 3){\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x){\n    OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(float_array[x] - 5.5f) > .0000001);\n    if (fabs(float_array[x] - .4) > .0000000001){\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x){\n    OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(double_array[x] - 10.45) > .0000000001);\n    if (fabs(double_array[x] - .5) > .0000000001){\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x){\n    OMPVV_TEST_AND_SET_VERBOSE(errors, enum_array[x] != VAL1);\n    if (enum_array[x] != VAL2){\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x){\n    char_array[x] = 1;\n    short_array[x] = 2;\n    int_array[x] = 3;\n    float_array[x] = .4;\n    double_array[x] = .5;\n    enum_array[x] = VAL2;\n  }\n\n#pragma omp target teams distribute defaultmap(tofrom: scalar) map(tofrom: char_array[0:ARRAY_SIZE], \\\n                                                                   short_array[0:ARRAY_SIZE], \\\n                                                                   int_array[0:ARRAY_SIZE], \\\n                                                                   float_array[0:ARRAY_SIZE], \\\n                                                                   double_array[0:ARRAY_SIZE], \\\n                                                                   enum_array[0:ARRAY_SIZE])\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    if (omp_get_team_num() == 0) {\n      scalar_char = char_array[x];\n      scalar_short = short_array[x];\n      scalar_int = int_array[x];\n      scalar_float = float_array[x];\n      scalar_double = double_array[x];\n      scalar_enum = enum_array[x];\n    }\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_char != char_array[0]);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_short != short_array[0]);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_int != int_array[0]);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(scalar_float - float_array[0]) > .0000001);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(scalar_double - double_array[0]) > .0000000001);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_enum != enum_array[0]);\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, char_array[x] != 1);\n    if (char_array[x] != 1) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, short_array[x] != 2);\n    if (short_array[x] != 2) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, int_array[x] != 3);\n    if (int_array[x] != 3) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(float_array[x] - .4) > .0000001);\n    if (fabs(float_array[x] - .4) > .0000000001) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(double_array[x] - .5) > .0000000001);\n    if (fabs(double_array[x] - .5) > .0000000001) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, enum_array[x] != VAL2);\n    if (enum_array[x] != VAL2) {\n      break;\n    }\n  }\n\n  return errors;\n}\n\nint test_defaultmap_off() {\n  OMPVV_INFOMSG(\"test_defaultmap_off\");\n\n  int errors = 0;\n\n  // we try with all the scalars\n  char scalar_char = 'a';\n  char scalar_char_copy;\n  char char_array_a[ARRAY_SIZE];\n  char char_array_b[ARRAY_SIZE];\n  short scalar_short = 10;\n  short scalar_short_copy;\n  short short_array_a[ARRAY_SIZE];\n  short short_array_b[ARRAY_SIZE];\n  int scalar_int = 11;\n  int scalar_int_copy;\n  int int_array_a[ARRAY_SIZE];\n  int int_array_b[ARRAY_SIZE];\n  float scalar_float = 5.5f;\n  float scalar_float_copy;\n  float float_array_a[ARRAY_SIZE];\n  float float_array_b[ARRAY_SIZE];\n  double scalar_double = 10.45;\n  double scalar_double_copy;\n  double double_array_a[ARRAY_SIZE];\n  double double_array_b[ARRAY_SIZE];\n  enum enum_type scalar_enum = VAL1;\n  enum enum_type scalar_enum_copy;\n  enum enum_type enum_array_a[ARRAY_SIZE];\n  enum enum_type enum_array_b[ARRAY_SIZE];\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    char_array_a[x] = x%10;\n    char_array_b[x] = 0;\n    short_array_a[x] = x%20;\n    short_array_b[x] = 0;\n    int_array_a[x] = x%30;\n    int_array_b[x] = 0;\n    float_array_a[x] = x / 40.0;\n    float_array_b[x] = 0;\n    double_array_a[x] = x / 50.0;\n    double_array_b[x] = 0;\n    enum_array_a[x] = (enum enum_type)(x%4 + 1);\n    enum_array_b[x] = VAL1;\n  }\n\n\n  //Testing the privatization nature of firstprivate default action\n#pragma omp target teams distribute map(tofrom: char_array_a[0:ARRAY_SIZE], char_array_b[0:ARRAY_SIZE], \\\n                                        short_array_a[0:ARRAY_SIZE], short_array_b[0:ARRAY_SIZE], \\\n                                        int_array_a[0:ARRAY_SIZE], int_array_b[0:ARRAY_SIZE], \\\n                                        float_array_a[0:ARRAY_SIZE], float_array_b[0:ARRAY_SIZE], \\\n                                        double_array_a[0:ARRAY_SIZE], double_array_b[0:ARRAY_SIZE], \\\n                                        enum_array_a[0:ARRAY_SIZE], enum_array_b[0:ARRAY_SIZE])\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    scalar_char = 0;\n    for (int y = 0; y < char_array_a[x]; ++y) {\n      scalar_char += 1;\n    }\n    char_array_b[x] = scalar_char;\n    scalar_short = 0;\n    for (int y = 0; y < short_array_a[x]; ++y) {\n      scalar_short += 1;\n    }\n    short_array_b[x] = scalar_short;\n    scalar_int = 0;\n    for (int y = 0; y < int_array_a[x]; ++y) {\n      scalar_int += 1;\n    }\n    int_array_b[x] = scalar_int;\n    scalar_float = 0;\n    for (int y = 0; y < ((int)float_array_a[x]); ++y) {\n      scalar_float += .7f;\n    }\n    float_array_b[x] = scalar_float;\n    scalar_double = 0;\n    for (int y = 0; y < ((int)double_array_a[x]); ++y) {\n      scalar_double += .9;\n    }\n    double_array_b[x] = scalar_double;\n    scalar_enum = VAL1;\n    for (int y = 1; y < enum_array_a[x]; ++y) {\n      scalar_enum = (enum enum_type)(scalar_enum + 1);\n    }\n    enum_array_b[x] = scalar_enum;\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, char_array_b[x] != char_array_a[x]);\n    if (char_array_b[x] != char_array_a[x]) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, short_array_b[x] != short_array_a[x]);\n    if (short_array_b[x] != short_array_a[x]) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, int_array_b[x] != int_array_a[x]);\n    if (int_array_b[x] != int_array_a[x]) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(float_array_b[x] - (((int) float_array_a[x]) * .7)) > .00001);\n    if (fabs(float_array_b[x] - (((int) float_array_a[x]) * .7)) > .00001) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(double_array_b[x] - (((int) double_array_a[x]) * .9)) > .000000001);\n    if (fabs(double_array_b[x] - (((int) double_array_a[x]) * .9)) > .000000001) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, enum_array_b[x] != enum_array_a[x]);\n    if (enum_array_b[x] != enum_array_a[x]) {\n      break;\n    }\n  }\n\n  scalar_char = 26;\n  scalar_short = 126;\n  scalar_int = 5126;\n  scalar_float = 5.126;\n  scalar_double = 51.26;\n  scalar_enum = VAL2;\n\n  scalar_char_copy = scalar_char;\n  scalar_short_copy = scalar_short;\n  scalar_int_copy = scalar_int;\n  scalar_float_copy = scalar_float;\n  scalar_double_copy = scalar_double;\n  scalar_enum_copy = scalar_enum;\n\n  // Testing the copy of scalar values to the device\n#pragma omp target teams distribute map(tofrom: char_array_a[0:ARRAY_SIZE], short_array_a[0:ARRAY_SIZE], \\\n                                        int_array_a[0:ARRAY_SIZE], float_array_a[0:ARRAY_SIZE], \\\n                                        double_array_a[0:ARRAY_SIZE], enum_array_a[0:ARRAY_SIZE])\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    char_array_a[x] = scalar_char;\n    short_array_a[x] = scalar_short;\n    int_array_a[x] = scalar_int;\n    float_array_a[x] = scalar_float;\n    double_array_a[x] = scalar_double;\n    enum_array_a[x] = scalar_enum;\n  }\n\n  // Testing the fact that values should not be modified\n  // at the host (unless shared memory or running on the host)\n#pragma omp target teams distribute\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    scalar_char = 0;\n    scalar_short = 0;\n    scalar_int = 0;\n    scalar_float = 0;\n    scalar_double = 0;\n    scalar_enum = VAL3;\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, char_array_a[x] != scalar_char_copy);\n    if (char_array_a[x] != scalar_char_copy) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, short_array_a[x] != scalar_short_copy);\n    if (short_array_a[x] != scalar_short_copy) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, int_array_a[x] != scalar_int_copy);\n    if (int_array_a[x] != scalar_int_copy) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(float_array_a[x] - scalar_float_copy) > .00001);\n    if (fabs(float_array_a[x] - scalar_float_copy) > .00001) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(double_array_a[x] - scalar_double_copy) > .000000001);\n    if (fabs(double_array_a[x] - scalar_double_copy) > .000000001) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, enum_array_a[x] != scalar_enum_copy);\n    if (enum_array_a[x] != scalar_enum_copy) {\n      break;\n    }\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_char != scalar_char_copy);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_short != scalar_short_copy);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_int != scalar_int_copy);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(scalar_float - scalar_float_copy) > .00001);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(scalar_double - scalar_double_copy) > .000000001);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_enum != scalar_enum_copy);\n\n  return errors;\n}\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_defaultmap_on());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_defaultmap_off());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_defaultmap.c---------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the defaultmap clause on a target teams distribute directive.\n// This tests the following scalars: char, short, int, float, double, and enum.\n// Both using the clause defaultmap(tofrom:scalar) is used. When it is used,\n// the test tests the to nature by setting arrays to the value.  Then it is also\n// tested that, as opposed to the default action on scalars which is to first-\n// privatize them, they are shared and returned to the host.\n//\n// It also tests the default operation of treating scalars without the defaultmap\n// clause.  The test first tests the privatization of the firstprivatized\n// scalars and then separately tests the proper initialization of them separately\n//\n////===----------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define ARRAY_SIZE 1024\nenum enum_type { VAL1 = 1, VAL2, VAL3, VAL4};\n\nint test_defaultmap_on() {\n  OMPVV_INFOMSG(\"test_defaultmap_on\");\n\n  int errors = 0;\n\n  // we try with all the scalars\n  char scalar_char = 'a';\n  char char_array[ARRAY_SIZE];\n  short scalar_short = 10;\n  short short_array[ARRAY_SIZE];\n  int scalar_int = 11;\n  int int_array[ARRAY_SIZE];\n  float scalar_float = 5.5f;\n  float float_array[ARRAY_SIZE];\n  double scalar_double = 10.45;\n  double double_array[ARRAY_SIZE];\n  enum enum_type scalar_enum = VAL1;\n  enum enum_type enum_array[ARRAY_SIZE];\n\n#pragma omp declare teams distribute defaultmap(tofrom: scalar) map(from: char_array[0:ARRAY_SIZE], \\\n                                                                   short_array[0:ARRAY_SIZE], \\\n                                                                   int_array[0:ARRAY_SIZE], \\\n                                                                   float_array[0:ARRAY_SIZE], \\\n                                                                   double_array[0:ARRAY_SIZE], \\\n                                                                   enum_array[0:ARRAY_SIZE])\n  for (int x = 0; x < ARRAY_SIZE; ++x){\n    char_array[x] = scalar_char;\n    short_array[x] = scalar_short;\n    int_array[x] = scalar_int;\n    float_array[x] = scalar_float;\n    double_array[x] = scalar_double;\n    enum_array[x] = scalar_enum;\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x){\n    OMPVV_TEST_AND_SET_VERBOSE(errors, char_array[x] != 'a');\n    if (char_array[x] != 1){\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x){\n    OMPVV_TEST_AND_SET_VERBOSE(errors, short_array[x] != 10);\n    if (short_array[x] != 2){\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x){\n    OMPVV_TEST_AND_SET_VERBOSE(errors, int_array[x] != 11);\n    if (int_array[x] != 3){\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x){\n    OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(float_array[x] - 5.5f) > .0000001);\n    if (fabs(float_array[x] - .4) > .0000000001){\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x){\n    OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(double_array[x] - 10.45) > .0000000001);\n    if (fabs(double_array[x] - .5) > .0000000001){\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x){\n    OMPVV_TEST_AND_SET_VERBOSE(errors, enum_array[x] != VAL1);\n    if (enum_array[x] != VAL2){\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x){\n    char_array[x] = 1;\n    short_array[x] = 2;\n    int_array[x] = 3;\n    float_array[x] = .4;\n    double_array[x] = .5;\n    enum_array[x] = VAL2;\n  }\n\n#pragma omp target teams distribute defaultmap(tofrom: scalar) map(tofrom: char_array[0:ARRAY_SIZE], \\\n                                                                   short_array[0:ARRAY_SIZE], \\\n                                                                   int_array[0:ARRAY_SIZE], \\\n                                                                   float_array[0:ARRAY_SIZE], \\\n                                                                   double_array[0:ARRAY_SIZE], \\\n                                                                   enum_array[0:ARRAY_SIZE])\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    if (omp_get_team_num() == 0) {\n      scalar_char = char_array[x];\n      scalar_short = short_array[x];\n      scalar_int = int_array[x];\n      scalar_float = float_array[x];\n      scalar_double = double_array[x];\n      scalar_enum = enum_array[x];\n    }\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_char != char_array[0]);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_short != short_array[0]);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_int != int_array[0]);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(scalar_float - float_array[0]) > .0000001);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(scalar_double - double_array[0]) > .0000000001);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_enum != enum_array[0]);\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, char_array[x] != 1);\n    if (char_array[x] != 1) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, short_array[x] != 2);\n    if (short_array[x] != 2) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, int_array[x] != 3);\n    if (int_array[x] != 3) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(float_array[x] - .4) > .0000001);\n    if (fabs(float_array[x] - .4) > .0000000001) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(double_array[x] - .5) > .0000000001);\n    if (fabs(double_array[x] - .5) > .0000000001) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, enum_array[x] != VAL2);\n    if (enum_array[x] != VAL2) {\n      break;\n    }\n  }\n\n  return errors;\n}\n\nint test_defaultmap_off() {\n  OMPVV_INFOMSG(\"test_defaultmap_off\");\n\n  int errors = 0;\n\n  // we try with all the scalars\n  char scalar_char = 'a';\n  char scalar_char_copy;\n  char char_array_a[ARRAY_SIZE];\n  char char_array_b[ARRAY_SIZE];\n  short scalar_short = 10;\n  short scalar_short_copy;\n  short short_array_a[ARRAY_SIZE];\n  short short_array_b[ARRAY_SIZE];\n  int scalar_int = 11;\n  int scalar_int_copy;\n  int int_array_a[ARRAY_SIZE];\n  int int_array_b[ARRAY_SIZE];\n  float scalar_float = 5.5f;\n  float scalar_float_copy;\n  float float_array_a[ARRAY_SIZE];\n  float float_array_b[ARRAY_SIZE];\n  double scalar_double = 10.45;\n  double scalar_double_copy;\n  double double_array_a[ARRAY_SIZE];\n  double double_array_b[ARRAY_SIZE];\n  enum enum_type scalar_enum = VAL1;\n  enum enum_type scalar_enum_copy;\n  enum enum_type enum_array_a[ARRAY_SIZE];\n  enum enum_type enum_array_b[ARRAY_SIZE];\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    char_array_a[x] = x%10;\n    char_array_b[x] = 0;\n    short_array_a[x] = x%20;\n    short_array_b[x] = 0;\n    int_array_a[x] = x%30;\n    int_array_b[x] = 0;\n    float_array_a[x] = x / 40.0;\n    float_array_b[x] = 0;\n    double_array_a[x] = x / 50.0;\n    double_array_b[x] = 0;\n    enum_array_a[x] = (enum enum_type)(x%4 + 1);\n    enum_array_b[x] = VAL1;\n  }\n\n\n  //Testing the privatization nature of firstprivate default action\n#pragma omp target teams distribute map(tofrom: char_array_a[0:ARRAY_SIZE], char_array_b[0:ARRAY_SIZE], \\\n                                        short_array_a[0:ARRAY_SIZE], short_array_b[0:ARRAY_SIZE], \\\n                                        int_array_a[0:ARRAY_SIZE], int_array_b[0:ARRAY_SIZE], \\\n                                        float_array_a[0:ARRAY_SIZE], float_array_b[0:ARRAY_SIZE], \\\n                                        double_array_a[0:ARRAY_SIZE], double_array_b[0:ARRAY_SIZE], \\\n                                        enum_array_a[0:ARRAY_SIZE], enum_array_b[0:ARRAY_SIZE])\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    scalar_char = 0;\n    for (int y = 0; y < char_array_a[x]; ++y) {\n      scalar_char += 1;\n    }\n    char_array_b[x] = scalar_char;\n    scalar_short = 0;\n    for (int y = 0; y < short_array_a[x]; ++y) {\n      scalar_short += 1;\n    }\n    short_array_b[x] = scalar_short;\n    scalar_int = 0;\n    for (int y = 0; y < int_array_a[x]; ++y) {\n      scalar_int += 1;\n    }\n    int_array_b[x] = scalar_int;\n    scalar_float = 0;\n    for (int y = 0; y < ((int)float_array_a[x]); ++y) {\n      scalar_float += .7f;\n    }\n    float_array_b[x] = scalar_float;\n    scalar_double = 0;\n    for (int y = 0; y < ((int)double_array_a[x]); ++y) {\n      scalar_double += .9;\n    }\n    double_array_b[x] = scalar_double;\n    scalar_enum = VAL1;\n    for (int y = 1; y < enum_array_a[x]; ++y) {\n      scalar_enum = (enum enum_type)(scalar_enum + 1);\n    }\n    enum_array_b[x] = scalar_enum;\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, char_array_b[x] != char_array_a[x]);\n    if (char_array_b[x] != char_array_a[x]) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, short_array_b[x] != short_array_a[x]);\n    if (short_array_b[x] != short_array_a[x]) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, int_array_b[x] != int_array_a[x]);\n    if (int_array_b[x] != int_array_a[x]) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(float_array_b[x] - (((int) float_array_a[x]) * .7)) > .00001);\n    if (fabs(float_array_b[x] - (((int) float_array_a[x]) * .7)) > .00001) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(double_array_b[x] - (((int) double_array_a[x]) * .9)) > .000000001);\n    if (fabs(double_array_b[x] - (((int) double_array_a[x]) * .9)) > .000000001) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, enum_array_b[x] != enum_array_a[x]);\n    if (enum_array_b[x] != enum_array_a[x]) {\n      break;\n    }\n  }\n\n  scalar_char = 26;\n  scalar_short = 126;\n  scalar_int = 5126;\n  scalar_float = 5.126;\n  scalar_double = 51.26;\n  scalar_enum = VAL2;\n\n  scalar_char_copy = scalar_char;\n  scalar_short_copy = scalar_short;\n  scalar_int_copy = scalar_int;\n  scalar_float_copy = scalar_float;\n  scalar_double_copy = scalar_double;\n  scalar_enum_copy = scalar_enum;\n\n  // Testing the copy of scalar values to the device\n#pragma omp target teams distribute map(tofrom: char_array_a[0:ARRAY_SIZE], short_array_a[0:ARRAY_SIZE], \\\n                                        int_array_a[0:ARRAY_SIZE], float_array_a[0:ARRAY_SIZE], \\\n                                        double_array_a[0:ARRAY_SIZE], enum_array_a[0:ARRAY_SIZE])\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    char_array_a[x] = scalar_char;\n    short_array_a[x] = scalar_short;\n    int_array_a[x] = scalar_int;\n    float_array_a[x] = scalar_float;\n    double_array_a[x] = scalar_double;\n    enum_array_a[x] = scalar_enum;\n  }\n\n  // Testing the fact that values should not be modified\n  // at the host (unless shared memory or running on the host)\n#pragma omp target teams distribute\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    scalar_char = 0;\n    scalar_short = 0;\n    scalar_int = 0;\n    scalar_float = 0;\n    scalar_double = 0;\n    scalar_enum = VAL3;\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, char_array_a[x] != scalar_char_copy);\n    if (char_array_a[x] != scalar_char_copy) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, short_array_a[x] != scalar_short_copy);\n    if (short_array_a[x] != scalar_short_copy) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, int_array_a[x] != scalar_int_copy);\n    if (int_array_a[x] != scalar_int_copy) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(float_array_a[x] - scalar_float_copy) > .00001);\n    if (fabs(float_array_a[x] - scalar_float_copy) > .00001) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(double_array_a[x] - scalar_double_copy) > .000000001);\n    if (fabs(double_array_a[x] - scalar_double_copy) > .000000001) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, enum_array_a[x] != scalar_enum_copy);\n    if (enum_array_a[x] != scalar_enum_copy) {\n      break;\n    }\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_char != scalar_char_copy);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_short != scalar_short_copy);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_int != scalar_int_copy);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(scalar_float - scalar_float_copy) > .00001);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(scalar_double - scalar_double_copy) > .000000001);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_enum != scalar_enum_copy);\n\n  return errors;\n}\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_defaultmap_on());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_defaultmap_off());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/offloading_success.cpp",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "#include <stdio.h>\n#include <omp.h>\n\nint main(void) {\n  int isHost = 0;\n\n#pragma omp target map(from: isHost)\n  { isHost = omp_is_initial_device(); }\n\n  if (isHost < 0) {\n    printf(\"Runtime error, isHost=%d\\n\", isHost);\n  }\n\n  // CHECK: Target region executed on the device\n  printf(\"Target region executed on the %s\\n\", isHost ? \"host\" : \"device\");\n\n  return isHost;\n}\n",
        "error_code": "#include <iostream>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nfloat gvuriekkht = 185;\nbyte slcoeozoog = 228;\nlong xostnravwi = 22;\nlong dcxenhgjbb = 184;\nshort srubkcmsmt = 100;\nshort zvyoicctcf = 35;\nshort pmwliswody = 203;\ndouble lbqyjdfebc = 64;\nlong mrxuwujgul = 146;\nbyte urpobcjifx = 251;\nfloat eslrbhbglx = 253;\nshort opqhzbkivx = 169;\nint bxclupbouu = 76;\ndouble fyywplistq = 98;\nshort epdxitooyf = 61;\ndouble bapbswjvst = 56;\nbyte lbqdxpqpcg = 15;\nshort wvlkkwuzku = 124;\nshort kvlipodhdv = 34;\nbyte bkckzjjrrg = 159;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    std::cout << \"Sum of \" << num1 << \" and \" << num2 << \" is \" << sum << std::endl;\n    return 0;\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_reduction_bitand.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 2361",
        "issue_id": 1,
        "original_code": "//===--- test_target_teams_distribute_reduction_bitand.c---------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the reduction clause on a target teams distribute directive,\n// testing that the variable in the reduction clause is properly reduced using\n// the bitand operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n#define THRESHOLD 512\n\nint test_bitand() {\n  unsigned int a[N];\n  double false_margin = pow(exp(1), log(.5)/N); // See the 'and' operator test for\n  int errors = 0;                               // an exaplantion of this math.\n  int num_teams[N];\n  int num_attempts = 0;\n  int have_true = 0, have_false = 0;\n  srand(1);\n\n  while ((!have_true || !have_false) && (num_attempts < THRESHOLD)) {\n    have_true = 0;\n    have_false = 0;\n    for (int x = 0; x < N; ++x) {\n      for (int y = 0; y < 16; ++y) {\n        if (rand() / (double) RAND_MAX < false_margin) {\n          a[x] += (1 << y);\n          have_true = 1;\n        } else {\n          have_false = 1;\n        }\n      }\n      num_teams[x] = -x;\n    }\n    num_attempts++;\n  }\n\n  OMPVV_WARNING_IF(!have_true, \"No true bits were generated to test\");\n  OMPVV_WARNING_IF(!have_false, \"No false bits were generated to test\");\n\n  unsigned int b = 0;\n  for (int x = 0; x < 16; ++x) {\n    b = b + (1 << x);\n  }\n\n#pragma omp target teams distribute reduction(&:b) defaultmap(tofrom:scalar)\n  for (int x = 0; x < N; ++x) {\n    num_teams[x] = omp_get_num_teams();\n    b = b & a[x];\n  }\n\n  unsigned int host_b = a[0];\n\n  for (int x = 0; x < N; ++x) {\n    host_b = host_b & a[x];\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_teams[x - 1] != num_teams[x], \"Kernel reported differing numbers of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_teams[0] == 1, \"Test operated with one team.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_teams[0] <= 0, \"Test reported invalid number of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, b != host_b);\n  OMPVV_ERROR_IF(host_b != b, \"Bit on device is %d but expected bit from host is %d.\", b, host_b);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_bitand() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_reduction_bitand.c---------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the reduction clause on a target teams distribute directive,\n// testing that the variable in the reduction clause is properly reduced using\n// the bitand operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n#define THRESHOLD 512\n\nint test_bitand() {\n  unsigned int a[N];\n  double false_margin = pow(exp(1), log(.5)/N); // See the 'and' operator test for\n  int errors = 0;                               // an exaplantion of this math.\n  int num_teams[N];\n  int num_attempts = 0;\n  int have_true = 0, have_false = 0;\n  srand(1);\n\n  while ((!have_true || !have_false) && (num_attempts < THRESHOLD)) {\n    have_true = 0;\n    have_false = 0;\n    for (int x = 0; x < N; ++x) {\n      for (int y = 0; y < 16; ++y) {\n        if (rand() / (double) RAND_MAX < false_margin) {\n          a[x] += (1 << y);\n          have_true = 1;\n        } else {\n          have_false = 1;\n        }\n      }\n      num_teams[x] = -x;\n    }\n    num_attempts++;\n  }\n\n  OMPVV_WARNING_IF(!have_true, \"No true bits were generated to test\");\n  OMPVV_WARNING_IF(!have_false, \"No false bits were generated to test\");\n\n  unsigned int b = 0;\n  for (int x = 0; x < 16; ++x) {\n    b = b + (1 << x);\n  }\n\n#pragma omp target teams distribute reduction(&:b) defaultmap(tofrom:scalar)\n  for (int x = 0; x < N; ++x) {\n    num_teams[x] = omp_get_num_teams();\n    b = b & a[x];\n  }\n\n  unsigned int host_b = a[0];\n\n  for (int x = 0; x < N; ++x) {\n    host_b = host_b & a[x];\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_teams[x - 1] != num_teams[x], \"Kernel reported differing numbers of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_teams[0] == 1, \"Test operated with one team.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_teams[0] <= 0, \"Test reported invalid number of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, b != host_b);\n  OMPVV_ERROR_IF(host_b != b, \"Bit on device is %d but expected bit from host is %d.\", b, host_b);\n\n  return errors;\n}\n\nint main() \n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_bitand() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_thread_limit.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp map\" at position 715",
        "issue_id": 0,
        "original_code": "//===--- test_target_teams_distribute_thread_limit.c--------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the thread_limit clause on a target teams distribute directive to\n// indicate a requested number of threads to execute the teams distribute region.\n// The specifications indicate that the number of threads that are given can be any\n// number that is equal to or less than the indicated value. \n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_target_teams_distribute_thread_limit(){\n  int num_threads = -9;\n  int errors = 0;\n  \n  \n  #pragma omp target teams distribute thread_limit(4) map(from: num_threads)\n    for (int x = 0; x < N; ++x) {\n      if (omp_get_team_num() == 0) {\n        #pragma omp parallel\n        {\n        if (omp_get_thread_num() == 0)\n          num_threads = omp_get_num_threads();\n        }\n      }\n    }\n    OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads > 4);\n\n  return errors;\n\n}\n\nint main(){\n  int errors = 0;\n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_thread_limit() != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n",
        "error_code": "//===--- test_target_teams_distribute_thread_limit.c--------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the thread_limit clause on a target teams distribute directive to\n// indicate a requested number of threads to execute the teams distribute region.\n// The specifications indicate that the number of threads that are given can be any\n// number that is equal to or less than the indicated value. \n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_target_teams_distribute_thread_limit(){\n  int num_threads = -9;\n  int errors = 0;\n  \n  \n  #pragma omp map teams distribute thread_limit(4) map(from: num_threads)\n    for (int x = 0; x < N; ++x) {\n      if (omp_get_team_num() == 0) {\n        #pragma omp parallel\n        {\n        if (omp_get_thread_num() == 0)\n          num_threads = omp_get_num_threads();\n        }\n      }\n    }\n    OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads > 4);\n\n  return errors;\n\n}\n\nint main(){\n  int errors = 0;\n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_thread_limit() != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_nowait.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n      was_async = 1;\n      break;\n    }\" at position 1958",
        "issue_id": 4,
        "original_code": "//===--- test_target_teams_distribute_nowait.c-------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the nowait clause on a target teams distribute directive and\n// uses a barrier to resyncronize the target regions.  Since we can't be sure\n// that operations will be asyncronous, we can only raise a warning if they are\n// not executed asynchronously.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n#define N_TASKS 16\n#define ITERATIONS 1024\n\nint main() {\n  OMPVV_WARNING(\"This test does not throw an error if tasks fail to execute asynchronously, as this is still correct behavior. If execution is not asynchronous, we will throw a warning.\");\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  int64_t work_storage[N_TASKS][N];\n  int order[N_TASKS];  // Each position marks the order in which that task executed\n  int errors = 0;\n  int ticket[1] = {0};\n\n\n#pragma omp target enter data map(to: ticket[0:1], order[0:N_TASKS])\n\n  for (int i = 0; i < N_TASKS; ++i) {\n#pragma omp target teams distribute map(alloc: work_storage[i][0:N], ticket[0:1]) nowait\n    for (int j = 0; j < N; ++j) {\n      work_storage[i][j] = 0;\n      for (int k = 0; k < N*(N_TASKS - i); ++k) { // Creates skewed work distribution\n\twork_storage[i][j] += k*i*j;              // This value will not be verified\n      }\n      int my_ticket = 0;\n#pragma omp atomic capture\n      my_ticket = ticket[0]++;\n      order[i] = my_ticket;\n    }\n  }\n#pragma omp taskwait\n\n#pragma omp target exit data map(from:ticket[0:1], order[0:N_TASKS])\n\n  if (ticket[0] != N_TASKS*N) {\n    OMPVV_ERROR(\"The test registered a different number of target regions than were spawned\");\n    errors = 1;\n  }\n\n  int was_async = 0;\n  for (int i = 1; i < N_TASKS; ++i) {\n    if (order[i] <= order[i - 1]) {\n      was_async = 1;\n      break;\n    }\n  }\n\n  OMPVV_WARNING_IF(!was_async, \"We could not detect asynchronous behavior between target regions\");\n  OMPVV_INFOMSG_IF(was_async, \"Asynchronous behavior detected, this suggests nowait had an effect\");\n  \n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_nowait.c-------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the nowait clause on a target teams distribute directive and\n// uses a barrier to resyncronize the target regions.  Since we can't be sure\n// that operations will be asyncronous, we can only raise a warning if they are\n// not executed asynchronously.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n#define N_TASKS 16\n#define ITERATIONS 1024\n\nint main() {\n  OMPVV_WARNING(\"This test does not throw an error if tasks fail to execute asynchronously, as this is still correct behavior. If execution is not asynchronous, we will throw a warning.\");\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  int64_t work_storage[N_TASKS][N];\n  int order[N_TASKS];  // Each position marks the order in which that task executed\n  int errors = 0;\n  int ticket[1] = {0};\n\n\n#pragma omp target enter data map(to: ticket[0:1], order[0:N_TASKS])\n\n  for (int i = 0; i < N_TASKS; ++i) {\n#pragma omp target teams distribute map(alloc: work_storage[i][0:N], ticket[0:1]) nowait\n    for (int j = 0; j < N; ++j) {\n      work_storage[i][j] = 0;\n      for (int k = 0; k < N*(N_TASKS - i); ++k) { // Creates skewed work distribution\n\twork_storage[i][j] += k*i*j;              // This value will not be verified\n      }\n      int my_ticket = 0;\n#pragma omp atomic capture\n      my_ticket = ticket[0]++;\n      order[i] = my_ticket;\n    }\n  }\n#pragma omp taskwait\n\n#pragma omp target exit data map(from:ticket[0:1], order[0:N_TASKS])\n\n  if (ticket[0] != N_TASKS*N) {\n    OMPVV_ERROR(\"The test registered a different number of target regions than were spawned\");\n    errors = 1;\n  }\n\n  int was_async = 0;\n  for (int i = 1; i < N_TASKS; ++i) {\n    if (order[i] <= order[i - 1]) \n  }\n\n  OMPVV_WARNING_IF(!was_async, \"We could not detect asynchronous behavior between target regions\");\n  OMPVV_INFOMSG_IF(was_async, \"Asynchronous behavior detected, this suggests nowait had an effect\");\n  \n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_taskloop_private.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//---------------------------------------- test_taskloop_private.c -----------------------------------------//\n//\n// OpenMP API Version 4.5 August 2015\n//\n// This test checks the taskloop directive with the 'private' clause specified.\n// The 'taskloop' construct parallels loops with independent iterations by creating tasks.\n// It allows for efficient parallel execution of loop iterations by distributing them among multiple threads. \n// The 'private' clause ensures that each task should have private copies. \n//----------------------------------------------------------------------------------------------------------//\n\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define NUM_THREADS 100\n#define NUM_TASKS 5\n\nint test_taskloop_private() {\n\n   int errors = 0;\n\n   int private_var;\n   int shared_var_sum = 0;\n\n   #pragma omp parallel num_threads(NUM_THREADS)\n   {\n\t    #pragma omp single\n   \t    {\n\t\t    #pragma omp taskloop private(private_var)\n            for(int i = 0; i < NUM_TASKS; i++)\n\t\t    {\n            \tint sum = 0;\n\t    \t\tfor(private_var = 0; private_var < 5; private_var++)\n\t    \t\t\tsum += private_var;\n\n\t\t\t    #pragma omp atomic\n\t    \t\tshared_var_sum += sum;\n\t \t    }\n   \t    }\n   }\n\n   //check if the value of shared_var_sum is equal to (NUM_TASKS * 10)\n   OMPVV_TEST_AND_SET_VERBOSE(errors, shared_var_sum != (NUM_TASKS * 10));\n\n   return errors;\n}\n\n\nint main() {\n  \n  int errors = 0;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, (test_taskloop_private()) != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n\n  return 0;\n}\n\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\ndouble dvnrsqmjif = 242;\nfloat buaevghslt = 46;\nshort sxevmrqpxe = 220;\nfloat jcekvnsvqr = 209;\nbyte dehaelwran = 203;\nint twmbduyhwd = 89;\nint jedlmudxtn = 240;\nfloat pdhngilqsa = 14;\ndouble jwvcygmyxr = 235;\ndouble zvxezceskh = 172;\nint ohjcdcnegg = 202;\nint kchoyhjkzj = 250;\ndouble trijueuqqp = 35;\nfloat pzpxwfqwiv = 149;\nfloat fosdxmqbzv = 176;\nbyte paergzeolf = 81;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_update_to.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp flush\" at position 793",
        "issue_id": 0,
        "original_code": "//===--- test_target_update_to.c ------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks target update with the 'to' clause by checking that\n// after a target update to is applied to an array, the device reads and\n// uses the expected, new value rather than the previous value.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint a[N];\nint b[N];\nint c[N];\n\nvoid update_b() {\n  int i;\n  for (i = 0; i < N; i++) {\n    b[i] = b[i] * 2;\n  }\n}\n\n// Test for OpenMP 4.5 target update with to\nint main() {\n  int errors= 0;\n  int i = 0;\n\n  OMPVV_TEST_OFFLOADING;\n\n  for (i = 0; i < N; i++) {\n    a[i] = 10;\n    b[i] = 2;\n    c[i] = 0;\n  }\n\n#pragma omp target data map(to: a[:N], b[:N]) map(from: c)\n  {\n#pragma omp target\n    {\n      int j = 0;\n      for (j = 0; j < N; j++) {\n        c[j] = (a[j] + b[j]);        // c = 12\n      }\n    }\n\n    update_b();\n\n#pragma omp target update to(b[:N])  // update b = 4\n\n#pragma omp target\n    {\n      int j = 0;\n      for (j = 0; j < N; j++) {\n        c[j] = (c[j] + b[j]);        // c = 16\n      }\n    }\n  }\n\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, c[i] != 16);\n  }\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_update_to.c ------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks target update with the 'to' clause by checking that\n// after a target update to is applied to an array, the device reads and\n// uses the expected, new value rather than the previous value.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint a[N];\nint b[N];\nint c[N];\n\nvoid update_b() {\n  int i;\n  for (i = 0; i < N; i++) {\n    b[i] = b[i] * 2;\n  }\n}\n\n// Test for OpenMP 4.5 target update with to\nint main() {\n  int errors= 0;\n  int i = 0;\n\n  OMPVV_TEST_OFFLOADING;\n\n  for (i = 0; i < N; i++) {\n    a[i] = 10;\n    b[i] = 2;\n    c[i] = 0;\n  }\n\n#pragma omp flush data map(to: a[:N], b[:N]) map(from: c)\n  {\n#pragma omp target\n    {\n      int j = 0;\n      for (j = 0; j < N; j++) {\n        c[j] = (a[j] + b[j]);        // c = 12\n      }\n    }\n\n    update_b();\n\n#pragma omp target update to(b[:N])  // update b = 4\n\n#pragma omp target\n    {\n      int j = 0;\n      for (j = 0; j < N; j++) {\n        c[j] = (c[j] + b[j]);        // c = 16\n      }\n    }\n  }\n\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, c[i] != 16);\n  }\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/gridmini_map_struct_float_mul.cpp",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===-- gridmini_float_mul_offload.c ---------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks that the float multiplication of members of the struct 'vec'\n// in the offloaded region provides the same answer as calculated by host. \n// Since support for struct on map is implementation specific in 4.5 the test does \n// not have a fail condition. \n//\n//===----------------------------------------------------------------------===//\n\n#include <cstdlib>\n#include <stdio.h>\n#include <iostream>\n#include \"ompvv.h\"\n#include \"omp.h\"\n\nusing namespace std;\nstruct vec {\n  float v1;\n  float v2;\n};\n\ninline  vec mult(vec x, vec y){\n  vec out;\n  out.v1 = x.v1*y.v1;\n  out.v2 = x.v2*y.v2;\n  return out;\n}\n\nint main(int argc, char* argv[]){\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n  int N = 10;\n  float x = (float)rand()/(float)(RAND_MAX/10.0);\n  float y = (float)rand()/(float)(RAND_MAX/5.0);\n  vec in1,in2;\n  in1.v1 = x;\n  in1.v2 = x;\n  in2.v1 = y;\n  in2.v2 = y;\n  vec out[N];\n\n  //calulate on host\n  vec expected = mult(in1,in2);\n\n#pragma omp target teams distribute parallel for map(to:in1,in2) map(from:out[0:N])\n    for(int n = 0; n < N; n++) {\n      out[n] = mult(in1,in2);\n    }\n    \n  for(int n = 0; n < N; n++) {\n    OMPVV_TEST_AND_SET(errors,out[n].v1 != expected.v1);\n    OMPVV_TEST_AND_SET(errors,out[n].v2 != expected.v2);\n  }\n  if(errors)\n    OMPVV_INFOMSG(\"Maping of entire struct is not supported by this OpenMP implementation.\\n\");\t\n\n  //No error will be reported even if it is recorded.\n  OMPVV_REPORT_AND_RETURN(0);\n\n}\n\n",
        "error_code": "#include <iostream>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nshort dduyztjkng = 108;\nlong ehepglrttq = 54;\nlong tgzlhxjwmo = 244;\nfloat tswbgsrjhg = 141;\ndouble renwouilyy = 170;\nfloat gbltigvyrb = 66;\ndouble gkeoylmsgr = 150;\ndouble opezhxntux = 170;\nlong otbvxyqmpa = 133;\nint cclclaeyju = 148;\nlong lcnesfcjow = 91;\nshort lxwvkrdxvv = 156;\nshort xvamcvhtht = 50;\nshort kbqnanflyo = 18;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    std::cout << \"Sum of \" << num1 << \" and \" << num2 << \" is \" << sum << std::endl;\n    return 0;\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_reduction_add.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_add() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\" at position 1624",
        "issue_id": 4,
        "original_code": "//===--- test_target_teams_distribute_reduction_add.c-------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the reduction clause on a target teams distribute directive,\n// testing that the variable in the reduction clause is properly reduced using\n// the add operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_add() {\n  int a[N];\n  int b[N];\n  int total = 0;\n  int host_total = 0;\n  int errors = 0;\n  int num_teams[N];\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    num_teams[x] = -1;\n  }\n\n#pragma omp target teams distribute reduction(+:total) defaultmap(tofrom:scalar)\n  for (int x = 0; x < N; ++x) {\n    num_teams[x] = omp_get_num_teams();\n    total += a[x] + b[x];\n  }\n\n  for (int x = 0; x < N; ++x) {\n    host_total += a[x] + b[x];\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_teams[x - 1] != num_teams[x], \"Kernel reported differing numbers of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_teams[0] == 1, \"Test operated with one team.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_teams[0] <= 0, \"Test reported invalid number of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, host_total != total);\n  OMPVV_ERROR_IF(host_total != total, \"Total on device is %d but expected total from host is %d.\", total, host_total);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_add() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_reduction_add.c-------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the reduction clause on a target teams distribute directive,\n// testing that the variable in the reduction clause is properly reduced using\n// the add operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_add() {\n  int a[N];\n  int b[N];\n  int total = 0;\n  int host_total = 0;\n  int errors = 0;\n  int num_teams[N];\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    num_teams[x] = -1;\n  }\n\n#pragma omp target teams distribute reduction(+:total) defaultmap(tofrom:scalar)\n  for (int x = 0; x < N; ++x) {\n    num_teams[x] = omp_get_num_teams();\n    total += a[x] + b[x];\n  }\n\n  for (int x = 0; x < N; ++x) {\n    host_total += a[x] + b[x];\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_teams[x - 1] != num_teams[x], \"Kernel reported differing numbers of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_teams[0] == 1, \"Test operated with one team.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_teams[0] <= 0, \"Test reported invalid number of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, host_total != total);\n  OMPVV_ERROR_IF(host_total != total, \"Total on device is %d but expected total from host is %d.\", total, host_total);\n\n  return errors;\n}\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_nested_target_simd.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 1752",
        "issue_id": 2,
        "original_code": "//===---- test_target_simd.c - Using simd directive inside of a terget region -===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// SIMD in OpenMP 4.5 does not have any API that allows us to confirm the creation \n// of SIMD lanes, nor the use of SIMD instructions in any architecture. Hence, our\n// tests are limited in that they check that the expected result is created, but\n// assume nothing in how they are mapped into a particular architecture\n//\n// This test creates a regular for loop and uses the SIMD directive inside \n// a target region then it checks that the values of the array are as expected\n//===--------------------------------------------------------------------------===//\n//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define ARRAY_SIZE 1024\n\nint test_target_simd() {\n  OMPVV_INFOMSG(\"test_target_simd\");\n  OMPVV_WARNING(\"This test cannot check if actual SIMD extensions at the hardware level\"\n                 \" were used, or of the generated code is different in any way\");\n\n  // Variable for errors counting\n  int errors = 0;\n\n  int a[ARRAY_SIZE];\n  int b[ARRAY_SIZE];\n  int c[ARRAY_SIZE];\n  int i;\n\n  // a and b array initialization\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      a[i] = 1;\n      b[i] = i;\n      c[i] = 2 * i;\n  }\n\n\n#pragma omp target map(to: b[0:ARRAY_SIZE], c[0:ARRAY_SIZE]) map(tofrom: a[0:ARRAY_SIZE])\n  {\n#pragma omp simd \n    for (i = 0; i < ARRAY_SIZE; ++i) {\n        a[i] += b[i] * c[i];\n    }\n  }\n\n\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      OMPVV_TEST_AND_SET(errors, (a[i] != 1 + (b[i] * c[i])));\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_simd());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_simd.c - Using simd directive inside of a terget region -===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// SIMD in OpenMP 4.5 does not have any API that allows us to confirm the creation \n// of SIMD lanes, nor the use of SIMD instructions in any architecture. Hence, our\n// tests are limited in that they check that the expected result is created, but\n// assume nothing in how they are mapped into a particular architecture\n//\n// This test creates a regular for loop and uses the SIMD directive inside \n// a target region then it checks that the values of the array are as expected\n//===--------------------------------------------------------------------------===//\n//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define ARRAY_SIZE 1024\n\nint test_target_simd() {\n  OMPVV_INFOMSG(\"test_target_simd\");\n  OMPVV_WARNING(\"This test cannot check if actual SIMD extensions at the hardware level\"\n                 \" were used, or of the generated code is different in any way\");\n\n  // Variable for errors counting\n  int errors = 0;\n\n  int a[ARRAY_SIZE];\n  int b[ARRAY_SIZE];\n  int c[ARRAY_SIZE];\n  int i;\n\n  // a and b array initialization\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      a[i] = 1;\n      b[i] = i;\n      c[i] = 2 * i;\n  }\n\n\n#pragma omp target map(to: b[0:ARRAY_SIZE], c[0:ARRAY_SIZE]) map(tofrom: a[0:ARRAY_SIZE])\n  {\n#pragma omp simd \n    for (i = 0; i < ARRAY_SIZE; ++i) {\n        a[i] += b[i] * c[i];\n    }\n  }\n\n\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      OMPVV_TEST_AND_SET(errors, (a[i] != 1 + (b[i] * c[i])));\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_simd());\n\n  OMPVV_REPORT_AND_RETURN(errors);yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_firstprivate.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===--- test_target_teams_distribute_firstprivate.c-------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the firstprivate clause and tests it in two separate parts.\n// The first test checks the privatization of the firstprivatized scalars and\n// an array and the second tests the proper initialization of both\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main() {\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int num_teams[N];\n  int privatized_array[10];\n  int privatized = 0;\n  int ishost;\n  int errors = 0;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    c[x] = 2*x;\n    d[x] = 0;\n    num_teams[x] = -1;\n  }\n\n  for (int x = 0; x < 10; ++x) {\n    privatized_array[x] = 0;\n  }\n\n  //Test privitization of data in firstprivate clause\n#pragma omp target data map(from: d[0:N]) map(to: a[0:N], b[0:N], c[0:N])\n  {\n#pragma omp target teams distribute firstprivate(privatized_array, privatized) \\\n  map(alloc: a[0:N], b[0:N], c[0:N], d[0:N]) num_teams(OMPVV_NUM_TEAMS_DEVICE)\n    for (int x = 0; x < N; ++x) {\n      num_teams[x] = omp_get_num_teams();\n      for (int y = 0; y < a[x] + b[x]; ++y) {\n        privatized++;\n        for (int z = 0; z < 10; ++z) {\n          privatized_array[z]++;\n        }\n      }\n      d[x] = c[x] * privatized;\n      for (int z = 0; z < 10; ++z) {\n        d[x] += privatized_array[z];\n      }\n      privatized = 0;\n      for (int z = 0; z < 10; ++z) {\n        privatized_array[z] = 0;\n      }\n    }\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, d[x] != 10*(1 + x) + (1 + x)*2*x);\n    if (d[x] != 10*(1 + x) + (1 + x)*2*x) {\n      break;\n    }\n    OMPVV_WARNING_IF(num_teams[x] == 1, \"Did not create enough teams to check for potential data races.\");\n  }\n\n  privatized = 1;\n  for (int x = 0; x < 10; ++x) {\n    privatized_array[x] = x;\n  }\n\n  for (int x = 0; x < N; ++x) {\n    num_teams[x] = -1;\n  }\n\n  //Test initialization of data in firstprivate clause\n#pragma omp target data map(from: d[0:N]) map(to: a[0:N], b[0:N], c[0:N])\n  {\n#pragma omp target teams distribute firstprivate(privatized_array, privatized) \\\n  map(alloc: a[0:N], b[0:N], c[0:N], d[0:N]) num_teams(OMPVV_NUM_TEAMS_DEVICE)\n    for (int x = 0; x < N; ++x) {\n      num_teams[x] = omp_get_num_teams();\n      d[x] = a[x] + b[x] + c[x] + privatized_array[x%10] + privatized;\n    }\n  }\n\n  int temp;\n  for (int x = 0; x < N; ++x) {\n    temp = x%10;\n    OMPVV_TEST_AND_SET_VERBOSE(errors, d[x] != 2 + 3*x + temp);\n    if (d[x] != 2 + 3*x + (x%10)) {\n      break;\n    }\n    OMPVV_WARNING_IF(num_teams[x] == 1, \"Did not create enough teams to check for potential data races.\");\n  }\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nfloat icjzgnsybr = 54;\ndouble zcnqrclnom = 254;\nint ivrearzjiw = 104;\nfloat snkizlglzg = 91;\nbyte eccdiwshjm = 40;\nshort hdceleexsl = 188;\nfloat lyfynunhdj = 76;\nint stoehxikqe = 128;\nfloat ssyxakswsj = 9;\nint ditvghansz = 143;\nshort lupaaakxvt = 113;\nbyte gxuzenblsc = 116;\ndouble ejrjirzryf = 28;\ndouble eqjgqchnab = 101;\nbyte jfuusrjpkq = 78;\nshort sfxjhrfzss = 241;\nlong kmqygejpeo = 242;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_map_struct_default.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===---test_target_map_struct_default.c - test of struct mapping to device -===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// This test checks the default variable mapping behavior. Without specifying \n// any attribute or map clause, all used variables inside the target region \n// should be mapped tofrom. There are two different test cases. The first one\n// where a struct is defined and used, the second one where a typedef struct is\n// defined, then a struct with that type is defined and then used. \n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nint test_map_struct() {\n\n  OMPVV_INFOMSG(\"Running test_map_struct()\");\n\n  int errors = 0;\n  int* pointers[6];\n\n  struct {\n    int a;\n    int b[N];\n    int *p;\n  } single, array[5];\n\n  single.p = (int*) malloc(5 * sizeof(int));\n  pointers[0] = single.p;\n\n  for (int i = 0; i < 5; ++i) {\n    array[i].p = (int*) malloc(5 * sizeof(int));\n    pointers[i + 1] = array[i].p;\n  }\n\n  // By default. map(tofrom: single) map(tofrom: array) map(tofrom: pointers[0:0])\n  {\n#pragma omp target\n    if (!omp_is_initial_device()) {\n      single.a = 1;\n      for (int i = 0; i < N; ++i)\n        single.b[i] = 1;\n\n      for (int i = 0; i < 5; ++i) {\n        array[i].a = 1;\n        for (int j = 0; j < N; ++j)\n          array[i].b[j] = 1;\n      }\n    }\n  } // end target\n  \n  // checking results\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (single.a != 1)); \n  for (int i = 0; i < N; ++i)\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (single.b[i] != 1));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (pointers[0] != single.p));\n  for (int i = 0; i < 5; ++i) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (array[i].a != 1)); \n    for (int j = 0; j < N; ++j)\n      OMPVV_TEST_AND_SET_VERBOSE(errors, (array[i].b[j] != 1));\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (pointers[i + 1] != array[i].p));\n  }\n\n  return errors;\n}\n\nint test_map_typedef() {\n\n  OMPVV_INFOMSG(\"Running test_map_typedef()\");\n\n  int errors = 0;\n  int* pointers[6];\n\n  typedef struct {\n    int a;\n    int b[N];\n    int *p;\n  } test_struct;\n\n  test_struct single, array[5];\n\n  single.p = (int*) malloc(5 * sizeof(int));\n  pointers[0] = single.p;\n\n  for (int i = 0; i < 5; ++i) {\n    array[i].p = (int*) malloc(5 * sizeof(int));\n    pointers[i + 1] = array[i].p;\n  }\n\n  //By default: map(tofrom: single) map(tofrom: array) map(tofrom: pointers)\n  {\n#pragma omp target\n    if (!omp_is_initial_device()) {  \n      single.a = 1;\n      for (int i = 0; i < N; ++i)\n        single.b[i] = 1;\n\n      for (int i = 0; i < 5; ++i) {\n        array[i].a = 1;\n        for (int j = 0; j < N; ++j)\n          array[i].b[j] = 1;\n      }\n    }\n  } // end target\n  \n  // checking results\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (single.a != 1)); \n  for (int i = 0; i < N; ++i)\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (single.b[i] != 1));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (pointers[0] != single.p));\n  for (int i = 0; i < 5; ++i) {\n   OMPVV_TEST_AND_SET_VERBOSE(errors, (array[i].a != 1)); \n    for (int j = 0; j < N; ++j)\n      OMPVV_TEST_AND_SET_VERBOSE(errors, (array[i].b[j] != 1));\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (pointers[i + 1] != array[i].p));\n  }\n\n  return errors;\n}\n\n\nint main () {\n  \n  int errors = 0;\n  //Check that offloading is enabled\n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n  \n  if (!is_offloading) {\n    OMPVV_ERROR(\"Mapping to device cannot be properly tested as offloading is not enabled\");\n    errors ++;\n    OMPVV_REPORT_AND_RETURN(errors);\n  }\n  \n  errors += test_map_struct();\n  errors += test_map_typedef();\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nshort ualsazeuxd = 195;\nfloat oiugroqrix = 131;\nshort flfhgbbexe = 74;\nfloat kskomycyla = 198;\nfloat oolwhwzjim = 228;\nlong rhzkwwmfov = 241;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_enter_exit_data_if.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 3560",
        "issue_id": 1,
        "original_code": "//===---- test_target_enter_exit_data_if.c --------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// The if clause determines if the section should be executed in the host or \n// the device. There are three things to test here: \n// (a) with offloading when 'if' clause evaluates to true then code\n// be executed on the device \n// (b) with offloading when 'if' clause evaluates to false then code should\n// be executed on the host\n// (c) without offloading all the code should be executed on the device\n// The if clause is evaluated on runtime which means that variables could\n// determine this behavior. We use a SIZE_THRESHOLD variable to check if we \n// should execute on the device or the host. Before starting the test we \n// sample offloading to see if it was enabled or not. If the code is executed\n// in the device, the result should be c[i] = a[i] + b[i] = i + 1. \n// If the code is executed on the host the result should be c[i] = -1\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define SIZE_THRESHOLD 512\n\nint main() {\n  int a[1024];\n  int b[1024];\n  int c[1024];\n  int size, i = 0, errors[2] = {0,0}, isOffloading = 0;\n\n  // a and b array initialization\n  for (i = 0; i < 1024; i++) {\n    a[i] = 1;\n    b[i] = i;\n  }\n\n  // We test for offloading\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n \n  OMPVV_WARNING_IF(!isOffloading, \"It is not possible to test conditional data transfers \"\n                 \"if the environment is shared or offloading is off. Not testing \"\n                 \"anything\"); \n\n  // check multiple sizes. \n  for (size = 256; size <= 1024; size += 256) {\n    // C initialization\n    for (i = 0; i < size; i++) {\n      c[i] = -1;\n    }\n#pragma omp target enter data if(size > SIZE_THRESHOLD) map(to: size) map(to: c[0:size])\n           \n#pragma omp target if(size > SIZE_THRESHOLD)  \\\n        map(to: a[0:size], b[0:size]) map(to: c[0:size]) //Mapping c again will not be required in OpenMP 4.5.\n\t\t\t\t\t\t\t\t\t     // Refer to https://gcc.gnu.org/bugzilla/show_bug.cgi?id=83295\n{\n        int isHost = -1;\n        isHost = omp_is_initial_device();\n        int alpha = (isHost ? 0 : 1);\n        int j = 0;\n        for (j = 0; j < size; j++) {\n          // c[j] is zero if executed in the host\n          // c[j] is 1+j if executed on the device\n          c[j] = alpha*(a[j] + b[j]);\n        }\n} // end target\n#pragma omp target exit data if(size > SIZE_THRESHOLD) map(from: c[0:size])\n\n    // checking results \n    for (i = 0; i < size; i++) {\n      if (isOffloading && size > SIZE_THRESHOLD) {\n        // Should have executed on the device\n        // if offloading was used\n        if (c[i] != i + 1) {\n          // c[i] is zero if it was executed in the host\n          errors[0] += 1;//error when executed on the device\n        }\n      } else {\n        // Should have executed in the host\n        // with or without offloading\n        if (c[i] != 0) {\n          errors[1] += 1;\n        }\n      } //end-else \n    }\n  } // end-for size\n\n  if (!errors[0] && !errors[1]) {\n    OMPVV_INFOMSG(\"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  } else if (errors[0]==0 && errors[1]!=0) {\n      OMPVV_ERROR(\"Test failed on host with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n    } else if (errors[0]!=0 && errors[1]==0) {\n        OMPVV_ERROR(\"Test failed on device with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n      } else if (errors[0]!=0 && errors[1]!=0) {\n              OMPVV_ERROR(\"Test failed on host and device with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n        }\n\n   OMPVV_REPORT_AND_RETURN((errors[0] && errors[1]));\n}\n",
        "error_code": "//===---- test_target_enter_exit_data_if.c --------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// The if clause determines if the section should be executed in the host or \n// the device. There are three things to test here: \n// (a) with offloading when 'if' clause evaluates to true then code\n// be executed on the device \n// (b) with offloading when 'if' clause evaluates to false then code should\n// be executed on the host\n// (c) without offloading all the code should be executed on the device\n// The if clause is evaluated on runtime which means that variables could\n// determine this behavior. We use a SIZE_THRESHOLD variable to check if we \n// should execute on the device or the host. Before starting the test we \n// sample offloading to see if it was enabled or not. If the code is executed\n// in the device, the result should be c[i] = a[i] + b[i] = i + 1. \n// If the code is executed on the host the result should be c[i] = -1\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define SIZE_THRESHOLD 512\n\nint main() {\n  int a[1024];\n  int b[1024];\n  int c[1024];\n  int size, i = 0, errors[2] = {0,0}, isOffloading = 0;\n\n  // a and b array initialization\n  for (i = 0; i < 1024; i++) {\n    a[i] = 1;\n    b[i] = i;\n  }\n\n  // We test for offloading\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n \n  OMPVV_WARNING_IF(!isOffloading, \"It is not possible to test conditional data transfers \"\n                 \"if the environment is shared or offloading is off. Not testing \"\n                 \"anything\"); \n\n  // check multiple sizes. \n  for (size = 256; size <= 1024; size += 256) {\n    // C initialization\n    for (i = 0; i < size; i++) {\n      c[i] = -1;\n    }\n#pragma omp target enter data if(size > SIZE_THRESHOLD) map(to: size) map(to: c[0:size])\n           \n#pragma omp target if(size > SIZE_THRESHOLD)  \\\n        map(to: a[0:size], b[0:size]) map(to: c[0:size]) //Mapping c again will not be required in OpenMP 4.5.\n\t\t\t\t\t\t\t\t\t     // Refer to https://gcc.gnu.org/bugzilla/show_bug.cgi?id=83295\n{\n        int isHost = -1;\n        isHost = omp_is_initial_device();\n        int alpha = (isHost ? 0 : 1);\n        int j = 0;\n        for (j = 0; j < size; j++) {\n          // c[j] is zero if executed in the host\n          // c[j] is 1+j if executed on the device\n          c[j] = alpha*(a[j] + b[j]);\n        }\n} // end target\n#pragma omp target exit data if(size > SIZE_THRESHOLD) map(from: c[0:size])\n\n    // checking results \n    for (i = 0; i < size; i++) {\n      if (isOffloading && size > SIZE_THRESHOLD) {\n        // Should have executed on the device\n        // if offloading was used\n        if (c[i] != i + 1) {\n          // c[i] is zero if it was executed in the host\n          errors[0] += 1;//error when executed on the device\n        }\n      } else {\n        // Should have executed in the host\n        // with or without offloading\n        if (c[i] != 0) {\n          errors[1] += 1;\n        }\n      } //end-else \n    }\n  } // end-for size\n\n  if (!errors[0] && !errors[1]) {\n    OMPVV_INFOMSG(\"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  } else if (errors[0]==0 && errors[1]!=0) {\n      OMPVV_ERROR(\"Test failed on host with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n    } else if (errors[0]!=0 && errors[1]==0) {\n        OMPVV_ERROR(\"Test failed on device with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n      } else if (errors[0]!=0 && errors[1]!=0) \n              OMPVV_ERROR(\"Test failed on host and device with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n        }\n\n   OMPVV_REPORT_AND_RETURN((errors[0] && errors[1]));\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_is_device_ptr.c",
        "correct": "n",
        "issue": "Removed memory allocation line \"omp_target_alloc() API call. If this test runs on the\n//  host, we will warn that we won't be allocating on any device and the test \n//  will fail.\n//\n////===-------------------------------------------------------------------------===//\n\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"ompvv.h\"\n\n#define N 10000\n\nint main() {\n  \n\n  int isOffloading;\" at position 234",
        "issue_id": 0,
        "original_code": "//===--- test_target_is_device_ptr.c--is_device_ptr clause on target directive--===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n//  This test checks for the use of the is_device_ptr() clause on an array that \n//  is allocated with the omp_target_alloc() API call. If this test runs on the\n//  host, we will warn that we won't be allocating on any device and the test \n//  will fail.\n//\n////===-------------------------------------------------------------------------===//\n\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"ompvv.h\"\n\n#define N 10000\n\nint main() {\n  \n\n  int isOffloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  \n  OMPVV_WARNING_IF(!isOffloading, \"This test is running on the host, the allocation of the memory returns a host pointer\");\n\n  int errors = 0;\n  int *array_device = NULL;\n  int *array_host = NULL;\n  \n\n  array_device = (int *) omp_target_alloc(N*sizeof(int), omp_get_default_device());\n  if (array_device == NULL) {\n    errors = 1; \n    OMPVV_ERROR(\"Array device is null: cannot allocate memory on device, is_device_ptr() cannot be properly tested\");\n    OMPVV_REPORT_AND_RETURN(errors);\n  } \n \n  array_host = (int *) malloc(N*sizeof(int));\n\n  for (int i = 0; i < N; ++i) {\n    array_host[i] = i;\n  }\n\n#pragma omp target is_device_ptr(array_device) map(tofrom: array_host[0:N]) \n{\n  for (int i = 0; i < N; ++i) {\n    array_device[i] = i;\n    array_host[i] += array_device[i];\n  } \n} // end target\n\n  // checking results\n  for (int i = 0; i < N; ++i) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, array_host[i] != 2*i);\n  }\n\n  omp_target_free(array_device, omp_get_default_device());\n  free(array_host);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_is_device_ptr.c--is_device_ptr clause on target directive--===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n//  This test checks for the use of the is_device_ptr() clause on an array that \n//  is allocated with the \n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  \n  OMPVV_WARNING_IF(!isOffloading, \"This test is running on the host, the allocation of the memory returns a host pointer\");\n\n  int errors = 0;\n  int *array_device = NULL;\n  int *array_host = NULL;\n  \n\n  array_device = (int *) omp_target_alloc(N*sizeof(int), omp_get_default_device());\n  if (array_device == NULL) {\n    errors = 1; \n    OMPVV_ERROR(\"Array device is null: cannot allocate memory on device, is_device_ptr() cannot be properly tested\");\n    OMPVV_REPORT_AND_RETURN(errors);\n  } \n \n  array_host = (int *) malloc(N*sizeof(int));\n\n  for (int i = 0; i < N; ++i) {\n    array_host[i] = i;\n  }\n\n#pragma omp target is_device_ptr(array_device) map(tofrom: array_host[0:N]) \n{\n  for (int i = 0; i < N; ++i) {\n    array_device[i] = i;\n    array_host[i] += array_device[i];\n  } \n} // end target\n\n  // checking results\n  for (int i = 0; i < N; ++i) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, array_host[i] != 2*i);\n  }\n\n  omp_target_free(array_device, omp_get_default_device());\n  free(array_host);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_private.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1710",
        "issue_id": 1,
        "original_code": "//===--- test_target_teams_distribute_private.c------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the private clause on a target teams distribute directive to\n// indicate that the variable in the private clause should be made private to\n// each team executing the teams distribute region.  The test then operates on\n// the privatized variable in such a way that would most likely cause competing\n// operations if the variable is not privatized.  If the computation completes\n// without errors, we assume that the privatization occured.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define SIZE 1024\n\nint main() {\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  int a[SIZE];\n  int b[SIZE];\n  int c[SIZE];\n  int d[SIZE];\n  int privatized;\n  int errors = 0;\n  int num_teams = -1;\n\n  for (int x = 0; x < SIZE; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    c[x] = 2*x;\n    d[x] = 0;\n  }\n\n#pragma omp target data map(from: d[0:SIZE]) map(to: a[0:SIZE], b[0:SIZE], c[0:SIZE])\n  {\n#pragma omp target teams distribute private(privatized) map(alloc: a[0:SIZE], b[0:SIZE], c[0:SIZE], d[0:SIZE]) map(tofrom: num_teams) num_teams(OMPVV_NUM_TEAMS_DEVICE)\n    for (int x = 0; x < SIZE; ++x) {\n      if (omp_get_team_num() == 0) {\n        num_teams = omp_get_num_teams();\n      }\n      privatized = 0;\n      for (int y = 0; y < a[x] + b[x]; ++y) {\n        privatized++;\n      }\n      d[x] = c[x] * privatized;\n    }\n  }\n\n  for (int x = 0; x < SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, d[x] != (1 + x)*2*x);\n    if (d[x] != (1 + x)*2*x) {\n      break;\n    }\n  }\n\n  OMPVV_WARNING_IF(num_teams == 1, \"Test ran with one team. Results of private test are inconclusive.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_teams < 1);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_private.c------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the private clause on a target teams distribute directive to\n// indicate that the variable in the private clause should be made private to\n// each team executing the teams distribute region.  The test then operates on\n// the privatized variable in such a way that would most likely cause competing\n// operations if the variable is not privatized.  If the computation completes\n// without errors, we assume that the privatization occured.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define SIZE 1024\n\nint main() {\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  int a[SIZE];\n  int b[SIZE];\n  int c[SIZE];\n  int d[SIZE];\n  int privatized;\n  int errors = 0;\n  int num_teams = -1;\n\n  for (int x = 0; x < SIZE; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    c[x] = 2*x;\n    d[x] = 0;\n  }\n\n#pragma omp target data map(from: d[0:SIZE]) map(to: a[0:SIZE], b[0:SIZE], c[0:SIZE])\n  {\n#pragma omp target teams distribute private(privatized) map(alloc: a[0:SIZE], b[0:SIZE], c[0:SIZE], d[0:SIZE]) map(tofrom: num_teams) num_teams(OMPVV_NUM_TEAMS_DEVICE)\n    for (int x = 0; x < SIZE; ++x) {\n      if (omp_get_team_num() == 0) {\n        num_teams = omp_get_num_teams();\n      }\n      privatized = 0;\n      for (int y = 0; y < a[x] + b[x]; ++y) {\n        privatized++;\n      }\n      d[x] = c[x] * privatized;\n    }\n  }\n\n  for (int x = 0; x < SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, d[x] != (1 + x)*2*x);\n    if (d[x] != (1 + x)*2*x) \n      break;\n    }\n  }\n\n  OMPVV_WARNING_IF(num_teams == 1, \"Test ran with one team. Results of private test are inconclusive.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_teams < 1);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/offloading_success.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp map\" at position 74",
        "issue_id": 0,
        "original_code": "#include <stdio.h>\n#include <omp.h>\n\nint main(void) {\n  int isHost = -1;\n\n#pragma omp target map(from:isHost)\n  { isHost = omp_is_initial_device(); }\n\n  if (isHost < 0) {\n    printf(\"Runtime error, isHost=%d\\n\", isHost);\n  }\n\n  // CHECK: Target region executed on the device\n  printf(\"Target region executed on the %s\\n\", isHost ? \"host\" : \"device\");\n\n  return isHost;\n}\n",
        "error_code": "#include <stdio.h>\n#include <omp.h>\n\nint main(void) {\n  int isHost = -1;\n\n#pragma omp map map(from:isHost)\n  { isHost = omp_is_initial_device(); }\n\n  if (isHost < 0) {\n    printf(\"Runtime error, isHost=%d\\n\", isHost);\n  }\n\n  // CHECK: Target region executed on the device\n  printf(\"Target region executed on the %s\\n\", isHost ? \"host\" : \"device\");\n\n  return isHost;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/qmcpack_target_static_lib.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, offload_test() != 1);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 558",
        "issue_id": 4,
        "original_code": "//===-- qmcpack_target_static_lib.c ---------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks that a target region can be compiled as a static\n// library. The library function offload_test contains a target region\n// which changes the value of a scalar on the device and maps it back.\n// This value is then checked by this driver code.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n#include \"libompvv.h\"\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, offload_test() != 1);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===-- qmcpack_target_static_lib.c ---------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks that a target region can be compiled as a static\n// library. The library function offload_test contains a target region\n// which changes the value of a scalar on the device and maps it back.\n// This value is then checked by this driver code.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n#include \"libompvv.h\"\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_task_final.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp parallel\" with directive \"#pragma omp cancel\" at position 1365",
        "issue_id": 0,
        "original_code": "//===-- test_task_final.c ------------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// Description:\n// testTaskWithFinalSimple():\n// This test demonstrates the use of final clause with tasks.\n// In this test we prove that omp_in_final() returns true\n// when the task is final else returns false.\n//\n//testNestedTaskWithFinalSimple()\n//This test demonstrates that all nested tasks under a final task\n// are also final tasks.\n//\n//testTaskWithFinalAdvanced()\n//This test demonstrates the use of final clause with tasks.\n// In this test we prove that if a task is declared as final,\n// then all subsequent tasks generated by this task will undeferred\n// tasks. Hence they all will be executed in the same thread as\n// parent task and each child task will be executed in order.\n\n//===----------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n// defines\n#define INC 5\n#define MUL 7\n#define DIV 3\n#define DEC 11\n#define INITVAL 10\n\nint testTaskWithFinalSimple(int numThreads, int isFinal) {\n  int errors = 0;\n  int ret = 0;\n  int *A = (int*) (malloc(numThreads*sizeof(int)));\n  assert(A != NULL);\n  omp_set_num_threads(numThreads);\n  // Initialize the arrays\n  for (int i = 0; i < numThreads; i++) {\n    A[i] = -1;\n  }\n#pragma omp parallel\n  {\n    int id = omp_get_thread_num();\n  // undeferred\n#pragma omp task final(isFinal)\n    {\n      A[id] = omp_in_final();\n    }\n  }\n  for (int i = 0; i < numThreads; i++) {\n    if ((isFinal == 1) && (A[i] == 0)) {\n      ret = -1;\n      break;\n    } else if ((isFinal == 0) && (A[i] != 0)) {\n      ret = -1;\n      break;\n    }\n  }\n  free(A);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, ret != 0);\n  return errors;\n}\n\nint testNestedTaskWithFinalSimple(int numThreads) {\n  int errors = 0;\n  int ret = 0;\n  int *A = (int*) (malloc(numThreads*sizeof(int)));\n  assert(A != NULL);\n  omp_set_num_threads(numThreads);\n  // Initialize the arrays\n  for (int i = 0; i < numThreads; i++) {\n    A[i] = 0;\n  }\n#pragma omp parallel\n  {\n    int id = omp_get_thread_num();\n  // undeferred\n#pragma omp task final(1)\n    {\n#pragma omp task shared(id)\n      {\n        A[id] = omp_in_final();\n      }\n    }\n  }\n  for (int i = 0; i < numThreads; i++) {\n    if (A[i] == 0) {\n      ret = -1;\n      break;\n    }\n  }\n  free(A);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, ret != 0);\n  return errors;\n}\n\nint testTaskWithFinalAdvanced(int numThreads) {\n  int errors = 0;\n  int ret = 0;\n  int *A = (int*) (malloc(numThreads*sizeof(int)));\n  assert(A != NULL);\n  int *B = (int*) (malloc(numThreads*sizeof(int)));\n  assert(B != NULL);\n  omp_set_num_threads(numThreads);\n  // Initialize the arrays\n  for (int i = 0; i < numThreads; i++) {\n    A[i] = 0;\n    B[i] = INITVAL;\n  }\n#pragma omp parallel\n  {\n    int id = omp_get_thread_num();\n#pragma omp task final(1)\n    {\n      int first_final_task_thrdid = omp_get_thread_num();\n      int first_1stchld_task_thrdid = 0, first_2ndchld_task_thrdid = 0,\n      first_3rdchld_task_thrdid = 0, root_id = id;\n#pragma omp task shared(first_1stchld_task_thrdid, root_id)\n        {\n          first_1stchld_task_thrdid = omp_get_thread_num();\n          B[root_id] += INC;\n#pragma omp task shared(root_id)\n          {\n            B[root_id] /= DIV;\n          }\n        }\n#pragma omp task shared(first_2ndchld_task_thrdid, root_id)\n        {\n          first_2ndchld_task_thrdid = omp_get_thread_num();\n          B[root_id] *= MUL;\n        }\n#pragma omp task shared(first_3rdchld_task_thrdid, root_id)\n        {\n          first_3rdchld_task_thrdid = omp_get_thread_num();\n          B[root_id] -= DEC;\n        }\n        if ((first_final_task_thrdid == first_1stchld_task_thrdid) &&\n           (first_final_task_thrdid == first_2ndchld_task_thrdid) &&\n           (first_final_task_thrdid == first_3rdchld_task_thrdid)) {\n          A[root_id] = 1;\n        }\n    }\n  }\n  for (int i = 0; i < numThreads; i++) {\n    if ((A[i] != 1) || (B[i] != (((INITVAL + INC)/DIV)*MUL - DEC))) {\n      ret = 1;\n      break;\n    }    \n  }\n  free(B);\n  free(A);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, ret != 0);\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testNestedTaskWithFinalSimple(4));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testNestedTaskWithFinalSimple(8));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testNestedTaskWithFinalSimple(16));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testNestedTaskWithFinalSimple(32));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testNestedTaskWithFinalSimple(64));\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(4, 1));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(8, 1));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(16, 1));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(32, 1));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(64, 1));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(4, 0));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(8, 0));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(16, 0));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(32, 0));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(64, 0));\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalAdvanced(4));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalAdvanced(8));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalAdvanced(16));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalAdvanced(32));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalAdvanced(64));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===-- test_task_final.c ------------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// Description:\n// testTaskWithFinalSimple():\n// This test demonstrates the use of final clause with tasks.\n// In this test we prove that omp_in_final() returns true\n// when the task is final else returns false.\n//\n//testNestedTaskWithFinalSimple()\n//This test demonstrates that all nested tasks under a final task\n// are also final tasks.\n//\n//testTaskWithFinalAdvanced()\n//This test demonstrates the use of final clause with tasks.\n// In this test we prove that if a task is declared as final,\n// then all subsequent tasks generated by this task will undeferred\n// tasks. Hence they all will be executed in the same thread as\n// parent task and each child task will be executed in order.\n\n//===----------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n// defines\n#define INC 5\n#define MUL 7\n#define DIV 3\n#define DEC 11\n#define INITVAL 10\n\nint testTaskWithFinalSimple(int numThreads, int isFinal) {\n  int errors = 0;\n  int ret = 0;\n  int *A = (int*) (malloc(numThreads*sizeof(int)));\n  assert(A != NULL);\n  omp_set_num_threads(numThreads);\n  // Initialize the arrays\n  for (int i = 0; i < numThreads; i++) {\n    A[i] = -1;\n  }\n#pragma omp cancel\n  {\n    int id = omp_get_thread_num();\n  // undeferred\n#pragma omp task final(isFinal)\n    {\n      A[id] = omp_in_final();\n    }\n  }\n  for (int i = 0; i < numThreads; i++) {\n    if ((isFinal == 1) && (A[i] == 0)) {\n      ret = -1;\n      break;\n    } else if ((isFinal == 0) && (A[i] != 0)) {\n      ret = -1;\n      break;\n    }\n  }\n  free(A);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, ret != 0);\n  return errors;\n}\n\nint testNestedTaskWithFinalSimple(int numThreads) {\n  int errors = 0;\n  int ret = 0;\n  int *A = (int*) (malloc(numThreads*sizeof(int)));\n  assert(A != NULL);\n  omp_set_num_threads(numThreads);\n  // Initialize the arrays\n  for (int i = 0; i < numThreads; i++) {\n    A[i] = 0;\n  }\n#pragma omp parallel\n  {\n    int id = omp_get_thread_num();\n  // undeferred\n#pragma omp task final(1)\n    {\n#pragma omp task shared(id)\n      {\n        A[id] = omp_in_final();\n      }\n    }\n  }\n  for (int i = 0; i < numThreads; i++) {\n    if (A[i] == 0) {\n      ret = -1;\n      break;\n    }\n  }\n  free(A);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, ret != 0);\n  return errors;\n}\n\nint testTaskWithFinalAdvanced(int numThreads) {\n  int errors = 0;\n  int ret = 0;\n  int *A = (int*) (malloc(numThreads*sizeof(int)));\n  assert(A != NULL);\n  int *B = (int*) (malloc(numThreads*sizeof(int)));\n  assert(B != NULL);\n  omp_set_num_threads(numThreads);\n  // Initialize the arrays\n  for (int i = 0; i < numThreads; i++) {\n    A[i] = 0;\n    B[i] = INITVAL;\n  }\n#pragma omp parallel\n  {\n    int id = omp_get_thread_num();\n#pragma omp task final(1)\n    {\n      int first_final_task_thrdid = omp_get_thread_num();\n      int first_1stchld_task_thrdid = 0, first_2ndchld_task_thrdid = 0,\n      first_3rdchld_task_thrdid = 0, root_id = id;\n#pragma omp task shared(first_1stchld_task_thrdid, root_id)\n        {\n          first_1stchld_task_thrdid = omp_get_thread_num();\n          B[root_id] += INC;\n#pragma omp task shared(root_id)\n          {\n            B[root_id] /= DIV;\n          }\n        }\n#pragma omp task shared(first_2ndchld_task_thrdid, root_id)\n        {\n          first_2ndchld_task_thrdid = omp_get_thread_num();\n          B[root_id] *= MUL;\n        }\n#pragma omp task shared(first_3rdchld_task_thrdid, root_id)\n        {\n          first_3rdchld_task_thrdid = omp_get_thread_num();\n          B[root_id] -= DEC;\n        }\n        if ((first_final_task_thrdid == first_1stchld_task_thrdid) &&\n           (first_final_task_thrdid == first_2ndchld_task_thrdid) &&\n           (first_final_task_thrdid == first_3rdchld_task_thrdid)) {\n          A[root_id] = 1;\n        }\n    }\n  }\n  for (int i = 0; i < numThreads; i++) {\n    if ((A[i] != 1) || (B[i] != (((INITVAL + INC)/DIV)*MUL - DEC))) {\n      ret = 1;\n      break;\n    }    \n  }\n  free(B);\n  free(A);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, ret != 0);\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testNestedTaskWithFinalSimple(4));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testNestedTaskWithFinalSimple(8));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testNestedTaskWithFinalSimple(16));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testNestedTaskWithFinalSimple(32));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testNestedTaskWithFinalSimple(64));\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(4, 1));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(8, 1));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(16, 1));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(32, 1));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(64, 1));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(4, 0));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(8, 0));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(16, 0));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(32, 0));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(64, 0));\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalAdvanced(4));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalAdvanced(8));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalAdvanced(16));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalAdvanced(32));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalAdvanced(64));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_taskloop_final.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp parallel\" with directive \"#pragma omp cancel\" at position 1602",
        "issue_id": 0,
        "original_code": "//--------------------------------------------- test_taskloop_final.c ----------------------------------------//\n//\n// OpenMP API Version 4.5 August 2015\n//\n// This test checks the taskloop directive with the 'final' clause specified.\n// The 'taskloop' construct parallelizes loops with independent iterations by creating tasks. \n// It allows for efficient parallel execution of loop iterations by distributing them among multiple threads. \n// The 'final clause is used to ensure that group of tasks in taskloop are run by same thread 'if' the \n// 'final' (expression) is TRUE, else different threads could execute the tasks.      \n//----------------------------------------------------------------------------------------------------------//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define NUM_TASKS 6\n#define NUM_THREADS 10\n\n#define M 100\n\n//The 2nd dimension of this array (i.e., 3) is dependent on the number of task constructs in the taskloop construct.\nint thread_ids[NUM_TASKS][3]; \n\n\n//if all thread ids are same, val=1 else val=0\nint thread_ids_are_same_in_task() {\n\n \tint val = -1; \n \tfor(int i = 0; i < NUM_TASKS; i++) \n\t{\n\t \tint first = thread_ids[i][0];\n\n\t \tfor(int j = 1; j < 3; j++) \n\t \t{\n\t        \tif(first != thread_ids[i][j]) {\n\t\t  \t\tval = 0;  //if all the thread ids are not same per task\n\t\t  \t\tbreak; \n\t\t\t}\n\t\t\telse if(first == thread_ids[i][j]) {\n\t\t    \t\tval = 1; //if all the thread ids are same per task\n\t\t\t}\n   \t\t}\n\t \n\t\tif(val == 0)\n\t       \t\tbreak;\t\n   \t}\n\n\treturn val;\n}\n\nint test_taskloop_final(int THRESHOLD) {\n  \n  int errors = 0; \n  \n  #pragma omp parallel num_threads(NUM_THREADS)\n  {\n  \t#pragma omp single\n    \t{\t\n        \t#pragma omp taskloop final(M == THRESHOLD)\n      \t\tfor (int i = 0; i < NUM_TASKS; i++) {\n\t\t\t#pragma omp task \n\t\t\t{\n\t \t\t\tthread_ids[i][0] = omp_get_thread_num();\n\t\t\t}\n\t\t\t#pragma omp task \n\t\t\t{\n\t \t\t\tthread_ids[i][1] = omp_get_thread_num();\n\t\t\t}\n\n\t\t\t#pragma omp task \n\t\t\t{\n\t \t\t\tthread_ids[i][2] = omp_get_thread_num();\n\t\t\t}\n\n      \t\t} \n   \t}\n  }\n\n int val = thread_ids_are_same_in_task();\n \n  if (M == THRESHOLD) {\n    if (val != 1) {\n      errors++; \n    }\n  } else if (M != THRESHOLD) {\n    if (val == 1) {\n        OMPVV_WARNING(\"Same thread has executed all the tasks generated by the taskloop\");\n    } else if(val == 0) {\n        OMPVV_INFOMSG(\"Multiple threads have executed the tasks generated by the taskloop\");\n    }\n  }\n\n  return errors;            \n\n}\n\nint main() {\n \n   int errors = 0;\n   \n   int THRESHOLD = 100; //Equal to M\n   OMPVV_TEST_AND_SET_VERBOSE(errors, (test_taskloop_final(THRESHOLD) != 0));\n\n   THRESHOLD = 110; // Not equal to M\n   OMPVV_TEST_AND_SET_VERBOSE(errors, (test_taskloop_final(THRESHOLD) != 0));\n\n   OMPVV_REPORT_AND_RETURN(errors);\n\n   return 0;\n}\n",
        "error_code": "//--------------------------------------------- test_taskloop_final.c ----------------------------------------//\n//\n// OpenMP API Version 4.5 August 2015\n//\n// This test checks the taskloop directive with the 'final' clause specified.\n// The 'taskloop' construct parallelizes loops with independent iterations by creating tasks. \n// It allows for efficient parallel execution of loop iterations by distributing them among multiple threads. \n// The 'final clause is used to ensure that group of tasks in taskloop are run by same thread 'if' the \n// 'final' (expression) is TRUE, else different threads could execute the tasks.      \n//----------------------------------------------------------------------------------------------------------//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define NUM_TASKS 6\n#define NUM_THREADS 10\n\n#define M 100\n\n//The 2nd dimension of this array (i.e., 3) is dependent on the number of task constructs in the taskloop construct.\nint thread_ids[NUM_TASKS][3]; \n\n\n//if all thread ids are same, val=1 else val=0\nint thread_ids_are_same_in_task() {\n\n \tint val = -1; \n \tfor(int i = 0; i < NUM_TASKS; i++) \n\t{\n\t \tint first = thread_ids[i][0];\n\n\t \tfor(int j = 1; j < 3; j++) \n\t \t{\n\t        \tif(first != thread_ids[i][j]) {\n\t\t  \t\tval = 0;  //if all the thread ids are not same per task\n\t\t  \t\tbreak; \n\t\t\t}\n\t\t\telse if(first == thread_ids[i][j]) {\n\t\t    \t\tval = 1; //if all the thread ids are same per task\n\t\t\t}\n   \t\t}\n\t \n\t\tif(val == 0)\n\t       \t\tbreak;\t\n   \t}\n\n\treturn val;\n}\n\nint test_taskloop_final(int THRESHOLD) {\n  \n  int errors = 0; \n  \n  #pragma omp cancel num_threads(NUM_THREADS)\n  {\n  \t#pragma omp single\n    \t{\t\n        \t#pragma omp taskloop final(M == THRESHOLD)\n      \t\tfor (int i = 0; i < NUM_TASKS; i++) {\n\t\t\t#pragma omp task \n\t\t\t{\n\t \t\t\tthread_ids[i][0] = omp_get_thread_num();\n\t\t\t}\n\t\t\t#pragma omp task \n\t\t\t{\n\t \t\t\tthread_ids[i][1] = omp_get_thread_num();\n\t\t\t}\n\n\t\t\t#pragma omp task \n\t\t\t{\n\t \t\t\tthread_ids[i][2] = omp_get_thread_num();\n\t\t\t}\n\n      \t\t} \n   \t}\n  }\n\n int val = thread_ids_are_same_in_task();\n \n  if (M == THRESHOLD) {\n    if (val != 1) {\n      errors++; \n    }\n  } else if (M != THRESHOLD) {\n    if (val == 1) {\n        OMPVV_WARNING(\"Same thread has executed all the tasks generated by the taskloop\");\n    } else if(val == 0) {\n        OMPVV_INFOMSG(\"Multiple threads have executed the tasks generated by the taskloop\");\n    }\n  }\n\n  return errors;            \n\n}\n\nint main() {\n \n   int errors = 0;\n   \n   int THRESHOLD = 100; //Equal to M\n   OMPVV_TEST_AND_SET_VERBOSE(errors, (test_taskloop_final(THRESHOLD) != 0));\n\n   THRESHOLD = 110; // Not equal to M\n   OMPVV_TEST_AND_SET_VERBOSE(errors, (test_taskloop_final(THRESHOLD) != 0));\n\n   OMPVV_REPORT_AND_RETURN(errors);\n\n   return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/omp_default_device.c",
        "correct": "n",
        "issue": "Removed memory allocation line \"omp_target_alloc).The test sets and gets the default device number and checks if \n// the default device has actually changed after a memory allocation was made on \n// the device.\n//\n////===-------------------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nint test_omp_device() {\n  OMPVV_INFOMSG(\"test_get_set_default_device\");\" at position 292",
        "issue_id": 0,
        "original_code": "//===----- omp_default_device.c ----------------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// This test is based on a bug encounted by an application where the default device \n// would change (after explicit omp_set_default_device) after allocation via \n// omp_target_alloc).The test sets and gets the default device number and checks if \n// the default device has actually changed after a memory allocation was made on \n// the device.\n//\n////===-------------------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nint test_omp_device() {\n  OMPVV_INFOMSG(\"test_get_set_default_device\");\n\n  int errors = 0, setDev, iDev1, iDev2;\n  double *buf1, *buf2;\n  int num_devices = omp_get_num_devices();\n  \n  OMPVV_TEST_AND_SET(errors, num_devices <= 0);\n\n  if(errors)\n   return errors;\n\n  // Set default device\n  if(num_devices > 1){\n    omp_set_default_device(num_devices-1);\n    setDev = num_devices-1;\n  }\n  else{\n    omp_set_default_device(0);\n    setDev = 0;\n  }\n\n  iDev1 = omp_get_default_device();\n  OMPVV_TEST_AND_SET(errors, iDev1 != setDev);\n\n\n  buf1 = (double *)omp_target_alloc (sizeof(double)* N, iDev1);\n  iDev2 = omp_get_default_device();\n  OMPVV_TEST_AND_SET(errors, iDev2 != iDev1);\n\n  omp_target_free (buf1, iDev1);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_omp_device());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n",
        "error_code": "//===----- omp_default_device.c ----------------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// This test is based on a bug encounted by an application where the default device \n// would change (after explicit omp_set_default_device) after allocation via \n// \n\n  int errors = 0, setDev, iDev1, iDev2;\n  double *buf1, *buf2;\n  int num_devices = omp_get_num_devices();\n  \n  OMPVV_TEST_AND_SET(errors, num_devices <= 0);\n\n  if(errors)\n   return errors;\n\n  // Set default device\n  if(num_devices > 1){\n    omp_set_default_device(num_devices-1);\n    setDev = num_devices-1;\n  }\n  else{\n    omp_set_default_device(0);\n    setDev = 0;\n  }\n\n  iDev1 = omp_get_default_device();\n  OMPVV_TEST_AND_SET(errors, iDev1 != setDev);\n\n\n  buf1 = (double *)omp_target_alloc (sizeof(double)* N, iDev1);\n  iDev2 = omp_get_default_device();\n  OMPVV_TEST_AND_SET(errors, iDev2 != iDev1);\n\n  omp_target_free (buf1, iDev1);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_omp_device());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/alpaka_complex_template.cpp",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp declare\" at position 1290",
        "issue_id": 0,
        "original_code": "//===--- alpaka_complex_template.cpp ----------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This is a stripped-down application code which sets up two template\n// structs which use standard library functions. A templated struct\n// containing the other struct is declared on the device. This test does\n// not check any results as it is only a test of declaring a templated\n// struct on the device. This test was provided by Jonas Hahnfeld from\n// https://bugs.llvm.org/show_bug.cgi?id=43771.\n//\n////===----------------------------------------------------------------------===//\n\n#include <type_traits>\n#include \"omp.h\"\n#include \"ompvv.h\"\n\ntemplate<int Dim> struct V {\n  int version_called;\n\n  template<bool B = (Dim == 0),\n           typename = typename std::enable_if<B>::type>\n  V() {\n    version_called = 1;\n  }\n\n  template<typename TArg0,\n           typename = typename std::enable_if<(std::is_same<unsigned long,\n                                               typename std::decay<TArg0>::type>::value)>::type>\n  V(TArg0 && arg0) {\n    version_called = 2;\n  }\n};\n\ntemplate<int Dim> struct S {\n  V<Dim> v;\n};\n\nint main(int argc, char *argv[]) {\n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_SHARED_ENVIRONMENT;\n\n  int errors = 0;\n  int version_set[2] = {-1};\n\n#pragma omp target map(from: version_set[0:2])\n  {\n    S<0> s;\n    version_set[0] = s.v.version_called;\n    V<1> v2((unsigned long) 1);\n    version_set[1] = v2.version_called;\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, version_set[0] != 1);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, version_set[1] != 2);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- alpaka_complex_template.cpp ----------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This is a stripped-down application code which sets up two template\n// structs which use standard library functions. A templated struct\n// containing the other struct is declared on the device. This test does\n// not check any results as it is only a test of declaring a templated\n// struct on the device. This test was provided by Jonas Hahnfeld from\n// https://bugs.llvm.org/show_bug.cgi?id=43771.\n//\n////===----------------------------------------------------------------------===//\n\n#include <type_traits>\n#include \"omp.h\"\n#include \"ompvv.h\"\n\ntemplate<int Dim> struct V {\n  int version_called;\n\n  template<bool B = (Dim == 0),\n           typename = typename std::enable_if<B>::type>\n  V() {\n    version_called = 1;\n  }\n\n  template<typename TArg0,\n           typename = typename std::enable_if<(std::is_same<unsigned long,\n                                               typename std::decay<TArg0>::type>::value)>::type>\n  V(TArg0 && arg0) {\n    version_called = 2;\n  }\n};\n\ntemplate<int Dim> struct S {\n  V<Dim> v;\n};\n\nint main(int argc, char *argv[]) {\n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_SHARED_ENVIRONMENT;\n\n  int errors = 0;\n  int version_set[2] = {-1};\n\n#pragma omp declare map(from: version_set[0:2])\n  {\n    S<0> s;\n    version_set[0] = s.v.version_called;\n    V<1> v2((unsigned long) 1);\n    version_set[1] = v2.version_called;\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, version_set[0] != 1);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, version_set[1] != 2);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_simd_simdlen.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 2226",
        "issue_id": 2,
        "original_code": "//===---- test_target_simd_simdlen.c - simd directive clause simdlen   -===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// This test checks for the use of the simdlen clause which provides a hint to the\n// compiler to the appropriate number of simd lanes when generating the simd\n// region of code. However, different to safelen, this clause does not guarantee \n// that the number of lanes will actually be the one specified. The number of lanes\n// is implementation defined \n// ===--------------------------------------------------------------------------===//\n//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define ARRAY_SIZE 1024\n\nint test_target_simd_simdlen() {\n  OMPVV_INFOMSG(\"test_target_simd_simdlen\");\n  OMPVV_WARNING(\"This test cannot check if actual SIMD extensions at the hardware level\" \\\n                 \" were used, or of the generated code is different in any way\");\n\n  // Variable for errors counting\n  int errors = 0;\n\n  int A[ARRAY_SIZE];\n  int i, len;\n\n  // a and b array initialization\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      A[i] = 1;\n  }\n\n  // Test simdlen of 1 5 8 13 16 100 128\n#pragma omp target simd simdlen(1) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      A[i] += A[i]; \n  }\n\n#pragma omp target simd simdlen(5) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      A[i] += A[i]; \n  }\n\n#pragma omp target simd simdlen(8) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      A[i] += A[i]; \n  }\n\n#pragma omp target simd simdlen(13) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      A[i] += A[i]; \n  }\n\n#pragma omp target simd simdlen(16) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      A[i] += A[i]; \n  }\n\n#pragma omp target simd simdlen(100) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      A[i] += A[i]; \n  }\n\n#pragma omp target simd simdlen(128) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      A[i] += A[i]; \n  }\n\n  // Check the results\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      OMPVV_TEST_AND_SET(errors, A[i] != 1<<7);\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_simd_simdlen());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_simd_simdlen.c - simd directive clause simdlen   -===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// This test checks for the use of the simdlen clause which provides a hint to the\n// compiler to the appropriate number of simd lanes when generating the simd\n// region of code. However, different to safelen, this clause does not guarantee \n// that the number of lanes will actually be the one specified. The number of lanes\n// is implementation defined \n// ===--------------------------------------------------------------------------===//\n//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define ARRAY_SIZE 1024\n\nint test_target_simd_simdlen() {\n  OMPVV_INFOMSG(\"test_target_simd_simdlen\");\n  OMPVV_WARNING(\"This test cannot check if actual SIMD extensions at the hardware level\" \\\n                 \" were used, or of the generated code is different in any way\");\n\n  // Variable for errors counting\n  int errors = 0;\n\n  int A[ARRAY_SIZE];\n  int i, len;\n\n  // a and b array initialization\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      A[i] = 1;\n  }\n\n  // Test simdlen of 1 5 8 13 16 100 128\n#pragma omp target simd simdlen(1) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      A[i] += A[i]; \n  }\n\n#pragma omp target simd simdlen(5) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      A[i] += A[i]; \n  }\n\n#pragma omp target simd simdlen(8) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      A[i] += A[i]; \n  }\n\n#pragma omp target simd simdlen(13) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      A[i] += A[i]; \n  }\n\n#pragma omp target simd simdlen(16) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      A[i] += A[i]; \n  }\n\n#pragma omp target simd simdlen(100) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      A[i] += A[i]; \n  }\n\n#pragma omp target simd simdlen(128) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      A[i] += A[i]; \n  }\n\n  // Check the results\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      OMPVV_TEST_AND_SET(errors, A[i] != 1<<7);\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_simd_simdlen());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_map_array_default.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 658",
        "issue_id": 1,
        "original_code": "//===--test_target_map_array_default.c - test default behavior of array map--===//\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// Whenever a map-type-modifier is not specified in the map clause, the symbol\n// is mapped as a tofrom. This test make sure this is satisfied\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nint main() {\n  int compute_array[N];\n  int sum = 0, result = 0, errors = 0;\n  int i;\n  \n  OMPVV_TEST_OFFLOADING;\n\n  // Array initialization\n  for (i=0; i<N; i++) \n    compute_array[i] = 10;\n\n#pragma omp target map(compute_array)\n  {\n    for (i = 0; i < N; i++)\n      compute_array[i] += i;\n   \n  } // End target\n\n  for (i = 0; i < N; i++)\n    sum = sum + compute_array[i];\n  \n  for (i = 0; i < N; i++)\n    result += 10 + i;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != sum);\n\n  OMPVV_REPORT_AND_RETURN(errors)\n}\n",
        "error_code": "//===--test_target_map_array_default.c - test default behavior of array map--===//\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// Whenever a map-type-modifier is not specified in the map clause, the symbol\n// is mapped as a tofrom. This test make sure this is satisfied\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nint main() {\n  int compute_array[N];\n  int sum = 0, result = 0, errors = 0;\n  int i;\n  \n  OMPVV_TEST_OFFLOADING;\n\n  // Array initialization\n  for (i=0; i<N; i++) \n    compute_array[i] = 10;\n\n#pragma omp target map(compute_array)\n  \n    for (i = 0; i < N; i++)\n      compute_array[i] += i;\n   \n  } // End target\n\n  for (i = 0; i < N; i++)\n    sum = sum + compute_array[i];\n  \n  for (i = 0; i < N; i++)\n    result += 10 + i;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != sum);\n\n  OMPVV_REPORT_AND_RETURN(errors)\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_parallel_for_if_no_modifier.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_if_no_modifier());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 5232",
        "issue_id": 4,
        "original_code": "//===---- test_target_teams_distribute_parallel_for_if_no_modifier.c --------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// In this test we want to try to check if the if clause is working \n// when used with the combined construct target teams distribute parallel for\n// and no modifier is specified.\n// To do this we check if offloading is working, if it is not, it won't be\n// possible for us to tell if the test passed or not, since it depends on \n// offloading capabilities. \n//\n// The if has a directive-name-modifier that specifies to which directive the \n// if applies to (either both directives, to the target or to the parallel). \n// we create three test, one for no directive, another one for the target directive\n// and another one for the parallel directive \n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define ATTEMPT_THRESHOLD 70\n#define NUM_ATTEMPTS 100\n#define N 1024\n\nint checkPreconditions() {\n  // We test if offloading is enable, and if \n  // the number of threads is not 1. Having \n  // the number of threads equal to 1 is legal, but \n  // we won't be able to test if the 'if' clause is \n  // affecting this or not\n\n  // Testing for offloading\n  int isOffloading = 0;\n  int i;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"With offloading off, it is not possible to test if on the parallel and not the target\");\n\n  // Testing for number of threads\n  int init_num_threads_dev[N], init_num_threads_host[N];\n  // init_num_threads_dev and init_num_threads_host arrays initialization\n  for (i = 0; i < N; i++) {\n    init_num_threads_dev[i] = 0;\n    init_num_threads_host[i] = 0;\n  }\n\n  // Get the init_num_threads for host and device. If it is 1, then we \n  // cannot test the if parallel \n  // See section 2.5.1 of the ref manual\n#pragma omp target teams distribute parallel for num_threads(OMPVV_NUM_THREADS_DEVICE)\n  for (i = 0; i < N; i++) {\n    init_num_threads_dev[i] = omp_get_num_threads();\n  }\n\n#pragma omp parallel for num_threads(OMPVV_NUM_THREADS_DEVICE)\n  for (i = 0; i < N; i++) {\n    init_num_threads_host[i] = omp_get_num_threads();\n  }\n  \n  // We check that not all the values are 1. This would make the test of if parallel\n  // not possible. \n  int raiseWarningDevice = 0, raiseWarningHost = 0;\n  for (i = 0; i < N; i++) {\n    if (init_num_threads_dev[i] > 1 ) {\n      raiseWarningDevice +=  1;\n    }\n    if ( init_num_threads_host[i] > 1) {\n      raiseWarningHost += 1;\n    }\n  }\n  OMPVV_WARNING_IF(raiseWarningDevice == 0, \"Initial number of threads in device was 1. It is not possible to test the if for the parallel directive\");\n  OMPVV_WARNING_IF(raiseWarningHost == 0, \"Initial number of threads in host was 1. It is not possible to test the if for the parallel directive\");\n\n  return isOffloading;\n}\n\nint test_target_teams_distribute_if_no_modifier() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_if_no_modifier\");\n\n  int isOffloading = checkPreconditions();\n\n  int a[N];\n  int warning[N] ; // num_threads = 1 is not technically an error\n  int attempt = 0;\n  int errors = 0;\n  int i;\n\n  for (i = 0; i < N; i++) {\n    a[i] = 1;\n    warning[i] = 0;\n  }\n\n  // We iterate NUM_ATTEMPTS times. When the iteration value is >= ATTEMPT_THRESHOLD the \n  // execution of the target region should happen in the devie, and the number of threads\n  // is expected to be greater than 1 (although if it is not, this is not an error, just warning)\n  // If the iteration variable attempt  < ATTEMPT_THRESHOLD, the if condition evaluates to false, \n  // and hence the execution should occur in the host with a number of threads equal to 1.\n  // We check that when we are executing on the host, the value of the iteration variable is \n  // greather than ATTEMPT_THRESHOLD, and we make sure the number of threads is 1. \n  for (attempt = 0; attempt < NUM_ATTEMPTS; ++attempt) {\n#pragma omp target teams distribute parallel for if(attempt >= ATTEMPT_THRESHOLD)\\\n    map(tofrom: a, warning) num_threads(OMPVV_NUM_THREADS_DEVICE)\n    for (i = 0; i < N; i++) {\n      if (omp_is_initial_device()) {\n        // if(false): We should execute in the host \n        // and the number of threads is expected \n        // to be 1\n        a[i] += (omp_get_num_threads() > 1) ? 10 : 0; // This +10 should not happena\n        a[i] += (attempt >= ATTEMPT_THRESHOLD) ? 10 : 0; // This +10 should not happena\n      } else {\n        a[i] += 1;\n        warning[i] += (omp_get_num_threads() == 1 ? 1 : 0); // We cannot say that this is an error but we can raise a warning\n      }\n    }\n  }\n\n  int raiseWarning = 0;\n  \n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, a[i] != 1 + (NUM_ATTEMPTS - ATTEMPT_THRESHOLD));\n    if (warning[i] != 0) {\n      raiseWarning = 1;\n    }\n  }\n  OMPVV_WARNING_IF(raiseWarning != 0, \"The number of threads was 1 even though we expected it to be more than 1. Not a compliance error in the specs\");\n\n  OMPVV_ERROR_IF(errors, \"error in if(no-modifier). Possible causes are: the number of threads was greater than 1 for if(false), the test executed in the host for if(true), or the test executed in the device for if(false)\");\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_if_no_modifier());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_teams_distribute_parallel_for_if_no_modifier.c --------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// In this test we want to try to check if the if clause is working \n// when used with the combined construct target teams distribute parallel for\n// and no modifier is specified.\n// To do this we check if offloading is working, if it is not, it won't be\n// possible for us to tell if the test passed or not, since it depends on \n// offloading capabilities. \n//\n// The if has a directive-name-modifier that specifies to which directive the \n// if applies to (either both directives, to the target or to the parallel). \n// we create three test, one for no directive, another one for the target directive\n// and another one for the parallel directive \n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define ATTEMPT_THRESHOLD 70\n#define NUM_ATTEMPTS 100\n#define N 1024\n\nint checkPreconditions() {\n  // We test if offloading is enable, and if \n  // the number of threads is not 1. Having \n  // the number of threads equal to 1 is legal, but \n  // we won't be able to test if the 'if' clause is \n  // affecting this or not\n\n  // Testing for offloading\n  int isOffloading = 0;\n  int i;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"With offloading off, it is not possible to test if on the parallel and not the target\");\n\n  // Testing for number of threads\n  int init_num_threads_dev[N], init_num_threads_host[N];\n  // init_num_threads_dev and init_num_threads_host arrays initialization\n  for (i = 0; i < N; i++) {\n    init_num_threads_dev[i] = 0;\n    init_num_threads_host[i] = 0;\n  }\n\n  // Get the init_num_threads for host and device. If it is 1, then we \n  // cannot test the if parallel \n  // See section 2.5.1 of the ref manual\n#pragma omp target teams distribute parallel for num_threads(OMPVV_NUM_THREADS_DEVICE)\n  for (i = 0; i < N; i++) {\n    init_num_threads_dev[i] = omp_get_num_threads();\n  }\n\n#pragma omp parallel for num_threads(OMPVV_NUM_THREADS_DEVICE)\n  for (i = 0; i < N; i++) {\n    init_num_threads_host[i] = omp_get_num_threads();\n  }\n  \n  // We check that not all the values are 1. This would make the test of if parallel\n  // not possible. \n  int raiseWarningDevice = 0, raiseWarningHost = 0;\n  for (i = 0; i < N; i++) {\n    if (init_num_threads_dev[i] > 1 ) {\n      raiseWarningDevice +=  1;\n    }\n    if ( init_num_threads_host[i] > 1) {\n      raiseWarningHost += 1;\n    }\n  }\n  OMPVV_WARNING_IF(raiseWarningDevice == 0, \"Initial number of threads in device was 1. It is not possible to test the if for the parallel directive\");\n  OMPVV_WARNING_IF(raiseWarningHost == 0, \"Initial number of threads in host was 1. It is not possible to test the if for the parallel directive\");\n\n  return isOffloading;\n}\n\nint test_target_teams_distribute_if_no_modifier() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_if_no_modifier\");\n\n  int isOffloading = checkPreconditions();\n\n  int a[N];\n  int warning[N] ; // num_threads = 1 is not technically an error\n  int attempt = 0;\n  int errors = 0;\n  int i;\n\n  for (i = 0; i < N; i++) {\n    a[i] = 1;\n    warning[i] = 0;\n  }\n\n  // We iterate NUM_ATTEMPTS times. When the iteration value is >= ATTEMPT_THRESHOLD the \n  // execution of the target region should happen in the devie, and the number of threads\n  // is expected to be greater than 1 (although if it is not, this is not an error, just warning)\n  // If the iteration variable attempt  < ATTEMPT_THRESHOLD, the if condition evaluates to false, \n  // and hence the execution should occur in the host with a number of threads equal to 1.\n  // We check that when we are executing on the host, the value of the iteration variable is \n  // greather than ATTEMPT_THRESHOLD, and we make sure the number of threads is 1. \n  for (attempt = 0; attempt < NUM_ATTEMPTS; ++attempt) {\n#pragma omp target teams distribute parallel for if(attempt >= ATTEMPT_THRESHOLD)\\\n    map(tofrom: a, warning) num_threads(OMPVV_NUM_THREADS_DEVICE)\n    for (i = 0; i < N; i++) {\n      if (omp_is_initial_device()) {\n        // if(false): We should execute in the host \n        // and the number of threads is expected \n        // to be 1\n        a[i] += (omp_get_num_threads() > 1) ? 10 : 0; // This +10 should not happena\n        a[i] += (attempt >= ATTEMPT_THRESHOLD) ? 10 : 0; // This +10 should not happena\n      } else {\n        a[i] += 1;\n        warning[i] += (omp_get_num_threads() == 1 ? 1 : 0); // We cannot say that this is an error but we can raise a warning\n      }\n    }\n  }\n\n  int raiseWarning = 0;\n  \n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, a[i] != 1 + (NUM_ATTEMPTS - ATTEMPT_THRESHOLD));\n    if (warning[i] != 0) {\n      raiseWarning = 1;\n    }\n  }\n  OMPVV_WARNING_IF(raiseWarning != 0, \"The number of threads was 1 even though we expected it to be more than 1. Not a compliance error in the specs\");\n\n  OMPVV_ERROR_IF(errors, \"error in if(no-modifier). Possible causes are: the number of threads was greater than 1 for if(false), the test executed in the host for if(true), or the test executed in the device for if(false)\");\n\n  return errors;\n}\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_private.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 1240",
        "issue_id": 2,
        "original_code": "//===--test_target_private.c ----------------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// Testing private clause with target directive. The test begins by initializing\n// and filling a 2-D array with all zeros and generating four threads. In a parallel\n// region, each thread is assigned a thread number and an integer. At the beginning\n// of the parallel region, the 2-D array is mapped to device alongside the private\n// integer value and firstprivate unqiue thread number. The integer value is set\n// equal to the thread number inside of the target region and each column of the\n// array is filled based on which thread is currently operating. Finally, back on the\n// host, we check that array is properly filled.\n//\n////===--------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define N 10\n\nint main() {\n\n  int compute_array[OMPVV_NUM_THREADS_HOST][N];\n  int errors = 0;\n  int i, j;\n  int real_num_threads;\n\n  //Check for offloading\n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n\n  for (i = 0; i < OMPVV_NUM_THREADS_HOST; i++) {\n    for (j = 0; j < N; j++) {\n      compute_array[i][j] = 0;\n    }\n  }\n\n  omp_set_num_threads(OMPVV_NUM_THREADS_HOST);\n#pragma omp parallel\n  {\n    int fp_val = omp_get_thread_num();\n    int p_val=0;\n    real_num_threads = omp_get_num_threads();\n\n#pragma omp target map(tofrom:compute_array[fp_val][0:N]) firstprivate(fp_val) private(p_val)\n    {\n      p_val = fp_val;\n      for (i = 0; i < N; i++)\n        compute_array[p_val][i] += p_val;\n    } // end target\n  }//end parallel\n\n  for (i = 0; i < real_num_threads; i++) {\n    for (j = 0; j < N; j++){\n      OMPVV_TEST_AND_SET_VERBOSE(errors, (compute_array[i][j] != i));\n    }\n  }//end for\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n}\n",
        "error_code": "//===--test_target_private.c ----------------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// Testing private clause with target directive. The test begins by initializing\n// and filling a 2-D array with all zeros and generating four threads. In a parallel\n// region, each thread is assigned a thread number and an integer. At the beginning\n// of the parallel region, the 2-D array is mapped to device alongside the private\n// integer value and firstprivate unqiue thread number. The integer value is set\n// equal to the thread number inside of the target region and each column of the\n// array is filled based on which thread is currently operating. Finally, back on the\n// host, we check that array is properly filled.\n//\n////===--------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define N 10\n\nint main() {\n\n  int compute_array[OMPVV_NUM_THREADS_HOST][N];\n  int errors = 0;\n  int i, j;\n  int real_num_threads;\n\n  //Check for offloading\n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n\n  for (i = 0; i < OMPVV_NUM_THREADS_HOST; i++) {\n    for (j = 0; j < N; j++) {\n      compute_array[i][j] = 0;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n    }\n  }\n\n  omp_set_num_threads(OMPVV_NUM_THREADS_HOST);\n#pragma omp parallel\n  {\n    int fp_val = omp_get_thread_num();\n    int p_val=0;\n    real_num_threads = omp_get_num_threads();\n\n#pragma omp target map(tofrom:compute_array[fp_val][0:N]) firstprivate(fp_val) private(p_val)\n    {\n      p_val = fp_val;\n      for (i = 0; i < N; i++)\n        compute_array[p_val][i] += p_val;\n    } // end target\n  }//end parallel\n\n  for (i = 0; i < real_num_threads; i++) {\n    for (j = 0; j < N; j++){\n      OMPVV_TEST_AND_SET_VERBOSE(errors, (compute_array[i][j] != i));\n    }\n  }//end for\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_taskloop_simd_shared.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp parallel\" with directive \"#pragma omp single\" at position 653",
        "issue_id": 0,
        "original_code": "//===--test_taskloop_simd_shared.c ----------------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// Test uses a value within a taskloop & an atomic construct to update the value of\n// s_val. The taskloop then uses SIMD to update the A array using the values from the \n// other 2 arrays & s_val.\n//\n////===--------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint taskloop_simd_shared() {\n\n  int errors = 0;\n  int i;\n  int A[N], B[N], C[N];\n  for(int i = 0; i < N; i++){\n    A[i] = 1;\n    B[i] = 2;\n    C[i] = 3;\n  }\n\n#pragma omp parallel\n  {\n    int s_val=4;\n    #pragma omp single\n    #pragma omp taskloop simd shared(s_val)\n      for (i = 0; i < N; i++){\n        A[i] *= B[i] * C[i] * s_val;\n      }\n    #pragma omp barrier\n    #pragma omp single\n    for(int i = 0; i < N; i++){\n      OMPVV_TEST_AND_SET_VERBOSE(errors, A[i] != B[i] * C[i] * s_val);\n    }\n  } //end parallel\n  return errors;\n\n}\n\nint main() {\n    int errors = 0;\n    OMPVV_TEST_AND_SET_VERBOSE(errors, taskloop_simd_shared());\n    OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--test_taskloop_simd_shared.c ----------------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// Test uses a value within a taskloop & an atomic construct to update the value of\n// s_val. The taskloop then uses SIMD to update the A array using the values from the \n// other 2 arrays & s_val.\n//\n////===--------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint taskloop_simd_shared() {\n\n  int errors = 0;\n  int i;\n  int A[N], B[N], C[N];\n  for(int i = 0; i < N; i++){\n    A[i] = 1;\n    B[i] = 2;\n    C[i] = 3;\n  }\n\n#pragma omp single\n  {\n    int s_val=4;\n    #pragma omp single\n    #pragma omp taskloop simd shared(s_val)\n      for (i = 0; i < N; i++){\n        A[i] *= B[i] * C[i] * s_val;\n      }\n    #pragma omp barrier\n    #pragma omp single\n    for(int i = 0; i < N; i++){\n      OMPVV_TEST_AND_SET_VERBOSE(errors, A[i] != B[i] * C[i] * s_val);\n    }\n  } //end parallel\n  return errors;\n\n}\n\nint main() {\n    int errors = 0;\n    OMPVV_TEST_AND_SET_VERBOSE(errors, taskloop_simd_shared());\n    OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_task_critical.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp parallel\" with directive \"#pragma omp single\" at position 894",
        "issue_id": 0,
        "original_code": "//===-- test_task_critical.c ------------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// Description:\n// testTaskWithCriticalBasic()\n// This is a basic test to demonstrate how a shared resource\n// can be accessed and written to in multiple thread environment.\n//\n//testTaskWithCriticalAdvanced()\n// This is a advanced test to demonstrate how a shared resource\n// can be accessed and written to in multiple thread environment.\n// In this a buffer is filled with random integers. The parallel\n// region counts the number of prime integers.\n//===----------------------------------------------------------------------===//\n\n\n\n#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\nint testTaskWithCriticalBasic() {\n  int errors = 0;\n  int count = 0;\n  int NThrds = -2;\n  omp_set_num_threads(OMPVV_NUM_THREADS_HOST);\n  \n#pragma omp parallel\n  {\n      if(omp_get_thread_num() == 0) NThrds = omp_get_num_threads();\n       \n#pragma omp task\n    {\n#pragma omp critical\n      {\n        count = count + 1;\n      }\n    }\n  }\n  int ret = 0;\n  if (count == NThrds) {\n    ret = 0;\n  } else {\n    ret = -1;\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, ret != 0);\n  return errors;\n}\n\n/**\n  Local Function check if number is prime\n*/\nint isPrime(unsigned int number) {\n  int ret = 0;\n  if (number < 2) {\n    return 1;\n  }\n  for (int num = 2; (num*num) <= number; num++) {\n    if ((number % num) == 0) {\n      ret = 1;\n      break;\n    }\n  }\n  return ret;\n}\n\nint testTaskWithCriticalAdvanced(int numThreads, int expectedVal) {\n  int errors = 0;\n  int countPrime = 0, count = 0;\n  unsigned int *A = (unsigned int*) (malloc(numThreads*sizeof(unsigned int)));\n  omp_set_num_threads(numThreads);\n  // fill data\n  for (int i = 0; i < numThreads; i++) {\n    A[i] = i;\n  }\n  // Calculate number of prime numbers \n#pragma omp parallel\n  {\n#pragma omp task\n    {\n      int idx = 0;\n#pragma omp critical\n      {\n        count++;\n        idx = count - 1;\n      }\n      int ret = isPrime(A[idx]);\n#pragma omp critical\n      {\n        if (ret == 0) {\n          countPrime++;\n        }\n      }\n    }\n  }\n  \n  free(A);\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, countPrime != expectedVal);\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithCriticalBasic());\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithCriticalAdvanced(1, 0));\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===-- test_task_critical.c ------------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// Description:\n// testTaskWithCriticalBasic()\n// This is a basic test to demonstrate how a shared resource\n// can be accessed and written to in multiple thread environment.\n//\n//testTaskWithCriticalAdvanced()\n// This is a advanced test to demonstrate how a shared resource\n// can be accessed and written to in multiple thread environment.\n// In this a buffer is filled with random integers. The parallel\n// region counts the number of prime integers.\n//===----------------------------------------------------------------------===//\n\n\n\n#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\nint testTaskWithCriticalBasic() {\n  int errors = 0;\n  int count = 0;\n  int NThrds = -2;\n  omp_set_num_threads(OMPVV_NUM_THREADS_HOST);\n  \n#pragma omp single\n  {\n      if(omp_get_thread_num() == 0) NThrds = omp_get_num_threads();\n       \n#pragma omp task\n    {\n#pragma omp critical\n      {\n        count = count + 1;\n      }\n    }\n  }\n  int ret = 0;\n  if (count == NThrds) {\n    ret = 0;\n  } else {\n    ret = -1;\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, ret != 0);\n  return errors;\n}\n\n/**\n  Local Function check if number is prime\n*/\nint isPrime(unsigned int number) {\n  int ret = 0;\n  if (number < 2) {\n    return 1;\n  }\n  for (int num = 2; (num*num) <= number; num++) {\n    if ((number % num) == 0) {\n      ret = 1;\n      break;\n    }\n  }\n  return ret;\n}\n\nint testTaskWithCriticalAdvanced(int numThreads, int expectedVal) {\n  int errors = 0;\n  int countPrime = 0, count = 0;\n  unsigned int *A = (unsigned int*) (malloc(numThreads*sizeof(unsigned int)));\n  omp_set_num_threads(numThreads);\n  // fill data\n  for (int i = 0; i < numThreads; i++) {\n    A[i] = i;\n  }\n  // Calculate number of prime numbers \n#pragma omp parallel\n  {\n#pragma omp task\n    {\n      int idx = 0;\n#pragma omp critical\n      {\n        count++;\n        idx = count - 1;\n      }\n      int ret = isPrime(A[idx]);\n#pragma omp critical\n      {\n        if (ret == 0) {\n          countPrime++;\n        }\n      }\n    }\n  }\n  \n  free(A);\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, countPrime != expectedVal);\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithCriticalBasic());\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithCriticalAdvanced(1, 0));\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_enter_exit_data_depend.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 2788",
        "issue_id": 2,
        "original_code": "//===---test_target_enter_exit_data_depend.c --------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// This test checks functionality of target enter data and target exit data \n// to depend 'in' and 'out' using two separate functions. The first function \n// test_async_between_task_target() mixes host-based tasks with target-based\n// tasks, while the second function test_async_between_target() is testing \n// for target enter exit data to depend 'in' and 'out' respectively, while also\n// checking that a nowait clause can be used to ensure asynchronous behavior.\n//\n//===------------------------------------------------------------------------===//\n\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\n/*\n * Test if it is possible to:\n * 1. target enter data to depend 'in' and 'out'\n * 2. target exit data to depend 'in' and 'out'\n * 3. Mix target-based tasks with host tasks.\n */\nint test_async_between_task_target() {\n  OMPVV_INFOMSG(\"test_async_between_task_target\");\n\n  int errors = 0;\n  double sum = 0.0;\n  double* h_array = (double *) malloc(N * sizeof(double));\n  double* in_1 = (double *) malloc(N * sizeof(double));\n  double* in_2 = (double *) malloc(N * sizeof(double));\n  \n  // host task\n#pragma omp task depend(out: in_1) shared(in_1)\n  {\n    for (int i = 0; i < N; ++i) {\n      in_1[i] = 1;\n    }\n  }\n\n  // host task\n#pragma omp task depend(out: in_2) shared(in_2)\n  {\n    for (int i = 0; i < N; ++i) {\n      in_2[i] = 2;\n    }\n  }\n\n  // target enter data\n#pragma omp target enter data map(alloc: h_array[0:N]) map(to: in_1[0:N]) map(to: in_2[0:N]) depend(out: h_array) depend(in: in_1) depend(in: in_2) \n\n  // target task to compute on the device\n  // adding redundant depends on in_1 + in_2 to make the test work if compiled for the host\n#pragma omp task shared (h_array, in_1, in_2) depend(inout: h_array) depend(in: in_1) depend(in: in_2)\n  {\n#pragma omp target  \n    {\n      for (int i = 0; i < N; ++i) {\n        h_array[i] = in_1[i]*in_2[i];\n      }\n    }\n  }\n\n  // target exit data\n#pragma omp target exit data map(from: h_array[0:N]) depend(inout: h_array) \n\n  // host task\n#pragma omp task depend(in: h_array) shared(sum, h_array)\n  {\n    // checking results\n    for (int i = 0; i < N; ++i) {\n      sum += h_array[i];\n    }\n  }\n#pragma omp taskwait\n\n  errors = 2.0*N != sum;\n\n#pragma omp target exit data map(release: h_array[0:N], in_1[0:N], in_2[0:N])\n  free(h_array);\n  free(in_1);\n  free(in_2);\n  return errors;\n}\n\n/*\n * Test if it is possible to:\n * 1. target enter data to depend 'out'\n * 2. target exit data to depend 'in'\n * 3. use nowait for async\n */\nint test_async_between_target() {\n  OMPVV_INFOMSG(\"test_async_between_target\");\n\n  int errors = 0;\n  int sum = 0;\n  int* h_array = (int *) malloc(N * sizeof(int));\n  int val = 2;\n\n  // target enter data\n#pragma omp target enter data map(alloc: h_array[0:N]) depend(out: h_array) \n\n#pragma omp target enter data map(to: val) depend(out: val) \n\n#pragma omp target depend(inout: h_array) depend(in: val) \n  {\n    for (int i = 0; i < N; ++i) {\n      h_array[i] = val;\n    }\n  }\n\n  // target exit data\n#pragma omp target exit data map(from: h_array[0:N]) depend(in: h_array) \n\n#pragma omp taskwait\n\n  // checking results\n  for (int i = 0; i < N; ++i) {\n    sum += h_array[i];\n  }\n  \n  OMPVV_TEST_AND_SET(errors, 2*N != sum);\n\n#pragma omp target exit data map(release: h_array[0:N], val)\n  free(h_array);\n  return errors;\n}\n\nint main(){\n  int errors = 0;\n \n  // We test for offloading\n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_async_between_target());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_async_between_task_target());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---test_target_enter_exit_data_depend.c --------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// This test checks functionality of target enter data and target exit data \n// to depend 'in' and 'out' using two separate functions. The first function \n// test_async_between_task_target() mixes host-based tasks with target-based\n// tasks, while the second function test_async_between_target() is testing \n// for target enter exit data to depend 'in' and 'out' respectively, while also\n// checking that a nowait clause can be used to ensure asynchronous behavior.\n//\n//===------------------------------------------------------------------------===//\n\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\n/*\n * Test if it is possible to:\n * 1. target enter data to depend 'in' and 'out'\n * 2. target exit data to depend 'in' and 'out'\n * 3. Mix target-based tasks with host tasks.\n */\nint test_async_between_task_target() {\n  OMPVV_INFOMSG(\"test_async_between_task_target\");\n\n  int errors = 0;\n  double sum = 0.0;\n  double* h_array = (double *) malloc(N * sizeof(double));\n  double* in_1 = (double *) malloc(N * sizeof(double));\n  double* in_2 = (double *) malloc(N * sizeof(double));\n  \n  // host task\n#pragma omp task depend(out: in_1) shared(in_1)\n  {\n    for (int i = 0; i < N; ++i) {\n      in_1[i] = 1;\n    }\n  }\n\n  // host task\n#pragma omp task depend(out: in_2) shared(in_2)\n  {\n    for (int i = 0; i < N; ++i) {\n      in_2[i] = 2;\n    }\n  }\n\n  // target enter data\n#pragma omp target enter data map(alloc: h_array[0:N]) map(to: in_1[0:N]) map(to: in_2[0:N]) depend(out: h_array) depend(in: in_1) depend(in: in_2) \n\n  // target task to compute on the device\n  // adding redundant depends on in_1 + in_2 to make the test work if compiled for the host\n#pragma omp task shared (h_array, in_1, in_2) depend(inout: h_array) depend(in: in_1) depend(in: in_2)\n  {\n#pragma omp target  \n    {\n      for (int i = 0; i < N; ++i) {\n        h_array[i] = in_1[i]*in_2[i];\n      }\n    }\n  }\n\n  // target exit data\n#pragma omp target exit data map(from: h_array[0:N]) depend(inout: h_array) \n\n  // host task\n#pragma omp task depend(in: h_array) shared(sum, h_array)\n  {\n    // checking results\n    for (int i = 0; i < N; ++i) {\n      sum += h_array[i];\n    }\n  }\n#pragma omp taskwait\n\n  errors = 2.0*N != sum;\n\n#pragma omp target exit data map(release: h_array[0:N], in_1[0:N], in_2[0:N])\n  free(h_array);\n  free(in_1);\n  free(in_2);\n  return errors;\n}\n\n/*\n * Test if it is possible to:\n * 1. target enter data to depend 'out'\n * 2. target exit data to depend 'in'\n * 3. use nowait for async\n */\nint test_async_between_target() {\n  OMPVV_INFOMSG(\"test_async_between_target\");\n\n  int errors = 0;\n  int sum = 0;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n  int* h_array = (int *) malloc(N * sizeof(int));\n  int val = 2;\n\n  // target enter data\n#pragma omp target enter data map(alloc: h_array[0:N]) depend(out: h_array) \n\n#pragma omp target enter data map(to: val) depend(out: val) \n\n#pragma omp target depend(inout: h_array) depend(in: val) \n  {\n    for (int i = 0; i < N; ++i) {\n      h_array[i] = val;\n    }\n  }\n\n  // target exit data\n#pragma omp target exit data map(from: h_array[0:N]) depend(in: h_array) \n\n#pragma omp taskwait\n\n  // checking results\n  for (int i = 0; i < N; ++i) {\n    sum += h_array[i];\n  }\n  \n  OMPVV_TEST_AND_SET(errors, 2*N != sum);\n\n#pragma omp target exit data map(release: h_array[0:N], val)\n  free(h_array);\n  return errors;\n}\n\nint main(){\n  int errors = 0;\n \n  // We test for offloading\n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_async_between_target());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_async_between_task_target());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/reduction_separated_directives.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n      counts_reduction = counts_team;\n    }\" at position 1275",
        "issue_id": 4,
        "original_code": "//===---- reduction_separated_directives.c --------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks the behavior of a reduction clause with separated target teams\n// parallel for directives by comparing the results to those from atomic-protected\n// writes without a reduction. This test comes from the aomp development repo, see\n// https://github.com/ROCm-Developer-Tools/aomp/issues/51.\n//\n//===----------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main()\n{\n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_SHARED_ENVIRONMENT;\n\n  int errors = 0;\n  int counts_atomic = 0;\n  int counts_reduction = 0;\n\n#pragma omp target teams map(from: counts_atomic)\n  {\n    int counts_team = 0;\n#pragma omp parallel\n    {\n#pragma omp for\n      for (int i = 0; i < N; ++i)\n#pragma omp atomic\n        counts_team += 1;\n    }\n    if (omp_get_team_num() == 0) {\n      counts_atomic = counts_team;\n    }\n  }\n\n#pragma omp target teams map(from: counts_reduction)\n  {\n    int counts_team = 0;\n#pragma omp parallel\n    {\n#pragma omp for reduction(+: counts_team)\n      for (int i = 0; i < N; ++i)\n        counts_team += 1;\n    }\n    if (omp_get_team_num() == 0) {\n      counts_reduction = counts_team;\n    }\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, counts_atomic != N);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, counts_reduction != N);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- reduction_separated_directives.c --------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks the behavior of a reduction clause with separated target teams\n// parallel for directives by comparing the results to those from atomic-protected\n// writes without a reduction. This test comes from the aomp development repo, see\n// https://github.com/ROCm-Developer-Tools/aomp/issues/51.\n//\n//===----------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main()\n{\n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_SHARED_ENVIRONMENT;\n\n  int errors = 0;\n  int counts_atomic = 0;\n  int counts_reduction = 0;\n\n#pragma omp target teams map(from: counts_atomic)\n  {\n    int counts_team = 0;\n#pragma omp parallel\n    {\n#pragma omp for\n      for (int i = 0; i < N; ++i)\n#pragma omp atomic\n        counts_team += 1;\n    }\n    if (omp_get_team_num() == 0) {\n      counts_atomic = counts_team;\n    }\n  }\n\n#pragma omp target teams map(from: counts_reduction)\n  {\n    int counts_team = 0;\n#pragma omp parallel\n    {\n#pragma omp for reduction(+: counts_team)\n      for (int i = 0; i < N; ++i)\n        counts_team += 1;\n    }\n    if (omp_get_team_num() == 0) \n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, counts_atomic != N);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, counts_reduction != N);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_reduction_or.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 1029",
        "issue_id": 2,
        "original_code": "//===--- test_target_teams_distribute_reduction_or.c-------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the reduction clause on a target teams distribute directive,\n// testing that the variable in the reduction clause is properly reduced using\n// the or operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n#define THRESHOLD 512\n\nint test_or() {\n  char a[N];\n  double true_margin = pow(exp(1), log(.5)/N);   // See the 'and' operator test for\n  int errors = 0;                                // an explanation of this math.\n  int num_teams[N];\n  int tested_true = 0;\n  int tested_false = 0;\n  int itr_count = 0;\n  srand(1);\n\n  while ((!tested_true || !tested_false) && (itr_count < THRESHOLD)) {\n    for (int x = 0; x < N; ++x) {\n      a[x] = rand() / (double)(RAND_MAX) > true_margin;\n      num_teams[x] = -x;\n    }\n\n    char result = 0;\n    char host_result = 0;\n\n#pragma omp target teams distribute reduction(||:result) defaultmap(tofrom:scalar)\n    for (int x = 0; x < N; ++x) {\n      num_teams[x] = omp_get_num_teams();\n      result = result || a[x];\n    }\n\n    for (int x = 0; x < N; ++x) {\n      host_result = host_result || a[x];\n    }\n\n    if (itr_count == 0) {\n      for (int x = 1; x < N; ++x) {\n        OMPVV_WARNING_IF(num_teams[x - 1] != num_teams[x], \"Kernel reported differing numbers of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n      }\n      OMPVV_WARNING_IF(num_teams[0] == 1, \"Test operated with one team.  Reduction clause cannot be tested.\");\n      OMPVV_WARNING_IF(num_teams[0] <= 0, \"Test reported invalid number of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n    }\n\n    OMPVV_TEST_AND_SET_VERBOSE(errors, host_result != result);\n    OMPVV_ERROR_IF(host_result != result, \"Result on device is %d but expected result from host is %d.\", result, host_result);\n\n    if (host_result) {\n      tested_true = 1;\n    } else {\n      tested_false = 1;\n    }\n\n    if (host_result != result) {\n      break;\n    }\n\n    itr_count++;\n  }\n\n  OMPVV_WARNING_IF(!tested_true, \"Did not test a case in which final result was true.\");\n  OMPVV_WARNING_IF(!tested_false, \"Did not test a case in which final result was false.\");\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_or() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_reduction_or.c-------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the reduction clause on a target teams distribute directive,\n// testing that the variable in the reduction clause is properly reduced using\n// the or operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n#define THRESHOLD 512\n\nint test_or() {\n  char a[N];\n  double true_margin = pow(exp(1), log(.5)/N);   // See the 'and' operator test for\n  int errors = 0;                                // an explanation of this math.\n  int num_teams[N];\n  int tested_true = 0;\n  int tested_false = 0;\n  int itr_count = 0;\n  srand(1);\n\n  while ((!tested_true || !tested_false) && (itr_count < THRESHOLD)) {\n    for (int x = 0; x < N; ++x) {\n      a[x] = rand() / (double)(RAND_MAX) > true_margin;\n      num_teams[x] = -x;\n    }\n\n    char result = 0;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n    char host_result = 0;\n\n#pragma omp target teams distribute reduction(||:result) defaultmap(tofrom:scalar)\n    for (int x = 0; x < N; ++x) {\n      num_teams[x] = omp_get_num_teams();\n      result = result || a[x];\n    }\n\n    for (int x = 0; x < N; ++x) {\n      host_result = host_result || a[x];\n    }\n\n    if (itr_count == 0) {\n      for (int x = 1; x < N; ++x) {\n        OMPVV_WARNING_IF(num_teams[x - 1] != num_teams[x], \"Kernel reported differing numbers of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n      }\n      OMPVV_WARNING_IF(num_teams[0] == 1, \"Test operated with one team.  Reduction clause cannot be tested.\");\n      OMPVV_WARNING_IF(num_teams[0] <= 0, \"Test reported invalid number of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n    }\n\n    OMPVV_TEST_AND_SET_VERBOSE(errors, host_result != result);\n    OMPVV_ERROR_IF(host_result != result, \"Result on device is %d but expected result from host is %d.\", result, host_result);\n\n    if (host_result) {\n      tested_true = 1;\n    } else {\n      tested_false = 1;\n    }\n\n    if (host_result != result) {\n      break;\n    }\n\n    itr_count++;\n  }\n\n  OMPVV_WARNING_IF(!tested_true, \"Did not test a case in which final result was true.\");\n  OMPVV_WARNING_IF(!tested_false, \"Did not test a case in which final result was false.\");\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_or() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_parallel_for_map_to.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_map_to());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 1019",
        "issue_id": 4,
        "original_code": "//===---- test_target_teams_distribute_parallel_for_map_to.c ----------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// Testing the mapping of arrays and scalar through the map clause with the \n// to map-modifier.\n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define N 2000\n\nint test_target_teams_distribute_parallel_for_map_to() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_map_to\");\n  \n  int a[N];\n  int b[N];\n  int d[N];\n  int scalar = 50; // This one is to test the to of an scalar\n  int errors = 0;\n  int i, j;\n\n  // array initialization\n  for (i = 0; i < N; i++) {\n    a[i] = 1;\n    b[i] = i;\n    d[i] = 0;\n  }\n\n#pragma omp target teams distribute parallel for map(to: a, b, scalar) map(tofrom: d)\n    for (j = 0; j < N; ++j) {\n      d[j] = (a[j] + b[j]) * scalar;\n    }\n\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, d[i] != (1 + i) * 50);\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_map_to());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_teams_distribute_parallel_for_map_to.c ----------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// Testing the mapping of arrays and scalar through the map clause with the \n// to map-modifier.\n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define N 2000\n\nint test_target_teams_distribute_parallel_for_map_to() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_map_to\");\n  \n  int a[N];\n  int b[N];\n  int d[N];\n  int scalar = 50; // This one is to test the to of an scalar\n  int errors = 0;\n  int i, j;\n\n  // array initialization\n  for (i = 0; i < N; i++) {\n    a[i] = 1;\n    b[i] = i;\n    d[i] = 0;\n  }\n\n#pragma omp target teams distribute parallel for map(to: a, b, scalar) map(tofrom: d)\n    for (j = 0; j < N; ++j) {\n      d[j] = (a[j] + b[j]) * scalar;\n    }\n\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, d[i] != (1 + i) * 50);\n  }\n\n  return errors;\n}\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_firstprivate.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n      OMPVV_TEST_AND_SET(errors, compute_array[i][j] != 101);\n      OMPVV_ERROR_IF(compute_array[i][j] == 100, \"p_val changed after target region for thread %d\",i);\n    }\" at position 1333",
        "issue_id": 4,
        "original_code": "//===--test_target_firstprivate.c ------------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n//Testing first private clause with target directive\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define N 10\n\nint main() {\n  int compute_array[OMPVV_NUM_THREADS_HOST][N];\n  int errors = 0;\n  int i,j;\n  int actualNumThreads;\n\n  OMPVV_TEST_OFFLOADING;\n\n  for (i=0; i<OMPVV_NUM_THREADS_HOST; i++) {\n    for (j=0; j<N; j++) {\n      compute_array[i][j] = 0;\n    }\n  }\n\n  omp_set_num_threads(OMPVV_NUM_THREADS_HOST);\n#pragma omp parallel private(i)\n  {\n    int p_val = omp_get_thread_num();\n    actualNumThreads = omp_get_num_threads();\n\n#pragma omp target map(tofrom:compute_array[p_val:1][0:N]) firstprivate(p_val)\n    {\n      for (i = 0; i < N; i++)\n        compute_array[p_val][i] = 100;\n      // Checking if the value is not copied back\n      p_val++;\n    } // End target\n\n    // Checking the results\n    if (p_val == omp_get_thread_num()) {\n      for (i = 0; i < N; i++)\n        compute_array[p_val][i]++;\n    }\n  } //end-parallel\n\n  OMPVV_WARNING_IF(actualNumThreads == 1, \"The number of threads in the host is 1. This tests is inconclusive\");\n  for (i=0; i<actualNumThreads; i++) {\n    for (j=0; j<N; j++){\n      OMPVV_TEST_AND_SET(errors, compute_array[i][j] != 101);\n      OMPVV_ERROR_IF(compute_array[i][j] == 100, \"p_val changed after target region for thread %d\",i);\n    }\n  }//end-for\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--test_target_firstprivate.c ------------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n//Testing first private clause with target directive\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define N 10\n\nint main() {\n  int compute_array[OMPVV_NUM_THREADS_HOST][N];\n  int errors = 0;\n  int i,j;\n  int actualNumThreads;\n\n  OMPVV_TEST_OFFLOADING;\n\n  for (i=0; i<OMPVV_NUM_THREADS_HOST; i++) {\n    for (j=0; j<N; j++) {\n      compute_array[i][j] = 0;\n    }\n  }\n\n  omp_set_num_threads(OMPVV_NUM_THREADS_HOST);\n#pragma omp parallel private(i)\n  {\n    int p_val = omp_get_thread_num();\n    actualNumThreads = omp_get_num_threads();\n\n#pragma omp target map(tofrom:compute_array[p_val:1][0:N]) firstprivate(p_val)\n    {\n      for (i = 0; i < N; i++)\n        compute_array[p_val][i] = 100;\n      // Checking if the value is not copied back\n      p_val++;\n    } // End target\n\n    // Checking the results\n    if (p_val == omp_get_thread_num()) {\n      for (i = 0; i < N; i++)\n        compute_array[p_val][i]++;\n    }\n  } //end-parallel\n\n  OMPVV_WARNING_IF(actualNumThreads == 1, \"The number of threads in the host is 1. This tests is inconclusive\");\n  for (i=0; i<actualNumThreads; i++) {\n    for (j=0; j<N; j++)\n  }//end-for\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_device1.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 988",
        "issue_id": 1,
        "original_code": "//===------test_target_device.c--------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// Description:\n// This is a basic test to demonstrate target + parallel for + device clause\n//\n//===------------------------------------------------------------------------===//\n#include <stdio.h>\n#include \"omp.h\"\n#include \"ompvv.h\"\n\n#define N 1024\n\n\nint Runtst(int gpu) {\n  int errors = 0;\n  int *A = (int *)malloc(sizeof(int) * N);\n  for (int i = 0; i < N; ++i) {\n    A[i] = i;\n  }\n\n#pragma omp target data map(tofrom: A[0:N]) device(gpu)\n  {\n    #pragma omp target parallel for device(gpu)\n    for (int i = 0; i < N; ++i) {\n      A[i] = A[i] * A[i];\n    }\n  }\n\n  // Verification\n \n  for (int i = 0; i < N; ++i) {\n    if (A[i] != i*i) {\n      errors++;\n    }\n  }\n\n  free(A);\n  return errors;\n}\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int TotGpus = omp_get_num_devices();\n  printf(\"TotGpus: %d\\n\", TotGpus);\n  int errors = 0;\n  for (int gpu = 0; gpu < TotGpus; ++gpu) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (Runtst(gpu) != 0)); \n  }\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===------test_target_device.c--------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// Description:\n// This is a basic test to demonstrate target + parallel for + device clause\n//\n//===------------------------------------------------------------------------===//\n#include <stdio.h>\n#include \"omp.h\"\n#include \"ompvv.h\"\n\n#define N 1024\n\n\nint Runtst(int gpu) {\n  int errors = 0;\n  int *A = (int *)malloc(sizeof(int) * N);\n  for (int i = 0; i < N; ++i) {\n    A[i] = i;\n  }\n\n#pragma omp target data map(tofrom: A[0:N]) device(gpu)\n  {\n    #pragma omp target parallel for device(gpu)\n    for (int i = 0; i < N; ++i) {\n      A[i] = A[i] * A[i];\n    }\n  }\n\n  // Verification\n \n  for (int i = 0; i < N; ++i) {\n    if (A[i] != i*i) {\n      errors++;\n    }\n  }\n\n  free(A);\n  return errors;\n}\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int TotGpus = omp_get_num_devices();\n  printf(\"TotGpus: %d\\n\", TotGpus);\n  int errors = 0;\n  for (int gpu = 0; gpu < TotGpus; ++gpu) \n    OMPVV_TEST_AND_SET_VERBOSE(errors, (Runtst(gpu) != 0)); \n  }\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_taskloop_num_tasks.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp parallel\" with directive \"#pragma omp map\" at position 1505",
        "issue_id": 0,
        "original_code": "//------------------------------------------- test_taskloop_num_tasks.c --------------------------------------//\n//\n// OpenMP API Version 4.5 September 2015\n//\n// This test checks the 'taskloop' directive with the 'num_tasks' clause specified.\n// The 'taskloop' construct parallelizes loops with independent iterations by creating tasks. \n// It allows for efficient parallel execution of loop iterations by distributing them among multiple threads. \n// The 'num_tasks' clause variable ensures that the loop iterations are shared among created 'num_tasks'.\n// i.e the loop iterations are divided among number of tasks (each num_task group is run by same the thread).\n//----------------------------------------------------------------------------------------------------------//\n\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define NUM_THREADS 100\n\n#define NUM_TASKS 6\n#define NUM_ITERATIONS 12\n\nint isGroupIdsSame(int thread_ids[])\n{\n        int iterationsPerGroup = NUM_ITERATIONS / NUM_TASKS;\n\n        for(int i = 0; i < NUM_ITERATIONS; i = i+iterationsPerGroup)\n        {\n          for(int j = 0; j<iterationsPerGroup; j++) {\n            if (thread_ids[i+j] != thread_ids[i]) {\n              return 0; // Return false if any id is different in a group\n            }\n          }\n        }\n\n        return 1; // Return true if all id's are same per group\n}\n\nint test_taskloop_num_tasks() {\n\n   int errors = 0;\n\n   long int var = 0;\n\n   int thread_ids[NUM_THREADS];\n   int num_threads = 0;\n\n   #pragma omp parallel num_threads(NUM_THREADS)\n   {\n      #pragma omp single\n      {\n        num_threads = omp_get_num_threads();\n        #pragma omp taskloop num_tasks(NUM_TASKS)\n        for(int i = 0; i < NUM_ITERATIONS; i++)\n        {\n\t        #pragma omp atomic \n\t        var = var + i;\n\n          thread_ids[i] = omp_get_thread_num();\n        }\n      }\n   }\n\n   \n\n   //To check if the num_threads actually executing the parallel region > 1\n   if(num_threads == 1) {\n     OMPVV_WARNING(\"Only a single thread executed the parallel region\");\n   } else {\n     //if all the tasks in a group are run by a same thread, get TRUE else FALSE\n     OMPVV_TEST_AND_SET_VERBOSE(errors, (isGroupIdsSame(thread_ids) != 1));   \n   }\n\n   OMPVV_TEST_AND_SET_VERBOSE(errors, var != ((NUM_ITERATIONS-1)*(NUM_ITERATIONS)/2));\n\n   return errors;\n}\n\nint main() {\n  \n  int errors = 0;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, (test_taskloop_num_tasks()) != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n\n  return 0;\n}\n",
        "error_code": "//------------------------------------------- test_taskloop_num_tasks.c --------------------------------------//\n//\n// OpenMP API Version 4.5 September 2015\n//\n// This test checks the 'taskloop' directive with the 'num_tasks' clause specified.\n// The 'taskloop' construct parallelizes loops with independent iterations by creating tasks. \n// It allows for efficient parallel execution of loop iterations by distributing them among multiple threads. \n// The 'num_tasks' clause variable ensures that the loop iterations are shared among created 'num_tasks'.\n// i.e the loop iterations are divided among number of tasks (each num_task group is run by same the thread).\n//----------------------------------------------------------------------------------------------------------//\n\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define NUM_THREADS 100\n\n#define NUM_TASKS 6\n#define NUM_ITERATIONS 12\n\nint isGroupIdsSame(int thread_ids[])\n{\n        int iterationsPerGroup = NUM_ITERATIONS / NUM_TASKS;\n\n        for(int i = 0; i < NUM_ITERATIONS; i = i+iterationsPerGroup)\n        {\n          for(int j = 0; j<iterationsPerGroup; j++) {\n            if (thread_ids[i+j] != thread_ids[i]) {\n              return 0; // Return false if any id is different in a group\n            }\n          }\n        }\n\n        return 1; // Return true if all id's are same per group\n}\n\nint test_taskloop_num_tasks() {\n\n   int errors = 0;\n\n   long int var = 0;\n\n   int thread_ids[NUM_THREADS];\n   int num_threads = 0;\n\n   #pragma omp map num_threads(NUM_THREADS)\n   {\n      #pragma omp single\n      {\n        num_threads = omp_get_num_threads();\n        #pragma omp taskloop num_tasks(NUM_TASKS)\n        for(int i = 0; i < NUM_ITERATIONS; i++)\n        {\n\t        #pragma omp atomic \n\t        var = var + i;\n\n          thread_ids[i] = omp_get_thread_num();\n        }\n      }\n   }\n\n   \n\n   //To check if the num_threads actually executing the parallel region > 1\n   if(num_threads == 1) {\n     OMPVV_WARNING(\"Only a single thread executed the parallel region\");\n   } else {\n     //if all the tasks in a group are run by a same thread, get TRUE else FALSE\n     OMPVV_TEST_AND_SET_VERBOSE(errors, (isGroupIdsSame(thread_ids) != 1));   \n   }\n\n   OMPVV_TEST_AND_SET_VERBOSE(errors, var != ((NUM_ITERATIONS-1)*(NUM_ITERATIONS)/2));\n\n   return errors;\n}\n\nint main() {\n  \n  int errors = 0;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, (test_taskloop_num_tasks()) != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n\n  return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/gemv_target_reduction.cpp",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp cancel\" at position 1016",
        "issue_id": 0,
        "original_code": "//===-- gemv_target_reduction.cpp - GEMV with target and reduction ---------===!\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// Taken from the suggestions of the QMCPack team. Uses the combined construct\n// target teams distribute but creates a parallel region inside that uses the \n// reduction clause\n// \n//!===----------------------------------------------------------------------===!\n#include <chrono>\n#include <string>\n#include <cmath>\n#include \"ompvv.h\"\n#include \"omp.h\"\n\n#define N 8192\n\nclass Timer\n{\n  const std::chrono::time_point<std::chrono::system_clock> start;\n  const std::string name;\n\npublic:\n  Timer(const std::string& name_in): start(std::chrono::system_clock::now()), name(name_in) {};\n  ~Timer()\n  {\n    auto end = std::chrono::system_clock::now();\n    OMPVV_INFOMSG(\"Function %s takes %lf us \",name.c_str(), std::chrono::duration_cast<std::chrono::duration<double, std::micro>>(end - start).count());\n  }\n};\n\ntemplate <typename T>\nvoid gemv(int n, T alpha, const T*  A, const T*  V, T*  Vout)\n{\n  #pragma omp target teams distribute map(to:A[:n*n], V[:n]) map(from:Vout[:n])\n  for(int row=0; row<n; row++)\n  {\n    T sum = T(0);\n    const T *  A_row = A+row*n;\n    #pragma omp parallel for reduction(+:sum)\n    for(int col=0; col<n; col++) {\n      sum += A_row[col]*V[col];\n    }\n    Vout[row] = sum*alpha;\n  }\n}\n\ntemplate <class T>\nT* allocate(size_t n)\n{\n  T* ptr = new T[n];\n  std::fill_n(ptr, n, T(1));\n  #pragma omp target enter data map(to:ptr[:n])\n  return ptr;\n}\n\ntemplate <class T>\nvoid deallocate(T* ptr, size_t n)\n{\n  #pragma omp target exit data map(delete:ptr[:n])\n  delete[] ptr;\n}\n\nint main()\n{\n  OMPVV_TEST_OFFLOADING;\n  auto* A = allocate<float>(N*N);\n  auto* V = allocate<float>(N);\n  auto* Vout = allocate<float>(N);\n  int errors = 0;\n\n  {\n    Timer local(\"GEMV\");\n    gemv(N, 1.0f, A, V, Vout);\n  }\n\n  #pragma omp target update from(Vout[:N])\n  for(int i=0; i<N; i++)\n  {\n    OMPVV_TEST_AND_SET(errors, std::abs(Vout[i]-N) > 0.0001);\n    OMPVV_ERROR_IF(std::abs(Vout[i]-N) > 0.0001, \"Error for Vout[%d] = %f, Should be %d\", i, Vout[i], N);\n  }\n\n  deallocate(A, N*N);\n  deallocate(V, N);\n  deallocate(Vout, N);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===-- gemv_target_reduction.cpp - GEMV with target and reduction ---------===!\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// Taken from the suggestions of the QMCPack team. Uses the combined construct\n// target teams distribute but creates a parallel region inside that uses the \n// reduction clause\n// \n//!===----------------------------------------------------------------------===!\n#include <chrono>\n#include <string>\n#include <cmath>\n#include \"ompvv.h\"\n#include \"omp.h\"\n\n#define N 8192\n\nclass Timer\n{\n  const std::chrono::time_point<std::chrono::system_clock> start;\n  const std::string name;\n\npublic:\n  Timer(const std::string& name_in): start(std::chrono::system_clock::now()), name(name_in) {};\n  ~Timer()\n  {\n    auto end = std::chrono::system_clock::now();\n    OMPVV_INFOMSG(\"Function %s takes %lf us \",name.c_str(), std::chrono::duration_cast<std::chrono::duration<double, std::micro>>(end - start).count());\n  }\n};\n\ntemplate <typename T>\nvoid gemv(int n, T alpha, const T*  A, const T*  V, T*  Vout)\n{\n  #pragma omp cancel teams distribute map(to:A[:n*n], V[:n]) map(from:Vout[:n])\n  for(int row=0; row<n; row++)\n  {\n    T sum = T(0);\n    const T *  A_row = A+row*n;\n    #pragma omp parallel for reduction(+:sum)\n    for(int col=0; col<n; col++) {\n      sum += A_row[col]*V[col];\n    }\n    Vout[row] = sum*alpha;\n  }\n}\n\ntemplate <class T>\nT* allocate(size_t n)\n{\n  T* ptr = new T[n];\n  std::fill_n(ptr, n, T(1));\n  #pragma omp target enter data map(to:ptr[:n])\n  return ptr;\n}\n\ntemplate <class T>\nvoid deallocate(T* ptr, size_t n)\n{\n  #pragma omp target exit data map(delete:ptr[:n])\n  delete[] ptr;\n}\n\nint main()\n{\n  OMPVV_TEST_OFFLOADING;\n  auto* A = allocate<float>(N*N);\n  auto* V = allocate<float>(N);\n  auto* Vout = allocate<float>(N);\n  int errors = 0;\n\n  {\n    Timer local(\"GEMV\");\n    gemv(N, 1.0f, A, V, Vout);\n  }\n\n  #pragma omp target update from(Vout[:N])\n  for(int i=0; i<N; i++)\n  {\n    OMPVV_TEST_AND_SET(errors, std::abs(Vout[i]-N) > 0.0001);\n    OMPVV_ERROR_IF(std::abs(Vout[i]-N) > 0.0001, \"Error for Vout[%d] = %f, Should be %d\", i, Vout[i], N);\n  }\n\n  deallocate(A, N*N);\n  deallocate(V, N);\n  deallocate(Vout, N);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_parallel_for_num_threads.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_num_threads());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 2325",
        "issue_id": 4,
        "original_code": "//===---- test_target_teams_distribute_parallel_for_num_threads.c -----------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// Test to check the num_threads clause. This clause changes the upper limit of \n// the number of threads inside the parallel region, when used with the combined\n// construct target teams distribute parallel for.\n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define N 1024\n\nint test_target_teams_distribute_parallel_for_num_threads() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_num_threads\");\n \n  int tested_num_threads[] = {1, 10, 100, 10000};\n  int num_threads[N]; // num_threads = 1 is not technically an error\n  int errors = 0;\n  int raiseWarningOneThread = 0;\n  int i, nt;\n\n\n  // Trying multiple num_threads values from 1 to a large number\n  for (nt = 0; nt < 4; nt++) {\n  \n    OMPVV_INFOMSG(\"Testing for num_threads(%d)\", tested_num_threads[nt]);\n    // Initializing the num_threads array\n    for (i = 0; i < N; i++) {\n      num_threads[i] = -1;\n    }\n#pragma omp target teams distribute parallel for\\\n        map(tofrom: num_threads) num_threads(tested_num_threads[nt])\n    for (i = 0; i < N; i++) {\n      num_threads[i] = omp_get_num_threads();\n    }\n\n    int raiseWarningDifNum = 0;\n    int prevNumThreads = -1;\n    \n    for (i = 0; i < N; i++) {\n      OMPVV_INFOMSG_IF(prevNumThreads != num_threads[i], \" %d threads reported\", num_threads[i]);\n      prevNumThreads = num_threads[i];\n      // If the number of threads is larger than the specified, this is an error\n      OMPVV_TEST_AND_SET(errors, num_threads[i] <=0 || num_threads[i] > tested_num_threads[nt]);\n      if (tested_num_threads[nt] != num_threads[i]) {\n        raiseWarningDifNum = 1;\n      }\n      if (tested_num_threads[nt] != 1 && num_threads[i] == 1) {\n        raiseWarningOneThread++;\n      }\n    }\n    OMPVV_WARNING_IF(raiseWarningDifNum != 0 , \"When testing num_threads(%d), the actual number of threads was different. This is not a compliance error with the specs\", tested_num_threads[nt]);  \n  }\n\n  OMPVV_WARNING_IF(raiseWarningOneThread == 4*N, \"The number of threads was always one, regardless of the num_threads clause. This is not a compliance error in the specs\");  \n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_num_threads());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_teams_distribute_parallel_for_num_threads.c -----------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// Test to check the num_threads clause. This clause changes the upper limit of \n// the number of threads inside the parallel region, when used with the combined\n// construct target teams distribute parallel for.\n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define N 1024\n\nint test_target_teams_distribute_parallel_for_num_threads() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_num_threads\");\n \n  int tested_num_threads[] = {1, 10, 100, 10000};\n  int num_threads[N]; // num_threads = 1 is not technically an error\n  int errors = 0;\n  int raiseWarningOneThread = 0;\n  int i, nt;\n\n\n  // Trying multiple num_threads values from 1 to a large number\n  for (nt = 0; nt < 4; nt++) {\n  \n    OMPVV_INFOMSG(\"Testing for num_threads(%d)\", tested_num_threads[nt]);\n    // Initializing the num_threads array\n    for (i = 0; i < N; i++) {\n      num_threads[i] = -1;\n    }\n#pragma omp target teams distribute parallel for\\\n        map(tofrom: num_threads) num_threads(tested_num_threads[nt])\n    for (i = 0; i < N; i++) {\n      num_threads[i] = omp_get_num_threads();\n    }\n\n    int raiseWarningDifNum = 0;\n    int prevNumThreads = -1;\n    \n    for (i = 0; i < N; i++) {\n      OMPVV_INFOMSG_IF(prevNumThreads != num_threads[i], \" %d threads reported\", num_threads[i]);\n      prevNumThreads = num_threads[i];\n      // If the number of threads is larger than the specified, this is an error\n      OMPVV_TEST_AND_SET(errors, num_threads[i] <=0 || num_threads[i] > tested_num_threads[nt]);\n      if (tested_num_threads[nt] != num_threads[i]) {\n        raiseWarningDifNum = 1;\n      }\n      if (tested_num_threads[nt] != 1 && num_threads[i] == 1) {\n        raiseWarningOneThread++;\n      }\n    }\n    OMPVV_WARNING_IF(raiseWarningDifNum != 0 , \"When testing num_threads(%d), the actual number of threads was different. This is not a compliance error with the specs\", tested_num_threads[nt]);  \n  }\n\n  OMPVV_WARNING_IF(raiseWarningOneThread == 4*N, \"The number of threads was always one, regardless of the num_threads clause. This is not a compliance error in the specs\");  \n  return errors;\n}\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_map_pointer.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===--- test_target_map_pointer.c ------------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// This test check if it is possible to map an array and a pointer to that array,\n// and then access the array through the pointer. It is necessary\n// to specify the array size with [:N]. If offloading is used, the value of p[] \n// is copied over the device. The array will be updated inside the omp target\n// region and compared afterwards\n//\n////===----------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nint main() {\n  int compute_array[N];\n  int *p;\n  int sum = 0, result = 0, errors = 0;\n  int i;\n  \n  \n  // Array initialization\n  for (i = 0; i < N; i++)\n    compute_array[i] = 0;\n  p = &compute_array[0];\n\n  int isOffloading;\n\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n\n  OMPVV_WARNING_IF(!isOffloading, \"This test is running on host, the value of p[] is not copied over to the device\"); \n\n#pragma omp target data map(tofrom: compute_array) //To test default pointer behavior, array must be mapped before the pointer\n#pragma omp target map(to: p[:N]) \n  {\n    // Array modified through the pointer\n    for (i = 0; i < N; i++)\n      p[i] = i;\n   \n  } // end target\n\n  // Result comparison\n  for (i = 0; i < N; i++)\n    sum = sum + compute_array[i];    \n  \n  for (i = 0; i < N; i++)\n    result += i;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != sum);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\ndouble wnvhzhjyhv = 96;\nbyte ffvrucjyuc = 125;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_default_shared.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===--- test_target_teams_distribute_default_shared.c-----------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the default(shared) clause on a target teams distribute\n// directive.  The test aims to validate that when the default(shared) clause\n// is present, all variables without explicit data sharing attributes will\n// be shared within the region.  To test this, we test that a data element\n// that should be shared due to the default(shared) clause is available to\n// all the teams.  The first test uses atomic to write to the variable without\n// race conditions.  The second test uses synchronization constructs to have\n// one thread change the shared variable and ensures all threads see the change.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main() {\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  int a[N];\n  int share = 0;\n  int errors = 0;\n  int num_teams;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n  }\n\n#pragma omp target data map(to: a[0:N]) map(tofrom: share, num_teams)\n  {\n#pragma omp target teams distribute default(shared) defaultmap(tofrom:scalar) num_teams(OMPVV_NUM_TEAMS_DEVICE)\n    for (int x = 0; x < N; ++x) {\n      if (omp_get_team_num() == 0) {\n        num_teams = omp_get_num_teams();\n      }\n#pragma omp atomic\n      share = share + a[x];\n    }\n  }\n\n  for (int x = 0; x < N; ++x) {\n    share = share - x;\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (share != 0));\n\n  share = 5;\n\n#pragma omp target data map(tofrom: a[0:N]) map(tofrom: share)\n  {\n#pragma omp target teams distribute default(shared) defaultmap(tofrom:scalar) num_teams(OMPVV_NUM_TEAMS_DEVICE)\n    for (int x = 0; x < N; ++x) {\n      a[x] = a[x] + share;\n    }\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (a[x] - 5 != x));\n    if (a[x] - 5 != x) {\n      break;\n    }\n  }\n\n  OMPVV_WARNING_IF(num_teams == 1, \"Test operated on one team, results of default shared test are inconclusive.\");\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nint jspzmbrzzh = 230;\nlong oyirklhawn = 83;\nlong ownajhifyd = 126;\nfloat rcisojylim = 255;\ndouble sridhorgrk = 69;\nint uaqhctbtqy = 63;\nshort nrkthjocgu = 58;\ndouble akxpnxoapy = 90;\nfloat nxazgpkxdv = 175;\nlong dkfsvpcwdr = 137;\ndouble mwuxdpekks = 113;\ndouble lhheobsezl = 192;\nbyte ghtjsaghqw = 28;\nbyte puastwfhks = 200;\nfloat sovwljslch = 176;\nlong dngsyimsrl = 18;\ndouble zjlgzedsbq = 148;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/linked_list.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n    node_t * next = head->next;\n    free (head);\n    head = next;\n  }\" at position 3050",
        "issue_id": 4,
        "original_code": "//===---linked_list.c--- Test that implements a linked list in the device-----===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n//\n//  This test creates a linked list, maps it to a device \n//  (if available) and modidifies the data on the device. \n//  The data is mapped back and contents are verified \n//  \n//  Last modified by Jose M Monsalve Diaz, December 24, 2019\n//\n////===----------------------------------------------------------------------===//\n\n#include <stdlib.h>\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define SIZE_LIST 10\n\ntypedef struct node {\n  int data;\n  struct node *next;\n} node_t;\n\nvoid map_ll(node_t * head) {\n  OMPVV_INFOMSG(\"Entering map_ll\");\n\n  node_t * temp = head;\n  if (!temp) {\n    OMPVV_ERROR(\"Head was null\");\n    return;\n  }\n\n#pragma omp target enter data map(to:temp[:1])\n#pragma omp target \n  {\n    temp->data += 1;  \n  }\n  while(temp->next) {\n    //version 1\n    // Note: using array dereference syntax, array section on leaf only\n    // Attachment is *not* explicitly guaranteed\n    //#pragma omp target enter data map(to:head[0].next[:1])\n    //version 2\n    //user does an explicit attachment, this is unequivocally correct code\n    //but rather slower and nastier.\n    node_t * cur = temp->next;\n#pragma omp target enter data map(to:cur[:1])\n#pragma omp target \n    {\n      cur->data += 1;\n      temp->next = cur;\n    }\n    temp=temp->next;\n  }\n}\n\nvoid unmap_ll(node_t * head) {\n  OMPVV_INFOMSG(\"Entering unmap_ll\");\n  node_t * temp = head, *tempNext;\n\n  if (!temp) {\n    OMPVV_ERROR(\"Head was null\");\n    return;\n  }\n\n  tempNext = temp->next;\n#pragma omp target exit data map(from:temp[0:1])\n  temp->next = tempNext;\n  while(temp->next) {\n    // Note: only copies back the data element to avoid overwriting next\n    // pointer\n\n    temp = temp->next;\n    // Save broken link\n    tempNext = temp->next;\n#pragma omp target exit data map(from: temp[0:1])\n    // Fix broken link\n    temp->next = tempNext;\n  }\n}\nvoid push(node_t * head, int data) {\n  node_t * current = head;\n  while (current->next != NULL) {\n    current = current->next;\n  }\n\n  // now we can add a new variable\n  current->next = (node_t *) malloc(sizeof(node_t));\n  current->next->data = data;\n  current->next->next = NULL;\n}\n\nvoid display(node_t * head)\n{\n  node_t * temp=head;\n  while(temp!=NULL)\n  {\n    printf(\"%d\\n\",temp->data);\n    temp=temp->next;\n  }\n}\n\nint check(node_t * head)\n{\n  OMPVV_INFOMSG(\"Entering check\");\n  int error = 0, i=0;\n  node_t * temp=head;\n  while(temp!=NULL)\n  {\n    OMPVV_TEST_AND_SET_VERBOSE(error, temp->data != i+1);\n    i++;  \n    temp=temp->next;\n  }\n  return error;\n}\n\nint main() {\n\n  OMPVV_TEST_OFFLOADING;\n  int i, error = 0;\n  node_t * head = NULL;\n  head = (node_t *) malloc(sizeof(node_t));\n  if (head == NULL) {\n    OMPVV_ERROR(\"There was a problem allocating the head node\");\n    return 1;\n  }\n\n  head->data = 0;\n  head->next = NULL;\n\n  for(i=1; i < SIZE_LIST; i++)\n    push(head,i);\n\n  map_ll(head);\n  unmap_ll(head);\n  \n  OMPVV_TEST_AND_SET_VERBOSE(error, check(head));\n\n  while (head) {\n    node_t * next = head->next;\n    free (head);\n    head = next;\n  }\n\n  OMPVV_REPORT_AND_RETURN(error);\n  return 0;\n}\n\n",
        "error_code": "//===---linked_list.c--- Test that implements a linked list in the device-----===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n//\n//  This test creates a linked list, maps it to a device \n//  (if available) and modidifies the data on the device. \n//  The data is mapped back and contents are verified \n//  \n//  Last modified by Jose M Monsalve Diaz, December 24, 2019\n//\n////===----------------------------------------------------------------------===//\n\n#include <stdlib.h>\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define SIZE_LIST 10\n\ntypedef struct node {\n  int data;\n  struct node *next;\n} node_t;\n\nvoid map_ll(node_t * head) {\n  OMPVV_INFOMSG(\"Entering map_ll\");\n\n  node_t * temp = head;\n  if (!temp) {\n    OMPVV_ERROR(\"Head was null\");\n    return;\n  }\n\n#pragma omp target enter data map(to:temp[:1])\n#pragma omp target \n  {\n    temp->data += 1;  \n  }\n  while(temp->next) {\n    //version 1\n    // Note: using array dereference syntax, array section on leaf only\n    // Attachment is *not* explicitly guaranteed\n    //#pragma omp target enter data map(to:head[0].next[:1])\n    //version 2\n    //user does an explicit attachment, this is unequivocally correct code\n    //but rather slower and nastier.\n    node_t * cur = temp->next;\n#pragma omp target enter data map(to:cur[:1])\n#pragma omp target \n    {\n      cur->data += 1;\n      temp->next = cur;\n    }\n    temp=temp->next;\n  }\n}\n\nvoid unmap_ll(node_t * head) {\n  OMPVV_INFOMSG(\"Entering unmap_ll\");\n  node_t * temp = head, *tempNext;\n\n  if (!temp) {\n    OMPVV_ERROR(\"Head was null\");\n    return;\n  }\n\n  tempNext = temp->next;\n#pragma omp target exit data map(from:temp[0:1])\n  temp->next = tempNext;\n  while(temp->next) {\n    // Note: only copies back the data element to avoid overwriting next\n    // pointer\n\n    temp = temp->next;\n    // Save broken link\n    tempNext = temp->next;\n#pragma omp target exit data map(from: temp[0:1])\n    // Fix broken link\n    temp->next = tempNext;\n  }\n}\nvoid push(node_t * head, int data) {\n  node_t * current = head;\n  while (current->next != NULL) {\n    current = current->next;\n  }\n\n  // now we can add a new variable\n  current->next = (node_t *) malloc(sizeof(node_t));\n  current->next->data = data;\n  current->next->next = NULL;\n}\n\nvoid display(node_t * head)\n{\n  node_t * temp=head;\n  while(temp!=NULL)\n  {\n    printf(\"%d\\n\",temp->data);\n    temp=temp->next;\n  }\n}\n\nint check(node_t * head)\n{\n  OMPVV_INFOMSG(\"Entering check\");\n  int error = 0, i=0;\n  node_t * temp=head;\n  while(temp!=NULL)\n  {\n    OMPVV_TEST_AND_SET_VERBOSE(error, temp->data != i+1);\n    i++;  \n    temp=temp->next;\n  }\n  return error;\n}\n\nint main() {\n\n  OMPVV_TEST_OFFLOADING;\n  int i, error = 0;\n  node_t * head = NULL;\n  head = (node_t *) malloc(sizeof(node_t));\n  if (head == NULL) {\n    OMPVV_ERROR(\"There was a problem allocating the head node\");\n    return 1;\n  }\n\n  head->data = 0;\n  head->next = NULL;\n\n  for(i=1; i < SIZE_LIST; i++)\n    push(head,i);\n\n  map_ll(head);\n  unmap_ll(head);\n  \n  OMPVV_TEST_AND_SET_VERBOSE(error, check(head));\n\n  while (head) \n\n  OMPVV_REPORT_AND_RETURN(error);\n  return 0;\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_task_if.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp parallel\" with directive \"#pragma omp flush\" at position 661",
        "issue_id": 0,
        "original_code": "//===-- test_task_if.c ------------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// Description\n// testTaskWithIf():\n// Create an undeferred task followed by a deferred task\n// in a parallel code section. Ensure that the undeferred\n// task is always executed before deferred task.\n//===----------------------------------------------------------------------===//\n\n\n\n#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\nint testTaskWithIf(int num_threads, int val, int inc) {\n  int errors = 0;\n  int *A = (int*) (malloc(num_threads*sizeof(int)));\n  omp_set_num_threads(num_threads);\n#pragma omp parallel\n  {\n    int id = omp_get_thread_num();\n    A[id] = val;\n#pragma omp task shared(A) if(0)\n    {\n#pragma omp critical\n      {\n        A[id] += inc;\n      }\n    }\n#pragma omp task shared(A) if(1)\n    {\n#pragma omp critical\n      {\n        A[id] *= inc;\n      }\n    }\n  }\n  int ret = 0;\n  for (int i = 0; i < num_threads; i++) {\n    if (A[i] != ((val + inc)*inc)) {\n      ret = 1;\n      break;\n    }\n  }\n  free(A);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, ret != 0);\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithIf(4, 5, 2));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithIf(8, 5, 2));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithIf(16, 5, 2));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithIf(32, 5, 2));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithIf(64, 5, 2));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===-- test_task_if.c ------------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// Description\n// testTaskWithIf():\n// Create an undeferred task followed by a deferred task\n// in a parallel code section. Ensure that the undeferred\n// task is always executed before deferred task.\n//===----------------------------------------------------------------------===//\n\n\n\n#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\nint testTaskWithIf(int num_threads, int val, int inc) {\n  int errors = 0;\n  int *A = (int*) (malloc(num_threads*sizeof(int)));\n  omp_set_num_threads(num_threads);\n#pragma omp flush\n  {\n    int id = omp_get_thread_num();\n    A[id] = val;\n#pragma omp task shared(A) if(0)\n    {\n#pragma omp critical\n      {\n        A[id] += inc;\n      }\n    }\n#pragma omp task shared(A) if(1)\n    {\n#pragma omp critical\n      {\n        A[id] *= inc;\n      }\n    }\n  }\n  int ret = 0;\n  for (int i = 0; i < num_threads; i++) {\n    if (A[i] != ((val + inc)*inc)) {\n      ret = 1;\n      break;\n    }\n  }\n  free(A);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, ret != 0);\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithIf(4, 5, 2));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithIf(8, 5, 2));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithIf(16, 5, 2));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithIf(32, 5, 2));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithIf(64, 5, 2));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_depends.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 2136",
        "issue_id": 1,
        "original_code": "//===----- test_target_depends.c -----------------------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks functionality of the depend clause with various dependence types\n// and map-type-modifiers. Two arrays are initalized on the host and updated within\n// several target regions that all utilize the depend clause with varying specified\n// dependence types. At the end, array values are verified on the host to ensure that \n// synchronization did not result in data races and values were mapped back to device.\n//\n////===-------------------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nint test_all_dependencies() {\n  OMPVV_INFOMSG(\"test_all_dependencies\");\n\n  int errors = 0;\n  int dep_1[N], dep_2[N];\n\n  // Initialize dep_1 and dep_2\n  for (int i = 0; i < N; ++i) {\n    dep_1[i] = 0;\n    dep_2[i] = 0;\n  }\n\n#pragma omp target depend(out: dep_1) map(tofrom: dep_1[0:N])\n  {\n    for (int i = 0; i < N; i++) {\n      dep_1[i] = 1;\n    }\n  } // end of omp target \n\n#pragma omp target depend(out: dep_2) map(tofrom: dep_2[0:N])\n  {\n    for (int i = 0; i < N; i++) {\n      dep_2[i] = 1;\n    }\n  } // end of omp target \n\n  #pragma omp task depend(inout: dep_1) depend(inout: dep_2) \\\n              shared(dep_1, dep_2)\n  {\n    for (int i = 0; i < N; ++i) {\n      dep_1[i]++;\n      dep_2[i]++;\n    }\n  }\n\n  #pragma omp target depend(inout: dep_1) depend(inout: dep_2) \\\n              map(tofrom: dep_1[0:N])  map(tofrom: dep_2[0:N])\n  {\n    for (int i = 0; i < N; i++) {\n      dep_1[i]++;\n      dep_2[i]++;\n    }\n  } // end of omp target \n\n  #pragma omp target depend(in: dep_1) depend(in: dep_2) \\\n              map(tofrom: dep_1[0:N])  map(tofrom: dep_2[0:N])\n  {\n    for (int i = 0; i < N; i++) {\n      dep_1[i]++;\n      dep_2[i]++;\n    }\n  } // end of omp target \n\n  #pragma omp taskwait\n  \n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, dep_1[i] != 4);\n    OMPVV_TEST_AND_SET(errors, dep_2[i] != 4);    \n  }\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_all_dependencies());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n",
        "error_code": "//===----- test_target_depends.c -----------------------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks functionality of the depend clause with various dependence types\n// and map-type-modifiers. Two arrays are initalized on the host and updated within\n// several target regions that all utilize the depend clause with varying specified\n// dependence types. At the end, array values are verified on the host to ensure that \n// synchronization did not result in data races and values were mapped back to device.\n//\n////===-------------------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nint test_all_dependencies() {\n  OMPVV_INFOMSG(\"test_all_dependencies\");\n\n  int errors = 0;\n  int dep_1[N], dep_2[N];\n\n  // Initialize dep_1 and dep_2\n  for (int i = 0; i < N; ++i) {\n    dep_1[i] = 0;\n    dep_2[i] = 0;\n  }\n\n#pragma omp target depend(out: dep_1) map(tofrom: dep_1[0:N])\n  {\n    for (int i = 0; i < N; i++) {\n      dep_1[i] = 1;\n    }\n  } // end of omp target \n\n#pragma omp target depend(out: dep_2) map(tofrom: dep_2[0:N])\n  {\n    for (int i = 0; i < N; i++) {\n      dep_2[i] = 1;\n    }\n  } // end of omp target \n\n  #pragma omp task depend(inout: dep_1) depend(inout: dep_2) \\\n              shared(dep_1, dep_2)\n  {\n    for (int i = 0; i < N; ++i) {\n      dep_1[i]++;\n      dep_2[i]++;\n    }\n  }\n\n  #pragma omp target depend(inout: dep_1) depend(inout: dep_2) \\\n              map(tofrom: dep_1[0:N])  map(tofrom: dep_2[0:N])\n  {\n    for (int i = 0; i < N; i++) {\n      dep_1[i]++;\n      dep_2[i]++;\n    }\n  } // end of omp target \n\n  #pragma omp target depend(in: dep_1) depend(in: dep_2) \\\n              map(tofrom: dep_1[0:N])  map(tofrom: dep_2[0:N])\n  {\n    for (int i = 0; i < N; i++) {\n      dep_1[i]++;\n      dep_2[i]++;\n    }\n  } // end of omp target \n\n  #pragma omp taskwait\n  \n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, dep_1[i] != 4);\n    OMPVV_TEST_AND_SET(errors, dep_2[i] != 4);    \n  }\n  return errors;\n}\n\nint main() \n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_all_dependencies());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_device.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===--- test_target_teams_distribute_device.c-------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the device clause to indicate which device should execute the\n// given target regions.  The test uses the separate device data environments to\n// ensure that operations are executed on the specified device.  If only one\n// device is available, the test issues a warning.\n//\n// By having a separate initialization of the same array on each device at the\n// same time, if all operations were occuring on the same device, we would\n// expect the same results from each device and it wouldn't be able to give\n// proper answers for each initialization.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define ARRAY_SIZE 1024\n\nint main() {\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n\n  int num_devices = omp_get_num_devices();\n  // Allocate num_devices + 1 to avoid zero-sized VLA if num_devices == 0\n  int a[num_devices+1][ARRAY_SIZE];\n  int b[ARRAY_SIZE];\n  int num_teams[num_devices+1];\n  int errors[num_devices+1];\n  int sum_errors = 0;\n\n  OMPVV_INFOMSG(\"Running tests on %d devices\", num_devices);\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    for (int dev = 0; dev < num_devices; ++dev) {\n      a[dev][x] = 1;\n    }\n    b[x] = x;\n  }\n\n  for (int x = 0; x < num_devices; ++x) {\n    num_teams[x] = 0;\n    errors[x] = 0;\n  }\n\n  for (int dev = 0; dev < num_devices; ++dev) {\n#pragma omp target enter data map(to: a[dev][0:ARRAY_SIZE], b[0:ARRAY_SIZE], num_teams[dev:1]) device(dev)\n  }\n\n  for (int dev = 0; dev < num_devices; ++dev) {\n#pragma omp target teams distribute map(alloc: a[dev][0:ARRAY_SIZE], b[0:ARRAY_SIZE], num_teams[dev:1]) device(dev)\n    for (int x = 0; x < ARRAY_SIZE; ++x) {\n      if (omp_get_team_num() == 0) {\n        num_teams[dev] = omp_get_num_teams();\n      }\n      a[dev][x] += b[x] + dev;\n    }\n  }\n\n  for (int dev = 0; dev < num_devices; ++dev) {\n#pragma omp target exit data map(from: a[dev][0:ARRAY_SIZE], num_teams[dev:1]) map(delete: b[0:ARRAY_SIZE]) device(dev)\n    for (int x = 0; x < ARRAY_SIZE; ++x) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors[dev], a[dev][x] != 1 + dev + b[x]);\n      if (a[dev][x] != 1 + dev + b[x]) {\n        break;\n      }\n    }\n  }\n\n  for (int x = 0; x < num_devices; ++x) {\n    sum_errors += errors[x];\n  }\n\n  for (int dev = 0; dev < num_devices; ++dev) {\n    OMPVV_WARNING_IF(!errors[dev] && num_teams[dev] == 1, \"Test operated with one team. Parallelism of teams distribute can't be guaranteed.\");\n    OMPVV_ERROR_IF(errors[dev], \"Test failed with device %d\", dev);\n  }\n\n  OMPVV_REPORT_AND_RETURN(sum_errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nlong zqqzhukxem = 172;\nbyte vjbtsyblmy = 8;\nlong xzzivhgbjd = 197;\nshort pfuvvjzkub = 29;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_parallel_for_schedule_private.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_sched_private());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 2647",
        "issue_id": 4,
        "original_code": "//===---- test_target_teams_distribute_parallel_for_schedule_private.c - private per thread combined construct-===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// private variables are private to the running thread. When using the scheduler clause it should be possible to\n// have a private variable that shares its memory space across multiple iterations\n//\n//\n//===---------------------------------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n// This has been selected for the num teams and num threads below\n#define SIZE_N 2048\n\nint test_target_teams_distribute_parallel_for_sched_private() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_schedule_private\");\n  \n  int a[SIZE_N];\n  int firstprivatized=1;\n  int reported_num_teams[SIZE_N];\n  int reported_team_num[SIZE_N];\n  int reported_num_threads[SIZE_N];\n  int errors = 0;\n\n  // array initialization\n  for (int i = 0; i < SIZE_N; i++) {\n    a[i] = 0;\n  }\n\n  // check multiple sizes. \n#pragma omp target teams distribute parallel for firstprivate(firstprivatized) num_teams(OMPVV_NUM_TEAMS_DEVICE) num_threads(OMPVV_NUM_THREADS_DEVICE) schedule(static,8)\n    for (int j = 0; j < SIZE_N; ++j) {\n      reported_num_teams[j] = omp_get_num_teams();\n      reported_num_threads[j] = omp_get_num_threads();\n      reported_team_num[j] = omp_get_team_num();\n      if (j%8 == 0)\n        firstprivatized = 0;\n      firstprivatized++;\n      a[j] += firstprivatized;\n    }\n\n  // Checking for reported teams and number of threads\n  OMPVV_WARNING_IF(reported_num_teams[0] == 1, \"Number of teams reported was 1, test cannot assert privatization across teams\");\n  // To have a single warning for threds. diff teams could have different number of threads, we warn if all are 1\n  int warning_threads = 0;\n  for (int i = 0; i < SIZE_N; i++) {\n    if (reported_num_threads[i] == 1)\n      warning_threads++;\n    if (i > 0) {\n      OMPVV_ERROR_IF(reported_num_teams[i] != reported_num_teams[i-1], \"Discrepancy in the reported number of teams across teams\");\n      if (reported_team_num[i] == reported_team_num[i-1] && reported_num_threads[i] != reported_num_threads[i-1])\n        OMPVV_ERROR(\"Discrepancy in the reported number of threads inside a single team\");\n    }\n  }\n  OMPVV_WARNING_IF(warning_threads == SIZE_N, \"Number of threads was 1 for all teams. test cannot assert privatization across teams\");\n  // Checking for the expected values \n  for (int i = 0; i < SIZE_N; i+=8) {\n    for (int j = 0; j < 8; j++) { \n      OMPVV_TEST_AND_SET(errors, a[i + j] != j+1);\n    }\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_sched_private());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_teams_distribute_parallel_for_schedule_private.c - private per thread combined construct-===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// private variables are private to the running thread. When using the scheduler clause it should be possible to\n// have a private variable that shares its memory space across multiple iterations\n//\n//\n//===---------------------------------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n// This has been selected for the num teams and num threads below\n#define SIZE_N 2048\n\nint test_target_teams_distribute_parallel_for_sched_private() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_schedule_private\");\n  \n  int a[SIZE_N];\n  int firstprivatized=1;\n  int reported_num_teams[SIZE_N];\n  int reported_team_num[SIZE_N];\n  int reported_num_threads[SIZE_N];\n  int errors = 0;\n\n  // array initialization\n  for (int i = 0; i < SIZE_N; i++) {\n    a[i] = 0;\n  }\n\n  // check multiple sizes. \n#pragma omp target teams distribute parallel for firstprivate(firstprivatized) num_teams(OMPVV_NUM_TEAMS_DEVICE) num_threads(OMPVV_NUM_THREADS_DEVICE) schedule(static,8)\n    for (int j = 0; j < SIZE_N; ++j) {\n      reported_num_teams[j] = omp_get_num_teams();\n      reported_num_threads[j] = omp_get_num_threads();\n      reported_team_num[j] = omp_get_team_num();\n      if (j%8 == 0)\n        firstprivatized = 0;\n      firstprivatized++;\n      a[j] += firstprivatized;\n    }\n\n  // Checking for reported teams and number of threads\n  OMPVV_WARNING_IF(reported_num_teams[0] == 1, \"Number of teams reported was 1, test cannot assert privatization across teams\");\n  // To have a single warning for threds. diff teams could have different number of threads, we warn if all are 1\n  int warning_threads = 0;\n  for (int i = 0; i < SIZE_N; i++) {\n    if (reported_num_threads[i] == 1)\n      warning_threads++;\n    if (i > 0) {\n      OMPVV_ERROR_IF(reported_num_teams[i] != reported_num_teams[i-1], \"Discrepancy in the reported number of teams across teams\");\n      if (reported_team_num[i] == reported_team_num[i-1] && reported_num_threads[i] != reported_num_threads[i-1])\n        OMPVV_ERROR(\"Discrepancy in the reported number of threads inside a single team\");\n    }\n  }\n  OMPVV_WARNING_IF(warning_threads == SIZE_N, \"Number of threads was 1 for all teams. test cannot assert privatization across teams\");\n  // Checking for the expected values \n  for (int i = 0; i < SIZE_N; i+=8) {\n    for (int j = 0; j < 8; j++) { \n      OMPVV_TEST_AND_SET(errors, a[i + j] != j+1);\n    }\n  }\n\n  return errors;\n}\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_num_teams.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 1286",
        "issue_id": 2,
        "original_code": "//===--- test_target_teams_distribute_num_teams.c----------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the num_teams clause on a target teams distribute directive to\n// indicate a requested number of teams to execute the teams distribute region.\n// The specifications indicate that the number of teams that are given can be any\n// number that is equal to or less than the indicated value.  We first run a\n// target teams distribute region without the clause to see what the default\n// number of teams is, and then we use a value that is less than that in the\n// test of the num_teams clause.  If the region is run with more teams than\n// indicated, the test errors.  If the region is run with less teams than\n// indicated, the test issues a warning since it is known that the device can\n// run with more teams than was actually given.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main() {\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  int a[N];\n  int b[N];\n  int c[N];\n  int num_teams[N];\n  int default_num_teams = 0;\n  int errors = 0;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    c[x] = 0;\n  }\n\n#pragma omp target teams distribute map(tofrom: default_num_teams, c[0:N]) map(to: a[0:N], b[0:N])\n  for (int x = 0; x < N; ++x) {\n    if (omp_get_team_num() == 0) {\n      default_num_teams = omp_get_num_teams();\n    }\n    c[x] = a[x] + b[x];\n  }\n\n\n  if (default_num_teams == 1) {\n    OMPVV_WARNING(\"Test operated with one team.  Testing num_teams clause cannot be done.\");\n  } else if(default_num_teams <= 0) {\n    OMPVV_ERROR(\"Test returned num_teams <= 0.\");\n    errors = 1;\n  } else {\n#pragma omp target teams distribute num_teams(default_num_teams / 2) map(to: a[0:N], b[0:N]) \\\n  map(from: c[0:N], num_teams[0:N])\n    for (int x = 0; x < N; ++x) {\n      num_teams[x] = omp_get_num_teams();\n      c[x] = a[x] + b[x];\n    }\n\n    for (int i = 1; i < N; ++i) {\n      if (num_teams[i] != num_teams[i - 1]) {\n        errors += 1;\n        OMPVV_ERROR(\"omp_get_num_teams returned an inconsistent number of teams between iterations.\");\n        break;\n      }\n    }\n\n    if (num_teams[0] > default_num_teams / 2) {\n      errors += 1;\n      OMPVV_ERROR(\"Test ran on more teams than requested.\");\n      return errors;\n    } else if (num_teams[0] < default_num_teams / 2) {\n      OMPVV_WARNING(\"Test ran on less teams than requested. This is still spec-conformant.\");\n    } else {\n      OMPVV_INFOMSG(\"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n    }\n  }\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_num_teams.c----------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the num_teams clause on a target teams distribute directive to\n// indicate a requested number of teams to execute the teams distribute region.\n// The specifications indicate that the number of teams that are given can be any\n// number that is equal to or less than the indicated value.  We first run a\n// target teams distribute region without the clause to see what the default\n// number of teams is, and then we use a value that is less than that in the\n// test of the num_teams clause.  If the region is run with more teams than\n// indicated, the test errors.  If the region is run with less teams than\n// indicated, the test issues a warning since it is known that the device can\n// run with more teams than was actually given.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main() {\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  int a[N];\n  int b[N];\n  int c[N];\n  int num_teams[N];\n  int default_num_teams = 0;\n  int errors = 0;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = 1;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n    b[x] = x;\n    c[x] = 0;\n  }\n\n#pragma omp target teams distribute map(tofrom: default_num_teams, c[0:N]) map(to: a[0:N], b[0:N])\n  for (int x = 0; x < N; ++x) {\n    if (omp_get_team_num() == 0) {\n      default_num_teams = omp_get_num_teams();\n    }\n    c[x] = a[x] + b[x];\n  }\n\n\n  if (default_num_teams == 1) {\n    OMPVV_WARNING(\"Test operated with one team.  Testing num_teams clause cannot be done.\");\n  } else if(default_num_teams <= 0) {\n    OMPVV_ERROR(\"Test returned num_teams <= 0.\");\n    errors = 1;\n  } else {\n#pragma omp target teams distribute num_teams(default_num_teams / 2) map(to: a[0:N], b[0:N]) \\\n  map(from: c[0:N], num_teams[0:N])\n    for (int x = 0; x < N; ++x) {\n      num_teams[x] = omp_get_num_teams();\n      c[x] = a[x] + b[x];\n    }\n\n    for (int i = 1; i < N; ++i) {\n      if (num_teams[i] != num_teams[i - 1]) {\n        errors += 1;\n        OMPVV_ERROR(\"omp_get_num_teams returned an inconsistent number of teams between iterations.\");\n        break;\n      }\n    }\n\n    if (num_teams[0] > default_num_teams / 2) {\n      errors += 1;\n      OMPVV_ERROR(\"Test ran on more teams than requested.\");\n      return errors;\n    } else if (num_teams[0] < default_num_teams / 2) {\n      OMPVV_WARNING(\"Test ran on less teams than requested. This is still spec-conformant.\");\n    } else {\n      OMPVV_INFOMSG(\"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n    }\n  }\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_task_lock.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 2032",
        "issue_id": 2,
        "original_code": "//===-- test_task_lock.c ------------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// Description\n// testTaskWithLockBasic()\n// This is a basic test to demonstrate how a shared resource\n// can be accessed and written to in multiple thread environment.\n// \n// testTaskWithLockAdvanced()\n// This is a advanced test to demonstrate how a shared resource\n// can be accessed and written to in multiple thread environment.\n// In this a buffer is filled with random integers. The parallel\n// region counts the number of prime integers.\n//===----------------------------------------------------------------------===//\n\n\n\n#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\nint testTaskWithLockBasic(int numThreads) {\n  int errors = 0;\n  int count = 0;\n  omp_lock_t lock;\n  omp_init_lock(&lock);\n  omp_set_num_threads(numThreads);\n#pragma omp parallel\n  {\n#pragma omp task\n    {\n    omp_set_lock(&lock);\n    {\n      count = count + 1;\n    }\n    omp_unset_lock(&lock);\n    }\n  }\n  omp_destroy_lock(&lock);\n  int ret = 0;\n  if (count == numThreads) {\n    ret = 0;\n  } else {\n    ret = -1;\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, ret != 0);\n  return errors;\n}\n\n/**\n  Local Function check if number is prime\n*/\nint isPrime(unsigned int number) {\n  int ret = 0;\n  if (number < 2) {\n    return 1;\n  }\n  for (int num = 2; (num*num) <= number; num++) {\n    if ((number % num) == 0) {\n      ret = 1;\n      break;\n    }\n  }\n  return ret;\n}\n\nint testTaskWithLockAdvanced(int numThreads, int expectedVal) {\n  int errors = 0;\n  omp_lock_t lock;\n  omp_init_lock(&lock);\n  int countPrime = 0, count = 0;\n  unsigned int *A = (unsigned int*) (malloc(numThreads*sizeof(unsigned int)));\n  omp_set_num_threads(numThreads);\n  // fill data\n  for (int i = 0; i < numThreads; i++) {\n    A[i] = i;\n  }\n  // Calculate number of prime numbers \n#pragma omp parallel\n  {\n#pragma omp task\n    {\n      int idx = 0;\n      omp_set_lock(&lock);\n      {\n        count++;\n        idx = count - 1;\n      }\n      omp_unset_lock(&lock);\n      int ret = isPrime(A[idx]);\n      omp_set_lock(&lock);\n      {\n        if (ret == 0) {\n          countPrime++;\n        }\n      }\n      omp_unset_lock(&lock);\n    }\n  }\n  free(A);\n  omp_destroy_lock(&lock);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, countPrime != expectedVal);\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithLockBasic(4));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithLockBasic(8));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithLockBasic(16));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithLockBasic(32));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithLockBasic(64));\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithLockAdvanced(1, 0));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithLockAdvanced(4, 2));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithLockAdvanced(8, 4));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithLockAdvanced(16, 6));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithLockAdvanced(32, 11));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithLockAdvanced(64, 18));\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===-- test_task_lock.c ------------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// Description\n// testTaskWithLockBasic()\n// This is a basic test to demonstrate how a shared resource\n// can be accessed and written to in multiple thread environment.\n// \n// testTaskWithLockAdvanced()\n// This is a advanced test to demonstrate how a shared resource\n// can be accessed and written to in multiple thread environment.\n// In this a buffer is filled with random integers. The parallel\n// region counts the number of prime integers.\n//===----------------------------------------------------------------------===//\n\n\n\n#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\nint testTaskWithLockBasic(int numThreads) {\n  int errors = 0;\n  int count = 0;\n  omp_lock_t lock;\n  omp_init_lock(&lock);\n  omp_set_num_threads(numThreads);\n#pragma omp parallel\n  {\n#pragma omp task\n    {\n    omp_set_lock(&lock);\n    {\n      count = count + 1;\n    }\n    omp_unset_lock(&lock);\n    }\n  }\n  omp_destroy_lock(&lock);\n  int ret = 0;\n  if (count == numThreads) {\n    ret = 0;\n  } else {\n    ret = -1;\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, ret != 0);\n  return errors;\n}\n\n/**\n  Local Function check if number is prime\n*/\nint isPrime(unsigned int number) {\n  int ret = 0;\n  if (number < 2) {\n    return 1;\n  }\n  for (int num = 2; (num*num) <= number; num++) {\n    if ((number % num) == 0) {\n      ret = 1;\n      break;\n    }\n  }\n  return ret;\n}\n\nint testTaskWithLockAdvanced(int numThreads, int expectedVal) {\n  int errors = 0;\n  omp_lock_t lock;\n  omp_init_lock(&lock);\n  int countPrime = 0, count = 0;\n  unsigned int *A = (unsigned int*) (malloc(numThreads*sizeof(unsigned int)));\n  omp_set_num_threads(numThreads);\n  // fill data\n  for (int i = 0; i < numThreads; i++) {\n    A[i] = i;\n  }\n  // Calculate number of prime numbers \n#pragma omp parallel\n  {\n#pragma omp task\n    {\n      int idx = 0;\n      omp_set_lock(&lock);\n      {\n        count++;\n        idx = count - 1;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n      }\n      omp_unset_lock(&lock);\n      int ret = isPrime(A[idx]);\n      omp_set_lock(&lock);\n      {\n        if (ret == 0) {\n          countPrime++;\n        }\n      }\n      omp_unset_lock(&lock);\n    }\n  }\n  free(A);\n  omp_destroy_lock(&lock);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, countPrime != expectedVal);\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithLockBasic(4));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithLockBasic(8));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithLockBasic(16));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithLockBasic(32));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithLockBasic(64));\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithLockAdvanced(1, 0));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithLockAdvanced(4, 2));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithLockAdvanced(8, 4));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithLockAdvanced(16, 6));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithLockAdvanced(32, 11));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithLockAdvanced(64, 18));\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_enter_data_devices.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 2278",
        "issue_id": 2,
        "original_code": "//===--- test_target_enter_data_devices.c ---------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n// \n// This file tests the target enter data directive when the device clause is\n// specified, and also when the device is set by omp_set_default_device().\n// The first function test_set_default_dev() does not specify the device\n// clause, but instead uses omp_set_default_device() to set device.\n// The second function test_device() uses the device clause on the target\n// enter data directive.\n// \n//===----------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nint test_set_default_dev() {\n\n  OMPVV_INFOMSG(\"test_set_default_dev\");\n\n  // Get number of devices\n  int num_dev = omp_get_num_devices();\n  OMPVV_INFOMSG(\"num_devices: %d\", num_dev);\n\n  int def_dev = omp_get_default_device();\n  OMPVV_INFOMSG(\"initial device: %d\", omp_get_initial_device());\n  OMPVV_INFOMSG(\"default device: %d\", def_dev);\n\n  // Allocate num_devices + 1 to avoid zero-sized VLA if num_devices == 0\n  int sum[num_dev+1], errors = 0, isHost[num_dev+1];\n  int h_matrix[num_dev+1][N], h_matrix_copy[num_dev+1][N];\n\n  // Initialize all the matrices\n  for (int dev = 0; dev < num_dev; ++dev) {\n    sum[dev] = 0;\n    isHost[dev] = 0;\n  }\n\n  for (int dev = 0; dev < num_dev; ++dev) {\n    omp_set_default_device(dev);\n    \n    // unstructured mapping\n    {\n#pragma omp target enter data map(alloc: h_matrix[dev][0:N]) // omp_target_alloc sets ref to infinity. alloc: has effect only if ref is zero (page 217 line 21 - Version 4.5 November 2015)\n      printf(\"\"); // forcing the compiler to not moving out of the scope\n    }\n#pragma omp target map(alloc: h_matrix[dev][0:N]) map(tofrom: isHost[dev:1]) // map(alloc: ) to avoid target to map the entire matrix h_matrix[dev][:]\n    {\n      isHost[dev] = omp_is_initial_device();\n      for (int i = 0; i < N; ++i) {\n        h_matrix[dev][i] = dev;\n      }\n    }\n  // Since we don't do enter exit data we copy the values from the device\n#pragma omp target map(from: h_matrix_copy[dev][0:N]) map(alloc: h_matrix[dev][0:N])\n    {\n      for (int i = 0; i < N; ++i) {\n        h_matrix_copy[dev][i] = h_matrix[dev][i];\n      }\n    }\n}\n\n  // checking results\n  for (int dev = 0; dev < num_dev; ++dev) {\n    OMPVV_INFOMSG(\"device %d ran on the %s\", dev, (isHost[dev])? \"host\" : \"device\");\n    for (int i = 0; i < N; ++i)\n      sum[dev] += h_matrix_copy[dev][i];\n    OMPVV_TEST_AND_SET(errors, (dev * N != sum[dev]));\n  }\n\n  omp_set_default_device(def_dev);\n\n  // Avoiding memory leaks this is outside of testing area\n  // Iterate over all the devices and delete the memory\n  for (int dev = 0; dev < num_dev; ++dev) {\n#pragma omp target exit data map(delete: h_matrix[dev][0:N]) device(dev)\n  }\n\n  return errors;\n}\n\nint test_device() {\n\n  OMPVV_INFOMSG(\"test_device\");\n\n  // Get number of devices\n  int num_dev = omp_get_num_devices();\n  OMPVV_INFOMSG(\"num_devices: %d\", num_dev);\n\n  OMPVV_INFOMSG(\"initial device: %d\", omp_get_initial_device());\n  OMPVV_INFOMSG(\"default device: %d\", omp_get_default_device());\n\n  // Allocate num_devices + 1 to avoid zero-sized VLA if num_devices == 0\n  int sum[num_dev+1], errors = 0, isHost[num_dev+1];\n  int h_matrix[num_dev+1][N], h_matrix_copy[num_dev+1][N];\n\n  // Initialize all the matrices\n  for (int dev = 0; dev < num_dev; ++dev) {\n    sum[dev] = 0;\n    isHost[dev] = 0;\n  }\n  for (int dev = 0; dev < num_dev; ++dev) {\n    // unstructured mapping\n    {\n#pragma omp target enter data map(alloc: h_matrix[dev][0:N]) device(dev)\n        printf(\"\");\n    }\n    // operation\n#pragma omp target map(alloc: h_matrix[dev][0:N]) map(tofrom: isHost[dev:1]) device(dev) // map(alloc: ) to avoid target to map the entire matrix h_matrix[dev][:]\n    {\n      isHost[dev] = omp_is_initial_device();\n      for (int i = 0; i < N; ++i)\n        h_matrix[dev][i] = dev;\n    }\n  // Since we don't do enter exit data we copy the values from the device\n#pragma omp target map(from: h_matrix_copy[dev][0:N])  map(alloc: h_matrix[dev][0:N]) device(dev)\n    {\n      for (int i = 0; i < N; ++i) {\n        h_matrix_copy[dev][i] = h_matrix[dev][i];\n      }\n    }\n  }\n\n  // checking results\n  for (int dev = 0; dev < num_dev; ++dev) {\n    OMPVV_INFOMSG(\"device %d ran on the %s\", dev, (isHost[dev])? \"host\" : \"device\");\n    for (int i = 0; i < N; ++i)\n      sum[dev] += h_matrix_copy[dev][i];\n    OMPVV_TEST_AND_SET(errors, (dev * N != sum[dev]));\n  }\n\n  // Avoiding memory leaks\n  // Iterate over all the devices and delete the memory\n  for (int dev = 0; dev < num_dev; ++dev) {\n#pragma omp target exit data map(delete: h_matrix[dev][0:N]) device(dev)\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET(errors, test_set_default_dev());\n  OMPVV_TEST_AND_SET(errors, test_device());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_enter_data_devices.c ---------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n// \n// This file tests the target enter data directive when the device clause is\n// specified, and also when the device is set by omp_set_default_device().\n// The first function test_set_default_dev() does not specify the device\n// clause, but instead uses omp_set_default_device() to set device.\n// The second function test_device() uses the device clause on the target\n// enter data directive.\n// \n//===----------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nint test_set_default_dev() {\n\n  OMPVV_INFOMSG(\"test_set_default_dev\");\n\n  // Get number of devices\n  int num_dev = omp_get_num_devices();\n  OMPVV_INFOMSG(\"num_devices: %d\", num_dev);\n\n  int def_dev = omp_get_default_device();\n  OMPVV_INFOMSG(\"initial device: %d\", omp_get_initial_device());\n  OMPVV_INFOMSG(\"default device: %d\", def_dev);\n\n  // Allocate num_devices + 1 to avoid zero-sized VLA if num_devices == 0\n  int sum[num_dev+1], errors = 0, isHost[num_dev+1];\n  int h_matrix[num_dev+1][N], h_matrix_copy[num_dev+1][N];\n\n  // Initialize all the matrices\n  for (int dev = 0; dev < num_dev; ++dev) {\n    sum[dev] = 0;\n    isHost[dev] = 0;\n  }\n\n  for (int dev = 0; dev < num_dev; ++dev) {\n    omp_set_default_device(dev);\n    \n    // unstructured mapping\n    {\n#pragma omp target enter data map(alloc: h_matrix[dev][0:N]) // omp_target_alloc sets ref to infinity. alloc: has effect only if ref is zero (page 217 line 21 - Version 4.5 November 2015)\n      printf(\"\"); // forcing the compiler to not moving out of the scope\n    }\n#pragma omp target map(alloc: h_matrix[dev][0:N]) map(tofrom: isHost[dev:1]) // map(alloc: ) to avoid target to map the entire matrix h_matrix[dev][:]\n    {\n      isHost[dev] = omp_is_initial_device();\n      for (int i = 0; i < N; ++i) {\n        h_matrix[dev][i] = dev;\n      }\n    }\n  // Since we don't do enter exit data we copy the values from the device\n#pragma omp target map(from: h_matrix_copy[dev][0:N]) map(alloc: h_matrix[dev][0:N])\n    {\n      for (int i = 0; i < N; ++i) {\n        h_matrix_copy[dev][i] = h_matrix[dev][i];yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n      }\n    }\n}\n\n  // checking results\n  for (int dev = 0; dev < num_dev; ++dev) {\n    OMPVV_INFOMSG(\"device %d ran on the %s\", dev, (isHost[dev])? \"host\" : \"device\");\n    for (int i = 0; i < N; ++i)\n      sum[dev] += h_matrix_copy[dev][i];\n    OMPVV_TEST_AND_SET(errors, (dev * N != sum[dev]));\n  }\n\n  omp_set_default_device(def_dev);\n\n  // Avoiding memory leaks this is outside of testing area\n  // Iterate over all the devices and delete the memory\n  for (int dev = 0; dev < num_dev; ++dev) {\n#pragma omp target exit data map(delete: h_matrix[dev][0:N]) device(dev)\n  }\n\n  return errors;\n}\n\nint test_device() {\n\n  OMPVV_INFOMSG(\"test_device\");\n\n  // Get number of devices\n  int num_dev = omp_get_num_devices();\n  OMPVV_INFOMSG(\"num_devices: %d\", num_dev);\n\n  OMPVV_INFOMSG(\"initial device: %d\", omp_get_initial_device());\n  OMPVV_INFOMSG(\"default device: %d\", omp_get_default_device());\n\n  // Allocate num_devices + 1 to avoid zero-sized VLA if num_devices == 0\n  int sum[num_dev+1], errors = 0, isHost[num_dev+1];\n  int h_matrix[num_dev+1][N], h_matrix_copy[num_dev+1][N];\n\n  // Initialize all the matrices\n  for (int dev = 0; dev < num_dev; ++dev) {\n    sum[dev] = 0;\n    isHost[dev] = 0;\n  }\n  for (int dev = 0; dev < num_dev; ++dev) {\n    // unstructured mapping\n    {\n#pragma omp target enter data map(alloc: h_matrix[dev][0:N]) device(dev)\n        printf(\"\");\n    }\n    // operation\n#pragma omp target map(alloc: h_matrix[dev][0:N]) map(tofrom: isHost[dev:1]) device(dev) // map(alloc: ) to avoid target to map the entire matrix h_matrix[dev][:]\n    {\n      isHost[dev] = omp_is_initial_device();\n      for (int i = 0; i < N; ++i)\n        h_matrix[dev][i] = dev;\n    }\n  // Since we don't do enter exit data we copy the values from the device\n#pragma omp target map(from: h_matrix_copy[dev][0:N])  map(alloc: h_matrix[dev][0:N]) device(dev)\n    {\n      for (int i = 0; i < N; ++i) {\n        h_matrix_copy[dev][i] = h_matrix[dev][i];\n      }\n    }\n  }\n\n  // checking results\n  for (int dev = 0; dev < num_dev; ++dev) {\n    OMPVV_INFOMSG(\"device %d ran on the %s\", dev, (isHost[dev])? \"host\" : \"device\");\n    for (int i = 0; i < N; ++i)\n      sum[dev] += h_matrix_copy[dev][i];\n    OMPVV_TEST_AND_SET(errors, (dev * N != sum[dev]));\n  }\n\n  // Avoiding memory leaks\n  // Iterate over all the devices and delete the memory\n  for (int dev = 0; dev < num_dev; ++dev) {\n#pragma omp target exit data map(delete: h_matrix[dev][0:N]) device(dev)\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET(errors, test_set_default_dev());\n  OMPVV_TEST_AND_SET(errors, test_device());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_declare_target_link_extended_list.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp declare\" with directive \"#pragma omp master\" at position 834",
        "issue_id": 0,
        "original_code": "//===------ test_declare_target_link_extended_list.c  ----------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks the second valid format of declare target directive with the \n// link clause. The extended list allows for mappable variables and function names \n// to be listed. The list items of a link clause are not mapped by the declare \n// target directive, instead their mapping is deferred until they are mapped by \n// target data or target constructs. The function modifies the arrays using the \n// linked scalar 'aint'. Modifications made inside the target region and\n// results are verified on the host.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint aint = 10;\n\n#pragma omp declare target link(aint)\n\n\nvoid compute_array(int a[N], int b[N], int c[N]) {\n  for (int i = 0; i < N; i++) {\n    a[i] = b[i]*c[i] + aint * i;\n  }\n  return;\n}\n \n\nint test_declare_target() {\n\n  OMPVV_INFOMSG(\"test_declare_target_link_extended_list\");\n\n  int errors = 0;\n  int x[N];\n  int y[N];\n  int z[N];\n  aint = 12;\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 0;\n    y[i] = 1;\n    z[i] = i;\n  }\n\n#pragma omp target map(from: x) map(to:y, z, aint)\n  {\n    compute_array(x, y, z);\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != (y[i] * z[i] + 12 * i));\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_declare_target() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===------ test_declare_target_link_extended_list.c  ----------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks the second valid format of declare target directive with the \n// link clause. The extended list allows for mappable variables and function names \n// to be listed. The list items of a link clause are not mapped by the declare \n// target directive, instead their mapping is deferred until they are mapped by \n// target data or target constructs. The function modifies the arrays using the \n// linked scalar 'aint'. Modifications made inside the target region and\n// results are verified on the host.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint aint = 10;\n\n#pragma omp master target link(aint)\n\n\nvoid compute_array(int a[N], int b[N], int c[N]) {\n  for (int i = 0; i < N; i++) {\n    a[i] = b[i]*c[i] + aint * i;\n  }\n  return;\n}\n \n\nint test_declare_target() {\n\n  OMPVV_INFOMSG(\"test_declare_target_link_extended_list\");\n\n  int errors = 0;\n  int x[N];\n  int y[N];\n  int z[N];\n  aint = 12;\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 0;\n    y[i] = 1;\n    z[i] = i;\n  }\n\n#pragma omp target map(from: x) map(to:y, z, aint)\n  {\n    compute_array(x, y, z);\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != (y[i] * z[i] + 12 * i));\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_declare_target() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_enter_exit_data_devices.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n\n  int errors = 0;\n  \n  //Test for offloading\n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_set_default_dev());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_device());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 3276",
        "issue_id": 4,
        "original_code": "//===--- test_target_enter_exit_data_devices.c---------------------------------------===//\n//\n//  OpenMP API Version 4.5 Nov 2015\n//\n//  This test checks for data mapping on multiple devices when using the target\n//  data map directive. The test uses omp_get_num_devices to confirm the number \n//  of total devices available. There are two separate functions, and both make sure \n//  that data mapping is happening on each available device. The first function does \n//  this through the use of omp_set_default_device, while the second function explicity \n//  uses the device() clause to control which device is being utilized.\n//\n//  Since OpenMP 4.5 does not have an API call to obtain the current device, \n//  this test does not guarantee that the execution devices are different. \n//\n////===------------------------------------------------------------------------------===/\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nint test_set_default_dev() {\n\n  OMPVV_INFOMSG(\"test_set_default_dev\");\n\n  // Get number of devices\n  int num_dev = omp_get_num_devices();\n  OMPVV_INFOMSG(\"num_devices: %d\", num_dev);\n\n  int def_dev = omp_get_default_device();\n  OMPVV_INFOMSG(\"initial device: %d\", omp_get_initial_device());\n  OMPVV_INFOMSG(\"default device: %d\", def_dev);\n\n  // Allocate num_devices + 1 to avoid zero-sized VLA if num_devices == 0\n  int sum[num_dev+1], errors = 0;\n  int h_matrix[num_dev+1][N];\n\n  for (int dev = 0; dev < num_dev; ++dev) {\n    omp_set_default_device(dev);\n\n#pragma omp target enter data map(alloc: h_matrix[dev][0 : N])\n    \n#pragma omp target map(alloc: h_matrix[dev][0 : N]) // map(alloc: ) to avoid target to map the entire matrix h_matrix[dev][:]\n    {\n      for (int i = 0; i < N; ++i)\n        h_matrix[dev][i] = dev;\n    }\n    // unstructured exit\n\n#pragma omp target exit data map(from: h_matrix[dev][0 : N])\n  }\n\n  // checking results\n  errors = 0;\n  for (int dev = 0; dev < num_dev; ++dev) {\n    sum[dev] = h_matrix[dev][0];\n    for (int i = 1; i < N; ++i)\n      sum[dev] += h_matrix[dev][i];\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (dev * N != sum[dev]));\n  }\n\n  omp_set_default_device(def_dev);\n\n  return errors;\n}\n\nint test_device() {\n\n  OMPVV_INFOMSG(\"test_device\");\n\n  // Get number of devices\n  int num_dev = omp_get_num_devices();\n  OMPVV_INFOMSG(\"num_devices: %d\", num_dev);\n\n  OMPVV_INFOMSG(\"initial device: %d\", omp_get_initial_device());\n  OMPVV_INFOMSG(\"default device: %d\", omp_get_default_device());\n\n  // Allocate num_devices + 1 to avoid zero-sized VLA if num_devices == 0\n  int sum[num_dev+1], errors = 0;\n  int h_matrix[num_dev+1][N];\n\n  for (int dev = 0; dev < num_dev; ++dev) {\n\n#pragma omp target enter data map(alloc: h_matrix[dev][0 : N]) device(dev) \n\n#pragma omp target map(alloc: h_matrix[dev][0 : N]) device(dev)\n    {\n      for (int i = 0; i < N; ++i)\n        h_matrix[dev][i] = dev;\n    }\n\n#pragma omp target exit data map(from: h_matrix[dev][0 : N]) device(dev)\n  \n}\n\n  // checking results\n  errors = 0;\n  for (int dev = 0; dev < num_dev; ++dev) {\n    sum[dev] = h_matrix[dev][0];\n    for (int i = 1; i < N; ++i)\n      sum[dev] += h_matrix[dev][i];\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (dev * N != sum[dev]));\n  }\n\n  return errors;\n}\n\nint main() {\n\n  int errors = 0;\n  \n  //Test for offloading\n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_set_default_dev());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_device());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_enter_exit_data_devices.c---------------------------------------===//\n//\n//  OpenMP API Version 4.5 Nov 2015\n//\n//  This test checks for data mapping on multiple devices when using the target\n//  data map directive. The test uses omp_get_num_devices to confirm the number \n//  of total devices available. There are two separate functions, and both make sure \n//  that data mapping is happening on each available device. The first function does \n//  this through the use of omp_set_default_device, while the second function explicity \n//  uses the device() clause to control which device is being utilized.\n//\n//  Since OpenMP 4.5 does not have an API call to obtain the current device, \n//  this test does not guarantee that the execution devices are different. \n//\n////===------------------------------------------------------------------------------===/\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nint test_set_default_dev() {\n\n  OMPVV_INFOMSG(\"test_set_default_dev\");\n\n  // Get number of devices\n  int num_dev = omp_get_num_devices();\n  OMPVV_INFOMSG(\"num_devices: %d\", num_dev);\n\n  int def_dev = omp_get_default_device();\n  OMPVV_INFOMSG(\"initial device: %d\", omp_get_initial_device());\n  OMPVV_INFOMSG(\"default device: %d\", def_dev);\n\n  // Allocate num_devices + 1 to avoid zero-sized VLA if num_devices == 0\n  int sum[num_dev+1], errors = 0;\n  int h_matrix[num_dev+1][N];\n\n  for (int dev = 0; dev < num_dev; ++dev) {\n    omp_set_default_device(dev);\n\n#pragma omp target enter data map(alloc: h_matrix[dev][0 : N])\n    \n#pragma omp target map(alloc: h_matrix[dev][0 : N]) // map(alloc: ) to avoid target to map the entire matrix h_matrix[dev][:]\n    {\n      for (int i = 0; i < N; ++i)\n        h_matrix[dev][i] = dev;\n    }\n    // unstructured exit\n\n#pragma omp target exit data map(from: h_matrix[dev][0 : N])\n  }\n\n  // checking results\n  errors = 0;\n  for (int dev = 0; dev < num_dev; ++dev) {\n    sum[dev] = h_matrix[dev][0];\n    for (int i = 1; i < N; ++i)\n      sum[dev] += h_matrix[dev][i];\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (dev * N != sum[dev]));\n  }\n\n  omp_set_default_device(def_dev);\n\n  return errors;\n}\n\nint test_device() {\n\n  OMPVV_INFOMSG(\"test_device\");\n\n  // Get number of devices\n  int num_dev = omp_get_num_devices();\n  OMPVV_INFOMSG(\"num_devices: %d\", num_dev);\n\n  OMPVV_INFOMSG(\"initial device: %d\", omp_get_initial_device());\n  OMPVV_INFOMSG(\"default device: %d\", omp_get_default_device());\n\n  // Allocate num_devices + 1 to avoid zero-sized VLA if num_devices == 0\n  int sum[num_dev+1], errors = 0;\n  int h_matrix[num_dev+1][N];\n\n  for (int dev = 0; dev < num_dev; ++dev) {\n\n#pragma omp target enter data map(alloc: h_matrix[dev][0 : N]) device(dev) \n\n#pragma omp target map(alloc: h_matrix[dev][0 : N]) device(dev)\n    {\n      for (int i = 0; i < N; ++i)\n        h_matrix[dev][i] = dev;\n    }\n\n#pragma omp target exit data map(from: h_matrix[dev][0 : N]) device(dev)\n  \n}\n\n  // checking results\n  errors = 0;\n  for (int dev = 0; dev < num_dev; ++dev) {\n    sum[dev] = h_matrix[dev][0];\n    for (int i = 1; i < N; ++i)\n      sum[dev] += h_matrix[dev][i];\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (dev * N != sum[dev]));\n  }\n\n  return errors;\n}\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_data_use_device_ptr.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp map\" at position 933",
        "issue_id": 0,
        "original_code": "//===-- test_target_data_use_device_ptr.c - test of use_device_ptr on target data ----===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// This file is a test for the use_device_ptr when used with the map\n// clause. This test uses arrays of size N which values are modified on the \n// device and tested in the host. Once the array has been mapped to the device,\n// the use_device_ptr should be able to be used with the ptr to the array and \n// subsequent modify values on the device. \n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nint main() {\n  int errors = 0, map_dummy;\n  int *array_device = NULL;\n  int *array_host = NULL;\n\n  array_device = (int *)malloc(N*sizeof(int));\n  array_host = (int *)malloc(N*sizeof(int));\n\n  for (int i = 0; i < N; ++i)\n    array_host[i] = i;\n  \n  OMPVV_TEST_OFFLOADING;\n\n#pragma omp target data map(tofrom: array_device[0:N])\n  {\n#pragma omp target data map(map_dummy) use_device_ptr(array_device)\n    {\n#pragma omp target is_device_ptr(array_device) map(tofrom: array_host[0:N])\n      {\n        for (int i = 0; i < N; ++i) {\n          array_device[i] = i;\n          array_host[i] += array_device[i];\n        } \n      } // end target\n    } // end target data\n  } // end target data\n\n  // checking results\n  for (int i = 0; i < N; ++i) {\n    OMPVV_TEST_AND_SET(errors, array_host[i] != 2*i);\n  }\n\n  free(array_device);\n  free(array_host);\n  \n  OMPVV_REPORT_AND_RETURN(errors);\n\n}\n",
        "error_code": "//===-- test_target_data_use_device_ptr.c - test of use_device_ptr on target data ----===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// This file is a test for the use_device_ptr when used with the map\n// clause. This test uses arrays of size N which values are modified on the \n// device and tested in the host. Once the array has been mapped to the device,\n// the use_device_ptr should be able to be used with the ptr to the array and \n// subsequent modify values on the device. \n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nint main() {\n  int errors = 0, map_dummy;\n  int *array_device = NULL;\n  int *array_host = NULL;\n\n  array_device = (int *)malloc(N*sizeof(int));\n  array_host = (int *)malloc(N*sizeof(int));\n\n  for (int i = 0; i < N; ++i)\n    array_host[i] = i;\n  \n  OMPVV_TEST_OFFLOADING;\n\n#pragma omp map data map(tofrom: array_device[0:N])\n  {\n#pragma omp target data map(map_dummy) use_device_ptr(array_device)\n    {\n#pragma omp target is_device_ptr(array_device) map(tofrom: array_host[0:N])\n      {\n        for (int i = 0; i < N; ++i) {\n          array_device[i] = i;\n          array_host[i] += array_device[i];\n        } \n      } // end target\n    } // end target data\n  } // end target data\n\n  // checking results\n  for (int i = 0; i < N; ++i) {\n    OMPVV_TEST_AND_SET(errors, array_host[i] != 2*i);\n  }\n\n  free(array_device);\n  free(array_host);\n  \n  OMPVV_REPORT_AND_RETURN(errors);\n\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_is_device_ptr.c",
        "correct": "n",
        "issue": "Removed memory allocation line \"omp_target_alloc which returns the pointer to the location on the\n// target that was allocated.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define SIZE_THRESHOLD 512\n#define ARRAY_SIZE 1024\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\" at position 295",
        "issue_id": 0,
        "original_code": "//===--- test_target_teams_distribute_is_device_ptr.c------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses is_device_ptr clause to indicate that the parameter that is\n// given is already an address to the data on the device.  The parameter is set\n// using the omp_target_alloc which returns the pointer to the location on the\n// target that was allocated.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define SIZE_THRESHOLD 512\n#define ARRAY_SIZE 1024\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  OMPVV_INFOMSG(\"test target_teams_distribute_is_device_ptr\");\n\n  int a[ARRAY_SIZE];\n  int b[ARRAY_SIZE];\n  int *c = (int *)omp_target_alloc(ARRAY_SIZE * sizeof(int), omp_get_default_device());\n  int errors = 0;\n\n  if (!c) {\n    OMPVV_WARNING(\"Test was unable to allocate memory on device.  Test could not procede.\");\n    OMPVV_REPORT_AND_RETURN(errors);\n  } else {\n    for (int x = 0; x < ARRAY_SIZE; ++x) {\n      a[x] = 1;\n      b[x] = x;\n    }\n\n#pragma omp target teams distribute is_device_ptr(c) map(tofrom: a[0:ARRAY_SIZE]) map(to: b[0:ARRAY_SIZE])\n    for (int x = 0; x < ARRAY_SIZE; ++x) {\n      c[x] = b[x] * b[x];\n      a[x] += c[x] + b[x];\n    }\n\n    for (int x = 0; x < ARRAY_SIZE; ++x) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, (a[x] != 1 + b[x] + b[x] * b[x]));\n      if (a[x] != 1 + b[x] + b[x] * b[x]) {\n\tbreak;\n      }\n    }\n\n    omp_target_free (c, omp_get_default_device());\n\n    OMPVV_REPORT_AND_RETURN(errors);\n  }\n}\n",
        "error_code": "//===--- test_target_teams_distribute_is_device_ptr.c------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses is_device_ptr clause to indicate that the parameter that is\n// given is already an address to the data on the device.  The parameter is set\n// using the \n  OMPVV_INFOMSG(\"test target_teams_distribute_is_device_ptr\");\n\n  int a[ARRAY_SIZE];\n  int b[ARRAY_SIZE];\n  int *c = (int *)omp_target_alloc(ARRAY_SIZE * sizeof(int), omp_get_default_device());\n  int errors = 0;\n\n  if (!c) {\n    OMPVV_WARNING(\"Test was unable to allocate memory on device.  Test could not procede.\");\n    OMPVV_REPORT_AND_RETURN(errors);\n  } else {\n    for (int x = 0; x < ARRAY_SIZE; ++x) {\n      a[x] = 1;\n      b[x] = x;\n    }\n\n#pragma omp target teams distribute is_device_ptr(c) map(tofrom: a[0:ARRAY_SIZE]) map(to: b[0:ARRAY_SIZE])\n    for (int x = 0; x < ARRAY_SIZE; ++x) {\n      c[x] = b[x] * b[x];\n      a[x] += c[x] + b[x];\n    }\n\n    for (int x = 0; x < ARRAY_SIZE; ++x) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, (a[x] != 1 + b[x] + b[x] * b[x]));\n      if (a[x] != 1 + b[x] + b[x] * b[x]) {\n\tbreak;\n      }\n    }\n\n    omp_target_free (c, omp_get_default_device());\n\n    OMPVV_REPORT_AND_RETURN(errors);\n  }\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_parallel_for_if_target_modifier.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 1555",
        "issue_id": 2,
        "original_code": "//===---- test_target_teams_distribute_parallel_for_if_no_modifier.c --------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// In this test we want to try to check if the if clause is working \n// when used with the combined construct target teams distribute parallel for\n// and the target modifier is specified.\n// To do this we check if offloading is working, if it is not, it won't be\n// possible for us to tell if the test passed or not, since it depends on \n// offloading capabilities. \n//\n// The if has a directive-name-modifier that specifies to which directive the \n// if applies to (either both directives, to the target or to the parallel). \n// We have three tests: one for no directive, another for the target directive\n// and another for the parallel directive \n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define ATTEMPT_THRESHOLD 70\n#define NUM_ATTEMPTS 100\n#define N 1024\n\nint checkPreconditions() {\n  // We test if offloading is enable\n\n  // Testing for offloading\n  int isOffloading = 0;\n  int i;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"With offloading off, it is not possible to test if\");\n\n  return isOffloading;\n}\n\nint test_target_teams_distribute_if_target_modifier() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_if_target_modifier\");\n  \n  int a[N], warning[N];\n  int attempt = 0;\n  int errors = 0;\n  int i;\n  int isOffloading;\n\n  isOffloading = checkPreconditions();\n\n  for (i = 0; i < N; i++) {\n    a[i] = 1;\n    warning[i] = 0;\n  }\n\n  // We iterate NUM_ATTEMPTS times. When the iteration value is >= ATTEMPT_THRESHOLD the \n  // execution of the target region should happen in the device, and the number of threads\n  // is expected to be greater than 1 (although if it is not, this is not an error, just warning)\n  // If the iteration variable attempt  < ATTEMPT_THRESHOLD, then the if condition evaluates to false, \n  // and hence the execution should occur in the host, while the number of threads should not change\n  // We check that when we are executing on the host, the value of the iteration variable is \n  // greather than ATTEMPT_THRESHOLD\n  for (attempt = 0; attempt < NUM_ATTEMPTS; ++attempt) {\n#pragma omp target teams distribute parallel for if(target: attempt >= ATTEMPT_THRESHOLD)\\\n    map(tofrom: a) num_threads(OMPVV_NUM_THREADS_DEVICE)\n    for (i = 0; i < N; i++) {\n      warning[i] += (omp_get_num_threads() == 1) ? 1 : 0; // Ideally we should not change the number of threads at any point\n      if (attempt >= ATTEMPT_THRESHOLD) {\n        a[i] += (isOffloading && omp_is_initial_device() ? 10 : 0); // True condition, it should run on the device\n      }\n      else {\n        a[i] += (omp_is_initial_device() ? 1 : 100);\n      } \n    }\n  }\n\n  int raiseWarning = 0;\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, a[i] != 1 + (ATTEMPT_THRESHOLD));\n    if (warning[i] != 0) {\n      raiseWarning = 1;\n    }\n  }\n\n  OMPVV_WARNING_IF(raiseWarning != 0, \"The number of threads was 1 even though we expected it to be more than 1. Not a compliance error in the specs\");\n  OMPVV_ERROR_IF(errors, \"error in if(target: modifier). The execution was expected to occur in the device, but it happened in the host when if(false), or the other way around\");\n\n  return errors;\n}\n\nint main() {\n \n  int errors = 0;\n\n  //Offloading is checked in checkPreconditions() function\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_if_target_modifier());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_teams_distribute_parallel_for_if_no_modifier.c --------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// In this test we want to try to check if the if clause is working \n// when used with the combined construct target teams distribute parallel for\n// and the target modifier is specified.\n// To do this we check if offloading is working, if it is not, it won't be\n// possible for us to tell if the test passed or not, since it depends on \n// offloading capabilities. \n//\n// The if has a directive-name-modifier that specifies to which directive the \n// if applies to (either both directives, to the target or to the parallel). \n// We have three tests: one for no directive, another for the target directive\n// and another for the parallel directive \n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define ATTEMPT_THRESHOLD 70\n#define NUM_ATTEMPTS 100\n#define N 1024\n\nint checkPreconditions() {\n  // We test if offloading is enable\n\n  // Testing for offloading\n  int isOffloading = 0;\n  int i;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"With offloading off, it is not possible to test if\");\n\n  return isOffloading;\n}\n\nint test_target_teams_distribute_if_target_modifier() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_if_target_modifier\");\n  \n  int a[N], warning[N];\n  int attempt = 0;\n  int errors = 0;\n  int i;\n  int isOffloading;\n\n  isOffloading = checkPreconditions();\n\n  for (i = 0; i < N;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1; i++) {\n    a[i] = 1;\n    warning[i] = 0;\n  }\n\n  // We iterate NUM_ATTEMPTS times. When the iteration value is >= ATTEMPT_THRESHOLD the \n  // execution of the target region should happen in the device, and the number of threads\n  // is expected to be greater than 1 (although if it is not, this is not an error, just warning)\n  // If the iteration variable attempt  < ATTEMPT_THRESHOLD, then the if condition evaluates to false, \n  // and hence the execution should occur in the host, while the number of threads should not change\n  // We check that when we are executing on the host, the value of the iteration variable is \n  // greather than ATTEMPT_THRESHOLD\n  for (attempt = 0; attempt < NUM_ATTEMPTS; ++attempt) {\n#pragma omp target teams distribute parallel for if(target: attempt >= ATTEMPT_THRESHOLD)\\\n    map(tofrom: a) num_threads(OMPVV_NUM_THREADS_DEVICE)\n    for (i = 0; i < N; i++) {\n      warning[i] += (omp_get_num_threads() == 1) ? 1 : 0; // Ideally we should not change the number of threads at any point\n      if (attempt >= ATTEMPT_THRESHOLD) {\n        a[i] += (isOffloading && omp_is_initial_device() ? 10 : 0); // True condition, it should run on the device\n      }\n      else {\n        a[i] += (omp_is_initial_device() ? 1 : 100);\n      } \n    }\n  }\n\n  int raiseWarning = 0;\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, a[i] != 1 + (ATTEMPT_THRESHOLD));\n    if (warning[i] != 0) {\n      raiseWarning = 1;\n    }\n  }\n\n  OMPVV_WARNING_IF(raiseWarning != 0, \"The number of threads was 1 even though we expected it to be more than 1. Not a compliance error in the specs\");\n  OMPVV_ERROR_IF(errors, \"error in if(target: modifier). The execution was expected to occur in the device, but it happened in the host when if(false), or the other way around\");\n\n  return errors;\n}\n\nint main() {\n \n  int errors = 0;\n\n  //Offloading is checked in checkPreconditions() function\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_if_target_modifier());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_parallel_for_map_default.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1470",
        "issue_id": 1,
        "original_code": "//===---- test_target_teams_distribute_parallel_for_map_default.c -----------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// test the mapping of arrays by default. The expected behavior is that all \n// the arrays are mapped tofrom by default.\n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define N 2000\n\nint test_target_teams_distribute_parallel_for_map_default() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_devices\");\n  \n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int scalar = 20;\n  int scalar2 = -1;\n  int errors = 0;\n  int i, j, dev;\n\n  // array initialization\n  for (i = 0; i < N; i++) {\n    a[i] = 1;\n    b[i] = i;\n    c[i] = 2*i;\n    d[i] = 0;\n  }\n\n\n#pragma omp target teams distribute parallel for\n  for (j = 0; j < N; ++j) {\n    // scalar is firstprivate for the target region, but \n    // in a parallel construct, if not default clause is present\n    // the variable is shared. Hence scalar = any other value \n    // could cause a data race.\n    // See page 182, line 1.\n    d[j] += c[j] * (a[j] + b[j] + scalar);\n#pragma omp atomic write\n    scalar2 = j;\n  } // atomic prevents indeterminacy from simultaneous writes\n    // since scalar2 is shared implicitly.\n\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, d[i] != (1 + i + 20) * 2*i);\n  }\n\n  return errors;\n}\n\n// Test for OpenMP 4.5 target enter data with if\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_map_default());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_teams_distribute_parallel_for_map_default.c -----------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// test the mapping of arrays by default. The expected behavior is that all \n// the arrays are mapped tofrom by default.\n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define N 2000\n\nint test_target_teams_distribute_parallel_for_map_default() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_devices\");\n  \n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int scalar = 20;\n  int scalar2 = -1;\n  int errors = 0;\n  int i, j, dev;\n\n  // array initialization\n  for (i = 0; i < N; i++) {\n    a[i] = 1;\n    b[i] = i;\n    c[i] = 2*i;\n    d[i] = 0;\n  }\n\n\n#pragma omp target teams distribute parallel for\n  for (j = 0; j < N; ++j) {\n    // scalar is firstprivate for the target region, but \n    // in a parallel construct, if not default clause is present\n    // the variable is shared. Hence scalar = any other value \n    // could cause a data race.\n    // See page 182, line 1.\n    d[j] += c[j] * (a[j] + b[j] + scalar);\n#pragma omp atomic write\n    scalar2 = j;\n  } // atomic prevents indeterminacy from simultaneous writes\n    // since scalar2 is shared implicitly.\n\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, d[i] != (1 + i + 20) * 2*i);\n  }\n\n  return errors;\n}\n\n// Test for OpenMP 4.5 target enter data with if\nint main() \n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_map_default());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_enter_data_depend.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 5260",
        "issue_id": 2,
        "original_code": "//===--- test_target_enter_data_depend.c ------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks the target enter data directive with a depend clause \n// specified. Behavior for depend 'in' and depend 'out' are both addressed.\n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include \"ompvv.h\"\n\n#define N 1000\n#define HOST_TASK1_BIT 0x1\n#define HOST_TASK2_BIT 0x2\n#define DEVICE_TASK1_BIT 0x4\n#define DEVICE_TASK2_BIT 0x8\n#define HOST_TASK3_BIT 0x10\n#define ALL_TASKS_BITS 0x1F\n\n/*\n * Test if it is possible to:\n * 1. target enter data to depend 'in' and 'out'\n * 2. target exit data to depend 'in' and 'out'\n * 3. Mix target-based tasks with host tasks.\n *\n * We use bits for each task to know where it fails\n */\nint test_async_between_task_target() {\n  OMPVV_INFOMSG(\"test_async_between_task_target\");\n\n  int errors = 0;\n  bool isHost = true;\n  int sum = 0.0;\n  int* h_array = (int *) malloc(N * sizeof(int));\n  int* h_array_copy = (int *) malloc(N * sizeof(int));\n  int* in_1 = (int *) malloc(N * sizeof(int));\n  int* in_2 = (int *) malloc(N * sizeof(int));\n  \n  // host task 1\n#pragma omp task depend(out: in_1) shared(in_1)\n  {\n    for (int i = 0; i < N; ++i) {\n      in_1[i] = HOST_TASK1_BIT; // 0b01\n    }\n  }\n\n  // host task 2\n#pragma omp task depend(out: in_2) shared(in_2)\n  {\n    for (int i = 0; i < N; ++i) {\n      in_2[i] = HOST_TASK2_BIT; // 0b10\n    }\n  }\n\n  // target enter data\n#pragma omp target enter data map(alloc: h_array[0:N]) map(to: in_1[0:N]) map(to: in_2[0:N]) depend(out: h_array) depend(in: in_1) depend(in: in_2) \n\n  // target task to compute on the device \n  // device task 1\n  // adding redundant depends on in_1 + in_2 to make the test work if compiled for the host\n#pragma omp task shared (isHost, h_array, in_1, in_2) depend(inout: h_array) depend(in: in_1) depend(in: in_2)\n  {\n#pragma omp target map(tofrom: isHost) map(alloc: in_1[0:N]) map(alloc: in_2[0:N]) map(alloc: h_array[0:N])\n    {\n      isHost = omp_is_initial_device();\n      for (int i = 0; i < N; ++i) {\n        h_array[i] = DEVICE_TASK1_BIT | in_1[i] | in_2[i]; // Expected = 0b111\n      }\n    }\n  }\n\n  // Device task 2\n#pragma omp task shared (h_array, h_array_copy) depend(in: h_array) depend(out: h_array_copy)\n  {\n#pragma omp target map(alloc: h_array[0:N]) map(from: h_array_copy[0:N])\n    {\n      for (int i = 0; i < N; ++i) {\n        h_array_copy[i] = h_array[i] | DEVICE_TASK2_BIT; //  Expected = 0b1111\n      }\n    }\n  }\n\n  // host task 3\n#pragma omp task depend(in: h_array_copy) shared(sum, h_array_copy)\n  {\n    // checking results\n    for (int i = 0; i < N; ++i) {\n      // Identify which task was problematic\n      h_array_copy[i] |= HOST_TASK3_BIT;\n      sum += (h_array_copy[i] & ALL_TASKS_BITS); // AND with 0b111 should produce sum\n    }\n  }\n#pragma omp taskwait\n\n  // We verify all the tasks without a task\n  int h_task1 = 0;\n  int h_task2 = 0;\n  int h_task3 = 0;\n  int d_task1 = 0;\n  int d_task2 = 0;\n  for (int i = 0; i < N; ++i) {\n    h_task1 |= !(h_array_copy[i] & HOST_TASK1_BIT);\n    h_task2 |= !(h_array_copy[i] & HOST_TASK2_BIT);\n    h_task2 |= !(h_array_copy[i] & HOST_TASK3_BIT);\n    d_task1 |= !(h_array_copy[i] & DEVICE_TASK1_BIT);\n    d_task2 |= !(h_array_copy[i] & DEVICE_TASK2_BIT);\n  }\n  OMPVV_ERROR_IF(h_task1 != 0, \"Error in host task 1\");\n  OMPVV_ERROR_IF(h_task2 != 0, \"Error in host task 2\");\n  OMPVV_ERROR_IF(h_task3 != 0, \"Error in host task 3\");\n  OMPVV_ERROR_IF(d_task1 != 0, \"Error in device task 1\");\n  OMPVV_ERROR_IF(d_task2 != 0, \"Error in device task 2\");\n\n  OMPVV_TEST_AND_SET(errors, (N * ALL_TASKS_BITS != sum));\n  OMPVV_INFOMSG(\"Test test_async_between_task_target ran on the %s\", (isHost ? \"host\" : \"device\"));\n \n// Garbage collection\n// This is outside of the testing area but we need to clear memory on the device \n// created with the target enter data\n#pragma omp target exit data map(delete: h_array[0:N], in_1[0:N], in_2[0:N])\n  free(h_array);\n  free(h_array_copy);\n  free(in_1);\n  free(in_2);\n\n  return errors;\n}\n\n/*\n * Test if it is possible to:\n * 1. target enter data to depend 'out'\n * 2. target exit data to depend 'in'\n * 3. use nowait for async\n */\nint test_async_between_target() {\n  OMPVV_INFOMSG(\"test_async_between_target\");\n\n  int errors = 0;\n  bool isHost = true;\n  int sum = 0;\n  int* h_array = (int *) malloc(N * sizeof(int));\n  int* h_array_copy = (int *) malloc(N * sizeof(int));\n  int val = DEVICE_TASK1_BIT;\n\n  // target enter data\n#pragma omp target enter data map(alloc: h_array[0:N]) depend(out: h_array) \n\n#pragma omp target enter data map(to: val) depend(out: val) \n\n#pragma omp target map(tofrom: isHost) map(alloc: h_array[0:N]) depend(inout: h_array) depend(in: val) \n  {\n    isHost = omp_is_initial_device();\n    for (int i = 0; i < N; ++i) {\n      h_array[i] = val; // val = DEVICE_TASK1_BIT\n    }\n  }\n\n#pragma omp target map(alloc: h_array[0:N]) map(from: h_array_copy[0:N]) depend(in: h_array) depend(out: h_array_copy) \n  {\n    for (int i = 0; i < N; ++i) {\n      h_array_copy[i] = h_array[i] | DEVICE_TASK2_BIT;\n    }\n  }\n#pragma omp taskwait\n\n  // checking results\n  int d_task1 = 0;\n  int d_task2 = 0;\n  for (int i = 0; i < N; ++i) {\n    sum += (h_array_copy[i] & (DEVICE_TASK1_BIT | DEVICE_TASK2_BIT)); // this will lead to 0b1100\n    // Checking each individual task\n    d_task1 |= !(h_array_copy[i] & DEVICE_TASK1_BIT);\n    d_task2 |= !(h_array_copy[i] & DEVICE_TASK2_BIT);\n  }\n  // Report on each task\n  OMPVV_ERROR_IF(d_task1 != 0, \"Error in device task 1\");\n  OMPVV_ERROR_IF(d_task2 != 0, \"Error in device task 2\");\n\n  OMPVV_TEST_AND_SET(errors, (N * (DEVICE_TASK1_BIT | DEVICE_TASK2_BIT) != sum));\n  OMPVV_INFOMSG(\"Test test_async_between_task_target ran on the %s\", (isHost ? \"host\" : \"device\"));\n\n// Garbage collection\n// This is outside of the testing area but we need to clear memory on the device \n// created with the target enter data\n#pragma omp target exit data map(delete: h_array[0:N], val)\n\n  free(h_array);\n  free(h_array_copy);\n  return errors;\n}\n\nint main(){\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET(errors, test_async_between_target());\n  OMPVV_TEST_AND_SET(errors, test_async_between_task_target());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n",
        "error_code": "//===--- test_target_enter_data_depend.c ------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks the target enter data directive with a depend clause \n// specified. Behavior for depend 'in' and depend 'out' are both addressed.\n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include \"ompvv.h\"\n\n#define N 1000\n#define HOST_TASK1_BIT 0x1\n#define HOST_TASK2_BIT 0x2\n#define DEVICE_TASK1_BIT 0x4\n#define DEVICE_TASK2_BIT 0x8\n#define HOST_TASK3_BIT 0x10\n#define ALL_TASKS_BITS 0x1F\n\n/*\n * Test if it is possible to:\n * 1. target enter data to depend 'in' and 'out'\n * 2. target exit data to depend 'in' and 'out'\n * 3. Mix target-based tasks with host tasks.\n *\n * We use bits for each task to know where it fails\n */\nint test_async_between_task_target() {\n  OMPVV_INFOMSG(\"test_async_between_task_target\");\n\n  int errors = 0;\n  bool isHost = true;\n  int sum = 0.0;\n  int* h_array = (int *) malloc(N * sizeof(int));\n  int* h_array_copy = (int *) malloc(N * sizeof(int));\n  int* in_1 = (int *) malloc(N * sizeof(int));\n  int* in_2 = (int *) malloc(N * sizeof(int));\n  \n  // host task 1\n#pragma omp task depend(out: in_1) shared(in_1)\n  {\n    for (int i = 0; i < N; ++i) {\n      in_1[i] = HOST_TASK1_BIT; // 0b01\n    }\n  }\n\n  // host task 2\n#pragma omp task depend(out: in_2) shared(in_2)\n  {\n    for (int i = 0; i < N; ++i) {\n      in_2[i] = HOST_TASK2_BIT; // 0b10\n    }\n  }\n\n  // target enter data\n#pragma omp target enter data map(alloc: h_array[0:N]) map(to: in_1[0:N]) map(to: in_2[0:N]) depend(out: h_array) depend(in: in_1) depend(in: in_2) \n\n  // target task to compute on the device \n  // device task 1\n  // adding redundant depends on in_1 + in_2 to make the test work if compiled for the host\n#pragma omp task shared (isHost, h_array, in_1, in_2) depend(inout: h_array) depend(in: in_1) depend(in: in_2)\n  {\n#pragma omp target map(tofrom: isHost) map(alloc: in_1[0:N]) map(alloc: in_2[0:N]) map(alloc: h_array[0:N])\n    {\n      isHost = omp_is_initial_device();\n      for (int i = 0; i < N; ++i) {\n        h_array[i] = DEVICE_TASK1_BIT | in_1[i] | in_2[i]; // Expected = 0b111\n      }\n    }\n  }\n\n  // Device task 2\n#pragma omp task shared (h_array, h_array_copy) depend(in: h_array) depend(out: h_array_copy)\n  {\n#pragma omp target map(alloc: h_array[0:N]) map(from: h_array_copy[0:N])\n    {\n      for (int i = 0; i < N; ++i) {\n        h_array_copy[i] = h_array[i] | DEVICE_TASK2_BIT; //  Expected = 0b1111\n      }\n    }\n  }\n\n  // host task 3\n#pragma omp task depend(in: h_array_copy) shared(sum, h_array_copy)\n  {\n    // checking results\n    for (int i = 0; i < N; ++i) {\n      // Identify which task was problematic\n      h_array_copy[i] |= HOST_TASK3_BIT;\n      sum += (h_array_copy[i] & ALL_TASKS_BITS); // AND with 0b111 should produce sum\n    }\n  }\n#pragma omp taskwait\n\n  // We verify all the tasks without a task\n  int h_task1 = 0;\n  int h_task2 = 0;\n  int h_task3 = 0;\n  int d_task1 = 0;\n  int d_task2 = 0;\n  for (int i = 0; i < N; ++i) {\n    h_task1 |= !(h_array_copy[i] & HOST_TASK1_BIT);\n    h_task2 |= !(h_array_copy[i] & HOST_TASK2_BIT);\n    h_task2 |= !(h_array_copy[i] & HOST_TASK3_BIT);\n    d_task1 |= !(h_array_copy[i] & DEVICE_TASK1_BIT);\n    d_task2 |= !(h_array_copy[i] & DEVICE_TASK2_BIT);\n  }\n  OMPVV_ERROR_IF(h_task1 != 0, \"Error in host task 1\");\n  OMPVV_ERROR_IF(h_task2 != 0, \"Error in host task 2\");\n  OMPVV_ERROR_IF(h_task3 != 0, \"Error in host task 3\");\n  OMPVV_ERROR_IF(d_task1 != 0, \"Error in device task 1\");\n  OMPVV_ERROR_IF(d_task2 != 0, \"Error in device task 2\");\n\n  OMPVV_TEST_AND_SET(errors, (N * ALL_TASKS_BITS != sum));\n  OMPVV_INFOMSG(\"Test test_async_between_task_target ran on the %s\", (isHost ? \"host\" : \"device\"));\n \n// Garbage collection\n// This is outside of the testing area but we need to clear memory on the device \n// created with the target enter data\n#pragma omp target exit data map(delete: h_array[0:N], in_1[0:N], in_2[0:N])\n  free(h_array);\n  free(h_array_copy);\n  free(in_1);\n  free(in_2);\n\n  return errors;\n}\n\n/*\n * Test if it is possible to:\n * 1. target enter data to depend 'out'\n * 2. target exit data to depend 'in'\n * 3. use nowait for async\n */\nint test_async_between_target() {\n  OMPVV_INFOMSG(\"test_async_between_target\");\n\n  int errors = 0;\n  bool isHost = true;\n  int sum = 0;\n  int* h_array = (int *) malloc(N * sizeof(int));\n  int* h_array_copy = (int *) malloc(N * sizeof(int));\n  int val = DEVICE_TASK1_BIT;\n\n  // target enter data\n#pragma omp target enter data map(alloc: h_array[0:N]) depend(out: h_array) \n\n#pragma omp target enter data map(to: val) depend(out: val) \n\n#pragma omp target map(tofrom: isHost) map(alloc: h_array[0:N]) depend(inout: h_array) depend(in: val) \n  {\n    isHost = omp_is_initial_device();\n    for (int i = 0; i < N; ++i) {\n      h_array[i] = val; // val = DEVICE_TASK1_BIT\n    }\n  }\n\n#pragma omp target map(alloc: h_array[0:N]) map(from: h_array_copy[0:N]) depend(in: h_array) depend(out: h_array_copy) \n  {\n    for (int i = 0; i < N; ++i) {\n      h_array_copy[i] = h_array[i] | DEVICE_TASK2_BIT;\n    }\n  }\n#pragma omp taskwait\n\n  // checking results\n  int d_task1 = 0;\n  int d_task2 = 0;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n  for (int i = 0; i < N; ++i) {\n    sum += (h_array_copy[i] & (DEVICE_TASK1_BIT | DEVICE_TASK2_BIT)); // this will lead to 0b1100\n    // Checking each individual task\n    d_task1 |= !(h_array_copy[i] & DEVICE_TASK1_BIT);\n    d_task2 |= !(h_array_copy[i] & DEVICE_TASK2_BIT);\n  }\n  // Report on each task\n  OMPVV_ERROR_IF(d_task1 != 0, \"Error in device task 1\");\n  OMPVV_ERROR_IF(d_task2 != 0, \"Error in device task 2\");\n\n  OMPVV_TEST_AND_SET(errors, (N * (DEVICE_TASK1_BIT | DEVICE_TASK2_BIT) != sum));\n  OMPVV_INFOMSG(\"Test test_async_between_task_target ran on the %s\", (isHost ? \"host\" : \"device\"));\n\n// Garbage collection\n// This is outside of the testing area but we need to clear memory on the device \n// created with the target enter data\n#pragma omp target exit data map(delete: h_array[0:N], val)\n\n  free(h_array);\n  free(h_array_copy);\n  return errors;\n}\n\nint main(){\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET(errors, test_async_between_target());\n  OMPVV_TEST_AND_SET(errors, test_async_between_task_target());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_taskloop_firstprivate.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  \n    int errors = 0;\n  \n    OMPVV_TEST_AND_SET_VERBOSE(errors, (test_taskloop_firstprivate()) != 0);\n    OMPVV_REPORT_AND_RETURN(errors);\n\n    return 0;\n}\" at position 1772",
        "issue_id": 4,
        "original_code": "//----------------------------------- test_taskloop_firstprivate.c ----------------------------------------//\n//\n// OpenMP API Version 4.5 November 2015\n//\n// This test checks the taskloop directive with the 'firstprivate' clause specified.\n// The 'taskloop' construct parallelize loops with independent iterations by creating tasks. \n// It allows for efficient parallel execution of loop iterations by distributing them among multiple threads. \n// The 'firstprivate' clause ensures that each task should have private copies and initialized                          // private copies with the value from the master thread. \n// -------------------------------------------------------------------------------------------------------//\n\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define NUM_THREADS 500\n#define NUM_TASKS 1000\n\nint is_task_values_equal_to_firstprivate(int first_priv_value, int a[])\n{\n    for(int i = 0; i < NUM_TASKS; i++) {\n    \tif(first_priv_value != a[i])\n        \treturn 0; //if all array values are not same. \n    }\t\n\n    return 1; //if all array values are same\n}\n\nint test_taskloop_firstprivate() {\n    \n    int errors = 0;\n    \n    int private_var = 11; \n    int var_not_in_openmp = private_var;\n\n    int task_vals[NUM_TASKS];\n    \n    #pragma omp parallel num_threads(NUM_THREADS)\n    {\n        #pragma omp single\n        {\n            #pragma omp taskloop firstprivate(private_var)\n            for (int i = 0; i < NUM_TASKS; i++) {\n\t\ttask_vals[i] = private_var;\n            }\n        }\n    }\n    \n    //if all the tasks values are same as first private value, get TRUE else FALSE \n    OMPVV_TEST_AND_SET_VERBOSE(errors, (is_task_values_equal_to_firstprivate(var_not_in_openmp, task_vals)) != 1);\n    \n    return errors;\n}\n\nint main() {\n  \n    int errors = 0;\n  \n    OMPVV_TEST_AND_SET_VERBOSE(errors, (test_taskloop_firstprivate()) != 0);\n    OMPVV_REPORT_AND_RETURN(errors);\n\n    return 0;\n}\n\n",
        "error_code": "//----------------------------------- test_taskloop_firstprivate.c ----------------------------------------//\n//\n// OpenMP API Version 4.5 November 2015\n//\n// This test checks the taskloop directive with the 'firstprivate' clause specified.\n// The 'taskloop' construct parallelize loops with independent iterations by creating tasks. \n// It allows for efficient parallel execution of loop iterations by distributing them among multiple threads. \n// The 'firstprivate' clause ensures that each task should have private copies and initialized                          // private copies with the value from the master thread. \n// -------------------------------------------------------------------------------------------------------//\n\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define NUM_THREADS 500\n#define NUM_TASKS 1000\n\nint is_task_values_equal_to_firstprivate(int first_priv_value, int a[])\n{\n    for(int i = 0; i < NUM_TASKS; i++) {\n    \tif(first_priv_value != a[i])\n        \treturn 0; //if all array values are not same. \n    }\t\n\n    return 1; //if all array values are same\n}\n\nint test_taskloop_firstprivate() {\n    \n    int errors = 0;\n    \n    int private_var = 11; \n    int var_not_in_openmp = private_var;\n\n    int task_vals[NUM_TASKS];\n    \n    #pragma omp parallel num_threads(NUM_THREADS)\n    {\n        #pragma omp single\n        {\n            #pragma omp taskloop firstprivate(private_var)\n            for (int i = 0; i < NUM_TASKS; i++) {\n\t\ttask_vals[i] = private_var;\n            }\n        }\n    }\n    \n    //if all the tasks values are same as first private value, get TRUE else FALSE \n    OMPVV_TEST_AND_SET_VERBOSE(errors, (is_task_values_equal_to_firstprivate(var_not_in_openmp, task_vals)) != 1);\n    \n    return errors;\n}\n\nint main() \n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_simd_collapse.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp map\" at position 1102",
        "issue_id": 0,
        "original_code": "//===--- test_target_simd_collapse.c------ testing collapse with SIMD--------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the collapse clause and tests that for simd loops out of the scope\n// of the collapsed loops are not parallelized.  This test tests using one and\n// two collapsed loops.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define ARRAY_SIZE 128 //Array Size of 128 uses 16MB target memory and\n//scales n^3 in test_collapse2()\n\nint test_collapse1() {\n  OMPVV_INFOMSG(\"Testing for collapse(1)\");\n  int * a_mem = (int*)malloc(ARRAY_SIZE*ARRAY_SIZE*sizeof(int));\n  int * b_mem = (int*)malloc(ARRAY_SIZE*(ARRAY_SIZE+1)*sizeof(int));\n  int (*a)[ARRAY_SIZE] = (int (*)[ARRAY_SIZE])a_mem;\n  int (*b)[ARRAY_SIZE + 1] = (int (*)[ARRAY_SIZE+1])b_mem;\n  int errors = 0;\n\n  // a and b array initialization\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    b[x][0] = 0;\n    for (int y = 0; y < ARRAY_SIZE; ++y) {\n      a[x][y] = x + y;\n      b[x][y+1] = 0;\n    }\n  }\n\n#pragma omp target simd map(to: a[0:ARRAY_SIZE][0:ARRAY_SIZE]) map(tofrom: b[0:ARRAY_SIZE][0:ARRAY_SIZE+1]) collapse(1)\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    for (int y = 0; y < ARRAY_SIZE; ++y) {\n      b[x][y + 1] = b[x][y] + a[x][y];\n    }\n  }\n\n  int temp_total;\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    temp_total = 0;\n    for (int y = 0; y < ARRAY_SIZE+1; ++y) {\n      OMPVV_TEST_AND_SET(errors, ((temp_total - b[x][y]) != 0));\n      if (y != ARRAY_SIZE) {\n        temp_total = temp_total + a[x][y];\n      }\n    }\n  }\n  free(a_mem);\n  free(b_mem);\n\n  return errors;\n}\n\nint test_collapse2() {\n  OMPVV_INFOMSG(\"Testing for collapse(2)\");\n  int * a_mem = (int *)malloc(ARRAY_SIZE*ARRAY_SIZE*ARRAY_SIZE*sizeof(int));\n  int * b_mem = (int *)malloc(ARRAY_SIZE*ARRAY_SIZE*(ARRAY_SIZE+1)*sizeof(int));\n  int (*a)[ARRAY_SIZE][ARRAY_SIZE] = (int (*)[ARRAY_SIZE][ARRAY_SIZE])a_mem;\n  int (*b)[ARRAY_SIZE][ARRAY_SIZE + 1] = (int (*)[ARRAY_SIZE][ARRAY_SIZE+1])b_mem;\n  int errors = 0;\n  int num_teams = 0;\n\n  // a and b array initialization\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    for (int y = 0; y < ARRAY_SIZE; ++y) {\n      b[x][y][0] = 0;\n      for (int z = 0; z < ARRAY_SIZE; ++z) {\n        a[x][y][z] = x + y + z;\n        b[x][y][z+1] = 0;\n      }\n    }\n  }\n\n#pragma omp target simd map(to: a[0:ARRAY_SIZE][0:ARRAY_SIZE][0:ARRAY_SIZE]) map(tofrom: b[0:ARRAY_SIZE][0:ARRAY_SIZE][0:ARRAY_SIZE+1], num_teams) collapse(2)\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    for (int y = 0; y < ARRAY_SIZE; ++y) {\n      for (int z = 0; z < ARRAY_SIZE; ++z) {\n        if (omp_get_team_num() == 0) {\n          num_teams = omp_get_num_teams();\n        }\n        b[x][y][z + 1] = b[x][y][z] + a[x][y][z];\n      }\n    }\n  }\n\n  int temp_total;\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    for (int y = 0; y < ARRAY_SIZE; ++y) {\n      temp_total = 0;\n      for (int z = 0; z < ARRAY_SIZE + 1; ++z) {\n        OMPVV_TEST_AND_SET(errors, ((temp_total - b[x][y][z]) != 0));\n        if (z != ARRAY_SIZE) {\n          temp_total = temp_total + a[x][y][z];\n        }\n      }\n    }\n  }\n\n  if (num_teams == 1) {\n    OMPVV_WARNING(\"Test operated with one team.  Parallelism of teams distribute can't be guaranteed.\");\n  }\n\n  free(a_mem);\n  free(b_mem);\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_collapse1() != 0);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_collapse2() != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_simd_collapse.c------ testing collapse with SIMD--------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the collapse clause and tests that for simd loops out of the scope\n// of the collapsed loops are not parallelized.  This test tests using one and\n// two collapsed loops.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define ARRAY_SIZE 128 //Array Size of 128 uses 16MB target memory and\n//scales n^3 in test_collapse2()\n\nint test_collapse1() {\n  OMPVV_INFOMSG(\"Testing for collapse(1)\");\n  int * a_mem = (int*)malloc(ARRAY_SIZE*ARRAY_SIZE*sizeof(int));\n  int * b_mem = (int*)malloc(ARRAY_SIZE*(ARRAY_SIZE+1)*sizeof(int));\n  int (*a)[ARRAY_SIZE] = (int (*)[ARRAY_SIZE])a_mem;\n  int (*b)[ARRAY_SIZE + 1] = (int (*)[ARRAY_SIZE+1])b_mem;\n  int errors = 0;\n\n  // a and b array initialization\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    b[x][0] = 0;\n    for (int y = 0; y < ARRAY_SIZE; ++y) {\n      a[x][y] = x + y;\n      b[x][y+1] = 0;\n    }\n  }\n\n#pragma omp map simd map(to: a[0:ARRAY_SIZE][0:ARRAY_SIZE]) map(tofrom: b[0:ARRAY_SIZE][0:ARRAY_SIZE+1]) collapse(1)\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    for (int y = 0; y < ARRAY_SIZE; ++y) {\n      b[x][y + 1] = b[x][y] + a[x][y];\n    }\n  }\n\n  int temp_total;\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    temp_total = 0;\n    for (int y = 0; y < ARRAY_SIZE+1; ++y) {\n      OMPVV_TEST_AND_SET(errors, ((temp_total - b[x][y]) != 0));\n      if (y != ARRAY_SIZE) {\n        temp_total = temp_total + a[x][y];\n      }\n    }\n  }\n  free(a_mem);\n  free(b_mem);\n\n  return errors;\n}\n\nint test_collapse2() {\n  OMPVV_INFOMSG(\"Testing for collapse(2)\");\n  int * a_mem = (int *)malloc(ARRAY_SIZE*ARRAY_SIZE*ARRAY_SIZE*sizeof(int));\n  int * b_mem = (int *)malloc(ARRAY_SIZE*ARRAY_SIZE*(ARRAY_SIZE+1)*sizeof(int));\n  int (*a)[ARRAY_SIZE][ARRAY_SIZE] = (int (*)[ARRAY_SIZE][ARRAY_SIZE])a_mem;\n  int (*b)[ARRAY_SIZE][ARRAY_SIZE + 1] = (int (*)[ARRAY_SIZE][ARRAY_SIZE+1])b_mem;\n  int errors = 0;\n  int num_teams = 0;\n\n  // a and b array initialization\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    for (int y = 0; y < ARRAY_SIZE; ++y) {\n      b[x][y][0] = 0;\n      for (int z = 0; z < ARRAY_SIZE; ++z) {\n        a[x][y][z] = x + y + z;\n        b[x][y][z+1] = 0;\n      }\n    }\n  }\n\n#pragma omp target simd map(to: a[0:ARRAY_SIZE][0:ARRAY_SIZE][0:ARRAY_SIZE]) map(tofrom: b[0:ARRAY_SIZE][0:ARRAY_SIZE][0:ARRAY_SIZE+1], num_teams) collapse(2)\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    for (int y = 0; y < ARRAY_SIZE; ++y) {\n      for (int z = 0; z < ARRAY_SIZE; ++z) {\n        if (omp_get_team_num() == 0) {\n          num_teams = omp_get_num_teams();\n        }\n        b[x][y][z + 1] = b[x][y][z] + a[x][y][z];\n      }\n    }\n  }\n\n  int temp_total;\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    for (int y = 0; y < ARRAY_SIZE; ++y) {\n      temp_total = 0;\n      for (int z = 0; z < ARRAY_SIZE + 1; ++z) {\n        OMPVV_TEST_AND_SET(errors, ((temp_total - b[x][y][z]) != 0));\n        if (z != ARRAY_SIZE) {\n          temp_total = temp_total + a[x][y][z];\n        }\n      }\n    }\n  }\n\n  if (num_teams == 1) {\n    OMPVV_WARNING(\"Test operated with one team.  Parallelism of teams distribute can't be guaranteed.\");\n  }\n\n  free(a_mem);\n  free(b_mem);\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_collapse1() != 0);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_collapse2() != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/gemv_target_many_matrices.cpp",
        "correct": "n",
        "issue": "Removed opening bracket at position 2307",
        "issue_id": 1,
        "original_code": "//===-- gemv_target_many_matrices.cpp - GEMV on many matrices in parallel ---===!\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// Taken from the suggestions of the QMCPack team. This test uses a target teams\n// distribute combined construct Additionally, it spawns multiple target \n// regions in parallel. Each on a different matrix\n//!===----------------------------------------------------------------------===!\n#include <chrono>\n#include <string>\n#include <vector>\n#include <cmath>\n#include \"ompvv.h\"\n#include \"omp.h\"\n\n#define N 4096\n#define NUM_CALC 8\n\nclass Timer\n{\n  const std::chrono::time_point<std::chrono::system_clock> start;\n  const std::string name;\n\npublic:\n  Timer(const std::string& name_in): start(std::chrono::system_clock::now()), name(name_in) {};\n  ~Timer()\n  {\n    auto end = std::chrono::system_clock::now();\n    OMPVV_INFOMSG(\"Function %s takes %lf us \",name.c_str(), std::chrono::duration_cast<std::chrono::duration<double, std::micro>>(end - start).count());\n  }\n};\n\ntemplate <typename T>\nvoid gemv(int n, T alpha, const T*  A, const T*  V, T*  Vout)\n{\n  #pragma omp target teams distribute map(to:A[:n*n], V[:n]) map(from:Vout[:n])\n  for(int row=0; row<n; row++)\n  {\n    T sum = T(0);\n    const T * A_row = A+row*n;\n    for(int col=0; col<n; col++) {\n      sum += A_row[col]*V[col];\n    }\n    Vout[row] = sum*alpha;\n  }\n}\n\ntemplate <class T>\nT* allocate(size_t n)\n{\n  T* ptr = new T[n];\n  std::fill_n(ptr, n, T(1));\n  #pragma omp target enter data map(to:ptr[:n])\n  return ptr;\n}\n\ntemplate <class T>\nvoid deallocate(T* ptr, size_t n)\n{\n  #pragma omp target exit data map(delete:ptr[:n])\n  delete[] ptr;\n}\n\nint main()\n{\n  OMPVV_TEST_OFFLOADING;\n  std::vector<float*> manyA;\n  std::vector<float*> manyV;\n  std::vector<float*> manyVout;\n  int errors = 0;\n\n  // Initializing matrices \n  for(int i=0; i < NUM_CALC; i++)\n  {\n    manyA.push_back(allocate<float>(N*N));\n    manyV.push_back(allocate<float>(N));\n    manyVout.push_back(allocate<float>(N));\n  }\n\n  // Doing the computation\n  {\n    Timer local(\"GEMV\");\n    #pragma omp parallel for\n    for(int i=0; i < NUM_CALC; i++) {\n      gemv(N, 1.0f, manyA[i], manyV[i], manyVout[i]);\n    }\n  }\n\n  for(int i=0; i < NUM_CALC; i++) {\n    auto*  Vout = manyVout[i];\n    #pragma omp target update from(Vout[:N])\n    for(int i=0; i<N; i++)\n    {\n      OMPVV_TEST_AND_SET(errors, std::abs(Vout[i]-N) > 0.0001);\n      OMPVV_ERROR_IF( std::abs(Vout[i]-N) > 0.0001, \"Error for Vout[%d] = %f, Should be %d\", i, Vout[i], N);\n    }\n    deallocate(manyA[i], N*N);\n    deallocate(manyV[i], N);\n    deallocate(manyVout[i], N);\n  }\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===-- gemv_target_many_matrices.cpp - GEMV on many matrices in parallel ---===!\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// Taken from the suggestions of the QMCPack team. This test uses a target teams\n// distribute combined construct Additionally, it spawns multiple target \n// regions in parallel. Each on a different matrix\n//!===----------------------------------------------------------------------===!\n#include <chrono>\n#include <string>\n#include <vector>\n#include <cmath>\n#include \"ompvv.h\"\n#include \"omp.h\"\n\n#define N 4096\n#define NUM_CALC 8\n\nclass Timer\n{\n  const std::chrono::time_point<std::chrono::system_clock> start;\n  const std::string name;\n\npublic:\n  Timer(const std::string& name_in): start(std::chrono::system_clock::now()), name(name_in) {};\n  ~Timer()\n  {\n    auto end = std::chrono::system_clock::now();\n    OMPVV_INFOMSG(\"Function %s takes %lf us \",name.c_str(), std::chrono::duration_cast<std::chrono::duration<double, std::micro>>(end - start).count());\n  }\n};\n\ntemplate <typename T>\nvoid gemv(int n, T alpha, const T*  A, const T*  V, T*  Vout)\n{\n  #pragma omp target teams distribute map(to:A[:n*n], V[:n]) map(from:Vout[:n])\n  for(int row=0; row<n; row++)\n  {\n    T sum = T(0);\n    const T * A_row = A+row*n;\n    for(int col=0; col<n; col++) {\n      sum += A_row[col]*V[col];\n    }\n    Vout[row] = sum*alpha;\n  }\n}\n\ntemplate <class T>\nT* allocate(size_t n)\n{\n  T* ptr = new T[n];\n  std::fill_n(ptr, n, T(1));\n  #pragma omp target enter data map(to:ptr[:n])\n  return ptr;\n}\n\ntemplate <class T>\nvoid deallocate(T* ptr, size_t n)\n{\n  #pragma omp target exit data map(delete:ptr[:n])\n  delete[] ptr;\n}\n\nint main()\n{\n  OMPVV_TEST_OFFLOADING;\n  std::vector<float*> manyA;\n  std::vector<float*> manyV;\n  std::vector<float*> manyVout;\n  int errors = 0;\n\n  // Initializing matrices \n  for(int i=0; i < NUM_CALC; i++)\n  {\n    manyA.push_back(allocate<float>(N*N));\n    manyV.push_back(allocate<float>(N));\n    manyVout.push_back(allocate<float>(N));\n  }\n\n  // Doing the computation\n  {\n    Timer local(\"GEMV\");\n    #pragma omp parallel for\n    for(int i=0; i < NUM_CALC; i++) {\n      gemv(N, 1.0f, manyA[i], manyV[i], manyVout[i]);\n    }\n  }\n\n  for(int i=0; i < NUM_CALC; i++) {\n    auto*  Vout = manyVout[i];\n    #pragma omp target update from(Vout[:N])\n    for(int i=0; i<N; i++)\n    \n      OMPVV_TEST_AND_SET(errors, std::abs(Vout[i]-N) > 0.0001);\n      OMPVV_ERROR_IF( std::abs(Vout[i]-N) > 0.0001, \"Error for Vout[%d] = %f, Should be %d\", i, Vout[i], N);\n    }\n    deallocate(manyA[i], N*N);\n    deallocate(manyV[i], N);\n    deallocate(manyVout[i], N);\n  }\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_parallel.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 584",
        "issue_id": 2,
        "original_code": "//===---- test_target_parallel.c - combined consutrct target and parallel  -------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// This test checks for the combined construct target and parallel. It allows to create a\n// parallel region inside of the target device. \n//\n//===----------------------------------------------------------------------------------===//\n//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include \"ompvv.h\"\n\nint test_target_parallel() {\n  OMPVV_INFOMSG(\"test_target_parallel\");\n\n  int num_threads[OMPVV_NUM_THREADS_DEVICE];\n  int errors = 0;\n\n#pragma omp target parallel num_threads(OMPVV_NUM_THREADS_DEVICE) map(from:num_threads[0:OMPVV_NUM_THREADS_DEVICE])\n  {\n    int thread_id = omp_get_thread_num();\n    num_threads[thread_id] = omp_get_num_threads();\n  }\n\n  //Warning if only 1 thread in region 2, parallel does nothing\n  OMPVV_WARNING_IF(num_threads[0] == 1, \"The number of threads in the parallel region was 1. This is not a specifications error but we could not confirm the parallel region.\");\n\n  //Error if num_threads is inconsistent between threads\n  for (int i = 1; i < num_threads[0]; ++i) {\n    OMPVV_TEST_AND_SET(errors, num_threads[i] != num_threads[0]);\n    OMPVV_ERROR_IF(num_threads[i] != num_threads[0], \"The number of threads recorded by thread %d was %d. Expected was %d.\", i, num_threads[i], num_threads[0]);\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_parallel());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_parallel.c - combined consutrct target and parallel  -------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// This test checks for the combined construct target and parallel. It allows to create a\n// parallel region inside of the target device. \n//\n//===----------------------------------------------------------------------------------===//\n//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include \"ompvv.h\"\n\nint test_target_parallel() {\n  OMPVV_INFOMSG(\"test_target_parallel\");\n\n  int num_threads[OMPVV_NUM_THREADS_DEVICE];yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n  int errors = 0;\n\n#pragma omp target parallel num_threads(OMPVV_NUM_THREADS_DEVICE) map(from:num_threads[0:OMPVV_NUM_THREADS_DEVICE])\n  {\n    int thread_id = omp_get_thread_num();\n    num_threads[thread_id] = omp_get_num_threads();\n  }\n\n  //Warning if only 1 thread in region 2, parallel does nothing\n  OMPVV_WARNING_IF(num_threads[0] == 1, \"The number of threads in the parallel region was 1. This is not a specifications error but we could not confirm the parallel region.\");\n\n  //Error if num_threads is inconsistent between threads\n  for (int i = 1; i < num_threads[0]; ++i) {\n    OMPVV_TEST_AND_SET(errors, num_threads[i] != num_threads[0]);\n    OMPVV_ERROR_IF(num_threads[i] != num_threads[0], \"The number of threads recorded by thread %d was %d. Expected was %d.\", i, num_threads[i], num_threads[0]);\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_parallel());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_parallel_sections.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===================-test_parallel_sections.c-=============================//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// testing the combined construct 'parallel sections'\n//\n//===---------------------------------------------------------------------===//\n\n\n\n#include <stdio.h>\n#include <unistd.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\nint Var = 0;\n\n// The following function waits for Var value to become 1 and then increments\n// it to Var = 1\nvoid function1(int *Var) {\n  int temp = -1;\n  while(1) {\n   #pragma omp atomic read\n    temp = *Var;\n    \n    if (temp == 1) {\n      #pragma omp atomic update\n      *Var += 1;\n      break;\n    }\n  }\n}\n\n// The following function check if Var == 0 and then increments to Var = 1\n// and then immediately it loops until Var == 3 and then increments it to\n// Var = 4\nvoid function2(int *Var) {\n  int temp = -1;\n  while(1) {\n    #pragma omp atomic read\n    temp = *Var;\n    \n    if (temp == 0) {\n      #pragma omp atomic update\n      *Var += 1;\n      break;\n    }\n  }\n\n  while(1) {\n    #pragma omp atomic read\n    temp = *Var;\n    \n    if (temp == 3) {\n      #pragma omp atomic update\n      *Var += 1;\n      break;\n    }\n  }\n}\n\n// The following function checks if Var == 2 and then increments to Var = 3\nvoid function3(int *Var) {\n  int temp = -1;\n  while(1) {\n    #pragma omp atomic read\n    temp = *Var;\n    \n    if (*Var == 2) {\n      #pragma omp atomic update\n      *Var += 1;\n      break;\n    }\n  }\n}\n\n\nint main() {\n  int errors = 0;\n  \n  #pragma omp parallel sections\n  {\n    if(omp_get_num_threads() == 1) \n    {\n      OMPVV_WARNING(\"Sections are executed by a single thread, test will be aborted.\")\n      exit(0);\n    }\n      \n    #pragma omp section\n    function1(&Var);\n\n    #pragma omp section\n    function2(&Var);\n\n    #pragma omp section\n    function3(&Var);\n  }\n \n  \n  // The final expected value of Var is '4'\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (Var != 4));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nbyte kqlaarssfh = 55;\nint reksgufhea = 143;\ndouble kjxmhrsadh = 114;\nshort cjwizwdfpg = 163;\nfloat eejnkofaqu = 52;\nshort imvfhxqjow = 69;\nfloat gjbrxdrfex = 250;\ndouble zksogssxdg = 21;\nfloat hunnjwzimg = 183;\nbyte ualzvxrevf = 84;\nint cfmihctffy = 50;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_declare_target_extended_list.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp declare\" with directive \"#pragma omp teams\" at position 661",
        "issue_id": 0,
        "original_code": "//===------ test_declare_target_extended_list.c ----------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks the second valid format of declare target directive. The\n// extended list allows for mappable variables and function names to be listed.\n// If an extended-list is present with no clause then the to clause is assumed.\n// Updates using the enclosed function are made inside the target region and\n// results are verified on the host.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint aint = 10;\n\n#pragma omp declare target(aint)\n\nvoid compute_array(int a[N], int b[N], int c[N]) {\n  for (int i = 0; i < N; i++) {\n    a[i] = b[i]*c[i] + aint * i;\n  }\n  return;\n}\n\n#pragma omp declare target(compute_array)\n\nint test_declare_target() {\n\n  OMPVV_INFOMSG(\"test_declare_target_extended_list\");\n\n  int errors = 0;\n  int x[N];\n  int y[N];\n  int z[N];\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 0;\n    y[i] = 1;\n    z[i] = i;\n  }\n\n#pragma omp target map(from: x) map(to:y, z)\n  {\n    compute_array(x, y, z);\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != (y[i] * z[i] + 10 * i));\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_declare_target() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===------ test_declare_target_extended_list.c ----------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks the second valid format of declare target directive. The\n// extended list allows for mappable variables and function names to be listed.\n// If an extended-list is present with no clause then the to clause is assumed.\n// Updates using the enclosed function are made inside the target region and\n// results are verified on the host.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint aint = 10;\n\n#pragma omp teams target(aint)\n\nvoid compute_array(int a[N], int b[N], int c[N]) {\n  for (int i = 0; i < N; i++) {\n    a[i] = b[i]*c[i] + aint * i;\n  }\n  return;\n}\n\n#pragma omp declare target(compute_array)\n\nint test_declare_target() {\n\n  OMPVV_INFOMSG(\"test_declare_target_extended_list\");\n\n  int errors = 0;\n  int x[N];\n  int y[N];\n  int z[N];\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 0;\n    y[i] = 1;\n    z[i] = i;\n  }\n\n#pragma omp target map(from: x) map(to:y, z)\n  {\n    compute_array(x, y, z);\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != (y[i] * z[i] + 10 * i));\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_declare_target() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_enter_exit_data_classes_complex.cpp",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp parallel\" at position 1598",
        "issue_id": 0,
        "original_code": "//===--test_targe_enter_exit_data_classes_complex.c - test inheritance class -===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n//\n// This test uses target enter data and exit data to map multiple levels of \n// inheritance in classes and templates. The target enter and exit data are used\n// in the constructor and destructor of all the levels of the hierarchy. \n// It requires the use of helper_ variables since it\n// is not legal to use the \"this\" pointer (implicitly or explicitly) in 4.5. \n//\n// We use a modify method, which is propagated through the hierarchy of classes,\n// to assign values to the array. Following we use a method to obtain a copy of the values \n// from the device. The disctintion between methods allows to show that\n// data is mapped and remains mapped in the device memory. This test does\n// not use any inheritance or anything similar, therefore the simple connotation\n//\n// Contrary to the test of target_enter_data, this test checks if during the exit\n// data it successfully copies back the attributes of the object\n////===----------------------------------------------------------------------===//\n\n#include <iostream>\n#include <typeinfo>\n#include <omp.h>\n#include <cmath>\n#include \"ompvv.h\"\n\n\nusing namespace std;\n\n#define N 1000\n\ntemplate<typename T>\nclass Mapper {\n\n  private:\n    T* ptr;\n    bool not_mapped;\n\n  public:\n    Mapper (T* p) : ptr(p) {\n      not_mapped = !omp_target_is_present(ptr, omp_get_default_device());\n      // maps if target is not present\n      T* helper_ptr = ptr;\n      OMPVV_INFOMSG_IF(not_mapped, \"Mapping class %s\", typeid(T).name());\n#pragma omp target enter data map(to: helper_ptr[0:1]) if(not_mapped)\n    }\n    ~Mapper() {\n      // unmaps iff this mapper mapped the target\n      T* helper_ptr = ptr;\n      OMPVV_INFOMSG_IF(not_mapped, \"Unmapping class %s\", typeid(T).name());\n#pragma omp target exit data map(delete: helper_ptr[0:1]) if(not_mapped)\n      ptr = NULL;\n    }\n};\n\nclass B : public Mapper<B> {\n\n  protected:\n    int n;\n    double* x;\n    int* errors;\n\n  public:\n    B(int n, int* err) : Mapper<B>(this), n(n), errors(err) {\n      x = new double[n];\n      for (int i = 0; i < n; i ++) {\n        x[i] = (double) i;\n      }\n      int &helper_n = this->n;\n      double *helper_x = this->x;\n\n      OMPVV_INFOMSG(\"Mapping B attributes\");\n#pragma omp target update to(helper_n)\n#pragma omp target enter data map(to:helper_x[0:n])\n    }\n\n    ~B() {\n      double *helper_x = this->x;\n      OMPVV_INFOMSG(\"Unmapping B attributes\");\n#pragma omp target exit data map(from:helper_x[0:n])\n      // checking results\n      for (int i = 0; i < N; ++i) {\n        OMPVV_TEST_AND_SET_VERBOSE(*errors, std::abs(x[i] - (double)(3*i)) > 0.0001);\n      }\n    }\n\n    void modifyB() {\n      OMPVV_INFOMSG(\"Modifying B\");\n      int &helper_n = this->n;\n      double *helper_x = this->x;\n#pragma omp target defaultmap(tofrom:scalar)\n      {\n        for (int i = 0; i < helper_n; ++i)\n          helper_x[i] += (double) i;\n      } \n    }\n};\n\nclass A : public Mapper<A>, public B {\n  private:\n    int* y;\n\n  public:\n    A(int s, int* err) : Mapper<A>(this), B(s, err) { \n      OMPVV_INFOMSG(\"Mapping A attributes\");\n      y = new int[n];\n      // Initialize y\n      for (int i = 0; i < n; i ++) {\n        y[i] = i;\n      }\n      int *helper_y = this->y;\n#pragma omp target enter data map(to: helper_y[0:n])\n    }\n    ~A() {\n      OMPVV_INFOMSG(\"Unmapping A attributes\");\n      int *helper_y = this->y;\n#pragma omp target exit data map(from: helper_y[0:n])\n      // checking results\n      for (int i = 0; i < N; ++i) {\n        OMPVV_TEST_AND_SET_VERBOSE(*errors, y[i] != 3*i);\n      }\n    }\n\n    void modifyA() {\n      modifyB();\n      OMPVV_INFOMSG(\"Modifying A\");\n      int &helper_n = this->n;      \n      int *helper_y = this->y;\n#pragma omp target defaultmap(tofrom:scalar)\n      {\n        for (int i = 0; i < helper_n; ++i) {\n          helper_y[i] += i;\n        }\n      }\n    }\n\n    void getAllAttributesDevice(double * copy_x, int * copy_y) {\n      int &helper_n = this->n;      \n      int *helper_y = this->y;\n      double *helper_x = this->x;\n#pragma omp target defaultmap(tofrom:scalar) map(from:copy_x[0:n], copy_y[0:n])\n      {\n        for (int i = 0; i < helper_n; ++i) {\n          copy_x[i] = helper_x[i];\n          copy_y[i] = helper_y[i];\n        }\n      }\n\n    }\n\n};\n\n\nint test_complex_class() {\n  OMPVV_INFOMSG(\"Testing complex class\");\n  int sumY = 0, errors = 0;\n  double sumX = 0.0;\n  int *h_y = new int[N];\n  double *h_x = new double[N];\n  // allocation on the device\n  A *obj = new A(N, &errors);\n\n  obj->modifyA();\n\n  obj->getAllAttributesDevice(h_x, h_y);\n\n  // checking results\n  for (int i = 0; i < N; ++i) {\n    sumY += h_y[i];\n    sumX += h_x[i];\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, N*(N-1) != sumY); \n  OMPVV_TEST_AND_SET_VERBOSE(errors, std::abs(sumX - (double) N*(N-1))>0.0001);\n\n  obj->modifyA();\n\n  delete obj;\n  delete[] h_x;\n  delete[] h_y;\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET(errors, test_complex_class());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--test_targe_enter_exit_data_classes_complex.c - test inheritance class -===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n//\n// This test uses target enter data and exit data to map multiple levels of \n// inheritance in classes and templates. The target enter and exit data are used\n// in the constructor and destructor of all the levels of the hierarchy. \n// It requires the use of helper_ variables since it\n// is not legal to use the \"this\" pointer (implicitly or explicitly) in 4.5. \n//\n// We use a modify method, which is propagated through the hierarchy of classes,\n// to assign values to the array. Following we use a method to obtain a copy of the values \n// from the device. The disctintion between methods allows to show that\n// data is mapped and remains mapped in the device memory. This test does\n// not use any inheritance or anything similar, therefore the simple connotation\n//\n// Contrary to the test of target_enter_data, this test checks if during the exit\n// data it successfully copies back the attributes of the object\n////===----------------------------------------------------------------------===//\n\n#include <iostream>\n#include <typeinfo>\n#include <omp.h>\n#include <cmath>\n#include \"ompvv.h\"\n\n\nusing namespace std;\n\n#define N 1000\n\ntemplate<typename T>\nclass Mapper {\n\n  private:\n    T* ptr;\n    bool not_mapped;\n\n  public:\n    Mapper (T* p) : ptr(p) {\n      not_mapped = !omp_target_is_present(ptr, omp_get_default_device());\n      // maps if target is not present\n      T* helper_ptr = ptr;\n      OMPVV_INFOMSG_IF(not_mapped, \"Mapping class %s\", typeid(T).name());\n#pragma omp parallel enter data map(to: helper_ptr[0:1]) if(not_mapped)\n    }\n    ~Mapper() {\n      // unmaps iff this mapper mapped the target\n      T* helper_ptr = ptr;\n      OMPVV_INFOMSG_IF(not_mapped, \"Unmapping class %s\", typeid(T).name());\n#pragma omp target exit data map(delete: helper_ptr[0:1]) if(not_mapped)\n      ptr = NULL;\n    }\n};\n\nclass B : public Mapper<B> {\n\n  protected:\n    int n;\n    double* x;\n    int* errors;\n\n  public:\n    B(int n, int* err) : Mapper<B>(this), n(n), errors(err) {\n      x = new double[n];\n      for (int i = 0; i < n; i ++) {\n        x[i] = (double) i;\n      }\n      int &helper_n = this->n;\n      double *helper_x = this->x;\n\n      OMPVV_INFOMSG(\"Mapping B attributes\");\n#pragma omp target update to(helper_n)\n#pragma omp target enter data map(to:helper_x[0:n])\n    }\n\n    ~B() {\n      double *helper_x = this->x;\n      OMPVV_INFOMSG(\"Unmapping B attributes\");\n#pragma omp target exit data map(from:helper_x[0:n])\n      // checking results\n      for (int i = 0; i < N; ++i) {\n        OMPVV_TEST_AND_SET_VERBOSE(*errors, std::abs(x[i] - (double)(3*i)) > 0.0001);\n      }\n    }\n\n    void modifyB() {\n      OMPVV_INFOMSG(\"Modifying B\");\n      int &helper_n = this->n;\n      double *helper_x = this->x;\n#pragma omp target defaultmap(tofrom:scalar)\n      {\n        for (int i = 0; i < helper_n; ++i)\n          helper_x[i] += (double) i;\n      } \n    }\n};\n\nclass A : public Mapper<A>, public B {\n  private:\n    int* y;\n\n  public:\n    A(int s, int* err) : Mapper<A>(this), B(s, err) { \n      OMPVV_INFOMSG(\"Mapping A attributes\");\n      y = new int[n];\n      // Initialize y\n      for (int i = 0; i < n; i ++) {\n        y[i] = i;\n      }\n      int *helper_y = this->y;\n#pragma omp target enter data map(to: helper_y[0:n])\n    }\n    ~A() {\n      OMPVV_INFOMSG(\"Unmapping A attributes\");\n      int *helper_y = this->y;\n#pragma omp target exit data map(from: helper_y[0:n])\n      // checking results\n      for (int i = 0; i < N; ++i) {\n        OMPVV_TEST_AND_SET_VERBOSE(*errors, y[i] != 3*i);\n      }\n    }\n\n    void modifyA() {\n      modifyB();\n      OMPVV_INFOMSG(\"Modifying A\");\n      int &helper_n = this->n;      \n      int *helper_y = this->y;\n#pragma omp target defaultmap(tofrom:scalar)\n      {\n        for (int i = 0; i < helper_n; ++i) {\n          helper_y[i] += i;\n        }\n      }\n    }\n\n    void getAllAttributesDevice(double * copy_x, int * copy_y) {\n      int &helper_n = this->n;      \n      int *helper_y = this->y;\n      double *helper_x = this->x;\n#pragma omp target defaultmap(tofrom:scalar) map(from:copy_x[0:n], copy_y[0:n])\n      {\n        for (int i = 0; i < helper_n; ++i) {\n          copy_x[i] = helper_x[i];\n          copy_y[i] = helper_y[i];\n        }\n      }\n\n    }\n\n};\n\n\nint test_complex_class() {\n  OMPVV_INFOMSG(\"Testing complex class\");\n  int sumY = 0, errors = 0;\n  double sumX = 0.0;\n  int *h_y = new int[N];\n  double *h_x = new double[N];\n  // allocation on the device\n  A *obj = new A(N, &errors);\n\n  obj->modifyA();\n\n  obj->getAllAttributesDevice(h_x, h_y);\n\n  // checking results\n  for (int i = 0; i < N; ++i) {\n    sumY += h_y[i];\n    sumX += h_x[i];\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, N*(N-1) != sumY); \n  OMPVV_TEST_AND_SET_VERBOSE(errors, std::abs(sumX - (double) N*(N-1))>0.0001);\n\n  obj->modifyA();\n\n  delete obj;\n  delete[] h_x;\n  delete[] h_y;\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET(errors, test_complex_class());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_depend_in_in.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 1568",
        "issue_id": 2,
        "original_code": "//===--- test_target_teams_distribute_depend_in_in.c-------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks if two depend(in) tasks are independent by trying to\n// create a asynchronous behavior. If no asynchronicity can be shown, then\n// the test gives only a warning, since this is still complaint. This test\n// will fail if invalid values are written.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_target_teams_distribute_depend_in_in() {\n  int isOffloading = 0;\n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int async_found = 0;\n  int errors = 0;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n    b[x] = 2*x;\n    c[x] = 0;\n    d[x] = 0;\n  }\n\n#pragma omp target data map(to: a[0:N], b[0:N]) map(tofrom: c[0:N], d[0:N])\n  {\n#pragma omp target teams distribute nowait depend(in:d) map(alloc: a[0:N], b[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n#pragma omp atomic\n      d[x] += a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(in:d) map(alloc: a[0:N], b[0:N], c[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n#pragma omp atomic\n      c[x] += 2*(a[x] + b[x]) + d[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, c[x] != 6*x && c[x] != 9*x);\n    OMPVV_ERROR_IF(errors, \"Found invalid results, cannot show independence between depend clauses on disjoint array sections.\");\n    if (errors) {\n      break;\n    }\n    if (c[x] == 6*x) {\n      async_found = 1;\n    }\n  }\n\n  OMPVV_INFOMSG_IF(!errors && async_found, \"Found asynchronous behavior between depend clauses on disjoint array sections.\");\n  OMPVV_WARNING_IF(!errors && !async_found, \"Constructs ran in sequence, could not show lack of dependence since nowait had no effect.\");\n\n  return errors;\n}\nint main() {\n  int errors = 0;\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  errors += test_target_teams_distribute_depend_in_in();\n  OMPVV_INFOMSG_IF(errors != 0, \"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_depend_in_in.c-------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks if two depend(in) tasks are independent by trying to\n// create a asynchronous behavior. If no asynchronicity can be shown, then\n// the test gives only a warning, since this is still complaint. This test\n// will fail if invalid values are written.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_target_teams_distribute_depend_in_in() {\n  int isOffloading = 0;\n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int async_found = 0;\n  int errors = 0;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n    b[x] = 2*x;\n    c[x] = 0;\n    d[x] = 0;\n  }\n\n#pragma omp target data map(to: a[0:N], b[0:N]) map(tofrom: c[0:N], d[0:N])\n  {\n#pragma omp target teams distribute nowait depend(in:d) map(alloc: a[0:N], b[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n#pragma omp atomic\n      d[x] += a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(in:d) map(alloc: a[0:N], b[0:N], c[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n#pragma omp atomic\n      c[x] += 2*(a[x] + b[x]) + d[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, c[x] != 6*x && c[x] != 9*x);\n    OMPVV_ERROR_IF(errors, \"Found invalid results, cannot show independence between depend clauses on disjoint array sections.\");\n    if (errors) {\n      break;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n    }\n    if (c[x] == 6*x) {\n      async_found = 1;\n    }\n  }\n\n  OMPVV_INFOMSG_IF(!errors && async_found, \"Found asynchronous behavior between depend clauses on disjoint array sections.\");\n  OMPVV_WARNING_IF(!errors && !async_found, \"Constructs ran in sequence, could not show lack of dependence since nowait had no effect.\");\n\n  return errors;\n}\nint main() {\n  int errors = 0;\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  errors += test_target_teams_distribute_depend_in_in();\n  OMPVV_INFOMSG_IF(errors != 0, \"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_parallel_for_map_from.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  int errors = 0;\n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_map_from());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 1008",
        "issue_id": 4,
        "original_code": "//===--- test_target_teams_distribute_parallel_for_map_from.c ---------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// Testing the map from of scalars and arrays when used with target teams \n// distrbute parallel for.\n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define N 1024\n\nint test_target_teams_distribute_parallel_for_map_from() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_map_from\");\n  \n  int a[N];\n  int scalar = 0;\n  int errors = 0;\n  int i,j, dev;\n\n  scalar = 0;\n  // array initialization\n  for (i = 0; i < N; ++i) {\n    a[i] = 1;\n  }\n\n\n#pragma omp target teams distribute parallel for map(from: a, scalar)\n  for (j = 0; j < N; ++j) {\n#pragma omp atomic write\n    scalar = 20;\n    a[j] = 10;\n  }\n\n  // check the results\n  OMPVV_TEST_AND_SET(errors, scalar != 20);\n  for (i = 0; i < N; ++i) {\n    OMPVV_TEST_AND_SET(errors, a[i] != 10);\n  }\n\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_map_from());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_parallel_for_map_from.c ---------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// Testing the map from of scalars and arrays when used with target teams \n// distrbute parallel for.\n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define N 1024\n\nint test_target_teams_distribute_parallel_for_map_from() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_map_from\");\n  \n  int a[N];\n  int scalar = 0;\n  int errors = 0;\n  int i,j, dev;\n\n  scalar = 0;\n  // array initialization\n  for (i = 0; i < N; ++i) {\n    a[i] = 1;\n  }\n\n\n#pragma omp target teams distribute parallel for map(from: a, scalar)\n  for (j = 0; j < N; ++j) {\n#pragma omp atomic write\n    scalar = 20;\n    a[j] = 10;\n  }\n\n  // check the results\n  OMPVV_TEST_AND_SET(errors, scalar != 20);\n  for (i = 0; i < N; ++i) {\n    OMPVV_TEST_AND_SET(errors, a[i] != 10);\n  }\n\n  return errors;\n}\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_defaultmap.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 1393",
        "issue_id": 2,
        "original_code": "//===----- test_target_defaultmap.c --------------------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// This test is made up of two functions that both check that the default mapping of \n// scalars to the device is tofrom. The first function test_default_map_on actively \n// specifies default mapping to be tofrom, while the function test_default_map_off\n// implicity specifies default mapping. Both functions initalize scalars on host, and\n// then change the value of the scalars on the device within the target region. The\n// scalar values are checked after target region to ensure they were correctly mapped \n// back to host. The five basic data types in C are used as scalars.\n//\n////===-------------------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\nint test_defaultmap_on() {\n  OMPVV_INFOMSG(\"test_defaultmap_on\");\n\n  int errors = 0;\n\n  // we try with all the scalars\n  char scalar_char = 'a';\n  short scalar_short = 10;\n  int scalar_int = 11;\n  float scalar_float = 5.5f;\n  double scalar_double = 10.45;\n  enum { VAL1 = 1, VAL2, VAL3, VAL4} scalar_enum = VAL1;\n  \n\n  // Map the same array to multiple devices. initialize with device number\n#pragma omp target defaultmap(tofrom: scalar)\n  {\n    scalar_char = 'b';\n    scalar_short = 20;\n    scalar_int = 33;\n    scalar_float = 6.5f;\n    scalar_double = 20.45;\n    scalar_enum = VAL4;\n  } // end of omp target \n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_char != 'b');\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_short != 20);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_int != 33);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_float != 6.5f);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_double != 20.45);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_enum != VAL4);\n  \n  return errors;\n}\n\nint test_defaultmap_off() {\n  OMPVV_INFOMSG(\"test_defaultmap_off\");\n  \n  int errors = 0;\n  \n    // we try with all the scalars\n    char scalar_char = 'a';\n    short scalar_short = 10;\n    int scalar_int = 11;\n    float scalar_float = 5.5f;\n    double scalar_double = 10.45;\n    enum { VAL1 = 1, VAL2, VAL3, VAL4} scalar_enum = VAL1;\n    \n    // Map the same array to multiple devices. initialize with device number\n  #pragma omp target \n    {\n      scalar_char = 'b';\n      scalar_short = 20;\n      scalar_int = 33;\n      scalar_float = 6.5f;\n      scalar_double = 20.45;\n      scalar_enum = VAL4;\n    } // end of omp target \n    \n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_char != 'a');\n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_short != 10);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_int != 11);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_float != 5.5f);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_double != 10.45);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_enum != VAL1);\n    \n    return errors;\n}\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_defaultmap_on());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_defaultmap_off());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n",
        "error_code": "//===----- test_target_defaultmap.c --------------------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// This test is made up of two functions that both check that the default mapping of \n// scalars to the device is tofrom. The first function test_default_map_on actively \n// specifies default mapping to be tofrom, while the function test_default_map_off\n// implicity specifies default mapping. Both functions initalize scalars on host, and\n// then change the value of the scalars on the device within the target region. The\n// scalar values are checked after target region to ensure they were correctly mapped \n// back to host. The five basic data types in C are used as scalars.\n//\n////===-------------------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\nint test_defaultmap_on() {\n  OMPVV_INFOMSG(\"test_defaultmap_on\");\n\n  int errors = 0;\n\n  // we try with all the scalars\n  char scalar_char = 'a';\n  short scalar_short = 10;\n  int scalar_int = 11;\n  float scalar_float = 5.5f;\n  double scalar_double = 10.45;\n  enum { VAL1 = 1, VAL2, VAL3, VAL4} scalar_enum = VAL1;\n  \n\n  // Map the same array to multiple devices. initialize with device number\n#pragma omp target defaultmap(tofrom: scalar)\n  {\n    scalar_char = 'b';\n    scalar_short = 20;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n    scalar_int = 33;\n    scalar_float = 6.5f;\n    scalar_double = 20.45;\n    scalar_enum = VAL4;\n  } // end of omp target \n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_char != 'b');\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_short != 20);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_int != 33);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_float != 6.5f);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_double != 20.45);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_enum != VAL4);\n  \n  return errors;\n}\n\nint test_defaultmap_off() {\n  OMPVV_INFOMSG(\"test_defaultmap_off\");\n  \n  int errors = 0;\n  \n    // we try with all the scalars\n    char scalar_char = 'a';\n    short scalar_short = 10;\n    int scalar_int = 11;\n    float scalar_float = 5.5f;\n    double scalar_double = 10.45;\n    enum { VAL1 = 1, VAL2, VAL3, VAL4} scalar_enum = VAL1;\n    \n    // Map the same array to multiple devices. initialize with device number\n  #pragma omp target \n    {\n      scalar_char = 'b';\n      scalar_short = 20;\n      scalar_int = 33;\n      scalar_float = 6.5f;\n      scalar_double = 20.45;\n      scalar_enum = VAL4;\n    } // end of omp target \n    \n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_char != 'a');\n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_short != 10);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_int != 11);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_float != 5.5f);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_double != 10.45);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_enum != VAL1);\n    \n    return errors;\n}\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_defaultmap_on());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_defaultmap_off());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/mmm_target.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp for\" at position 1295",
        "issue_id": 0,
        "original_code": "//===--- mmm_target.c--- test that implements MM on a target region --------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n//  DESCRIPTION:\n//    OpenMp Example - Matrix Multiply - C Version\n//    Demonstrates a matrix multiply using OpenMP. Threads share row iterations\n//\n//  Last modified by Jose M Monsalve Diaz, December 25, 2019\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/time.h>\n#include \"ompvv.h\"\n\n#define rowA 100\n#define colA 100\n#define colB 100\n\nint main (int argc, char *argv[])\n{\n  OMPVV_TEST_OFFLOADING;\n  int tid, nthreads, i, j, k;\n  int *a = (int*) malloc(sizeof(int) * rowA * colA);           // matrix A to be multiplied\n  int *b = (int*) malloc(sizeof(int) * colA * colB);           // matrix B to be multiplied\n  int *c = (int*) malloc(sizeof(int) * rowA * colB);           // result matrix C\n\n  // Initialize matrices\n  for (i = 0; i < rowA; i++)\n    for (j = 0; j < colA; j++)\n      a[i*rowA+j] = 10; // i+j;\n  for (i = 0; i < colA; i++)\n    for (j = 0; j < colB; j++)\n      b[i*colA+j] = 50; //i*j;\n  for (i = 0; i < rowA; i++)\n    for (j = 0; j < colB; j++)\n      c[i*rowA+j] = 0;\n\n  int DimA = rowA*colA;\n  int DimB = colB*colA;\n  int DimC = rowA*colA;\n\n#pragma omp target map(to: a[0:DimA],b[0:DimB]) map(from: c[0:DimC])\n  {\n    for (i = 0; i < rowA; i++)\n      for(j = 0; j < colB; j++)\n        for(k = 0; k < colA; k++)\n          c[i*rowA+j] = a[i*rowA+j] * b[k*colA+j];\n  }//end-target\n\n  // Check results\n  int error = 0;\n  for (i = 0; i < rowA; i++)\n  {\n    for (j = 0; j < colB; j++) {\n      OMPVV_TEST_AND_SET(error, 500 != c[i*rowA+j]);\n      OMPVV_ERROR_IF(500 != c[i*rowA+j], \"Error: [%d][%d] should be 500 is %d\",i,j,c[i*rowA+j]);\n    }\n  }\n  free(a);\n  free(b);\n  free(c);\n\n  OMPVV_REPORT_AND_RETURN(error);\n}\n",
        "error_code": "//===--- mmm_target.c--- test that implements MM on a target region --------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n//  DESCRIPTION:\n//    OpenMp Example - Matrix Multiply - C Version\n//    Demonstrates a matrix multiply using OpenMP. Threads share row iterations\n//\n//  Last modified by Jose M Monsalve Diaz, December 25, 2019\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/time.h>\n#include \"ompvv.h\"\n\n#define rowA 100\n#define colA 100\n#define colB 100\n\nint main (int argc, char *argv[])\n{\n  OMPVV_TEST_OFFLOADING;\n  int tid, nthreads, i, j, k;\n  int *a = (int*) malloc(sizeof(int) * rowA * colA);           // matrix A to be multiplied\n  int *b = (int*) malloc(sizeof(int) * colA * colB);           // matrix B to be multiplied\n  int *c = (int*) malloc(sizeof(int) * rowA * colB);           // result matrix C\n\n  // Initialize matrices\n  for (i = 0; i < rowA; i++)\n    for (j = 0; j < colA; j++)\n      a[i*rowA+j] = 10; // i+j;\n  for (i = 0; i < colA; i++)\n    for (j = 0; j < colB; j++)\n      b[i*colA+j] = 50; //i*j;\n  for (i = 0; i < rowA; i++)\n    for (j = 0; j < colB; j++)\n      c[i*rowA+j] = 0;\n\n  int DimA = rowA*colA;\n  int DimB = colB*colA;\n  int DimC = rowA*colA;\n\n#pragma omp for map(to: a[0:DimA],b[0:DimB]) map(from: c[0:DimC])\n  {\n    for (i = 0; i < rowA; i++)\n      for(j = 0; j < colB; j++)\n        for(k = 0; k < colA; k++)\n          c[i*rowA+j] = a[i*rowA+j] * b[k*colA+j];\n  }//end-target\n\n  // Check results\n  int error = 0;\n  for (i = 0; i < rowA; i++)\n  {\n    for (j = 0; j < colB; j++) {\n      OMPVV_TEST_AND_SET(error, 500 != c[i*rowA+j]);\n      OMPVV_ERROR_IF(500 != c[i*rowA+j], \"Error: [%d][%d] should be 500 is %d\",i,j,c[i*rowA+j]);\n    }\n  }\n  free(a);\n  free(b);\n  free(c);\n\n  OMPVV_REPORT_AND_RETURN(error);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/gemv_target_teams_dist_par_for.cpp",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n    OMPVV_TEST_AND_SET(errors, std::abs(Vout[i]-N) > 0.0001);\n    OMPVV_ERROR_IF(std::abs(Vout[i]-N) > 0.0001, \"Error for Vout[%d] = %f, Should be %d\", i, Vout[i], N);\n  }\" at position 1679",
        "issue_id": 4,
        "original_code": "//===-- gemv_target_teams_dist_par_for.cpp - GEMV using combined construct--===!\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// Taken from the suggestions of the QMCPack team. This test uses the combined\n// construct target teams distribute parallel for\n//!===----------------------------------------------------------------------===!\n#include <chrono>\n#include <string>\n#include <cmath>\n#include \"ompvv.h\"\n#include \"omp.h\"\n\n#define N 8192\n\nclass Timer\n{\n  const std::chrono::time_point<std::chrono::system_clock> start;\n  const std::string name;\n\npublic:\n  Timer(const std::string& name_in): start(std::chrono::system_clock::now()), name(name_in) {};\n  ~Timer()\n  {\n    auto end = std::chrono::system_clock::now();\n    OMPVV_INFOMSG(\"Function %s takes %lf us \",name.c_str(), std::chrono::duration_cast<std::chrono::duration<double, std::micro>>(end - start).count());\n  }\n};\n\ntemplate <typename T>\nvoid gemv(int n, T alpha, const T*  A, const T*  V, T*  Vout)\n{\n  #pragma omp target teams distribute parallel for map(to:A[:n*n], V[:n]) map(from:Vout[:n])\n  for(int row=0; row<n; row++)\n  {\n    T sum = T(0);\n    const T * A_row = A+row*n;\n    for(int col=0; col<n; col++) {\n      sum += A_row[col]*V[col];\n    }\n    Vout[row] = sum*alpha;\n  }\n}\n\ntemplate <class T>\nT* allocate(size_t n)\n{\n  T* ptr = new T[n];\n  std::fill_n(ptr, n, T(1));\n  return ptr;\n}\n\ntemplate <class T>\nvoid deallocate(T* ptr, size_t n)\n{\n  delete[] ptr;\n}\n\nint main()\n{\n  OMPVV_TEST_OFFLOADING;\n  auto* A = allocate<float>(N*N);\n  auto* V = allocate<float>(N);\n  auto* Vout = allocate<float>(N);\n  int errors = 0;\n\n  {\n    Timer local(\"GEMV\");\n    gemv(N, 1.0f, A, V, Vout);\n  }\n\n  for(int i=0; i<N; i++)\n  {\n    OMPVV_TEST_AND_SET(errors, std::abs(Vout[i]-N) > 0.0001);\n    OMPVV_ERROR_IF(std::abs(Vout[i]-N) > 0.0001, \"Error for Vout[%d] = %f, Should be %d\", i, Vout[i], N);\n  }\n\n  deallocate(A, N*N);\n  deallocate(V, N);\n  deallocate(Vout, N);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===-- gemv_target_teams_dist_par_for.cpp - GEMV using combined construct--===!\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// Taken from the suggestions of the QMCPack team. This test uses the combined\n// construct target teams distribute parallel for\n//!===----------------------------------------------------------------------===!\n#include <chrono>\n#include <string>\n#include <cmath>\n#include \"ompvv.h\"\n#include \"omp.h\"\n\n#define N 8192\n\nclass Timer\n{\n  const std::chrono::time_point<std::chrono::system_clock> start;\n  const std::string name;\n\npublic:\n  Timer(const std::string& name_in): start(std::chrono::system_clock::now()), name(name_in) {};\n  ~Timer()\n  {\n    auto end = std::chrono::system_clock::now();\n    OMPVV_INFOMSG(\"Function %s takes %lf us \",name.c_str(), std::chrono::duration_cast<std::chrono::duration<double, std::micro>>(end - start).count());\n  }\n};\n\ntemplate <typename T>\nvoid gemv(int n, T alpha, const T*  A, const T*  V, T*  Vout)\n{\n  #pragma omp target teams distribute parallel for map(to:A[:n*n], V[:n]) map(from:Vout[:n])\n  for(int row=0; row<n; row++)\n  {\n    T sum = T(0);\n    const T * A_row = A+row*n;\n    for(int col=0; col<n; col++) {\n      sum += A_row[col]*V[col];\n    }\n    Vout[row] = sum*alpha;\n  }\n}\n\ntemplate <class T>\nT* allocate(size_t n)\n{\n  T* ptr = new T[n];\n  std::fill_n(ptr, n, T(1));\n  return ptr;\n}\n\ntemplate <class T>\nvoid deallocate(T* ptr, size_t n)\n{\n  delete[] ptr;\n}\n\nint main()\n{\n  OMPVV_TEST_OFFLOADING;\n  auto* A = allocate<float>(N*N);\n  auto* V = allocate<float>(N);\n  auto* Vout = allocate<float>(N);\n  int errors = 0;\n\n  {\n    Timer local(\"GEMV\");\n    gemv(N, 1.0f, A, V, Vout);\n  }\n\n  for(int i=0; i<N; i++)\n  \n\n  deallocate(A, N*N);\n  deallocate(V, N);\n  deallocate(Vout, N);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_parallel_for.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===---- test_target_teams_distribute_parallel_for.c - combined consutrct -===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// testing the combined construct target teams distribute parallel for\n//\n//===----------------------------------------------------------------------------------===//\n//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define ARRAY_SIZE 1024\n\nint test_target_teams_distribute_parallel_for() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for\");\n\n  // Variable for errors counting\n  int errors = 0;\n\n  int a[ARRAY_SIZE];\n  int b[ARRAY_SIZE];\n  int c[ARRAY_SIZE];\n  int num_teams = 0;\n  int num_threads[ARRAY_SIZE];\n  int alert_num_threads = 0;\n  int i;\n\n  // a and b array initialization\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n    a[i] = 1;\n    b[i] = i;\n    c[i] = 2 * i;\n    num_threads[i] = 0;\n  }\n\n\n#pragma omp target teams distribute parallel for map(from:num_teams, num_threads) num_teams(OMPVV_NUM_TEAMS_DEVICE) num_threads(OMPVV_NUM_THREADS_DEVICE)\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n#pragma omp atomic write\n    num_teams = omp_get_num_teams();\n    num_threads[i] = omp_get_num_threads();\n    a[i] += b[i] * c[i];\n  }\n\n\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n    OMPVV_TEST_AND_SET(errors, (a[i] != 1 + (b[i] * c[i])));\n    if (num_threads[i] == 1) {\n      alert_num_threads++;\n    }\n  }\n\n  // Rise lack of parallelism alerts\n  if (num_teams == 1) {\n    OMPVV_WARNING(\"Test operated with one team.  Parallelism of teams distribute can't be guaranteed.\");\n  }\n  if (alert_num_threads == ARRAY_SIZE) {\n    OMPVV_WARNING(\"Test operated with one thread in all the teams. Parallel clause had no effect\");\n  }\n\n  return errors;\n}\n\n// Test for OpenMP 4.5 target data with if\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nshort thpitorlqq = 188;\ndouble wdahmcnvnb = 128;\nshort fcdfeqdbop = 170;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files2/test_target_teams_distribute_parallel_for_firstprivate.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp declare\" at position 1178",
        "issue_id": 0,
        "original_code": "//===---- test_target_teams_distribute_parallel_for_firstprivate.c - combined consutrct -===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// This test check for a private variable within a pragma omp target teams distribute \n// parallel for that is initialized from the host through firstprivate clause\n// We use a private variable within a for loop and asign it every iteration\n// hoping that we won't get into data races. We do this multiple times to improve\n// test\n//\n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define SIZE_N 1024\n\nint test_target_teams_distribute_parallel_for_firstprivate() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_firstprivate\");\n  \n  int a[SIZE_N];\n  int b[SIZE_N];\n  int c[SIZE_N];\n  int d[SIZE_N];\n  int firstized = 10;\n  int privatized;\n  int reported_num_teams[SIZE_N];\n  int reported_team_num[SIZE_N];\n  int reported_num_threads[SIZE_N];\n  int errors = 0;\n  int i, j, dev;\n\n  // array initialization\n  for (i = 0; i < SIZE_N; i++) {\n    a[i] = 1;\n    b[i] = i;\n    c[i] = 2*i;\n    d[i] = 0;\n  }\n\n  // check multiple sizes. \n#pragma omp target data map(to: a[0:SIZE_N], b[0:SIZE_N], c[0:SIZE_N])\n  {\n#pragma omp target teams distribute parallel for firstprivate(privatized, firstized, i) num_teams(OMPVV_NUM_TEAMS_DEVICE) num_threads(OMPVV_NUM_THREADS_DEVICE)\n      for (j = 0; j < SIZE_N; ++j) {\n        reported_num_teams[j] = omp_get_num_teams();\n        reported_num_threads[j] = omp_get_num_threads();\n        reported_team_num[j] = omp_get_team_num();\n        privatized = 0;\n        for (i = 0; i < a[j] + b[j]; ++i) {\n          privatized++;\n        }\n        privatized += firstized;\n        d[j] = c[j] * privatized;\n      }\n  }\n\n  // Checking for reported teams and number of threads\n  OMPVV_WARNING_IF(reported_num_teams[0] == 1, \"Number of teams reported was 1, test cannot assert privatization across teams\");\n  // To have a single warning for threds. diff teams could have different number of threads, we warn if all are 1\n  int warning_threads = 0;\n  for (i = 0; i < SIZE_N; i++) {\n    if (reported_num_threads[i] == 1)\n      warning_threads++;\n    if (i > 0) {\n      OMPVV_ERROR_IF(reported_num_teams[i] != reported_num_teams[i-1], \"Discrepancy in the reported number of teams across teams\");\n      if (reported_team_num[i] == reported_team_num[i-1] && reported_num_threads[i] != reported_num_threads[i-1])\n        OMPVV_ERROR(\"Discrepancy in the reported number of threads inside a single team\");\n    }\n  }\n  OMPVV_WARNING_IF(warning_threads == SIZE_N, \"Number of threads was 1 for all teams. test cannot assert privatization across teams\");\n  // Checking for the expected values \n  for (i = 0; i < SIZE_N; i++) {\n    // 10 = initial value of privatized + 1 initial value of a[i] \n    // + i initial value of b[i]\n    OMPVV_TEST_AND_SET(errors, d[i] != (10 + 1 + i)*2*i);\n  }\n\n  return errors;\n}\n\n// Test for OpenMP 4.5 target enter data with if\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_firstprivate());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_teams_distribute_parallel_for_firstprivate.c - combined consutrct -===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// This test check for a private variable within a pragma omp target teams distribute \n// parallel for that is initialized from the host through firstprivate clause\n// We use a private variable within a for loop and asign it every iteration\n// hoping that we won't get into data races. We do this multiple times to improve\n// test\n//\n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define SIZE_N 1024\n\nint test_target_teams_distribute_parallel_for_firstprivate() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_firstprivate\");\n  \n  int a[SIZE_N];\n  int b[SIZE_N];\n  int c[SIZE_N];\n  int d[SIZE_N];\n  int firstized = 10;\n  int privatized;\n  int reported_num_teams[SIZE_N];\n  int reported_team_num[SIZE_N];\n  int reported_num_threads[SIZE_N];\n  int errors = 0;\n  int i, j, dev;\n\n  // array initialization\n  for (i = 0; i < SIZE_N; i++) {\n    a[i] = 1;\n    b[i] = i;\n    c[i] = 2*i;\n    d[i] = 0;\n  }\n\n  // check multiple sizes. \n#pragma omp declare data map(to: a[0:SIZE_N], b[0:SIZE_N], c[0:SIZE_N])\n  {\n#pragma omp target teams distribute parallel for firstprivate(privatized, firstized, i) num_teams(OMPVV_NUM_TEAMS_DEVICE) num_threads(OMPVV_NUM_THREADS_DEVICE)\n      for (j = 0; j < SIZE_N; ++j) {\n        reported_num_teams[j] = omp_get_num_teams();\n        reported_num_threads[j] = omp_get_num_threads();\n        reported_team_num[j] = omp_get_team_num();\n        privatized = 0;\n        for (i = 0; i < a[j] + b[j]; ++i) {\n          privatized++;\n        }\n        privatized += firstized;\n        d[j] = c[j] * privatized;\n      }\n  }\n\n  // Checking for reported teams and number of threads\n  OMPVV_WARNING_IF(reported_num_teams[0] == 1, \"Number of teams reported was 1, test cannot assert privatization across teams\");\n  // To have a single warning for threds. diff teams could have different number of threads, we warn if all are 1\n  int warning_threads = 0;\n  for (i = 0; i < SIZE_N; i++) {\n    if (reported_num_threads[i] == 1)\n      warning_threads++;\n    if (i > 0) {\n      OMPVV_ERROR_IF(reported_num_teams[i] != reported_num_teams[i-1], \"Discrepancy in the reported number of teams across teams\");\n      if (reported_team_num[i] == reported_team_num[i-1] && reported_num_threads[i] != reported_num_threads[i-1])\n        OMPVV_ERROR(\"Discrepancy in the reported number of threads inside a single team\");\n    }\n  }\n  OMPVV_WARNING_IF(warning_threads == SIZE_N, \"Number of threads was 1 for all teams. test cannot assert privatization across teams\");\n  // Checking for the expected values \n  for (i = 0; i < SIZE_N; i++) {\n    // 10 = initial value of privatized + 1 initial value of a[i] \n    // + i initial value of b[i]\n    OMPVV_TEST_AND_SET(errors, d[i] != (10 + 1 + i)*2*i);\n  }\n\n  return errors;\n}\n\n// Test for OpenMP 4.5 target enter data with if\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_firstprivate());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    }
]