[
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_data_map_pointer_translation.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp declare\" at position 960",
        "issue_id": 0,
        "original_code": "//===---- test_target_data_map_array_translation.c - pointer to already mapped array-===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// According to the OpenMP Specs, if a pointer is used in the mapping of a variable\n// and the pointer points to a host array that is already available in the device,\n// this pointer's address has to be updated with the device address. \n//\n// See page 105, lines 24 through 32.\n//\n// This test check these conditions are valid\n//\n//===----------------------------------------------------------------------===//\n\n#include \"ompvv.h\"\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 1000\n\nint test_map_same_function() {\n\n  OMPVV_INFOMSG(\"Testing map same function definition\")\n\n  int sum = 0, sum2 = 0, errors = 0;\n\n  // host arrays: heap and stack\n  int *h_array_h = (int *)malloc(N * sizeof(int));\n  int h_array_s[N];\n\n  // Pointers to be used for the translation\n  int *ptr_h_array_h;\n  int *ptr_h_array_s;\n\n#pragma omp target data map(h_array_h[0:N]) map(h_array_s[0:N])\n  {\n    // Multiple tests at once.\n\n    ptr_h_array_h = h_array_h;\n    ptr_h_array_s = h_array_s;\n\n    OMPVV_INFOMSG(\"map(ptr) specified full-length array section\")\n#pragma omp target map(ptr_h_array_h[0:N], ptr_h_array_s[0:N])\n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] = 1;\n        ptr_h_array_s[i] = 2;\n      }\n    } // end target\n\n    OMPVV_INFOMSG(\"map(ptr) specified zero-length array section\")\n#pragma omp target map(ptr_h_array_h[:0], ptr_h_array_s[:0])\n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] += 1;\n        ptr_h_array_s[i] += 2;\n      }\n    } // end target\n\n    OMPVV_INFOMSG(\"no map(ptr) Specified\")\n#pragma omp target \n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] += 1;\n        ptr_h_array_s[i] += 2;\n      }\n    } // end target\n\n  } // end target data\n\n  // checking results\n  for (int i = 0; i < N; ++i) {\n    sum += h_array_h[i];\n    sum2 += h_array_s[i];\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (3*N != sum) || (6*N != sum2));\n\n  free(h_array_h);\n  return errors;\n}\n\nvoid helper_function(int *ptr_h_array_h, int *ptr_h_array_s) {\n\n    OMPVV_INFOMSG(\"map(ptr) specified full-length array section\")\n#pragma omp target map(ptr_h_array_h[0:N], ptr_h_array_s[0:N])\n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] = 1;\n        ptr_h_array_s[i] = 2;\n      }\n    } // end target\n\n    OMPVV_INFOMSG(\"map(ptr) specified zero-length array section\")\n#pragma omp target map(ptr_h_array_h[:0], ptr_h_array_s[:0])\n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] += 1;\n        ptr_h_array_s[i] += 2;\n      }\n    } // end target\n\n    OMPVV_INFOMSG(\"no map(ptr) Specified\")\n#pragma omp target \n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] += 1;\n        ptr_h_array_s[i] += 2;\n      }\n    } // end target\n}\n\nint test_map_different_function() {\n\n  OMPVV_INFOMSG(\"Testing map different function definition\")\n\n  int sum = 0, sum2 = 0, errors = 0;\n\n  // host arrays: heap and stack\n  int *h_array_h = (int *)malloc(N * sizeof(int));\n  int h_array_s[N];\n\n#pragma omp target data map(h_array_h[0:N]) map(h_array_s[0:N])\n  {\n    // Multiple tests at once.\n    helper_function(h_array_h, h_array_s);\n\n  } // end target data\n\n  // checking results\n  for (int i = 0; i < N; ++i) {\n    sum += h_array_h[i];\n    sum2 += h_array_s[i];\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (3*N != sum) || (6*N != sum2));\n\n  free(h_array_h);\n  return errors;\n}\nint main() {\n  OMPVV_TEST_OFFLOADING\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_same_function());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_different_function());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_data_map_array_translation.c - pointer to already mapped array-===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// According to the OpenMP Specs, if a pointer is used in the mapping of a variable\n// and the pointer points to a host array that is already available in the device,\n// this pointer's address has to be updated with the device address. \n//\n// See page 105, lines 24 through 32.\n//\n// This test check these conditions are valid\n//\n//===----------------------------------------------------------------------===//\n\n#include \"ompvv.h\"\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 1000\n\nint test_map_same_function() {\n\n  OMPVV_INFOMSG(\"Testing map same function definition\")\n\n  int sum = 0, sum2 = 0, errors = 0;\n\n  // host arrays: heap and stack\n  int *h_array_h = (int *)malloc(N * sizeof(int));\n  int h_array_s[N];\n\n  // Pointers to be used for the translation\n  int *ptr_h_array_h;\n  int *ptr_h_array_s;\n\n#pragma omp declare data map(h_array_h[0:N]) map(h_array_s[0:N])\n  {\n    // Multiple tests at once.\n\n    ptr_h_array_h = h_array_h;\n    ptr_h_array_s = h_array_s;\n\n    OMPVV_INFOMSG(\"map(ptr) specified full-length array section\")\n#pragma omp target map(ptr_h_array_h[0:N], ptr_h_array_s[0:N])\n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] = 1;\n        ptr_h_array_s[i] = 2;\n      }\n    } // end target\n\n    OMPVV_INFOMSG(\"map(ptr) specified zero-length array section\")\n#pragma omp target map(ptr_h_array_h[:0], ptr_h_array_s[:0])\n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] += 1;\n        ptr_h_array_s[i] += 2;\n      }\n    } // end target\n\n    OMPVV_INFOMSG(\"no map(ptr) Specified\")\n#pragma omp target \n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] += 1;\n        ptr_h_array_s[i] += 2;\n      }\n    } // end target\n\n  } // end target data\n\n  // checking results\n  for (int i = 0; i < N; ++i) {\n    sum += h_array_h[i];\n    sum2 += h_array_s[i];\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (3*N != sum) || (6*N != sum2));\n\n  free(h_array_h);\n  return errors;\n}\n\nvoid helper_function(int *ptr_h_array_h, int *ptr_h_array_s) {\n\n    OMPVV_INFOMSG(\"map(ptr) specified full-length array section\")\n#pragma omp target map(ptr_h_array_h[0:N], ptr_h_array_s[0:N])\n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] = 1;\n        ptr_h_array_s[i] = 2;\n      }\n    } // end target\n\n    OMPVV_INFOMSG(\"map(ptr) specified zero-length array section\")\n#pragma omp target map(ptr_h_array_h[:0], ptr_h_array_s[:0])\n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] += 1;\n        ptr_h_array_s[i] += 2;\n      }\n    } // end target\n\n    OMPVV_INFOMSG(\"no map(ptr) Specified\")\n#pragma omp target \n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] += 1;\n        ptr_h_array_s[i] += 2;\n      }\n    } // end target\n}\n\nint test_map_different_function() {\n\n  OMPVV_INFOMSG(\"Testing map different function definition\")\n\n  int sum = 0, sum2 = 0, errors = 0;\n\n  // host arrays: heap and stack\n  int *h_array_h = (int *)malloc(N * sizeof(int));\n  int h_array_s[N];\n\n#pragma omp target data map(h_array_h[0:N]) map(h_array_s[0:N])\n  {\n    // Multiple tests at once.\n    helper_function(h_array_h, h_array_s);\n\n  } // end target data\n\n  // checking results\n  for (int i = 0; i < N; ++i) {\n    sum += h_array_h[i];\n    sum2 += h_array_s[i];\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (3*N != sum) || (6*N != sum2));\n\n  free(h_array_h);\n  return errors;\n}\nint main() {\n  OMPVV_TEST_OFFLOADING\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_same_function());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_different_function());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_update_to_present.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 2816",
        "issue_id": 1,
        "original_code": "//===--- test_target_update_to_present.c ----------------------------------------------------===//\n//\n//  OpenMP API Version 5.1 Aug 2021\n//\n//  This test checks behavior of the target update clause when the specified motion-modifier  \n//  is present. Tests 1. A corresponding list item and an original list item exist for each \n//  list item in a to or from clause. If the corresponding list item is not present in the\n//  device data environment and the present modifier is not specified in the clause then no\n//  assignment occurs to or from the original list item. Also tests 2. Otherwise, each\n//  corresponding list item in the device data environment has an original list item in the\n//  current task's data environment. \n//\n////===--------------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\n\nint test_target_update_to_present() {\n   \n   int errors = 0;\n\n   struct test_struct {\n     int s; \n     int S[N]; \n   }; \n\n   int scalar_var; // scalar \n   int A[N]; // aggregate \n   struct test_struct new_struct; // aggregate\n   int *ptr; // scalar, pointer \n   int isOffloadingOn = 0;\n\n   OMPVV_TEST_AND_SET_OFFLOADING(isOffloadingOn);\n\n   scalar_var = 1; \n   A[0] = 0; A[50] = 50;\n   new_struct.s = 10; new_struct.S[0] = 10; new_struct.S[1] = 10;\n   ptr = &A[0]; \n   ptr[50] = 50; ptr[51] = 51;\n  \n   // Tests OpenMP 5.1 Specification pp. 207 lines 2-4\n   #pragma omp target update to(scalar_var, A, new_struct) \n   if (isOffloadingOn) {\n      // Skip this test if target offloading is not enabled (running on the host).\n      if (omp_target_is_present(&scalar_var, omp_get_default_device()))\n        errors++;\n      if (omp_target_is_present(&A, omp_get_default_device()))\n        errors++;\n      if (omp_target_is_present(&new_struct, omp_get_default_device()))\n        errors++;\n   }\n\n   // Tests OpenMP 5.1 Specification pp. 207 lines 5-6\n   #pragma omp target enter data map(alloc: scalar_var, A, new_struct)\n   #pragma omp target update to(present: scalar_var, A, new_struct) \n   if (!omp_target_is_present(&scalar_var, omp_get_default_device()))\n     errors++;\n   if (!omp_target_is_present(&A, omp_get_default_device()))\n     errors++;\n   if (!omp_target_is_present(&new_struct, omp_get_default_device()))\n     errors++;\n   #pragma omp target map(tofrom: errors) defaultmap(none) map(to: scalar_var, A, new_struct)\n   {     \n        if(scalar_var != 1){errors++;}\n        if(A[0] != 0 || A[50] != 50){errors++;}\n        if(A[50] != 50 || A[51] != 51){errors++;}\n        if(new_struct.s != 10){errors++;}\n        if(new_struct.S[0] != 10){errors++;}\n   }\n   #pragma omp target exit data map(release: scalar_var, A, new_struct)\n   \n   return errors;\n}\n\nint main() {\n   int errors = 0;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_update_to_present() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}           \n",
        "error_code": "//===--- test_target_update_to_present.c ----------------------------------------------------===//\n//\n//  OpenMP API Version 5.1 Aug 2021\n//\n//  This test checks behavior of the target update clause when the specified motion-modifier  \n//  is present. Tests 1. A corresponding list item and an original list item exist for each \n//  list item in a to or from clause. If the corresponding list item is not present in the\n//  device data environment and the present modifier is not specified in the clause then no\n//  assignment occurs to or from the original list item. Also tests 2. Otherwise, each\n//  corresponding list item in the device data environment has an original list item in the\n//  current task's data environment. \n//\n////===--------------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\n\nint test_target_update_to_present() {\n   \n   int errors = 0;\n\n   struct test_struct {\n     int s; \n     int S[N]; \n   }; \n\n   int scalar_var; // scalar \n   int A[N]; // aggregate \n   struct test_struct new_struct; // aggregate\n   int *ptr; // scalar, pointer \n   int isOffloadingOn = 0;\n\n   OMPVV_TEST_AND_SET_OFFLOADING(isOffloadingOn);\n\n   scalar_var = 1; \n   A[0] = 0; A[50] = 50;\n   new_struct.s = 10; new_struct.S[0] = 10; new_struct.S[1] = 10;\n   ptr = &A[0]; \n   ptr[50] = 50; ptr[51] = 51;\n  \n   // Tests OpenMP 5.1 Specification pp. 207 lines 2-4\n   #pragma omp target update to(scalar_var, A, new_struct) \n   if (isOffloadingOn) {\n      // Skip this test if target offloading is not enabled (running on the host).\n      if (omp_target_is_present(&scalar_var, omp_get_default_device()))\n        errors++;\n      if (omp_target_is_present(&A, omp_get_default_device()))\n        errors++;\n      if (omp_target_is_present(&new_struct, omp_get_default_device()))\n        errors++;\n   }\n\n   // Tests OpenMP 5.1 Specification pp. 207 lines 5-6\n   #pragma omp target enter data map(alloc: scalar_var, A, new_struct)\n   #pragma omp target update to(present: scalar_var, A, new_struct) \n   if (!omp_target_is_present(&scalar_var, omp_get_default_device()))\n     errors++;\n   if (!omp_target_is_present(&A, omp_get_default_device()))\n     errors++;\n   if (!omp_target_is_present(&new_struct, omp_get_default_device()))\n     errors++;\n   #pragma omp target map(tofrom: errors) defaultmap(none) map(to: scalar_var, A, new_struct)\n   {     \n        if(scalar_var != 1){errors++;}\n        if(A[0] != 0 || A[50] != 50){errors++;}\n        if(A[50] != 50 || A[51] != 51){errors++;}\n        if(new_struct.s != 10){errors++;}\n        if(new_struct.S[0] != 10){errors++;}\n   }\n   #pragma omp target exit data map(release: scalar_var, A, new_struct)\n   \n   return errors;\n}\n\nint main() \n   int errors = 0;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_update_to_present() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}           \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_data_use_device_ptr.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp cancel\" at position 933",
        "issue_id": 0,
        "original_code": "//===-- test_target_data_use_device_ptr.c - test of use_device_ptr on target data ----===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// This file is a test for the use_device_ptr when used with the map\n// clause. This test uses arrays of size N which values are modified on the \n// device and tested in the host. Once the array has been mapped to the device,\n// the use_device_ptr should be able to be used with the ptr to the array and \n// subsequent modify values on the device. \n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nint main() {\n  int errors = 0, map_dummy;\n  int *array_device = NULL;\n  int *array_host = NULL;\n\n  array_device = (int *)malloc(N*sizeof(int));\n  array_host = (int *)malloc(N*sizeof(int));\n\n  for (int i = 0; i < N; ++i)\n    array_host[i] = i;\n  \n  OMPVV_TEST_OFFLOADING;\n\n#pragma omp target data map(tofrom: array_device[0:N])\n  {\n#pragma omp target data map(map_dummy) use_device_ptr(array_device)\n    {\n#pragma omp target is_device_ptr(array_device) map(tofrom: array_host[0:N])\n      {\n        for (int i = 0; i < N; ++i) {\n          array_device[i] = i;\n          array_host[i] += array_device[i];\n        } \n      } // end target\n    } // end target data\n  } // end target data\n\n  // checking results\n  for (int i = 0; i < N; ++i) {\n    OMPVV_TEST_AND_SET(errors, array_host[i] != 2*i);\n  }\n\n  free(array_device);\n  free(array_host);\n  \n  OMPVV_REPORT_AND_RETURN(errors);\n\n}\n",
        "error_code": "//===-- test_target_data_use_device_ptr.c - test of use_device_ptr on target data ----===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// This file is a test for the use_device_ptr when used with the map\n// clause. This test uses arrays of size N which values are modified on the \n// device and tested in the host. Once the array has been mapped to the device,\n// the use_device_ptr should be able to be used with the ptr to the array and \n// subsequent modify values on the device. \n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nint main() {\n  int errors = 0, map_dummy;\n  int *array_device = NULL;\n  int *array_host = NULL;\n\n  array_device = (int *)malloc(N*sizeof(int));\n  array_host = (int *)malloc(N*sizeof(int));\n\n  for (int i = 0; i < N; ++i)\n    array_host[i] = i;\n  \n  OMPVV_TEST_OFFLOADING;\n\n#pragma omp cancel data map(tofrom: array_device[0:N])\n  {\n#pragma omp target data map(map_dummy) use_device_ptr(array_device)\n    {\n#pragma omp target is_device_ptr(array_device) map(tofrom: array_host[0:N])\n      {\n        for (int i = 0; i < N; ++i) {\n          array_device[i] = i;\n          array_host[i] += array_device[i];\n        } \n      } // end target\n    } // end target data\n  } // end target data\n\n  // checking results\n  for (int i = 0; i < N; ++i) {\n    OMPVV_TEST_AND_SET(errors, array_host[i] != 2*i);\n  }\n\n  free(array_device);\n  free(array_host);\n  \n  OMPVV_REPORT_AND_RETURN(errors);\n\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_assume_no_openmp.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===--- test_assume_no_openmp.c --------------------------------------------===//\n//\n//  OpenMP API Version 5.1 Aug 2021\n//\n//  Using assume no_openmp, the compiler can be optimized as it knows that a\n//  structured block does not contain any openmp directives.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint errors, i;\n\nint test_assume_no_openmp() {\n    int arr[N];\n    #pragma omp assume no_openmp\n    {\n        for(i = 0; i < N; i++){\n            arr[i] = i;\n        }\n    }\n    #pragma omp target parallel for map(tofrom: arr)\n    for(i = 0; i < N; i++){\n        arr[i] = arr[i]*2;\n    }\n    // Test that no issues were caused from using assume directive\n    for(i = 0; i < N; i++){\n        OMPVV_TEST_AND_SET(errors, arr[i] != i*2);\n    }\n    return errors;\n}\n\nint main() {\n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_assume_no_openmp() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nshort qenylxxgpk = 163;\ndouble adlamagqzv = 43;\nint xouckbitqr = 180;\nlong iduzvahvpd = 74;\nfloat ysdfugpczt = 225;\nfloat mkzohrkioq = 4;\nbyte itglrxahir = 151;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_atomic_num_hint_device.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1978",
        "issue_id": 1,
        "original_code": "//===--- test_atomic_num_hint_device.c ------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n//  This test checks if atomic hints passed by enum value\n//  are processed correctly for device execution. If the sync hint is not\n//  yet defined in the specification, it defaults to \n//  omp_sync_hint_none (0x0). \n////===--------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n\nint test_atomic_with_used_enum_value() {\n  OMPVV_INFOMSG(\"test_atomic_with_used_enum_value\");\n  int errors = 0, x = 0, num_threads = -1;\n\n#pragma omp target map(tofrom: num_threads,x)  \n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_DEVICE) default(shared)\n  {\n    if (omp_get_thread_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n#pragma omp atomic hint(0X4) // corrosponds to omp_sync_hint_nonspeculative\n    x++;\n  }\n\n  OMPVV_ERROR_IF(num_threads < 0, \"Test ran with invalid number of threads (less than zero)\");\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so the results are not conclusive\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, x != num_threads);\n\n  return errors;\n}\n\nint test_atomic_with_unused_enum_value() {\n  OMPVV_INFOMSG(\"test_atomic_with_unused_enum_value\");\n  int errors = 0, x = 0, num_threads = -1;\n\n#pragma omp target map(tofrom: num_threads,x)  \n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_DEVICE) default(shared)\n  {\n    if (omp_get_thread_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n#pragma omp atomic hint(0X1024) //As of OMP Spec 5.0 only values till 0x8 have been taken\n    x++;\n  }\n\n  OMPVV_ERROR_IF(num_threads < 0, \"Test ran with invalid number of threads (less than zero)\");\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so the results are not conclusive\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, x != num_threads);\n\n  return errors;\n}\n\n\nint main() {\n  int errors = 0;\n\n  OMPVV_TEST_OFFLOADING;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_atomic_with_used_enum_value());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_atomic_with_unused_enum_value());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_atomic_num_hint_device.c ------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n//  This test checks if atomic hints passed by enum value\n//  are processed correctly for device execution. If the sync hint is not\n//  yet defined in the specification, it defaults to \n//  omp_sync_hint_none (0x0). \n////===--------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n\nint test_atomic_with_used_enum_value() {\n  OMPVV_INFOMSG(\"test_atomic_with_used_enum_value\");\n  int errors = 0, x = 0, num_threads = -1;\n\n#pragma omp target map(tofrom: num_threads,x)  \n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_DEVICE) default(shared)\n  {\n    if (omp_get_thread_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n#pragma omp atomic hint(0X4) // corrosponds to omp_sync_hint_nonspeculative\n    x++;\n  }\n\n  OMPVV_ERROR_IF(num_threads < 0, \"Test ran with invalid number of threads (less than zero)\");\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so the results are not conclusive\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, x != num_threads);\n\n  return errors;\n}\n\nint test_atomic_with_unused_enum_value() {\n  OMPVV_INFOMSG(\"test_atomic_with_unused_enum_value\");\n  int errors = 0, x = 0, num_threads = -1;\n\n#pragma omp target map(tofrom: num_threads,x)  \n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_DEVICE) default(shared)\n  {\n    if (omp_get_thread_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n#pragma omp atomic hint(0X1024) //As of OMP Spec 5.0 only values till 0x8 have been taken\n    x++;\n  }\n\n  OMPVV_ERROR_IF(num_threads < 0, \"Test ran with invalid number of threads (less than zero)\");\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so the results are not conclusive\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, x != num_threads);\n\n  return errors;\n}\n\n\nint main() \n  int errors = 0;\n\n  OMPVV_TEST_OFFLOADING;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_atomic_with_used_enum_value());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_atomic_with_unused_enum_value());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_parallel_for.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp master\" at position 863",
        "issue_id": 0,
        "original_code": "//===---- test_target_teams_distribute_parallel_for.c - combined consutrct -===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// testing the combined construct target teams distribute parallel for\n//\n//===----------------------------------------------------------------------------------===//\n//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define ARRAY_SIZE 1024\n\nint test_target_teams_distribute_parallel_for() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for\");\n\n  // Variable for errors counting\n  int errors = 0;\n\n  int a[ARRAY_SIZE];\n  int b[ARRAY_SIZE];\n  int c[ARRAY_SIZE];\n  int num_teams = 0;\n  int num_threads[ARRAY_SIZE];\n  int alert_num_threads = 0;\n  int i;\n\n  // a and b array initialization\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n    a[i] = 1;\n    b[i] = i;\n    c[i] = 2 * i;\n    num_threads[i] = 0;\n  }\n\n\n#pragma omp target teams distribute parallel for map(from:num_teams, num_threads) num_teams(OMPVV_NUM_TEAMS_DEVICE) num_threads(OMPVV_NUM_THREADS_DEVICE)\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n#pragma omp atomic write\n    num_teams = omp_get_num_teams();\n    num_threads[i] = omp_get_num_threads();\n    a[i] += b[i] * c[i];\n  }\n\n\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n    OMPVV_TEST_AND_SET(errors, (a[i] != 1 + (b[i] * c[i])));\n    if (num_threads[i] == 1) {\n      alert_num_threads++;\n    }\n  }\n\n  // Rise lack of parallelism alerts\n  if (num_teams == 1) {\n    OMPVV_WARNING(\"Test operated with one team.  Parallelism of teams distribute can't be guaranteed.\");\n  }\n  if (alert_num_threads == ARRAY_SIZE) {\n    OMPVV_WARNING(\"Test operated with one thread in all the teams. Parallel clause had no effect\");\n  }\n\n  return errors;\n}\n\n// Test for OpenMP 4.5 target data with if\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_teams_distribute_parallel_for.c - combined consutrct -===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// testing the combined construct target teams distribute parallel for\n//\n//===----------------------------------------------------------------------------------===//\n//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define ARRAY_SIZE 1024\n\nint test_target_teams_distribute_parallel_for() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for\");\n\n  // Variable for errors counting\n  int errors = 0;\n\n  int a[ARRAY_SIZE];\n  int b[ARRAY_SIZE];\n  int c[ARRAY_SIZE];\n  int num_teams = 0;\n  int num_threads[ARRAY_SIZE];\n  int alert_num_threads = 0;\n  int i;\n\n  // a and b array initialization\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n    a[i] = 1;\n    b[i] = i;\n    c[i] = 2 * i;\n    num_threads[i] = 0;\n  }\n\n\n#pragma omp master teams distribute parallel for map(from:num_teams, num_threads) num_teams(OMPVV_NUM_TEAMS_DEVICE) num_threads(OMPVV_NUM_THREADS_DEVICE)\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n#pragma omp atomic write\n    num_teams = omp_get_num_teams();\n    num_threads[i] = omp_get_num_threads();\n    a[i] += b[i] * c[i];\n  }\n\n\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n    OMPVV_TEST_AND_SET(errors, (a[i] != 1 + (b[i] * c[i])));\n    if (num_threads[i] == 1) {\n      alert_num_threads++;\n    }\n  }\n\n  // Rise lack of parallelism alerts\n  if (num_teams == 1) {\n    OMPVV_WARNING(\"Test operated with one team.  Parallelism of teams distribute can't be guaranteed.\");\n  }\n  if (alert_num_threads == ARRAY_SIZE) {\n    OMPVV_WARNING(\"Test operated with one thread in all the teams. Parallel clause had no effect\");\n  }\n\n  return errors;\n}\n\n// Test for OpenMP 4.5 target data with if\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_scope_private_construct.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n\tint errors = 0;\n\tOMPVV_TEST_OFFLOADING;\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_scope() != 0);\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\" at position 833",
        "issue_id": 4,
        "original_code": "//--------------- test_scope_private_construct.c -----------------------------//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// This test checks that the scope private construct clause is properly working.\n// The test itself passes a test integer into the scope pragma and ensures that\n// all changes made to it are not kept outside of the scope region.\n//----------------------------------------------------------------------------//\n\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\nint test_scope(){\n\tint errors = 0;\n\tint test_int = 1;\n\t#pragma omp parallel shared(test_int)\n\t{\n\t\t#pragma omp scope private(test_int)\n\t\t{\n\t\t\ttest_int += 1;\n\t\t}\n\t}\n\tOMPVV_TEST_AND_SET_VERBOSE(errors,test_int != 1);\n\tOMPVV_INFOMSG_IF(test_int == 2, \"test int was not private\");\n\treturn errors;\n}\n\nint main(){\n\tint errors = 0;\n\tOMPVV_TEST_OFFLOADING;\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_scope() != 0);\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//--------------- test_scope_private_construct.c -----------------------------//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// This test checks that the scope private construct clause is properly working.\n// The test itself passes a test integer into the scope pragma and ensures that\n// all changes made to it are not kept outside of the scope region.\n//----------------------------------------------------------------------------//\n\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\nint test_scope(){\n\tint errors = 0;\n\tint test_int = 1;\n\t#pragma omp parallel shared(test_int)\n\t{\n\t\t#pragma omp scope private(test_int)\n\t\t{\n\t\t\ttest_int += 1;\n\t\t}\n\t}\n\tOMPVV_TEST_AND_SET_VERBOSE(errors,test_int != 1);\n\tOMPVV_INFOMSG_IF(test_int == 2, \"test int was not private\");\n\treturn errors;\n}\n\nint main()\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_taskloop_simd_reduction.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1497",
        "issue_id": 1,
        "original_code": "//===--- test_taskloop_simd_reduction.c -------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the taskloop simd combined directive with the reduction clause specified.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_taskloop_reduction() {\n\n   int errors = 0;\n   int a[N];\n   int b[N]; \n   int sum = 0;\n   int num_threads = -1;\n   int real_sum = 0;\n\n   for (int i = 0; i < N; i++) {\n      a[i] = 5;\n      b[i] = i * 2; \n   }\n\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST) shared(a, b, num_threads, sum) \n{\n   #pragma omp single\n   #pragma omp taskloop simd reduction(+:sum)\n   for (int i = 0; i < N; i++) {\n      #pragma omp atomic\n      sum += a[i]*b[i]; \n   }\n   num_threads = omp_get_num_threads();\n\n   #pragma omp single\n   #pragma omp taskloop simd reduction(+:sum)\n   for (int i = 0; i < N; i++) {\n      #pragma omp atomic\n      sum++;\n   }\n\n}\n\n   real_sum += N;\n\n   for (int i = 0; i < N; i++) {\n      real_sum += a[i]*b[i];\n   }\n\n   OMPVV_TEST_AND_SET_VERBOSE(errors, sum != real_sum);\n\n   OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of taskloop can't be guaranteed.\");\n   OMPVV_ERROR_IF(num_threads < 1, \"Test returned an invalid number of threads.\");\n   OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n\n\n   return errors;            \n}\n\n\nint main() {\n\n   int errors = 0;\n\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_taskloop_reduction());\n\n   OMPVV_REPORT_AND_RETURN(errors);\n\n}\n",
        "error_code": "//===--- test_taskloop_simd_reduction.c -------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the taskloop simd combined directive with the reduction clause specified.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_taskloop_reduction() {\n\n   int errors = 0;\n   int a[N];\n   int b[N]; \n   int sum = 0;\n   int num_threads = -1;\n   int real_sum = 0;\n\n   for (int i = 0; i < N; i++) {\n      a[i] = 5;\n      b[i] = i * 2; \n   }\n\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST) shared(a, b, num_threads, sum) \n{\n   #pragma omp single\n   #pragma omp taskloop simd reduction(+:sum)\n   for (int i = 0; i < N; i++) {\n      #pragma omp atomic\n      sum += a[i]*b[i]; \n   }\n   num_threads = omp_get_num_threads();\n\n   #pragma omp single\n   #pragma omp taskloop simd reduction(+:sum)\n   for (int i = 0; i < N; i++) {\n      #pragma omp atomic\n      sum++;\n   }\n\n}\n\n   real_sum += N;\n\n   for (int i = 0; i < N; i++) {\n      real_sum += a[i]*b[i];\n   }\n\n   OMPVV_TEST_AND_SET_VERBOSE(errors, sum != real_sum);\n\n   OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of taskloop can't be guaranteed.\");\n   OMPVV_ERROR_IF(num_threads < 1, \"Test returned an invalid number of threads.\");\n   OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n\n\n   return errors;            \n}\n\n\nint main() \n\n   int errors = 0;\n\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_taskloop_reduction());\n\n   OMPVV_REPORT_AND_RETURN(errors);\n\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_dispatch.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1649",
        "issue_id": 1,
        "original_code": "//===---- test_dispatch_device.c -----------------------------------------===//\n// \n// OpenMP API Version 5.1\n//\n// Uses dispatch construct as context for variant directive. When the dispatch\n// construct is reached, the variant function, add_two, should be used.\n//\n// Inspired by \"OpenMP 5.1 Features: The Dispatch Construct\" video:\n// https://www.youtube.com/watch?v=ruugaX95gIs\n// \n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include \"ompvv.h\"\n#include <stdbool.h>\n\n#define N 1024\n\nint errors;\nint i = 0;\nint arr[N];\n\nvoid add_two(int *arr);\n\n#pragma omp declare variant(add_two) match(construct={dispatch}) \nvoid add(int *arr){\n    #pragma omp parallel for\n    for (int i = 0; i < N; i++){ // Base function adds 1 to array values\n      arr[i] = arr[i]+1;\n    }\n}\n\nvoid add_two(int *arr){\n    for (int i = 0; i < N; i++){\n      arr[i] = arr[i]+2; // Variant function adds 2 to array values\n    }\n}\n\nint test_wrapper() { \n    errors = 0;\n\n    add(arr);\n    for(i = 0; i < N; i++){\n        OMPVV_TEST_AND_SET(errors, arr[i] != 1);\n    } \n    OMPVV_ERROR_IF(errors > 0, \"Base function is not working properly\");\n\n    #pragma omp dispatch\n        add(arr);\n   \n    for(i = 0; i < N; i++){\n        OMPVV_TEST_AND_SET(errors, arr[i] != 3 && arr[i] != 2);\n    }\n    OMPVV_INFOMSG_IF(errors > 0 || arr[0] == 2,\n                   \"Dispatch is either not working or was not considered\"\n                   \" by the implementation as part of the context selector.\");\n    return errors;\n}\n\nint main () {\n    for (int i = 0; i < N; i++){\n      arr[i] = 0;\n    }\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_wrapper());\n   OMPVV_REPORT_AND_RETURN(errors);\n} \n",
        "error_code": "//===---- test_dispatch_device.c -----------------------------------------===//\n// \n// OpenMP API Version 5.1\n//\n// Uses dispatch construct as context for variant directive. When the dispatch\n// construct is reached, the variant function, add_two, should be used.\n//\n// Inspired by \"OpenMP 5.1 Features: The Dispatch Construct\" video:\n// https://www.youtube.com/watch?v=ruugaX95gIs\n// \n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include \"ompvv.h\"\n#include <stdbool.h>\n\n#define N 1024\n\nint errors;\nint i = 0;\nint arr[N];\n\nvoid add_two(int *arr);\n\n#pragma omp declare variant(add_two) match(construct={dispatch}) \nvoid add(int *arr){\n    #pragma omp parallel for\n    for (int i = 0; i < N; i++){ // Base function adds 1 to array values\n      arr[i] = arr[i]+1;\n    }\n}\n\nvoid add_two(int *arr){\n    for (int i = 0; i < N; i++){\n      arr[i] = arr[i]+2; // Variant function adds 2 to array values\n    }\n}\n\nint test_wrapper() { \n    errors = 0;\n\n    add(arr);\n    for(i = 0; i < N; i++){\n        OMPVV_TEST_AND_SET(errors, arr[i] != 1);\n    } \n    OMPVV_ERROR_IF(errors > 0, \"Base function is not working properly\");\n\n    #pragma omp dispatch\n        add(arr);\n   \n    for(i = 0; i < N; i++){\n        OMPVV_TEST_AND_SET(errors, arr[i] != 3 && arr[i] != 2);\n    }\n    OMPVV_INFOMSG_IF(errors > 0 || arr[0] == 2,\n                   \"Dispatch is either not working or was not considered\"\n                   \" by the implementation as part of the context selector.\");\n    return errors;\n}\n\nint main () {\n    for (int i = 0; i < N; i++)\n      arr[i] = 0;\n    }\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_wrapper());\n   OMPVV_REPORT_AND_RETURN(errors);\n} \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_taskloop_numtask_strict.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1397",
        "issue_id": 1,
        "original_code": "//===--- test_taskloop_strict_numtasks.c -----------------------------------------------===//\n//\n//  OpenMP API Version 5.1 Aug 2021\n//\n// This test checks the behavior of taskloop's clause num_tasks when the strict \n// modifier is present. The num_task strict expression specifies the exact number of \n// tasks which should be given logical iterations, except for the sequentially\n// last task which may have fewer than the specified iterations. \n////===--------------------------------------------------------------------------------------===//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint errors;\n\nint test_taskloop_strict_numtasks() {\n  int arr[N];\n  int sum = 0;\n  int parallel_sum = 0; \n  for (int i=0; i<N; i++){\n        arr[i] = 1;\n        sum += arr[i];\n }\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST)\n#pragma omp single\n#pragma omp taskloop num_tasks(strict: 100) reduction(+: parallel_sum)\n  for (int i = 0; i < N; i++) {\n  \tparallel_sum += arr[i];\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, parallel_sum != sum);\n  OMPVV_INFOMSG_IF(sum == 0, \"Array was not initialized.\");\n  OMPVV_INFOMSG_IF(parallel_sum == 0, \"Data sharing of parallel_sum was wrong.\");\n  OMPVV_INFOMSG_IF(parallel_sum == sum, \"Test passed.\");\n  OMPVV_INFOMSG_IF(parallel_sum != sum, \"Test did not pass.\");\n  return errors;\n}\n\nint main() {\n  errors = 0;\n  OMPVV_TEST_OFFLOADING;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_taskloop_strict_numtasks() != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_taskloop_strict_numtasks.c -----------------------------------------------===//\n//\n//  OpenMP API Version 5.1 Aug 2021\n//\n// This test checks the behavior of taskloop's clause num_tasks when the strict \n// modifier is present. The num_task strict expression specifies the exact number of \n// tasks which should be given logical iterations, except for the sequentially\n// last task which may have fewer than the specified iterations. \n////===--------------------------------------------------------------------------------------===//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint errors;\n\nint test_taskloop_strict_numtasks() {\n  int arr[N];\n  int sum = 0;\n  int parallel_sum = 0; \n  for (int i=0; i<N; i++){\n        arr[i] = 1;\n        sum += arr[i];\n }\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST)\n#pragma omp single\n#pragma omp taskloop num_tasks(strict: 100) reduction(+: parallel_sum)\n  for (int i = 0; i < N; i++) {\n  \tparallel_sum += arr[i];\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, parallel_sum != sum);\n  OMPVV_INFOMSG_IF(sum == 0, \"Array was not initialized.\");\n  OMPVV_INFOMSG_IF(parallel_sum == 0, \"Data sharing of parallel_sum was wrong.\");\n  OMPVV_INFOMSG_IF(parallel_sum == sum, \"Test passed.\");\n  OMPVV_INFOMSG_IF(parallel_sum != sum, \"Test did not pass.\");\n  return errors;\n}\n\nint main() \n  errors = 0;\n  OMPVV_TEST_OFFLOADING;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_taskloop_strict_numtasks() != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_taskloop_num_tasks.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp parallel\" with directive \"#pragma omp declare\" at position 1505",
        "issue_id": 0,
        "original_code": "//------------------------------------------- test_taskloop_num_tasks.c --------------------------------------//\n//\n// OpenMP API Version 4.5 September 2015\n//\n// This test checks the 'taskloop' directive with the 'num_tasks' clause specified.\n// The 'taskloop' construct parallelizes loops with independent iterations by creating tasks. \n// It allows for efficient parallel execution of loop iterations by distributing them among multiple threads. \n// The 'num_tasks' clause variable ensures that the loop iterations are shared among created 'num_tasks'.\n// i.e the loop iterations are divided among number of tasks (each num_task group is run by same the thread).\n//----------------------------------------------------------------------------------------------------------//\n\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define NUM_THREADS 100\n\n#define NUM_TASKS 6\n#define NUM_ITERATIONS 12\n\nint isGroupIdsSame(int thread_ids[])\n{\n        int iterationsPerGroup = NUM_ITERATIONS / NUM_TASKS;\n\n        for(int i = 0; i < NUM_ITERATIONS; i = i+iterationsPerGroup)\n        {\n          for(int j = 0; j<iterationsPerGroup; j++) {\n            if (thread_ids[i+j] != thread_ids[i]) {\n              return 0; // Return false if any id is different in a group\n            }\n          }\n        }\n\n        return 1; // Return true if all id's are same per group\n}\n\nint test_taskloop_num_tasks() {\n\n   int errors = 0;\n\n   long int var = 0;\n\n   int thread_ids[NUM_THREADS];\n   int num_threads = 0;\n\n   #pragma omp parallel num_threads(NUM_THREADS)\n   {\n      #pragma omp single\n      {\n        num_threads = omp_get_num_threads();\n        #pragma omp taskloop num_tasks(NUM_TASKS)\n        for(int i = 0; i < NUM_ITERATIONS; i++)\n        {\n\t        #pragma omp atomic \n\t        var = var + i;\n\n          thread_ids[i] = omp_get_thread_num();\n        }\n      }\n   }\n\n   \n\n   //To check if the num_threads actually executing the parallel region > 1\n   if(num_threads == 1) {\n     OMPVV_WARNING(\"Only a single thread executed the parallel region\");\n   } else {\n     //if all the tasks in a group are run by a same thread, get TRUE else FALSE\n     OMPVV_TEST_AND_SET_VERBOSE(errors, (isGroupIdsSame(thread_ids) != 1));   \n   }\n\n   OMPVV_TEST_AND_SET_VERBOSE(errors, var != ((NUM_ITERATIONS-1)*(NUM_ITERATIONS)/2));\n\n   return errors;\n}\n\nint main() {\n  \n  int errors = 0;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, (test_taskloop_num_tasks()) != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n\n  return 0;\n}\n",
        "error_code": "//------------------------------------------- test_taskloop_num_tasks.c --------------------------------------//\n//\n// OpenMP API Version 4.5 September 2015\n//\n// This test checks the 'taskloop' directive with the 'num_tasks' clause specified.\n// The 'taskloop' construct parallelizes loops with independent iterations by creating tasks. \n// It allows for efficient parallel execution of loop iterations by distributing them among multiple threads. \n// The 'num_tasks' clause variable ensures that the loop iterations are shared among created 'num_tasks'.\n// i.e the loop iterations are divided among number of tasks (each num_task group is run by same the thread).\n//----------------------------------------------------------------------------------------------------------//\n\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define NUM_THREADS 100\n\n#define NUM_TASKS 6\n#define NUM_ITERATIONS 12\n\nint isGroupIdsSame(int thread_ids[])\n{\n        int iterationsPerGroup = NUM_ITERATIONS / NUM_TASKS;\n\n        for(int i = 0; i < NUM_ITERATIONS; i = i+iterationsPerGroup)\n        {\n          for(int j = 0; j<iterationsPerGroup; j++) {\n            if (thread_ids[i+j] != thread_ids[i]) {\n              return 0; // Return false if any id is different in a group\n            }\n          }\n        }\n\n        return 1; // Return true if all id's are same per group\n}\n\nint test_taskloop_num_tasks() {\n\n   int errors = 0;\n\n   long int var = 0;\n\n   int thread_ids[NUM_THREADS];\n   int num_threads = 0;\n\n   #pragma omp declare num_threads(NUM_THREADS)\n   {\n      #pragma omp single\n      {\n        num_threads = omp_get_num_threads();\n        #pragma omp taskloop num_tasks(NUM_TASKS)\n        for(int i = 0; i < NUM_ITERATIONS; i++)\n        {\n\t        #pragma omp atomic \n\t        var = var + i;\n\n          thread_ids[i] = omp_get_thread_num();\n        }\n      }\n   }\n\n   \n\n   //To check if the num_threads actually executing the parallel region > 1\n   if(num_threads == 1) {\n     OMPVV_WARNING(\"Only a single thread executed the parallel region\");\n   } else {\n     //if all the tasks in a group are run by a same thread, get TRUE else FALSE\n     OMPVV_TEST_AND_SET_VERBOSE(errors, (isGroupIdsSame(thread_ids) != 1));   \n   }\n\n   OMPVV_TEST_AND_SET_VERBOSE(errors, var != ((NUM_ITERATIONS-1)*(NUM_ITERATIONS)/2));\n\n   return errors;\n}\n\nint main() {\n  \n  int errors = 0;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, (test_taskloop_num_tasks()) != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n\n  return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_team_default_shared.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n      num_teams = omp_get_num_teams();\n    }\" at position 1201",
        "issue_id": 4,
        "original_code": "//===--- test_target_teams_distribute_default_shared.c-----------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the default(shared) clause on a teams distribute\n// directive.  The test aims to validate that when the default(shared) clause\n// is present, all variables without explicit data sharing attributes will\n// be shared within the region.  To test this, we test that a data element\n// that should be shared due to the default(shared) clause is available to\n// all the teams.  The first test uses atomic to write to the variable without\n// race conditions.  The second test uses synchronization constructs to have\n// one thread change the shared variable and ensures all threads see the change.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main() {\n  int a[N];\n  int share = 0;\n  int errors = 0;\n  int num_teams;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n  }\n\n#pragma omp teams distribute default(shared) num_teams(OMPVV_NUM_TEAMS_DEVICE)\n  for ( int i = 0; i < omp_get_num_teams(); i++){\n    if (omp_get_team_num() == 0) {\n      num_teams = omp_get_num_teams();\n    }\n#pragma omp atomic\n    share++;\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (share != num_teams));\n\n  \n  OMPVV_WARNING_IF(num_teams == 1, \"Test operated on one team, results of default shared test are inconclusive.\");\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_default_shared.c-----------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the default(shared) clause on a teams distribute\n// directive.  The test aims to validate that when the default(shared) clause\n// is present, all variables without explicit data sharing attributes will\n// be shared within the region.  To test this, we test that a data element\n// that should be shared due to the default(shared) clause is available to\n// all the teams.  The first test uses atomic to write to the variable without\n// race conditions.  The second test uses synchronization constructs to have\n// one thread change the shared variable and ensures all threads see the change.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main() {\n  int a[N];\n  int share = 0;\n  int errors = 0;\n  int num_teams;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n  }\n\n#pragma omp teams distribute default(shared) num_teams(OMPVV_NUM_TEAMS_DEVICE)\n  for ( int i = 0; i < omp_get_num_teams(); i++){\n    if (omp_get_team_num() == 0) \n#pragma omp atomic\n    share++;\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (share != num_teams));\n\n  \n  OMPVV_WARNING_IF(num_teams == 1, \"Test operated on one team, results of default shared test are inconclusive.\");\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_simd_safelen.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 2845",
        "issue_id": 1,
        "original_code": "//===---- test_target_simd_safelen.c - simd directive clause safelen   -===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// This test checks for the use of the safelen clause which prevents parallelization\n// over SIMD lanes that goes behond the contant value passed to the clause. This\n// is due to th possible iteration dependecies usually larger than 1. Regardless of \n// the SIMD len in hardware, the passed parameter should allow any possitive integer\n//===--------------------------------------------------------------------------===//\n//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define ARRAY_SIZE 1024\n\nint test_target_simd_safelen() {\n  OMPVV_INFOMSG(\"test_target_simd_safelen\");\n  OMPVV_WARNING(\"This test cannot check if actual SIMD extensions at the hardware level\" \\\n                 \" were used, or of the generated code is different in any way\");\n\n  // Variable for errors counting\n  int errors = 0;\n\n  int A[ARRAY_SIZE];\n  int A_host[ARRAY_SIZE];\n  int i, len;\n\n  // a and b array initialization\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      A[i] = 1;\n      A_host[i] = 1;\n  }\n\n  // Test safelen of 1 5 8 13 16 100 128\n#pragma omp target simd safelen(1) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 1; i < ARRAY_SIZE; ++i) {\n      A[i-1] += A[i]; \n  }\n\n#pragma omp target simd safelen(5) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 5; i < ARRAY_SIZE; ++i) {\n      A[i-5] += A[i]; \n  }\n\n#pragma omp target simd safelen(8) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 8; i < ARRAY_SIZE; ++i) {\n      A[i-8] += A[i]; \n  }\n\n#pragma omp target simd safelen(13) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 13; i < ARRAY_SIZE; ++i) {\n      A[i-13] += A[i]; \n  }\n\n#pragma omp target simd safelen(16) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 16; i < ARRAY_SIZE; ++i) {\n      A[i-16] += A[i]; \n  }\n\n#pragma omp target simd safelen(100) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 100; i < ARRAY_SIZE; ++i) {\n      A[i-100] += A[i]; \n  }\n\n#pragma omp target simd safelen(128) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 128; i < ARRAY_SIZE; ++i) {\n      A[i-128] += A[i]; \n  }\n\n\n  // Get the resultiong values form the CPU without any omp region\n  for (i = 1; i < ARRAY_SIZE; ++i) {\n      A_host[i-1] += A_host[i]; \n  }\n\n  for (i = 5; i < ARRAY_SIZE; ++i) {\n      A_host[i-5] += A_host[i]; \n  }\n\n  for (i = 8; i < ARRAY_SIZE; ++i) {\n      A_host[i-8] += A_host[i]; \n  }\n\n  for (i = 13; i < ARRAY_SIZE; ++i) {\n      A_host[i-13] += A_host[i]; \n  }\n\n  for (i = 16; i < ARRAY_SIZE; ++i) {\n      A_host[i-16] += A_host[i]; \n  }\n\n  for (i = 100; i < ARRAY_SIZE; ++i) {\n      A_host[i-100] += A_host[i]; \n  }\n\n  for (i = 128; i < ARRAY_SIZE; ++i) {\n      A_host[i-128] += A_host[i]; \n  }\n\n  // Check the results\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      OMPVV_TEST_AND_SET(errors, (A[i] != A_host[i]));\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_simd_safelen());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_simd_safelen.c - simd directive clause safelen   -===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// This test checks for the use of the safelen clause which prevents parallelization\n// over SIMD lanes that goes behond the contant value passed to the clause. This\n// is due to th possible iteration dependecies usually larger than 1. Regardless of \n// the SIMD len in hardware, the passed parameter should allow any possitive integer\n//===--------------------------------------------------------------------------===//\n//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define ARRAY_SIZE 1024\n\nint test_target_simd_safelen() {\n  OMPVV_INFOMSG(\"test_target_simd_safelen\");\n  OMPVV_WARNING(\"This test cannot check if actual SIMD extensions at the hardware level\" \\\n                 \" were used, or of the generated code is different in any way\");\n\n  // Variable for errors counting\n  int errors = 0;\n\n  int A[ARRAY_SIZE];\n  int A_host[ARRAY_SIZE];\n  int i, len;\n\n  // a and b array initialization\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      A[i] = 1;\n      A_host[i] = 1;\n  }\n\n  // Test safelen of 1 5 8 13 16 100 128\n#pragma omp target simd safelen(1) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 1; i < ARRAY_SIZE; ++i) {\n      A[i-1] += A[i]; \n  }\n\n#pragma omp target simd safelen(5) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 5; i < ARRAY_SIZE; ++i) {\n      A[i-5] += A[i]; \n  }\n\n#pragma omp target simd safelen(8) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 8; i < ARRAY_SIZE; ++i) {\n      A[i-8] += A[i]; \n  }\n\n#pragma omp target simd safelen(13) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 13; i < ARRAY_SIZE; ++i) {\n      A[i-13] += A[i]; \n  }\n\n#pragma omp target simd safelen(16) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 16; i < ARRAY_SIZE; ++i) {\n      A[i-16] += A[i]; \n  }\n\n#pragma omp target simd safelen(100) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 100; i < ARRAY_SIZE; ++i) {\n      A[i-100] += A[i]; \n  }\n\n#pragma omp target simd safelen(128) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 128; i < ARRAY_SIZE; ++i) {\n      A[i-128] += A[i]; \n  }\n\n\n  // Get the resultiong values form the CPU without any omp region\n  for (i = 1; i < ARRAY_SIZE; ++i) {\n      A_host[i-1] += A_host[i]; \n  }\n\n  for (i = 5; i < ARRAY_SIZE; ++i) {\n      A_host[i-5] += A_host[i]; \n  }\n\n  for (i = 8; i < ARRAY_SIZE; ++i) {\n      A_host[i-8] += A_host[i]; \n  }\n\n  for (i = 13; i < ARRAY_SIZE; ++i) {\n      A_host[i-13] += A_host[i]; \n  }\n\n  for (i = 16; i < ARRAY_SIZE; ++i) {\n      A_host[i-16] += A_host[i]; \n  }\n\n  for (i = 100; i < ARRAY_SIZE; ++i) {\n      A_host[i-100] += A_host[i]; \n  }\n\n  for (i = 128; i < ARRAY_SIZE; ++i) {\n      A_host[i-128] += A_host[i]; \n  }\n\n  // Check the results\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      OMPVV_TEST_AND_SET(errors, (A[i] != A_host[i]));\n  }\n\n  return errors;\n}\n\nint main() \n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_simd_safelen());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_firstprivate.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp map\" at position 1000",
        "issue_id": 0,
        "original_code": "//===--- test_target_teams_distribute_firstprivate.c-------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the firstprivate clause and tests it in two separate parts.\n// The first test checks the privatization of the firstprivatized scalars and\n// an array and the second tests the proper initialization of both\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main() {\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int num_teams[N];\n  int privatized_array[10];\n  int privatized = 0;\n  int ishost;\n  int errors = 0;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    c[x] = 2*x;\n    d[x] = 0;\n    num_teams[x] = -1;\n  }\n\n  for (int x = 0; x < 10; ++x) {\n    privatized_array[x] = 0;\n  }\n\n  //Test privitization of data in firstprivate clause\n#pragma omp target data map(from: d[0:N]) map(to: a[0:N], b[0:N], c[0:N])\n  {\n#pragma omp target teams distribute firstprivate(privatized_array, privatized) \\\n  map(alloc: a[0:N], b[0:N], c[0:N], d[0:N]) num_teams(OMPVV_NUM_TEAMS_DEVICE)\n    for (int x = 0; x < N; ++x) {\n      num_teams[x] = omp_get_num_teams();\n      for (int y = 0; y < a[x] + b[x]; ++y) {\n        privatized++;\n        for (int z = 0; z < 10; ++z) {\n          privatized_array[z]++;\n        }\n      }\n      d[x] = c[x] * privatized;\n      for (int z = 0; z < 10; ++z) {\n        d[x] += privatized_array[z];\n      }\n      privatized = 0;\n      for (int z = 0; z < 10; ++z) {\n        privatized_array[z] = 0;\n      }\n    }\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, d[x] != 10*(1 + x) + (1 + x)*2*x);\n    if (d[x] != 10*(1 + x) + (1 + x)*2*x) {\n      break;\n    }\n    OMPVV_WARNING_IF(num_teams[x] == 1, \"Did not create enough teams to check for potential data races.\");\n  }\n\n  privatized = 1;\n  for (int x = 0; x < 10; ++x) {\n    privatized_array[x] = x;\n  }\n\n  for (int x = 0; x < N; ++x) {\n    num_teams[x] = -1;\n  }\n\n  //Test initialization of data in firstprivate clause\n#pragma omp target data map(from: d[0:N]) map(to: a[0:N], b[0:N], c[0:N])\n  {\n#pragma omp target teams distribute firstprivate(privatized_array, privatized) \\\n  map(alloc: a[0:N], b[0:N], c[0:N], d[0:N]) num_teams(OMPVV_NUM_TEAMS_DEVICE)\n    for (int x = 0; x < N; ++x) {\n      num_teams[x] = omp_get_num_teams();\n      d[x] = a[x] + b[x] + c[x] + privatized_array[x%10] + privatized;\n    }\n  }\n\n  int temp;\n  for (int x = 0; x < N; ++x) {\n    temp = x%10;\n    OMPVV_TEST_AND_SET_VERBOSE(errors, d[x] != 2 + 3*x + temp);\n    if (d[x] != 2 + 3*x + (x%10)) {\n      break;\n    }\n    OMPVV_WARNING_IF(num_teams[x] == 1, \"Did not create enough teams to check for potential data races.\");\n  }\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_firstprivate.c-------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the firstprivate clause and tests it in two separate parts.\n// The first test checks the privatization of the firstprivatized scalars and\n// an array and the second tests the proper initialization of both\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main() {\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int num_teams[N];\n  int privatized_array[10];\n  int privatized = 0;\n  int ishost;\n  int errors = 0;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    c[x] = 2*x;\n    d[x] = 0;\n    num_teams[x] = -1;\n  }\n\n  for (int x = 0; x < 10; ++x) {\n    privatized_array[x] = 0;\n  }\n\n  //Test privitization of data in firstprivate clause\n#pragma omp map data map(from: d[0:N]) map(to: a[0:N], b[0:N], c[0:N])\n  {\n#pragma omp target teams distribute firstprivate(privatized_array, privatized) \\\n  map(alloc: a[0:N], b[0:N], c[0:N], d[0:N]) num_teams(OMPVV_NUM_TEAMS_DEVICE)\n    for (int x = 0; x < N; ++x) {\n      num_teams[x] = omp_get_num_teams();\n      for (int y = 0; y < a[x] + b[x]; ++y) {\n        privatized++;\n        for (int z = 0; z < 10; ++z) {\n          privatized_array[z]++;\n        }\n      }\n      d[x] = c[x] * privatized;\n      for (int z = 0; z < 10; ++z) {\n        d[x] += privatized_array[z];\n      }\n      privatized = 0;\n      for (int z = 0; z < 10; ++z) {\n        privatized_array[z] = 0;\n      }\n    }\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, d[x] != 10*(1 + x) + (1 + x)*2*x);\n    if (d[x] != 10*(1 + x) + (1 + x)*2*x) {\n      break;\n    }\n    OMPVV_WARNING_IF(num_teams[x] == 1, \"Did not create enough teams to check for potential data races.\");\n  }\n\n  privatized = 1;\n  for (int x = 0; x < 10; ++x) {\n    privatized_array[x] = x;\n  }\n\n  for (int x = 0; x < N; ++x) {\n    num_teams[x] = -1;\n  }\n\n  //Test initialization of data in firstprivate clause\n#pragma omp target data map(from: d[0:N]) map(to: a[0:N], b[0:N], c[0:N])\n  {\n#pragma omp target teams distribute firstprivate(privatized_array, privatized) \\\n  map(alloc: a[0:N], b[0:N], c[0:N], d[0:N]) num_teams(OMPVV_NUM_TEAMS_DEVICE)\n    for (int x = 0; x < N; ++x) {\n      num_teams[x] = omp_get_num_teams();\n      d[x] = a[x] + b[x] + c[x] + privatized_array[x%10] + privatized;\n    }\n  }\n\n  int temp;\n  for (int x = 0; x < N; ++x) {\n    temp = x%10;\n    OMPVV_TEST_AND_SET_VERBOSE(errors, d[x] != 2 + 3*x + temp);\n    if (d[x] != 2 + 3*x + (x%10)) {\n      break;\n    }\n    OMPVV_WARNING_IF(num_teams[x] == 1, \"Did not create enough teams to check for potential data races.\");\n  }\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_metadirective_arch_is_nvidia.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1558",
        "issue_id": 1,
        "original_code": "//===---test_metadirective_arch_is_nvidia.c --------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n// \n// Test for metadirectives based on OpenMP 5.0 examples metadirective.1-3.c\n//\n////===---------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint metadirective1() {\n   \n   int v1[N], v2[N], v3[N];\n\n   int target_device_num, host_device_num, default_device;\n   int errors = 0;\n\n   for(int i=0; i<N; i++) { \n      v1[i] = (i+1); \n      v2[i] = -(i+1); \n   }\n\n   host_device_num = omp_get_initial_device();\n\n   default_device = omp_get_default_device();\n\n   #pragma omp target map(to:v1,v2) map(from:v3, target_device_num) device(default_device)\n   {\n      #pragma omp metadirective \\\n                   when(   device={arch(\"nvptx\")}: teams distribute parallel for) \\\n                   default(                     parallel for)\n\n         for (int i = 0; i < N; i++) {\n\t    #pragma omp atomic write\n            target_device_num = omp_get_device_num();\n            v3[i] = v1[i] * v2[i];\n         }\n   }\n   \n   OMPVV_TEST_AND_SET(errors, host_device_num == target_device_num);\n   OMPVV_ERROR_IF(host_device_num == target_device_num, \"Device number that executes target region is \"\n                                                        \"the same as the device number on the host\");\n \n   for (int i = 0; i < N; i++) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, v3[i] != v1[i] * v2[i]);\n   }\n\n   return errors;\n}\n\nint main () {\n   \n   int errors = 0;\n   OMPVV_TEST_OFFLOADING;\n \n   OMPVV_TEST_AND_SET_VERBOSE(errors, metadirective1());\n  \n   OMPVV_REPORT_AND_RETURN(errors);\n\n}\n",
        "error_code": "//===---test_metadirective_arch_is_nvidia.c --------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n// \n// Test for metadirectives based on OpenMP 5.0 examples metadirective.1-3.c\n//\n////===---------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint metadirective1() {\n   \n   int v1[N], v2[N], v3[N];\n\n   int target_device_num, host_device_num, default_device;\n   int errors = 0;\n\n   for(int i=0; i<N; i++) { \n      v1[i] = (i+1); \n      v2[i] = -(i+1); \n   }\n\n   host_device_num = omp_get_initial_device();\n\n   default_device = omp_get_default_device();\n\n   #pragma omp target map(to:v1,v2) map(from:v3, target_device_num) device(default_device)\n   {\n      #pragma omp metadirective \\\n                   when(   device={arch(\"nvptx\")}: teams distribute parallel for) \\\n                   default(                     parallel for)\n\n         for (int i = 0; i < N; i++) {\n\t    #pragma omp atomic write\n            target_device_num = omp_get_device_num();\n            v3[i] = v1[i] * v2[i];\n         }\n   }\n   \n   OMPVV_TEST_AND_SET(errors, host_device_num == target_device_num);\n   OMPVV_ERROR_IF(host_device_num == target_device_num, \"Device number that executes target region is \"\n                                                        \"the same as the device number on the host\");\n \n   for (int i = 0; i < N; i++) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, v3[i] != v1[i] * v2[i]);\n   }\n\n   return errors;\n}\n\nint main () \n   \n   int errors = 0;\n   OMPVV_TEST_OFFLOADING;\n \n   OMPVV_TEST_AND_SET_VERBOSE(errors, metadirective1());\n  \n   OMPVV_REPORT_AND_RETURN(errors);\n\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_taskwait_depend.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===---- test_taskwait_depend.c ---------------------------------------------===//\n// \n// OpenMP API Version 5.0 \n// \n// This test uses the taskwait directive with the depend clause, which\n// ensures that the item listed in depend shares a depend with a\n// previous task to ensure sychronization\n//\n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\nint errors = 0;\nint test_wrapper() { //wrapper for taskwait depend function\n    #pragma omp parallel for\n        for (int i=1; i<N; i++){\n          int x,y,err = 0;\n          #pragma omp task depend(inout: x) shared(x) // 1st Task\n          x=i;\n          #pragma omp task depend(inout: y) shared(y) // 2nd Task\n          y=i;\n          #pragma omp taskwait depend(in: x) //Requires the completion of the 1st task\n          OMPVV_TEST_AND_SET(err, x!= i);\n          #pragma omp taskwait depend(in: x,y) //Requires the completion of both tasks\n          OMPVV_TEST_AND_SET(err, y!=i || x!=i);\n          #pragma omp atomic\n          errors += err;\n        }\n    return errors;\n}\n\n\nint main () {\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_wrapper());\n  OMPVV_REPORT_AND_RETURN(errors);\n}  \n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nlong hmvbqcvahd = 142;\nint dvsuvaklzc = 143;\nfloat wxgfjrwlky = 118;\nshort zjmmkftcvd = 243;\nfloat ahlijsvyix = 49;\nfloat zhrxwocgih = 96;\ndouble fvtwbcfkqw = 63;\ndouble uozrnnzmmh = 10;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_declare_target_enter_device_type_nohost.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp declare\" with directive \"#pragma omp for\" at position 912",
        "issue_id": 0,
        "original_code": "//===---- test_declare_target_enter_device_type_nohost.c  ---------------------------===//\n// \n// OpenMP API Version 5.2 \n//\n// The declare target directive specifies that variables, functions(C,C++ and Fortran),\n// and subroutines (Fortran) are mapped to a device. If a device_type\n// clause is present on the contained declare target directive, then its argument \n// determines which versions are made available. If device_type(nohost) is present \n// only a device version of the procedure is made available. \n// The device version of the function has to be specified via declare variant to support\n// fallback execution.\n// \n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 10\nint errors = 0;\nint a[N], b[N], c[N];  \nint dev=-9, i = 0;\n\nvoid target_function();\n#pragma omp declare target enter(target_function) device_type(nohost)\n#pragma omp declare target enter(a,b,c,i,dev)\n\n#pragma omp declare variant(target_function) match(device={kind(nohost)})\nvoid update() {\n  for (i = 0; i < N; i++) {\n    a[i] += 5;\n    b[i] += 5;\n    c[i] += 5;\n  }\n}\n\nvoid target_function(){\n  for (i = 0; i < N; i++) {\n    a[i] += 1;\n    b[i] += 2;\n    c[i] += 3;\n  }\n} \n\nint test_declare_target_enter_device_type_nohost() { \n\n  update();         \n\n  #pragma omp target update to(a,b,c)\n\n  #pragma omp target  \n  {\n    update();     //Will call target_function() on device OR update() in case of fallback\n    dev = omp_get_device_num();\n  }\n\n  #pragma omp target update from (a,b,c)\n  \n  if (dev != omp_get_initial_device()) {\n    for (i = 0; i < N; i++) { //check array values on host\n      if ( a[i] != 6 || b[i] != 7 || c[i] != 8 ) {\n        errors++;\n      }\n    }\n  } else {\n    OMPVV_WARNING(\"Default device is the host device. Target region was executed on the host\");\n    for (i = 0; i < N; i++) { //check array values on host\n      if ( a[i] != 10 || b[i] != 10 || c[i] != 10 ) {\n        errors++;\n      }\n    }\n  }\n  \n  return errors;\n}\n\nint main () {\n\n  OMPVV_TEST_OFFLOADING;\n  \n  //initalize arrays on host\n  for (i = 0; i < N; i++) {\n    a[i] = 0;\n    b[i] = 0;\n    c[i] = 0;\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_declare_target_enter_device_type_nohost());\n  OMPVV_REPORT_AND_RETURN(errors);\n}  \n",
        "error_code": "//===---- test_declare_target_enter_device_type_nohost.c  ---------------------------===//\n// \n// OpenMP API Version 5.2 \n//\n// The declare target directive specifies that variables, functions(C,C++ and Fortran),\n// and subroutines (Fortran) are mapped to a device. If a device_type\n// clause is present on the contained declare target directive, then its argument \n// determines which versions are made available. If device_type(nohost) is present \n// only a device version of the procedure is made available. \n// The device version of the function has to be specified via declare variant to support\n// fallback execution.\n// \n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 10\nint errors = 0;\nint a[N], b[N], c[N];  \nint dev=-9, i = 0;\n\nvoid target_function();\n#pragma omp for target enter(target_function) device_type(nohost)\n#pragma omp declare target enter(a,b,c,i,dev)\n\n#pragma omp declare variant(target_function) match(device={kind(nohost)})\nvoid update() {\n  for (i = 0; i < N; i++) {\n    a[i] += 5;\n    b[i] += 5;\n    c[i] += 5;\n  }\n}\n\nvoid target_function(){\n  for (i = 0; i < N; i++) {\n    a[i] += 1;\n    b[i] += 2;\n    c[i] += 3;\n  }\n} \n\nint test_declare_target_enter_device_type_nohost() { \n\n  update();         \n\n  #pragma omp target update to(a,b,c)\n\n  #pragma omp target  \n  {\n    update();     //Will call target_function() on device OR update() in case of fallback\n    dev = omp_get_device_num();\n  }\n\n  #pragma omp target update from (a,b,c)\n  \n  if (dev != omp_get_initial_device()) {\n    for (i = 0; i < N; i++) { //check array values on host\n      if ( a[i] != 6 || b[i] != 7 || c[i] != 8 ) {\n        errors++;\n      }\n    }\n  } else {\n    OMPVV_WARNING(\"Default device is the host device. Target region was executed on the host\");\n    for (i = 0; i < N; i++) { //check array values on host\n      if ( a[i] != 10 || b[i] != 10 || c[i] != 10 ) {\n        errors++;\n      }\n    }\n  }\n  \n  return errors;\n}\n\nint main () {\n\n  OMPVV_TEST_OFFLOADING;\n  \n  //initalize arrays on host\n  for (i = 0; i < N; i++) {\n    a[i] = 0;\n    b[i] = 0;\n    c[i] = 0;\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_declare_target_enter_device_type_nohost());\n  OMPVV_REPORT_AND_RETURN(errors);\n}  \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_parallel.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp teams\" at position 604",
        "issue_id": 0,
        "original_code": "//===---- test_target_parallel.c - combined consutrct target and parallel  -------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// This test checks for the combined construct target and parallel. It allows to create a\n// parallel region inside of the target device. \n//\n//===----------------------------------------------------------------------------------===//\n//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include \"ompvv.h\"\n\nint test_target_parallel() {\n  OMPVV_INFOMSG(\"test_target_parallel\");\n\n  int num_threads[OMPVV_NUM_THREADS_DEVICE];\n  int errors = 0;\n\n#pragma omp target parallel num_threads(OMPVV_NUM_THREADS_DEVICE) map(from:num_threads[0:OMPVV_NUM_THREADS_DEVICE])\n  {\n    int thread_id = omp_get_thread_num();\n    num_threads[thread_id] = omp_get_num_threads();\n  }\n\n  //Warning if only 1 thread in region 2, parallel does nothing\n  OMPVV_WARNING_IF(num_threads[0] == 1, \"The number of threads in the parallel region was 1. This is not a specifications error but we could not confirm the parallel region.\");\n\n  //Error if num_threads is inconsistent between threads\n  for (int i = 1; i < num_threads[0]; ++i) {\n    OMPVV_TEST_AND_SET(errors, num_threads[i] != num_threads[0]);\n    OMPVV_ERROR_IF(num_threads[i] != num_threads[0], \"The number of threads recorded by thread %d was %d. Expected was %d.\", i, num_threads[i], num_threads[0]);\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_parallel());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_parallel.c - combined consutrct target and parallel  -------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// This test checks for the combined construct target and parallel. It allows to create a\n// parallel region inside of the target device. \n//\n//===----------------------------------------------------------------------------------===//\n//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include \"ompvv.h\"\n\nint test_target_parallel() {\n  OMPVV_INFOMSG(\"test_target_parallel\");\n\n  int num_threads[OMPVV_NUM_THREADS_DEVICE];\n  int errors = 0;\n\n#pragma omp teams parallel num_threads(OMPVV_NUM_THREADS_DEVICE) map(from:num_threads[0:OMPVV_NUM_THREADS_DEVICE])\n  {\n    int thread_id = omp_get_thread_num();\n    num_threads[thread_id] = omp_get_num_threads();\n  }\n\n  //Warning if only 1 thread in region 2, parallel does nothing\n  OMPVV_WARNING_IF(num_threads[0] == 1, \"The number of threads in the parallel region was 1. This is not a specifications error but we could not confirm the parallel region.\");\n\n  //Error if num_threads is inconsistent between threads\n  for (int i = 1; i < num_threads[0]; ++i) {\n    OMPVV_TEST_AND_SET(errors, num_threads[i] != num_threads[0]);\n    OMPVV_ERROR_IF(num_threads[i] != num_threads[0], \"The number of threads recorded by thread %d was %d. Expected was %d.\", i, num_threads[i], num_threads[0]);\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_parallel());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_reduction_and.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 2632",
        "issue_id": 1,
        "original_code": "//===--- test_target_teams_distribute_reduction_and.c------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the reduction clause on a target teams distribute directive,\n// testing that the variable in the reduction clause is properly reduced using\n// the and operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n#define THRESHOLD 512\n\nint test_and() {\n  char a[N];\n      // The below calculation is meant to ensure about half the arrays we will\n      // test will come out to true under the 'and' operator, and the rest false.\n      // For the and operator, a test array that comes out true requires every\n      // entry to be false, which is why this margin is so close to 100%.\n  double false_margin = pow(exp(1), log(.5)/N);\n  int errors = 0;\n  int num_teams[N];\n  int tested_true = 0;\n  int tested_false = 0;\n  int itr_count = 0;\n  srand(1);\n\n  while ((!tested_true || !tested_false) && (itr_count < THRESHOLD)) {\n    for (int x = 0; x < N; ++x) {\n      a[x] = (rand() / (double) (RAND_MAX) < false_margin);\n      num_teams[x] = -x;\n    }\n\n    char result = 1;\n    char host_result = 1;\n\n#pragma omp target teams distribute reduction(&&:result) defaultmap(tofrom:scalar)\n    for (int x = 0; x < N; ++x) {\n      num_teams[x] = omp_get_num_teams();\n      result = result && a[x];\n    }\n\n    for (int x = 0; x < N; ++x) {\n      host_result = host_result && a[x];\n    }\n\n    if (itr_count == 0) {\n      for (int x = 1; x < N; ++x) {\n        OMPVV_WARNING_IF(num_teams[x - 1] != num_teams[x], \"Kernel reported differing numbers of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n      }\n      OMPVV_WARNING_IF(num_teams[0] == 1, \"Test operated with one team.  Reduction clause cannot be tested.\");\n      OMPVV_WARNING_IF(num_teams[0] <= 0, \"Test reported invalid number of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n    }\n\n    OMPVV_TEST_AND_SET_VERBOSE(errors, host_result != result);\n    OMPVV_ERROR_IF(host_result != result, \"Result on device is %d but expected result from host is %d.\", result, host_result);\n\n    if (host_result) {\n      tested_true = 1;\n    } else {\n      tested_false = 1;\n    }\n\n    if (host_result != result) {\n      break;\n    }\n\n    itr_count++;\n  }\n\n  OMPVV_WARNING_IF(!tested_true, \"Did not test a case in which final result was true.\");\n  OMPVV_WARNING_IF(!tested_false, \"Did not test a case in which final result was false.\");\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_and() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_reduction_and.c------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the reduction clause on a target teams distribute directive,\n// testing that the variable in the reduction clause is properly reduced using\n// the and operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n#define THRESHOLD 512\n\nint test_and() {\n  char a[N];\n      // The below calculation is meant to ensure about half the arrays we will\n      // test will come out to true under the 'and' operator, and the rest false.\n      // For the and operator, a test array that comes out true requires every\n      // entry to be false, which is why this margin is so close to 100%.\n  double false_margin = pow(exp(1), log(.5)/N);\n  int errors = 0;\n  int num_teams[N];\n  int tested_true = 0;\n  int tested_false = 0;\n  int itr_count = 0;\n  srand(1);\n\n  while ((!tested_true || !tested_false) && (itr_count < THRESHOLD)) {\n    for (int x = 0; x < N; ++x) {\n      a[x] = (rand() / (double) (RAND_MAX) < false_margin);\n      num_teams[x] = -x;\n    }\n\n    char result = 1;\n    char host_result = 1;\n\n#pragma omp target teams distribute reduction(&&:result) defaultmap(tofrom:scalar)\n    for (int x = 0; x < N; ++x) {\n      num_teams[x] = omp_get_num_teams();\n      result = result && a[x];\n    }\n\n    for (int x = 0; x < N; ++x) {\n      host_result = host_result && a[x];\n    }\n\n    if (itr_count == 0) {\n      for (int x = 1; x < N; ++x) {\n        OMPVV_WARNING_IF(num_teams[x - 1] != num_teams[x], \"Kernel reported differing numbers of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n      }\n      OMPVV_WARNING_IF(num_teams[0] == 1, \"Test operated with one team.  Reduction clause cannot be tested.\");\n      OMPVV_WARNING_IF(num_teams[0] <= 0, \"Test reported invalid number of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n    }\n\n    OMPVV_TEST_AND_SET_VERBOSE(errors, host_result != result);\n    OMPVV_ERROR_IF(host_result != result, \"Result on device is %d but expected result from host is %d.\", result, host_result);\n\n    if (host_result) {\n      tested_true = 1;\n    } else {\n      tested_false = 1;\n    }\n\n    if (host_result != result) {\n      break;\n    }\n\n    itr_count++;\n  }\n\n  OMPVV_WARNING_IF(!tested_true, \"Did not test a case in which final result was true.\");\n  OMPVV_WARNING_IF(!tested_false, \"Did not test a case in which final result was false.\");\n\n  return errors;\n}\n\nint main() \n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_and() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_depend_inoutset.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp parallel\" with directive \"#pragma omp atomic\" at position 667",
        "issue_id": 0,
        "original_code": "//===--- test_depend_inoutset.c ----------------------------===//\n//\n//  OpenMP API Version 5.1 Aug 2021\n//\n//  This test verifies the use of inoutset in depend clause. The 'mutexinoutset'\n//  clause is mutually exclusive when running, meaning that the tasks must be\n//  seperate from one another. Inoutset, on the other hand, is not mutually\n//  exclusive with itself. \n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint errors;\nint arr[N];\nint depend_inoutset(){\n  for(int i = 0; i < N; i++){\n    arr[i] = 0;\n  }\n  #pragma omp parallel\n  #pragma omp single\n  {\n    for(int i = 0; i < N; i++){\n      #pragma omp task depend(out: arr[i])\n      arr[i] = i + 1;\n    }\n    for(int i = 0; i < N; i++){\n      #pragma omp task depend(inoutset: arr[i])\n      arr[i] = arr[i] + 2;\n    }\n    for(int i = 0; i < N; i++){\n      #pragma omp task depend(inoutset: arr[i])\n      arr[i] = arr[i] + 3;\n    }\n  }\n  for(int i = 0; i < N; i++){\n    OMPVV_TEST_AND_SET_VERBOSE(errors, arr[i] != i + 6);\n  }\n  return errors;\n\n}\n\nint main() {\n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, depend_inoutset() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n   \n}\n",
        "error_code": "//===--- test_depend_inoutset.c ----------------------------===//\n//\n//  OpenMP API Version 5.1 Aug 2021\n//\n//  This test verifies the use of inoutset in depend clause. The 'mutexinoutset'\n//  clause is mutually exclusive when running, meaning that the tasks must be\n//  seperate from one another. Inoutset, on the other hand, is not mutually\n//  exclusive with itself. \n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint errors;\nint arr[N];\nint depend_inoutset(){\n  for(int i = 0; i < N; i++){\n    arr[i] = 0;\n  }\n  #pragma omp atomic\n  #pragma omp single\n  {\n    for(int i = 0; i < N; i++){\n      #pragma omp task depend(out: arr[i])\n      arr[i] = i + 1;\n    }\n    for(int i = 0; i < N; i++){\n      #pragma omp task depend(inoutset: arr[i])\n      arr[i] = arr[i] + 2;\n    }\n    for(int i = 0; i < N; i++){\n      #pragma omp task depend(inoutset: arr[i])\n      arr[i] = arr[i] + 3;\n    }\n  }\n  for(int i = 0; i < N; i++){\n    OMPVV_TEST_AND_SET_VERBOSE(errors, arr[i] != i + 6);\n  }\n  return errors;\n\n}\n\nint main() {\n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, depend_inoutset() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n   \n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_memcpy_async_depobj.c",
        "correct": "n",
        "issue": "Removed memory allocation line \"omp_target_alloc( sizeof(double)*N, t);\" at position 909",
        "issue_id": 0,
        "original_code": "//===--- test_target_memcpy_async_depobj.c --------------------------------===//\n//\n//  OpenMP API Version 5.1 Nov 2020\n//\n//  Inspired from OpenMP 5.1 Examples Doc, 5.16.4 & 8.9\n//  This test utilizes the omp_target_memcpy_async construct to\n//  allocate memory on the device asynchronously. The construct\n//  uses 'obj' for dependency, so that memory is only copied once\n//  the variable listed in the depend clause is changed.\n//\n////===--------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint errors, i;\n\nint test_target_memcpy_async_depobj() {\n\n    int h, t, i, err_r;\n    errors = 0;\n    double *mem;\n    double *mem_dev_cpy;\n    h = omp_get_initial_device();\n    t = omp_get_default_device();\n\n\n    mem = (double *)malloc( sizeof(double)*N);\n    mem_dev_cpy = (double *)omp_target_alloc( sizeof(double)*N, t);\n\n    OMPVV_TEST_AND_SET_VERBOSE(errors, mem == NULL);\n    if(mem == NULL) {\n       return errors;\n    }\n\n    OMPVV_TEST_AND_SET_VERBOSE(errors, mem_dev_cpy == NULL);\n    if(mem_dev_cpy == NULL) {\n       return errors;\n    }\n\n    for(i = 0; i < N; i++){\n        mem[i] = i;\n    }\n    omp_depend_t obj;\n    #pragma omp depobj(obj) depend(inout: mem_dev_cpy)\n    omp_depend_t obj_arr[1] = {obj};\n\n    /* copy to device memory */\n    err_r = omp_target_memcpy_async(mem_dev_cpy, mem, sizeof(double)*N,\n                                0,          0,\n                                t,          h,\n                                1,          obj_arr);\n    if(err_r) {\n       OMPVV_ERROR(\"omp_target_memcpy_async returns not 0\");\n       free(mem);\n       omp_target_free(mem_dev_cpy, t);\n       return errors;\n    }\n\n    #pragma omp taskwait depend(depobj: obj)\n    #pragma omp target is_device_ptr(mem_dev_cpy) device(t) depend(depobj: obj)\n    {\n        for(i = 0; i < N; i++){\n            mem_dev_cpy[i] = mem_dev_cpy[i]*2; // initialize data\n        }\n    }\n    /* copy to host memory */\n    omp_target_memcpy_async(mem, mem_dev_cpy, sizeof(double)*N,\n                                0,          0,\n                                h,          t,\n                                1,          obj_arr);\n\n    #pragma omp taskwait depend(depobj: obj)\n    for(i = 0; i < N; i++){\n        OMPVV_TEST_AND_SET(errors, mem[i]!=i*2);\n    }\n    // free resources\n    free(mem);\n    omp_target_free(mem_dev_cpy, t);\n    #pragma omp depobj(obj) destroy\n    return errors;\n}\n\nint main() {\n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_memcpy_async_depobj() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_memcpy_async_depobj.c --------------------------------===//\n//\n//  OpenMP API Version 5.1 Nov 2020\n//\n//  Inspired from OpenMP 5.1 Examples Doc, 5.16.4 & 8.9\n//  This test utilizes the omp_target_memcpy_async construct to\n//  allocate memory on the device asynchronously. The construct\n//  uses 'obj' for dependency, so that memory is only copied once\n//  the variable listed in the depend clause is changed.\n//\n////===--------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint errors, i;\n\nint test_target_memcpy_async_depobj() {\n\n    int h, t, i, err_r;\n    errors = 0;\n    double *mem;\n    double *mem_dev_cpy;\n    h = omp_get_initial_device();\n    t = omp_get_default_device();\n\n\n    mem = (double *)malloc( sizeof(double)*N);\n    mem_dev_cpy = (double *)\n\n    OMPVV_TEST_AND_SET_VERBOSE(errors, mem == NULL);\n    if(mem == NULL) {\n       return errors;\n    }\n\n    OMPVV_TEST_AND_SET_VERBOSE(errors, mem_dev_cpy == NULL);\n    if(mem_dev_cpy == NULL) {\n       return errors;\n    }\n\n    for(i = 0; i < N; i++){\n        mem[i] = i;\n    }\n    omp_depend_t obj;\n    #pragma omp depobj(obj) depend(inout: mem_dev_cpy)\n    omp_depend_t obj_arr[1] = {obj};\n\n    /* copy to device memory */\n    err_r = omp_target_memcpy_async(mem_dev_cpy, mem, sizeof(double)*N,\n                                0,          0,\n                                t,          h,\n                                1,          obj_arr);\n    if(err_r) {\n       OMPVV_ERROR(\"omp_target_memcpy_async returns not 0\");\n       free(mem);\n       omp_target_free(mem_dev_cpy, t);\n       return errors;\n    }\n\n    #pragma omp taskwait depend(depobj: obj)\n    #pragma omp target is_device_ptr(mem_dev_cpy) device(t) depend(depobj: obj)\n    {\n        for(i = 0; i < N; i++){\n            mem_dev_cpy[i] = mem_dev_cpy[i]*2; // initialize data\n        }\n    }\n    /* copy to host memory */\n    omp_target_memcpy_async(mem, mem_dev_cpy, sizeof(double)*N,\n                                0,          0,\n                                h,          t,\n                                1,          obj_arr);\n\n    #pragma omp taskwait depend(depobj: obj)\n    for(i = 0; i < N; i++){\n        OMPVV_TEST_AND_SET(errors, mem[i]!=i*2);\n    }\n    // free resources\n    free(mem);\n    omp_target_free(mem_dev_cpy, t);\n    #pragma omp depobj(obj) destroy\n    return errors;\n}\n\nint main() {\n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_memcpy_async_depobj() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_declare_mapper_iterator.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===---- test_declare_mapper_iterator.c -------------------------------------===//\n// \n// OpenMP API Version 5.2 \n//\n// This example has been adapted from the 5.2 OpenMP Examples document:\n// \"declare mapper Directive\", and \"OpenMP Directive Syntax -> complex iterator\"\n// The declare mapper directive will be used to automatically map variable\n// according to its prescription:  full structure, plus the dynamic storage of the\n// data element. The mapper can include an iterator modifier of map\n//\n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\ntypedef struct myvec{\n    size_t len;\n    double *data;\n} myvec_t;\n\n\n#pragma omp declare mapper(myvec_t v) map(iterator(it = 0:v.len), tofrom: v.data[it]) \n\nvoid init( myvec_t *s )\n{ \n  for(size_t i = 0; i < s->len; i++)\n    s->data[i] = i; \n}\n\n\nint test_declare_mapper_iterator() { \n\n  OMPVV_INFOMSG(\"test_declare_mapper_iterator\");\n  int errors = 0;\n\n   myvec_t s;\n\n   s.data = (double *)calloc(N,sizeof(double));\n   s.len  = N;\n\n  #pragma omp target\n  {\n    init(&s);\n  }\n\n  for (int i = 0; i < N; ++i) {\n    OMPVV_TEST_AND_SET(errors, s.data[i] != i);\n  }\t\n  \n  return errors;\n}\n\nint main () {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_declare_mapper_iterator());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}  \n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\ndouble faanlyrska = 104;\nlong wovhhjalpd = 233;\nfloat eqpxipsckb = 250;\ndouble mxnsdyesyk = 30;\ndouble znuzdnkaxu = 46;\nfloat pulsjgggsg = 33;\nfloat msmwryjdvj = 131;\nint twssamkafr = 100;\ndouble hmutcqgkbg = 148;\nshort qiudvxwlmi = 2;\nfloat syvkihdhwi = 161;\nlong jwkvdpvnuc = 126;\ndouble wmzjgfxzbw = 85;\nshort roytpdmcak = 26;\nint hufznpsysd = 193;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_metadirective_target_device_kind.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1421",
        "issue_id": 1,
        "original_code": "//===--------------------- test_metadirective_target_device_kind.c ---------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n// \n// Tests that target_device is recognized & will work properly when matching a\n// GPU. More specifically, uses the kind clause to see if gpu or nohost is recognized\n// as the target device's \"kind\" implementation. \n//\n////===---------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_metadirective_target_device() {\n   int errors = 0;\n   int A[N];\n\n   for (int i = 0; i < N; i++) {\n      A[i] = 1;\n   }\n\n      // Expect that one of these are true, so the array should be set to masked thread num (0)\n      #pragma omp metadirective \\\n         when( target_device={kind(gpu)}: target defaultmap(none) map(tofrom: A)) \\\n         when( target_device={kind(nohost)}: target defaultmap(none) map(tofrom: A)) \\\n         default( target defaultmap(none) map(to: A))\n         for(int i = 0; i < N; i++){\n            A[i] = i;\n         }\n\n   for (int i = 0; i < N; i++) {\n      OMPVV_TEST_AND_SET(errors, A[i] != i);\n   }\n\n   OMPVV_INFOMSG(\"Test ran with a number of available devices greater than 0\");\n\n   return errors;\n}\n\nint main () {\n  int errors = 0;\n  OMPVV_TEST_OFFLOADING;\n\n  if (omp_get_num_devices() > 0) {\n    errors = test_metadirective_target_device();\n  } else {\n    OMPVV_INFOMSG(\"Cannot test target_device without a target device!\")\n  }\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n  return 0;\n}\n",
        "error_code": "//===--------------------- test_metadirective_target_device_kind.c ---------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n// \n// Tests that target_device is recognized & will work properly when matching a\n// GPU. More specifically, uses the kind clause to see if gpu or nohost is recognized\n// as the target device's \"kind\" implementation. \n//\n////===---------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_metadirective_target_device() {\n   int errors = 0;\n   int A[N];\n\n   for (int i = 0; i < N; i++) {\n      A[i] = 1;\n   }\n\n      // Expect that one of these are true, so the array should be set to masked thread num (0)\n      #pragma omp metadirective \\\n         when( target_device={kind(gpu)}: target defaultmap(none) map(tofrom: A)) \\\n         when( target_device={kind(nohost)}: target defaultmap(none) map(tofrom: A)) \\\n         default( target defaultmap(none) map(to: A))\n         for(int i = 0; i < N; i++){\n            A[i] = i;\n         }\n\n   for (int i = 0; i < N; i++) {\n      OMPVV_TEST_AND_SET(errors, A[i] != i);\n   }\n\n   OMPVV_INFOMSG(\"Test ran with a number of available devices greater than 0\");\n\n   return errors;\n}\n\nint main () {\n  int errors = 0;\n  OMPVV_TEST_OFFLOADING;\n\n  if (omp_get_num_devices() > 0) {\n    errors = test_metadirective_target_device();\n  } else \n    OMPVV_INFOMSG(\"Cannot test target_device without a target device!\")\n  }\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n  return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_uses_allocators_low_lat.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 1228",
        "issue_id": 2,
        "original_code": "//===--- test_target_uses_allocators_low_lat.c ----------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// The tests checks the uses_allocators clause with omp_low_lat_mem_alloc. \n// The variable allaocated in the target is modified. Result is copied back to\n// the host and checked with computed value on host.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_uses_allocators_low_lat() {\n  int errors = 0;\n  int x = 0;\n  int device_result = 0;\n  int result = 0;\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      result += j + i ;\n    }\n  }\n\n#pragma omp target uses_allocators(omp_low_lat_mem_alloc) allocate(omp_low_lat_mem_alloc: x) firstprivate(x) map(from: device_result)\n{\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      x += j + i;\n    }\n  }\n  device_result = x;\n}\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != device_result);\n\n  return errors;\n}\n\nint main() {\n\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_uses_allocators_low_lat() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n",
        "error_code": "//===--- test_target_uses_allocators_low_lat.c ----------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// The tests checks the uses_allocators clause with omp_low_lat_mem_alloc. \n// The variable allaocated in the target is modified. Result is copied back to\n// the host and checked with computed value on host.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_uses_allocators_low_lat() {\n  int errors = 0;\n  int x = 0;\n  int device_result = 0;\n  int result = 0;\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      result += j + i ;\n    }\n  }\n\n#pragma omp target uses_allocators(omp_low_lat_mem_alloc) allocate(omp_low_lat_mem_alloc: x) firstprivate(x) map(from: device_result)\n{\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      x += j + i;\n    }\n  }\n  device_result = x;\n}\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != device_result);\n\n  return errors;\n}\n\nint main() {\n\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_uses_allocators_low_lat() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_parallel_linear.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 974",
        "issue_id": 1,
        "original_code": "//===------test_target_linear.c--------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Tests the target directive with parallel for + device + linear clauses\n//\n//===------------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include \"omp.h\"\n#include \"ompvv.h\"\n\n#define N 1024\n\n\n\nint Runtst(int gpu) {\n  int *A = (int *) malloc(sizeof(int) * N), errors = 0;\n  for (int i = 0; i < N; ++i) {\n    A[i] = i;\n  }\n  int val = 0;\n#pragma omp target data map(tofrom: A[0:N], val) device(gpu)\n  {\n#pragma omp target parallel for device(gpu) linear(val:2)\n    for (int i = 0; i < N; ++i) {\n      val += 2;\n      A[i] = val;\n    }\n  }\n\n  // Verification\n \n  for (int i = 0; i < N; ++i) {\n    if (A[i] != (i+1) * 2) {\n      errors++;\n    }\n  }\n\n  free(A);\n  return errors;\n}\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int TotGpus = omp_get_num_devices();\n  int errors = 0;\n  for (int gpu = 0; gpu <= TotGpus; ++gpu) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (Runtst(gpu) != 0));\n  }\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===------test_target_linear.c--------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Tests the target directive with parallel for + device + linear clauses\n//\n//===------------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include \"omp.h\"\n#include \"ompvv.h\"\n\n#define N 1024\n\n\n\nint Runtst(int gpu) {\n  int *A = (int *) malloc(sizeof(int) * N), errors = 0;\n  for (int i = 0; i < N; ++i) {\n    A[i] = i;\n  }\n  int val = 0;\n#pragma omp target data map(tofrom: A[0:N], val) device(gpu)\n  {\n#pragma omp target parallel for device(gpu) linear(val:2)\n    for (int i = 0; i < N; ++i) {\n      val += 2;\n      A[i] = val;\n    }\n  }\n\n  // Verification\n \n  for (int i = 0; i < N; ++i) {\n    if (A[i] != (i+1) * 2) {\n      errors++;\n    }\n  }\n\n  free(A);\n  return errors;\n}\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int TotGpus = omp_get_num_devices();\n  int errors = 0;\n  for (int gpu = 0; gpu <= TotGpus; ++gpu) \n    OMPVV_TEST_AND_SET_VERBOSE(errors, (Runtst(gpu) != 0));\n  }\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_dispatch_nocontext.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp declare\" with directive \"#pragma omp parallel\" at position 791",
        "issue_id": 0,
        "original_code": "//===---- test_dispatch_nocontext.c ---------------------------------------===//\n//\n//\n// OpenMP API Version 5.1\n//\n// Uses dispatch construct as context for variant directive. Uses nocontext\n// clause which can determine whether dispatch is a viable construct for the\n// variant directive. When nocontext is true, then dispatch is not a viable\n// construct and vice versa.\n//\n// Inspired by \"OpenMP 5.1 Features: The Dispatch Construct\" video:\n// https://www.youtube.com/watch?v=ruugaX95gIs\n//\n//===----------------------------------------------------------------------===//\n\n#include \"ompvv.h\"\n#include <math.h>\n#include <omp.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 1024\n\nint arr[N]; // implicit map array\nint errors;\nint i = 0;\n\nvoid add_two(int *arr);\n\n#pragma omp declare variant(add_two) match(construct = {dispatch})\nvoid add(int *arr) {\n  for (int i = 0; i < N; i++) { // Base function adds 1 to array values\n    arr[i] = i + 1;\n  }\n}\n\nvoid add_two(int *arr) {\n  for (int i = 0; i < N; i++) {\n    arr[i] = i + 2; // Variant function adds 2 to array values\n  }\n}\n\nint test_wrapper() {\n  errors = 0;\n  int err_ar[2] = {0, 0};\n  bool nocontext_arg;\n  add(arr);\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, arr[i] != i + 1);\n  }\n  OMPVV_ERROR_IF(errors > 0, \"Base function is not working properly\");\n  nocontext_arg = true;\n  #pragma omp dispatch nocontext(nocontext_arg)\n  add(arr);\n\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(err_ar[0], (arr[i] != i + 1));\n  }\n  errors += err_ar[0];\n  OMPVV_ERROR_IF(errors > 0,\n                 \"Dispatch w/ nocontext true is not working properly\");\n\n  nocontext_arg = false;\n  #pragma omp dispatch nocontext(nocontext_arg)\n  add(arr);\n\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(err_ar[1], (arr[i] != i + 1) && (arr[i] != i + 2));\n  }\n  // OMP 5.1, Pg54:6 -Whether the dispatch construct is added to the construct\n  // set is implementation defined.\n  errors += err_ar[1];\n  OMPVV_INFOMSG_IF(errors > 0 || arr[0] == 1,\n                   \"Dispatch is either not working or was not considered\"\n                   \" by the implementation as part of the context selector.\");\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_wrapper());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_dispatch_nocontext.c ---------------------------------------===//\n//\n//\n// OpenMP API Version 5.1\n//\n// Uses dispatch construct as context for variant directive. Uses nocontext\n// clause which can determine whether dispatch is a viable construct for the\n// variant directive. When nocontext is true, then dispatch is not a viable\n// construct and vice versa.\n//\n// Inspired by \"OpenMP 5.1 Features: The Dispatch Construct\" video:\n// https://www.youtube.com/watch?v=ruugaX95gIs\n//\n//===----------------------------------------------------------------------===//\n\n#include \"ompvv.h\"\n#include <math.h>\n#include <omp.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 1024\n\nint arr[N]; // implicit map array\nint errors;\nint i = 0;\n\nvoid add_two(int *arr);\n\n#pragma omp parallel variant(add_two) match(construct = {dispatch})\nvoid add(int *arr) {\n  for (int i = 0; i < N; i++) { // Base function adds 1 to array values\n    arr[i] = i + 1;\n  }\n}\n\nvoid add_two(int *arr) {\n  for (int i = 0; i < N; i++) {\n    arr[i] = i + 2; // Variant function adds 2 to array values\n  }\n}\n\nint test_wrapper() {\n  errors = 0;\n  int err_ar[2] = {0, 0};\n  bool nocontext_arg;\n  add(arr);\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, arr[i] != i + 1);\n  }\n  OMPVV_ERROR_IF(errors > 0, \"Base function is not working properly\");\n  nocontext_arg = true;\n  #pragma omp dispatch nocontext(nocontext_arg)\n  add(arr);\n\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(err_ar[0], (arr[i] != i + 1));\n  }\n  errors += err_ar[0];\n  OMPVV_ERROR_IF(errors > 0,\n                 \"Dispatch w/ nocontext true is not working properly\");\n\n  nocontext_arg = false;\n  #pragma omp dispatch nocontext(nocontext_arg)\n  add(arr);\n\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(err_ar[1], (arr[i] != i + 1) && (arr[i] != i + 2));\n  }\n  // OMP 5.1, Pg54:6 -Whether the dispatch construct is added to the construct\n  // set is implementation defined.\n  errors += err_ar[1];\n  OMPVV_INFOMSG_IF(errors > 0 || arr[0] == 1,\n                   \"Dispatch is either not working or was not considered\"\n                   \" by the implementation as part of the context selector.\");\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_wrapper());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_update_if.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp declare\" at position 1544",
        "issue_id": 0,
        "original_code": "//===---- test_target_update_if.c - check the if clause of target update ------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// The if clause determines if the section should be updated on  \n// the device. There are two scenarios to test here: \n// (a) with offloading when 'if' clause evaluates to true then \n// associated data is updated depending on the motion clause.\n// (b) with offloading when 'if' clause evaluates to false \n// then there is no update\n// The if clause is evaluated on runtime which means that variables could\n// determine this behavior. \n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define N 100\n\nint a[N];\nint b[N];\nint c[N];\nint count, toggle=0;\n\nint init_b(){\n  if(toggle % 2){\n    int i;\n    for (i = 0; i < N; i++) {\n      b[i] = b[i] * 2; \n    }\n    toggle++;\n    return 1;\n  }\n  else{\n    toggle++;\n    return 0;\n  }\n}\n  \n// Test for OpenMP 4.5 target update with if\nint main() {\n  int errors[2]={0,0}, i = 0, report_errors = 0, change_flag = 0;\n\n  for (i = 0; i < N; i++) {\n    a[i] = 10;\n  }\n\n  // We test for offloading\n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading); \n  \n  if (!is_offloading)\n  OMPVV_WARNING(\"It is not possible to test conditional data transfers \"\n                 \"if the environment is shared or offloading is off. Not testing \"\n                 \"anything\");\n    \n  for(count = 0; count < 4; count++){\n    for (i = 0; i < N; i++) {\n      b[i] = 2; \n      c[i] = 0;\n  }\n#pragma omp target data map(to: a[:N], b[:N]) map(tofrom: c)\n{\n  #pragma omp target \n  {\n        int j = 0;\n        for (j = 0; j < N; j++) {\n          c[j] = (a[j] + b[j]);//c=12 \n        }\n  } // end target\n\n  change_flag = init_b();\n  #pragma omp target update if (change_flag) to(b[:N]) //update b=4 for all odd iterations\n\n  #pragma omp target //default mapping is tofrom on b and c\n  {\n        int j = 0;\n        for (j = 0; j < N; j++) {\n          c[j] = (c[j] + b[j]);//if b is updated c=16 else c=14\n        }\n  } // end target\n\n}// end target-data\n\n    // checking results \n  if (change_flag) {\n    for (i = 0; i < N; i++) {\n        if (c[i] != 16) {\n          errors[0] += 1;\n        }\n    }\n  }\n  else {\n    for (i = 0; i < N; i++) {\n        if (c[i] != 14) {\n          errors[1] += 1;\n        }\n    }\n  }\n}//end for\n\n  OMPVV_TEST_AND_SET_VERBOSE(report_errors, errors[0] > 0);\n  OMPVV_INFOMSG_IF(errors[0] > 0, \"Target update test when if clause is true failed\");\n  OMPVV_TEST_AND_SET_VERBOSE(report_errors, errors[1] > 0);\n  OMPVV_INFOMSG_IF(errors[1] > 0,  \"Target update test when if clause is false failed\");\n\n  OMPVV_REPORT_AND_RETURN(report_errors);\n}\n",
        "error_code": "//===---- test_target_update_if.c - check the if clause of target update ------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// The if clause determines if the section should be updated on  \n// the device. There are two scenarios to test here: \n// (a) with offloading when 'if' clause evaluates to true then \n// associated data is updated depending on the motion clause.\n// (b) with offloading when 'if' clause evaluates to false \n// then there is no update\n// The if clause is evaluated on runtime which means that variables could\n// determine this behavior. \n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define N 100\n\nint a[N];\nint b[N];\nint c[N];\nint count, toggle=0;\n\nint init_b(){\n  if(toggle % 2){\n    int i;\n    for (i = 0; i < N; i++) {\n      b[i] = b[i] * 2; \n    }\n    toggle++;\n    return 1;\n  }\n  else{\n    toggle++;\n    return 0;\n  }\n}\n  \n// Test for OpenMP 4.5 target update with if\nint main() {\n  int errors[2]={0,0}, i = 0, report_errors = 0, change_flag = 0;\n\n  for (i = 0; i < N; i++) {\n    a[i] = 10;\n  }\n\n  // We test for offloading\n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading); \n  \n  if (!is_offloading)\n  OMPVV_WARNING(\"It is not possible to test conditional data transfers \"\n                 \"if the environment is shared or offloading is off. Not testing \"\n                 \"anything\");\n    \n  for(count = 0; count < 4; count++){\n    for (i = 0; i < N; i++) {\n      b[i] = 2; \n      c[i] = 0;\n  }\n#pragma omp declare data map(to: a[:N], b[:N]) map(tofrom: c)\n{\n  #pragma omp target \n  {\n        int j = 0;\n        for (j = 0; j < N; j++) {\n          c[j] = (a[j] + b[j]);//c=12 \n        }\n  } // end target\n\n  change_flag = init_b();\n  #pragma omp target update if (change_flag) to(b[:N]) //update b=4 for all odd iterations\n\n  #pragma omp target //default mapping is tofrom on b and c\n  {\n        int j = 0;\n        for (j = 0; j < N; j++) {\n          c[j] = (c[j] + b[j]);//if b is updated c=16 else c=14\n        }\n  } // end target\n\n}// end target-data\n\n    // checking results \n  if (change_flag) {\n    for (i = 0; i < N; i++) {\n        if (c[i] != 16) {\n          errors[0] += 1;\n        }\n    }\n  }\n  else {\n    for (i = 0; i < N; i++) {\n        if (c[i] != 14) {\n          errors[1] += 1;\n        }\n    }\n  }\n}//end for\n\n  OMPVV_TEST_AND_SET_VERBOSE(report_errors, errors[0] > 0);\n  OMPVV_INFOMSG_IF(errors[0] > 0, \"Target update test when if clause is true failed\");\n  OMPVV_TEST_AND_SET_VERBOSE(report_errors, errors[1] > 0);\n  OMPVV_INFOMSG_IF(errors[1] > 0,  \"Target update test when if clause is false failed\");\n\n  OMPVV_REPORT_AND_RETURN(report_errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_capture_omp_affinity.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp parallel\" with directive \"#pragma omp atomic\" at position 923",
        "issue_id": 0,
        "original_code": "//===--- test_capture_omp_affinity.c ----------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks that the omp_capture_affinity() can be used within a \n// parallel region to determine affinity of each thread.\n//\n// Adopted from OpenMP 5.0 Example affinity_display.3.c\n//===------------------------------------------------------------------------===//\n\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <string.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define BUFFER_STORE 80\n\nint main() {\n\n   int i, threads, errors = 0, thrd_num, num_threads = 0;\n   int  format_size = 13; //size of my_format\n   char format[] = \"thrd_num=%0.4n\";\n\n   char **buffer;\n\n   threads = OMPVV_NUM_THREADS_HOST;\n\n   buffer = (char **) malloc( sizeof(char *) * threads );\n\n   for (i = 0; i < threads; i++) { \n      buffer[i] = (char *) malloc( sizeof(char) * BUFFER_STORE); \n   }\n\n   #pragma omp parallel private(thrd_num) num_threads(threads) \n   {\n      thrd_num = omp_get_thread_num();\n      if(thrd_num > threads) { //safety: dont exceed # of buffers\n        OMPVV_ERROR(\"Number of thread greater than requested\");\n        exit(1); \n      }\n\n      if(thrd_num == 0)\n        num_threads = omp_get_num_threads();\n\n      omp_capture_affinity(buffer[thrd_num], (size_t) BUFFER_STORE, format);\n   }\n\n   // Checks if the affinity string is corrrectly captured\n   for(i = 0; i < num_threads; i++) {\n      char str[30];\n      snprintf(str, sizeof(str), \"thrd_num=%0.4d\", i);\n\n      for(int j = 0; j < format_size; ++j) {\n        if(str[j] != buffer[i][j]) {\n          errors++;\n          break;\n        }\n      }\n      free(buffer[i]);\n   }\n\n   free (buffer);\n\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_capture_omp_affinity.c ----------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks that the omp_capture_affinity() can be used within a \n// parallel region to determine affinity of each thread.\n//\n// Adopted from OpenMP 5.0 Example affinity_display.3.c\n//===------------------------------------------------------------------------===//\n\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <string.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define BUFFER_STORE 80\n\nint main() {\n\n   int i, threads, errors = 0, thrd_num, num_threads = 0;\n   int  format_size = 13; //size of my_format\n   char format[] = \"thrd_num=%0.4n\";\n\n   char **buffer;\n\n   threads = OMPVV_NUM_THREADS_HOST;\n\n   buffer = (char **) malloc( sizeof(char *) * threads );\n\n   for (i = 0; i < threads; i++) { \n      buffer[i] = (char *) malloc( sizeof(char) * BUFFER_STORE); \n   }\n\n   #pragma omp atomic private(thrd_num) num_threads(threads) \n   {\n      thrd_num = omp_get_thread_num();\n      if(thrd_num > threads) { //safety: dont exceed # of buffers\n        OMPVV_ERROR(\"Number of thread greater than requested\");\n        exit(1); \n      }\n\n      if(thrd_num == 0)\n        num_threads = omp_get_num_threads();\n\n      omp_capture_affinity(buffer[thrd_num], (size_t) BUFFER_STORE, format);\n   }\n\n   // Checks if the affinity string is corrrectly captured\n   for(i = 0; i < num_threads; i++) {\n      char str[30];\n      snprintf(str, sizeof(str), \"thrd_num=%0.4d\", i);\n\n      for(int j = 0; j < format_size; ++j) {\n        if(str[j] != buffer[i][j]) {\n          errors++;\n          break;\n        }\n      }\n      free(buffer[i]);\n   }\n\n   free (buffer);\n\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_map_pointer_no_map_type_modifier.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp master\" at position 1035",
        "issue_id": 0,
        "original_code": "//===--- test_target_map_pointer_no_map_type_modifier.c -----------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// When map-type-modifier (e.g. to, from and tofrom) are not specified, the \n// default behavior should be tofrom. This test checks if this is the case by\n// creating an array and a pointer to the array. The array and pointer are mapped\n// to the device. The mapped pointer should point to the device array when used\n// inside the omp target region. The array is then changed through the pointer.\n// Array is mapped as tofrom, while pointer is mapped with default value.  \n// \n////===------------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\n// Test that maptype of non-scalar pointer in map clause defaults to tofrom \nint test_default_tofrom() {\n  int compute_array[N];\n  int *p;\t\n  int sum = 0, result = 0, errors = 0;\n  int i;\n \n  for (i = 0; i < N; i++) \n    compute_array[i] = 0;\n  \n  p = &compute_array[0];\n\n#pragma omp target map(p[0:N])\n  {\n    for (i = 0; i < N; i++)\n      p[i] = i;\n  } // end target\n\n  for (i = 0; i < N; i++)\n    sum = sum + compute_array[i];    \n\n  for (i = 0; i < N; i++)\n    result += i;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != sum);\n  \n  return errors; \n}\n\nint main() {\n  int errors = 0;\n    \n  int isOffloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_default_tofrom());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_map_pointer_no_map_type_modifier.c -----------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// When map-type-modifier (e.g. to, from and tofrom) are not specified, the \n// default behavior should be tofrom. This test checks if this is the case by\n// creating an array and a pointer to the array. The array and pointer are mapped\n// to the device. The mapped pointer should point to the device array when used\n// inside the omp target region. The array is then changed through the pointer.\n// Array is mapped as tofrom, while pointer is mapped with default value.  \n// \n////===------------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\n// Test that maptype of non-scalar pointer in map clause defaults to tofrom \nint test_default_tofrom() {\n  int compute_array[N];\n  int *p;\t\n  int sum = 0, result = 0, errors = 0;\n  int i;\n \n  for (i = 0; i < N; i++) \n    compute_array[i] = 0;\n  \n  p = &compute_array[0];\n\n#pragma omp master map(p[0:N])\n  {\n    for (i = 0; i < N; i++)\n      p[i] = i;\n  } // end target\n\n  for (i = 0; i < N; i++)\n    sum = sum + compute_array[i];    \n\n  for (i = 0; i < N; i++)\n    result += i;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != sum);\n  \n  return errors; \n}\n\nint main() {\n  int errors = 0;\n    \n  int isOffloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_default_tofrom());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_allocate.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 864",
        "issue_id": 1,
        "original_code": "//===------ test_target_allocate.c --------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Tests the target directive with allocate clause.\n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_target_allocate() { \n\n   int errors = 0;\n\n   int x = 0;\n   int host_result = 0, device_result = 0;\n\n   for (int i = 0; i < N; i++) {\n      host_result += i;\n   }\n   \n   #pragma omp target uses_allocators(omp_default_mem_alloc) allocate(omp_default_mem_alloc:x) firstprivate(x) map(from: device_result)\n   {\n      for (int i = 0; i < N; i++) {\n         x += i;\n      }\n      device_result = x; \n  \n   }\n   \n   OMPVV_TEST_AND_SET(errors, device_result != host_result);\n   \n   return errors; \n}\n\nint main() {\n\n   OMPVV_TEST_OFFLOADING;\n \n   int errors = 0;\n\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_allocate() != 0);\n\n   OMPVV_REPORT_AND_RETURN(errors);\n\n}\n",
        "error_code": "//===------ test_target_allocate.c --------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Tests the target directive with allocate clause.\n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_target_allocate() { \n\n   int errors = 0;\n\n   int x = 0;\n   int host_result = 0, device_result = 0;\n\n   for (int i = 0; i < N; i++) {\n      host_result += i;\n   }\n   \n   #pragma omp target uses_allocators(omp_default_mem_alloc) allocate(omp_default_mem_alloc:x) firstprivate(x) map(from: device_result)\n   {\n      for (int i = 0; i < N; i++) {\n         x += i;\n      }\n      device_result = x; \n  \n   }\n   \n   OMPVV_TEST_AND_SET(errors, device_result != host_result);\n   \n   return errors; \n}\n\nint main() \n\n   OMPVV_TEST_OFFLOADING;\n \n   int errors = 0;\n\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_allocate() != 0);\n\n   OMPVV_REPORT_AND_RETURN(errors);\n\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_atomic_fail_seq_cst.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp parallel\" with directive \"#pragma omp cancel\" at position 611",
        "issue_id": 0,
        "original_code": "//===--- test_atomic_fail_seq_cst.c -----------------------------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// Utilizes an atomic acquire w/ an atomic release to ensure the implicit\n// setting of x=10. Restrictions on atomic fail state they must be used\n// on an atomic compare.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_atomic_fail_seq_cst() {\n  OMPVV_INFOMSG(\"test_atomic_fail_seq_cst\");\n\n  int x = 0, y = 0;\n  int errors = 0;\n\n#pragma omp parallel num_threads(2)\n   {\n      int thrd = omp_get_thread_num();\n       if (thrd == 0) {\n          y = 1;\n          #pragma omp atomic write seq_cst\n          x = 10;\n       } else {\n          while (y != 5) {\n            #pragma omp atomic compare acquire fail(seq_cst)\n            if(y == 1){\n               y = 5;\n            }\n          }\n          OMPVV_TEST_AND_SET(errors, x != 10);\n          OMPVV_TEST_AND_SET(errors, y != 5);\n       }\n   }\n   return errors;\n}\n\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_atomic_fail_seq_cst());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_atomic_fail_seq_cst.c -----------------------------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// Utilizes an atomic acquire w/ an atomic release to ensure the implicit\n// setting of x=10. Restrictions on atomic fail state they must be used\n// on an atomic compare.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_atomic_fail_seq_cst() {\n  OMPVV_INFOMSG(\"test_atomic_fail_seq_cst\");\n\n  int x = 0, y = 0;\n  int errors = 0;\n\n#pragma omp cancel num_threads(2)\n   {\n      int thrd = omp_get_thread_num();\n       if (thrd == 0) {\n          y = 1;\n          #pragma omp atomic write seq_cst\n          x = 10;\n       } else {\n          while (y != 5) {\n            #pragma omp atomic compare acquire fail(seq_cst)\n            if(y == 1){\n               y = 5;\n            }\n          }\n          OMPVV_TEST_AND_SET(errors, x != 10);\n          OMPVV_TEST_AND_SET(errors, y != 5);\n       }\n   }\n   return errors;\n}\n\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_atomic_fail_seq_cst());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_firstprivate.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp parallel\" with directive \"#pragma omp declare\" at position 637",
        "issue_id": 0,
        "original_code": "//===--test_target_firstprivate.c ------------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n//Testing first private clause with target directive\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define N 10\n\nint main() {\n  int compute_array[OMPVV_NUM_THREADS_HOST][N];\n  int errors = 0;\n  int i,j;\n  int actualNumThreads;\n\n  OMPVV_TEST_OFFLOADING;\n\n  for (i=0; i<OMPVV_NUM_THREADS_HOST; i++) {\n    for (j=0; j<N; j++) {\n      compute_array[i][j] = 0;\n    }\n  }\n\n  omp_set_num_threads(OMPVV_NUM_THREADS_HOST);\n#pragma omp parallel private(i)\n  {\n    int p_val = omp_get_thread_num();\n    actualNumThreads = omp_get_num_threads();\n\n#pragma omp target map(tofrom:compute_array[p_val:1][0:N]) firstprivate(p_val)\n    {\n      for (i = 0; i < N; i++)\n        compute_array[p_val][i] = 100;\n      // Checking if the value is not copied back\n      p_val++;\n    } // End target\n\n    // Checking the results\n    if (p_val == omp_get_thread_num()) {\n      for (i = 0; i < N; i++)\n        compute_array[p_val][i]++;\n    }\n  } //end-parallel\n\n  OMPVV_WARNING_IF(actualNumThreads == 1, \"The number of threads in the host is 1. This tests is inconclusive\");\n  for (i=0; i<actualNumThreads; i++) {\n    for (j=0; j<N; j++){\n      OMPVV_TEST_AND_SET(errors, compute_array[i][j] != 101);\n      OMPVV_ERROR_IF(compute_array[i][j] == 100, \"p_val changed after target region for thread %d\",i);\n    }\n  }//end-for\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--test_target_firstprivate.c ------------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n//Testing first private clause with target directive\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define N 10\n\nint main() {\n  int compute_array[OMPVV_NUM_THREADS_HOST][N];\n  int errors = 0;\n  int i,j;\n  int actualNumThreads;\n\n  OMPVV_TEST_OFFLOADING;\n\n  for (i=0; i<OMPVV_NUM_THREADS_HOST; i++) {\n    for (j=0; j<N; j++) {\n      compute_array[i][j] = 0;\n    }\n  }\n\n  omp_set_num_threads(OMPVV_NUM_THREADS_HOST);\n#pragma omp declare private(i)\n  {\n    int p_val = omp_get_thread_num();\n    actualNumThreads = omp_get_num_threads();\n\n#pragma omp target map(tofrom:compute_array[p_val:1][0:N]) firstprivate(p_val)\n    {\n      for (i = 0; i < N; i++)\n        compute_array[p_val][i] = 100;\n      // Checking if the value is not copied back\n      p_val++;\n    } // End target\n\n    // Checking the results\n    if (p_val == omp_get_thread_num()) {\n      for (i = 0; i < N; i++)\n        compute_array[p_val][i]++;\n    }\n  } //end-parallel\n\n  OMPVV_WARNING_IF(actualNumThreads == 1, \"The number of threads in the host is 1. This tests is inconclusive\");\n  for (i=0; i<actualNumThreads; i++) {\n    for (j=0; j<N; j++){\n      OMPVV_TEST_AND_SET(errors, compute_array[i][j] != 101);\n      OMPVV_ERROR_IF(compute_array[i][j] == 100, \"p_val changed after target region for thread %d\",i);\n    }\n  }//end-for\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_map_pointer.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp master\" at position 1019",
        "issue_id": 0,
        "original_code": "//===--- test_target_map_pointer.c ------------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// This test check if it is possible to map an array and a pointer to that array,\n// and then access the array through the pointer. It is necessary\n// to specify the array size with [:N]. If offloading is used, the value of p[] \n// is copied over the device. The array will be updated inside the omp target\n// region and compared afterwards\n//\n////===----------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nint main() {\n  int compute_array[N];\n  int *p;\n  int sum = 0, result = 0, errors = 0;\n  int i;\n  \n  \n  // Array initialization\n  for (i = 0; i < N; i++)\n    compute_array[i] = 0;\n  p = &compute_array[0];\n\n  int isOffloading;\n\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n\n  OMPVV_WARNING_IF(!isOffloading, \"This test is running on host, the value of p[] is not copied over to the device\"); \n\n#pragma omp target data map(tofrom: compute_array) //To test default pointer behavior, array must be mapped before the pointer\n#pragma omp target map(to: p[:N]) \n  {\n    // Array modified through the pointer\n    for (i = 0; i < N; i++)\n      p[i] = i;\n   \n  } // end target\n\n  // Result comparison\n  for (i = 0; i < N; i++)\n    sum = sum + compute_array[i];    \n  \n  for (i = 0; i < N; i++)\n    result += i;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != sum);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n}\n",
        "error_code": "//===--- test_target_map_pointer.c ------------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// This test check if it is possible to map an array and a pointer to that array,\n// and then access the array through the pointer. It is necessary\n// to specify the array size with [:N]. If offloading is used, the value of p[] \n// is copied over the device. The array will be updated inside the omp target\n// region and compared afterwards\n//\n////===----------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nint main() {\n  int compute_array[N];\n  int *p;\n  int sum = 0, result = 0, errors = 0;\n  int i;\n  \n  \n  // Array initialization\n  for (i = 0; i < N; i++)\n    compute_array[i] = 0;\n  p = &compute_array[0];\n\n  int isOffloading;\n\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n\n  OMPVV_WARNING_IF(!isOffloading, \"This test is running on host, the value of p[] is not copied over to the device\"); \n\n#pragma omp master data map(tofrom: compute_array) //To test default pointer behavior, array must be mapped before the pointer\n#pragma omp target map(to: p[:N]) \n  {\n    // Array modified through the pointer\n    for (i = 0; i < N; i++)\n      p[i] = i;\n   \n  } // end target\n\n  // Result comparison\n  for (i = 0; i < N; i++)\n    sum = sum + compute_array[i];    \n  \n  for (i = 0; i < N; i++)\n    result += i;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != sum);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_device.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===--- test_target_map_devices.c --- target map to multiple devces ---------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n//  This test checks for data mapping on multiple devices when using the target\n//  directive. It makes sure that data mapping is happening on each device\n//  through the use of omp_set_default_device as well as the device() clause\n//\n//  Since OpenMP 4.5 does not have an API call to obtain the current device, \n//  this test does not guarantee that the execution devices are different. \n//  \n//  Last modified by Jose M Monsalve Diaz, December 25, 2019\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nint test_target_device_clause() {\n  OMPVV_INFOMSG(\"test_target_device_clause\");\n\n  // Get number of devices\n  int num_dev = omp_get_num_devices();\n  OMPVV_INFOMSG(\"num_devices tested = %d\", num_dev);\n  \n  int array[N];\n  int errors = 0;\n  \n  // Array initialization\n  for (int i = 0; i < N; ++i) {\n    array[i] = -1;\n  }\n\n  // Map the same array to multiple devices. initialize with device number\n  for (int dev = 0; dev < num_dev; ++dev) {\n#pragma omp target data map(tofrom: array[0:N]) device(dev)\n    { \n    #pragma omp target map(alloc: array[0:N]) device(dev)\n      {\n        for (int i = 0; i < N; ++i) {\n          array[i] += dev + 1;\n        }\n      } // end of omp target \n    } // end of omp target data\n    for (int i = 0; i < N; ++i) {\n      OMPVV_TEST_AND_SET(errors, array[i] != dev);\n      array[i] = -1;\n    }\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_device_clause());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nint kffzurqfel = 19;\nint catkmvkqkq = 44;\nint lsedglzkti = 192;\nint wdgmalyqdg = 1;\nint ouzefljhlr = 88;\nlong lzielecvez = 157;\nbyte tnfuaeqiwo = 38;\nfloat svanxbhunh = 213;\nbyte oaeyeljaci = 23;\nbyte aaspckkjci = 174;\nint xqkoprbcqv = 221;\nshort cpfivqkpnd = 85;\nbyte akcfhmobxf = 192;\nbyte qgkxiwnfjd = 25;\nbyte xfdgagalwj = 106;\nbyte emyzkreudf = 196;\ndouble otpdqpiqnf = 221;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_lastprivate.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1846",
        "issue_id": 1,
        "original_code": "//===--- test_target_teams_distribute_lastprivate.c--------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the lastprivate clause to indicate that the privatized value\n// that is passed as the parameter should also be returned with the value that\n// results from the thread that runs the last iteration of the for loop in the\n// target teams distribute directive.  The clause can be used with both scalar\n// and array data types and both situations are tested.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define SIZE 1024\n\nint main() {\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  int a[SIZE];\n  int b[SIZE];\n  int c[SIZE];\n  int privatized = 0;\n  int privatized_array[2];\n  int errors = 0;\n\n  for (int x = 0; x < SIZE; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    c[x] = 0;\n  }\n\n\n#pragma omp target data map(to: a[0:SIZE], b[0:SIZE]) map(tofrom: c[0:SIZE])\n  {\n#pragma omp target teams distribute lastprivate(privatized) map(alloc: a[0:SIZE], b[0:SIZE], c[0:SIZE]) \\\n  defaultmap(tofrom:scalar)\n    for (int x = 0; x < SIZE; ++x) {\n      privatized = a[x] - b[x];\n      c[x] = privatized + b[x];\n    }\n  }\n\n  for (int x = 0; x < SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, c[x] - a[x] != 0);\n    if (c[x] - a[x] != 0) {\n      break;\n    }\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, privatized != a[SIZE - 1] - b[SIZE - 1]);\n\n  for (int x = 0; x < SIZE; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    c[x] = x % 10;\n  }\n\n#pragma omp target data map(to: a[0:SIZE], b[0:SIZE], c[0:SIZE]) map(tofrom: privatized_array[0:2])\n  {\n#pragma omp target teams distribute lastprivate(privatized_array) map(alloc: a[0:SIZE], b[0:SIZE], c[0:SIZE])\n    for (int x = 0; x < SIZE; ++x) {\n      privatized_array[0] = a[x] + b[x] + c[x];\n      privatized_array[1] = (a[x] + b[x]) * c[x];\n    }\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, privatized_array[0] != (a[SIZE - 1] + b[SIZE - 1] + c[SIZE - 1]));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, privatized_array[1] != ((a[SIZE - 1] + b[SIZE - 1]) * c[SIZE - 1]));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_lastprivate.c--------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the lastprivate clause to indicate that the privatized value\n// that is passed as the parameter should also be returned with the value that\n// results from the thread that runs the last iteration of the for loop in the\n// target teams distribute directive.  The clause can be used with both scalar\n// and array data types and both situations are tested.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define SIZE 1024\n\nint main() {\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  int a[SIZE];\n  int b[SIZE];\n  int c[SIZE];\n  int privatized = 0;\n  int privatized_array[2];\n  int errors = 0;\n\n  for (int x = 0; x < SIZE; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    c[x] = 0;\n  }\n\n\n#pragma omp target data map(to: a[0:SIZE], b[0:SIZE]) map(tofrom: c[0:SIZE])\n  {\n#pragma omp target teams distribute lastprivate(privatized) map(alloc: a[0:SIZE], b[0:SIZE], c[0:SIZE]) \\\n  defaultmap(tofrom:scalar)\n    for (int x = 0; x < SIZE; ++x) {\n      privatized = a[x] - b[x];\n      c[x] = privatized + b[x];\n    }\n  }\n\n  for (int x = 0; x < SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, c[x] - a[x] != 0);\n    if (c[x] - a[x] != 0) {\n      break;\n    }\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, privatized != a[SIZE - 1] - b[SIZE - 1]);\n\n  for (int x = 0; x < SIZE; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    c[x] = x % 10;\n  }\n\n#pragma omp target data map(to: a[0:SIZE], b[0:SIZE], c[0:SIZE]) map(tofrom: privatized_array[0:2])\n  {\n#pragma omp target teams distribute lastprivate(privatized_array) map(alloc: a[0:SIZE], b[0:SIZE], c[0:SIZE])\n    for (int x = 0; x < SIZE; ++x) \n      privatized_array[0] = a[x] + b[x] + c[x];\n      privatized_array[1] = (a[x] + b[x]) * c[x];\n    }\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, privatized_array[0] != (a[SIZE - 1] + b[SIZE - 1] + c[SIZE - 1]));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, privatized_array[1] != ((a[SIZE - 1] + b[SIZE - 1]) * c[SIZE - 1]));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/gridmini_map_class.cpp",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n    OMPVV_TEST_AND_SET(errors,out[n].v[0] != expected.v[0]);\n    OMPVV_TEST_AND_SET(errors,out[n].v[0] != expected.v[1]);\n  }\" at position 1224",
        "issue_id": 4,
        "original_code": "//===-- gridmini_map_struct_array.cpp ---------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks that support for mapping attributes of class object.  \n// This is verified by checking result of mult of array attribute in the \n// offloaded region provides the same answer as calculated on host. \n//\n//===----------------------------------------------------------------------===//\n\n#include <cstdlib>\n#include <stdio.h>\n#include <iostream>\n#include \"ompvv.h\"\n#include \"omp.h\"\n\nusing namespace std;\nclass vec {\n public:\n  float v[2];\n};\n\ninline  vec mult(vec x, vec y){\n  vec out;\n  out.v[0] = x.v[0]*y.v[0];\n  out.v[1] = x.v[1]*y.v[1];\n  return out;\n}\n\nint main(int argc, char* argv[]){\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n  int N = 10;\n  float x = (float)rand()/(float)(RAND_MAX/10.0);\n  float y = (float)rand()/(float)(RAND_MAX/5.0);\n  vec in1,in2;\n  in1.v[0] = x;\n  in1.v[1] = x;\n  in2.v[0] = y;\n  in2.v[1] = y;\n  vec out[N];\n\n  //calulate on host\n  vec expected = mult(in1,in2);\n\n#pragma omp target teams distribute parallel for map(to:in1,in2) map(from:out[0:N])\n    for(int n = 0; n < N; n++) {\n      out[n] = mult(in1,in2);\n    }\n    \n  for(int n = 0; n < N; n++) {\n    OMPVV_TEST_AND_SET(errors,out[n].v[0] != expected.v[0]);\n    OMPVV_TEST_AND_SET(errors,out[n].v[0] != expected.v[1]);\n  }\n\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n}\n\n",
        "error_code": "//===-- gridmini_map_struct_array.cpp ---------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks that support for mapping attributes of class object.  \n// This is verified by checking result of mult of array attribute in the \n// offloaded region provides the same answer as calculated on host. \n//\n//===----------------------------------------------------------------------===//\n\n#include <cstdlib>\n#include <stdio.h>\n#include <iostream>\n#include \"ompvv.h\"\n#include \"omp.h\"\n\nusing namespace std;\nclass vec {\n public:\n  float v[2];\n};\n\ninline  vec mult(vec x, vec y){\n  vec out;\n  out.v[0] = x.v[0]*y.v[0];\n  out.v[1] = x.v[1]*y.v[1];\n  return out;\n}\n\nint main(int argc, char* argv[]){\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n  int N = 10;\n  float x = (float)rand()/(float)(RAND_MAX/10.0);\n  float y = (float)rand()/(float)(RAND_MAX/5.0);\n  vec in1,in2;\n  in1.v[0] = x;\n  in1.v[1] = x;\n  in2.v[0] = y;\n  in2.v[1] = y;\n  vec out[N];\n\n  //calulate on host\n  vec expected = mult(in1,in2);\n\n#pragma omp target teams distribute parallel for map(to:in1,in2) map(from:out[0:N])\n    for(int n = 0; n < N; n++) {\n      out[n] = mult(in1,in2);\n    }\n    \n  for(int n = 0; n < N; n++) \n\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_requires_unified_shared_memory_stack.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp requires\" with directive \"#pragma omp map\" at position 635",
        "issue_id": 0,
        "original_code": "//===---test_requires_unified_shared_memory_stack.c ------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Testing memory access from host and device to a variable allocated in the stack\n// The variable is accessed through a pointer to guarantee that there is no default\n// mapping tofrom: of the stack array\n//\n// Default mapping of the pointer should translate into the host pointer value, which\n// should be accessible from the device\n//\n////===----------------------------------------------------------------------===//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp requires unified_shared_memory\n\nint unified_shared_memory_stack() {\n  OMPVV_INFOMSG(\"Unified shared memory testing - Array on stack\");\n  int errors = 0;\n  \n  int anArray[N];\n  int anArrayCopy[N];\n  int * aPtr = anArray;\n\n  for (int i = 0; i < N; i++) {\n    anArray[i] = i;\n    anArrayCopy[i] = 0;\n  }\n\n  // Test for writes to this varriable from device\n#pragma omp target \n  {\n    for (int i = 0; i < N; i++) {\n      aPtr[i] += 10;\n    }\n  }\n  // Modify again on the host\n  for (int i = 0; i < N; i++) {\n    aPtr[i] += 10;\n  }\n\n  // Test for reads to this variable from device\n#pragma omp target \n  {\n    for (int i = 0; i < N; i++) {\n      anArrayCopy[i] = aPtr[i];\n    }\n  }\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArray[i] != i + 20);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArrayCopy[i] != i + 20);\n    if (errors) break;\n  }\n  return errors;\n}\n\nint main() {\n  int isOffloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"With no offloading, unified shared memory is guaranteed due to host execution\");\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, unified_shared_memory_stack());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---test_requires_unified_shared_memory_stack.c ------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Testing memory access from host and device to a variable allocated in the stack\n// The variable is accessed through a pointer to guarantee that there is no default\n// mapping tofrom: of the stack array\n//\n// Default mapping of the pointer should translate into the host pointer value, which\n// should be accessible from the device\n//\n////===----------------------------------------------------------------------===//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp map unified_shared_memory\n\nint unified_shared_memory_stack() {\n  OMPVV_INFOMSG(\"Unified shared memory testing - Array on stack\");\n  int errors = 0;\n  \n  int anArray[N];\n  int anArrayCopy[N];\n  int * aPtr = anArray;\n\n  for (int i = 0; i < N; i++) {\n    anArray[i] = i;\n    anArrayCopy[i] = 0;\n  }\n\n  // Test for writes to this varriable from device\n#pragma omp target \n  {\n    for (int i = 0; i < N; i++) {\n      aPtr[i] += 10;\n    }\n  }\n  // Modify again on the host\n  for (int i = 0; i < N; i++) {\n    aPtr[i] += 10;\n  }\n\n  // Test for reads to this variable from device\n#pragma omp target \n  {\n    for (int i = 0; i < N; i++) {\n      anArrayCopy[i] = aPtr[i];\n    }\n  }\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArray[i] != i + 20);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArrayCopy[i] != i + 20);\n    if (errors) break;\n  }\n  return errors;\n}\n\nint main() {\n  int isOffloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"With no offloading, unified shared memory is guaranteed due to host execution\");\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, unified_shared_memory_stack());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_simd_nontemporal.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp simd\" with directive \"#pragma omp atomic\" at position 801",
        "issue_id": 0,
        "original_code": "//===--- test_simd_nontemporal.c -----------------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//  \n// This test checks for support of the nontemporal clause on a simd construct. \n// The nontemporal clause indicates that accesses to the storage location of list \n// items have low temporal locality across the iterations in which those storage \n// locations are accessed. \n//  \n////===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1028\n#define STRIDE_LEN 100\n\nint test_simd_nontemporal() {\n   int errors = 0;\n   int i;\n   int a[N], b[N], c[N];\n\n   for (i = 0; i < N; i++) {\n      a[i] = 10; \n      b[i] = i;\n      c[i] = 2 * i;\n   }   \n\n   #pragma omp simd nontemporal (a, b, c)\n      for (i = 0; i < N; i += STRIDE_LEN) {\n         a[i] = b[i] * c[i];\n      }   \n\n   for (i = 0; i < N; i++) {\n      if (i % STRIDE_LEN == 0) { \n         OMPVV_TEST_AND_SET(errors, a[i] != (b[i] * c[i]));\n      } else { \n\t OMPVV_TEST_AND_SET(errors, a[i] != 10);\n      }\n   }   \n\n   return errors;\n}\n\nint main () {\n   int errors = 0;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_simd_nontemporal())\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n\n",
        "error_code": "//===--- test_simd_nontemporal.c -----------------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//  \n// This test checks for support of the nontemporal clause on a simd construct. \n// The nontemporal clause indicates that accesses to the storage location of list \n// items have low temporal locality across the iterations in which those storage \n// locations are accessed. \n//  \n////===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1028\n#define STRIDE_LEN 100\n\nint test_simd_nontemporal() {\n   int errors = 0;\n   int i;\n   int a[N], b[N], c[N];\n\n   for (i = 0; i < N; i++) {\n      a[i] = 10; \n      b[i] = i;\n      c[i] = 2 * i;\n   }   \n\n   #pragma omp atomic nontemporal (a, b, c)\n      for (i = 0; i < N; i += STRIDE_LEN) {\n         a[i] = b[i] * c[i];\n      }   \n\n   for (i = 0; i < N; i++) {\n      if (i % STRIDE_LEN == 0) { \n         OMPVV_TEST_AND_SET(errors, a[i] != (b[i] * c[i]));\n      } else { \n\t OMPVV_TEST_AND_SET(errors, a[i] != 10);\n      }\n   }   \n\n   return errors;\n}\n\nint main () {\n   int errors = 0;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_simd_nontemporal())\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_data_pointer_swap.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===--- test_target_data_pointer_swap.c------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test swaps two pointers' values inside a target data region, testing\n// that the map clauses are applied to their original list items. The address\n// used at the entrance to the data region should be the same used at the exit\n// of the region to copy the data back.\n//\n////===---------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_pointer_swap() {\n  int* a = (int *) malloc(N * sizeof(int));\n  int* b = (int *) malloc(N * sizeof(int));\n  int* temp;\n  int is_offloading;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n    b[x] = 0;\n  }\n\n#pragma omp target data map(tofrom: a[0:N]) map(to: b[0:N])\n  {\n#pragma omp target map(alloc: a[0:N], b[0:N])\n    for (int x = 0; x < N; ++x) {\n      b[x] = a[x]*2;\n    }\n    temp = a;\n    a = b;\n    b = temp;\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET(errors, b[x] != x);\n    if (is_offloading) {\n      OMPVV_TEST_AND_SET(errors, a[x] != 0);\n    } else {\n      OMPVV_TEST_AND_SET(errors, a[x] != 2*x);\n    }\n  }\n\n  free(a);\n  free(b);\n\n  return errors;\n}\n\nint test_pointer_swap_with_update() {\n  int* a = (int *) malloc(N * sizeof(int));\n  int* b = (int *) malloc(N * sizeof(int));\n  int* temp;\n  int errors = 0;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n    b[x] = 0;\n  }\n\n#pragma omp target data map(tofrom: a[0:N]) map(to: b[0:N])\n  {\n#pragma omp target map(alloc: a[0:N], b[0:N])\n    for (int x = 0; x < N; ++x) {\n      b[x] = a[x]*2;\n    }\n\n    temp = a;\n    a = b;\n    b = temp;\n\n#pragma omp target update from(a[0:N])\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET(errors, b[x] != x);\n    OMPVV_TEST_AND_SET(errors, a[x] != 2*x);\n  }\n\n  free(a);\n  free(b);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_pointer_swap());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_pointer_swap_with_update());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nshort qhhptelfrn = 249;\nfloat qgaiazicpv = 168;\ndouble lyoumuzbvu = 117;\nint badefnwkxn = 37;\nlong fyfqaepnxz = 73;\nlong qulqptzxbn = 16;\nshort amswnvpsnl = 69;\nint rmhdutfzgw = 60;\ndouble twahkjfcwq = 249;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_loop_nested_device.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_loop_nested_teams());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_loop_nested_parallel());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 2921",
        "issue_id": 4,
        "original_code": "//===--- test_loop_nested_device.c ------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the loop directive without any clauses with nested loops.\n// The construct is applied in a teams and a parallel construct and the\n// correctness of array operations in the nested loops in the loop construct\n// is checked. Compare with test_loop_bind.c, which performs the same\n// operations in a nested loop with a bind clause. This test checks the above\n// all in an offloading (target) context.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 32\n\nint test_loop_nested_teams() {\n  OMPVV_INFOMSG(\"test_loop_nested_teams\");\n  int errors = 0;\n  int x[N][N];\n  int y[N];\n  int z[N];\n  int num_teams = -1;\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      x[i][j] = 1;\n    }\n    y[i] = i;\n    z[i] = 2*i;\n  }\n\n#pragma omp target teams num_teams(OMPVV_NUM_TEAMS_DEVICE) thread_limit(OMPVV_NUM_THREADS_HOST) map(tofrom: x, y, z, num_teams)\n  {\n#pragma omp loop\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        x[i][j] += y[i]*z[i];\n      }\n    }\n    #pragma omp parallel if(0)\n    if (omp_get_team_num() == 0) {\n      num_teams = omp_get_num_teams();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, x[i][j] != 1 + (y[i]*z[i]));\n    }\n  }\n\n\n  OMPVV_WARNING_IF(num_teams == 1, \"Test ran with one team, so parallelism of loop construct can't be guaranteed.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_teams < 1);\n  OMPVV_ERROR_IF(num_teams < 1, \"omp_get_num_teams() returned an invalid number of teams.\");\n\n  return errors;\n}\n\nint test_loop_nested_parallel() {\n  OMPVV_INFOMSG(\"test_loop_nested_parallel\");\n  int errors = 0;\n  int x[N][N];\n  int y[N];\n  int z[N];\n  int num_threads = -1;\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      x[i][j] = 1;\n    }\n    y[i] = i;\n    z[i] = 2*i;\n  }\n\n#pragma omp target parallel num_threads(OMPVV_NUM_THREADS_HOST) map(tofrom: x, y, z, num_threads)\n  {\n#pragma omp loop\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        x[i][j] += y[i]*z[i];\n      }\n    }\n    if (omp_get_thread_num() == 0 && omp_get_team_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, x[i][j] != 1 + (y[i]*z[i]));\n    }\n  }\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of loop construct can't be guaranteed.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n  OMPVV_ERROR_IF(num_threads < 1, \"omp_get_num_threads() returned an invalid number of threads.\");\n\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_loop_nested_teams());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_loop_nested_parallel());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_loop_nested_device.c ------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the loop directive without any clauses with nested loops.\n// The construct is applied in a teams and a parallel construct and the\n// correctness of array operations in the nested loops in the loop construct\n// is checked. Compare with test_loop_bind.c, which performs the same\n// operations in a nested loop with a bind clause. This test checks the above\n// all in an offloading (target) context.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 32\n\nint test_loop_nested_teams() {\n  OMPVV_INFOMSG(\"test_loop_nested_teams\");\n  int errors = 0;\n  int x[N][N];\n  int y[N];\n  int z[N];\n  int num_teams = -1;\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      x[i][j] = 1;\n    }\n    y[i] = i;\n    z[i] = 2*i;\n  }\n\n#pragma omp target teams num_teams(OMPVV_NUM_TEAMS_DEVICE) thread_limit(OMPVV_NUM_THREADS_HOST) map(tofrom: x, y, z, num_teams)\n  {\n#pragma omp loop\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        x[i][j] += y[i]*z[i];\n      }\n    }\n    #pragma omp parallel if(0)\n    if (omp_get_team_num() == 0) {\n      num_teams = omp_get_num_teams();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, x[i][j] != 1 + (y[i]*z[i]));\n    }\n  }\n\n\n  OMPVV_WARNING_IF(num_teams == 1, \"Test ran with one team, so parallelism of loop construct can't be guaranteed.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_teams < 1);\n  OMPVV_ERROR_IF(num_teams < 1, \"omp_get_num_teams() returned an invalid number of teams.\");\n\n  return errors;\n}\n\nint test_loop_nested_parallel() {\n  OMPVV_INFOMSG(\"test_loop_nested_parallel\");\n  int errors = 0;\n  int x[N][N];\n  int y[N];\n  int z[N];\n  int num_threads = -1;\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      x[i][j] = 1;\n    }\n    y[i] = i;\n    z[i] = 2*i;\n  }\n\n#pragma omp target parallel num_threads(OMPVV_NUM_THREADS_HOST) map(tofrom: x, y, z, num_threads)\n  {\n#pragma omp loop\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        x[i][j] += y[i]*z[i];\n      }\n    }\n    if (omp_get_thread_num() == 0 && omp_get_team_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, x[i][j] != 1 + (y[i]*z[i]));\n    }\n  }\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of loop construct can't be guaranteed.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n  OMPVV_ERROR_IF(num_threads < 1, \"omp_get_num_threads() returned an invalid number of threads.\");\n\n  return errors;\n}\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_master_taskloop.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp parallel\" with directive \"#pragma omp declare\" at position 732",
        "issue_id": 0,
        "original_code": "//===--- test_master_taskloop.c ---------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the master taskloop directive in a parallel region. The\n// test performs simple operations on an int array which are then checked for\n// correctness.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_master_taskloop() {\n  OMPVV_INFOMSG(\"test_master_taskloop\");\n  int errors = 0;\n  int num_threads = -1;\n  int x[N];\n  int y[N];\n  int z[N];\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 1;\n    y[i] = i + 1;\n    z[i] = 2*(i + 1);\n  }\n\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST) shared(x, y, z, num_threads)\n  {\n#pragma omp master taskloop\n    for (int i = 0; i < N; i++) {\n      x[i] += y[i]*z[i];\n    }\n    if (omp_get_thread_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != 1 + (y[i]*z[i]));\n  }\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of taskloop can't be guaranteed.\");\n  OMPVV_ERROR_IF(num_threads < 1, \"Test returned an invalid number of threads.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n\n  return errors;\n}\n\n\nint main() {\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_master_taskloop());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_master_taskloop.c ---------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the master taskloop directive in a parallel region. The\n// test performs simple operations on an int array which are then checked for\n// correctness.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_master_taskloop() {\n  OMPVV_INFOMSG(\"test_master_taskloop\");\n  int errors = 0;\n  int num_threads = -1;\n  int x[N];\n  int y[N];\n  int z[N];\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 1;\n    y[i] = i + 1;\n    z[i] = 2*(i + 1);\n  }\n\n#pragma omp declare num_threads(OMPVV_NUM_THREADS_HOST) shared(x, y, z, num_threads)\n  {\n#pragma omp master taskloop\n    for (int i = 0; i < N; i++) {\n      x[i] += y[i]*z[i];\n    }\n    if (omp_get_thread_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != 1 + (y[i]*z[i]));\n  }\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of taskloop can't be guaranteed.\");\n  OMPVV_ERROR_IF(num_threads < 1, \"Test returned an invalid number of threads.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n\n  return errors;\n}\n\n\nint main() {\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_master_taskloop());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_task_target_default_firstprivate.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp cancel\" at position 781",
        "issue_id": 0,
        "original_code": "//------------test_task_target_default_firstprivate.c------------\n//\n// OpenMP API Version 5.1 Aug 2021\n//\n// Tests the behavior of the default clause when the specified\n// data-sharing attribute is firstprivate. This test focuses on\n// the use of the task and target constructs. Firstprivate should\n// allow any data initialzed outside the task region to return to\n// its original value after being manipulated within the task region.\n// --------------------------------------------------------------//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint errors;\n\nint test_default_firstprivate_task(){\n\tint test_num = 1;\n\tint test_arr[N];\n\tint sum = 0;\n\tfor (int i = 0; i<N; i++){\n\t\ttest_arr[i] = i;\n\t\tsum += i;\n\t}\n\n\t#pragma omp target map(tofrom: test_num, test_arr)\n\t{\n\t\t#pragma omp task default(firstprivate)\n\t\t{\n\t\t\ttest_num += 1;\n\t\t\tfor (int i = 0; i<N; i++){\n\t\t\t\ttest_arr[i] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tint new_sum = 0;\n\tint wrong_sum = 0; \n\tfor (int i = 0; i<N; i++){\n\t\tnew_sum += test_arr[i];\n\t\twrong_sum += 1;\n\t}\n\n\tOMPVV_TEST_AND_SET(errors, test_num != 1);\n\tOMPVV_INFOMSG_IF(test_num == 2, \"Scalar was not firstprivate, changes made in task affected original copy\");\n\tOMPVV_TEST_AND_SET(errors, sum != new_sum);\n\tOMPVV_INFOMSG_IF(new_sum == wrong_sum, \"Array was not firstprivate, changes made in task affected original copy\");\n\treturn errors;\n}\n\nint main(){\n\terrors = 0;\n\tOMPVV_TEST_OFFLOADING;\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_default_firstprivate_task() != 0);\n\tOMPVV_REPORT_AND_RETURN(errors);\n\n}\n",
        "error_code": "//------------test_task_target_default_firstprivate.c------------\n//\n// OpenMP API Version 5.1 Aug 2021\n//\n// Tests the behavior of the default clause when the specified\n// data-sharing attribute is firstprivate. This test focuses on\n// the use of the task and target constructs. Firstprivate should\n// allow any data initialzed outside the task region to return to\n// its original value after being manipulated within the task region.\n// --------------------------------------------------------------//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint errors;\n\nint test_default_firstprivate_task(){\n\tint test_num = 1;\n\tint test_arr[N];\n\tint sum = 0;\n\tfor (int i = 0; i<N; i++){\n\t\ttest_arr[i] = i;\n\t\tsum += i;\n\t}\n\n\t#pragma omp cancel map(tofrom: test_num, test_arr)\n\t{\n\t\t#pragma omp task default(firstprivate)\n\t\t{\n\t\t\ttest_num += 1;\n\t\t\tfor (int i = 0; i<N; i++){\n\t\t\t\ttest_arr[i] = 1;\n\t\t\t}\n\t\t}\n\t}\n\n\tint new_sum = 0;\n\tint wrong_sum = 0; \n\tfor (int i = 0; i<N; i++){\n\t\tnew_sum += test_arr[i];\n\t\twrong_sum += 1;\n\t}\n\n\tOMPVV_TEST_AND_SET(errors, test_num != 1);\n\tOMPVV_INFOMSG_IF(test_num == 2, \"Scalar was not firstprivate, changes made in task affected original copy\");\n\tOMPVV_TEST_AND_SET(errors, sum != new_sum);\n\tOMPVV_INFOMSG_IF(new_sum == wrong_sum, \"Array was not firstprivate, changes made in task affected original copy\");\n\treturn errors;\n}\n\nint main(){\n\terrors = 0;\n\tOMPVV_TEST_OFFLOADING;\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_default_firstprivate_task() != 0);\n\tOMPVV_REPORT_AND_RETURN(errors);\n\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_requires_dynamic_allocators.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1599",
        "issue_id": 1,
        "original_code": "//===------ test_requires_dynamic_allocators.c ----------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Tests the requires dynamic allocators clause by working with an OMP\n// allocator inside a target region. Allocators testing is based on the\n// OpenMP 5.0 example for allocators. The allocator testing first creates\n// an allocator, with 64-byte alignment and the default memory space,\n// then checks that 64-byte alignment is correct and that the memory can\n// be written to in the target region. The tests checks that the values\n// were written correctly, and then frees the memory and deletes the\n// allocator.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#pragma omp requires dynamic_allocators\n\n#define N 1024\n\nint test_requires() {\n  int saved_x[N];\n  int errors = 0;\n\n#pragma omp target map(from: saved_x)\n  {\n    int* x;\n    omp_memspace_handle_t x_memspace = omp_default_mem_space;\n    omp_alloctrait_t x_traits[1] = {{omp_atk_alignment, 64}};\n    omp_allocator_handle_t x_alloc = omp_init_allocator(x_memspace, 1, x_traits);\n\n    x = (int *) omp_alloc(N*sizeof(int), x_alloc);\n\n#pragma omp parallel for simd simdlen(16) aligned(x: 64)\n    for (int i = 0; i < N; i++) {\n      x[i] = i;\n    }\n\n    for (int i = 0; i < N; i++) {\n      saved_x[i] = x[i];\n    }\n\n    omp_free(x, x_alloc);\n    omp_destroy_allocator(x_alloc);\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, saved_x[i] != i);\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_requires() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===------ test_requires_dynamic_allocators.c ----------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Tests the requires dynamic allocators clause by working with an OMP\n// allocator inside a target region. Allocators testing is based on the\n// OpenMP 5.0 example for allocators. The allocator testing first creates\n// an allocator, with 64-byte alignment and the default memory space,\n// then checks that 64-byte alignment is correct and that the memory can\n// be written to in the target region. The tests checks that the values\n// were written correctly, and then frees the memory and deletes the\n// allocator.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#pragma omp requires dynamic_allocators\n\n#define N 1024\n\nint test_requires() {\n  int saved_x[N];\n  int errors = 0;\n\n#pragma omp target map(from: saved_x)\n  {\n    int* x;\n    omp_memspace_handle_t x_memspace = omp_default_mem_space;\n    omp_alloctrait_t x_traits[1] = {{omp_atk_alignment, 64}};\n    omp_allocator_handle_t x_alloc = omp_init_allocator(x_memspace, 1, x_traits);\n\n    x = (int *) omp_alloc(N*sizeof(int), x_alloc);\n\n#pragma omp parallel for simd simdlen(16) aligned(x: 64)\n    for (int i = 0; i < N; i++) {\n      x[i] = i;\n    }\n\n    for (int i = 0; i < N; i++) {\n      saved_x[i] = x[i];\n    }\n\n    omp_free(x, x_alloc);\n    omp_destroy_allocator(x_alloc);\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, saved_x[i] != i);\n  }\n\n  return errors;\n}\n\nint main() \n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_requires() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_thread_limit.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===---------------- test_target_teams_thread_limit.c -----------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// This test uses the thread_limit clause on the teams construct. The test validates \n// that only the specified threads are created by summing a shared variable across \n// all threads in a team. If the threads are correctly limited, this should produce \n// the expected value. Additional warnings are sent if specific issues occur.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main() {\n\tint errors[OMPVV_NUM_TEAMS_DEVICE];\n\tint num_teams = 0;\n        int sum_errors = 0;\n        int i;\n\tint testing_thread_limit = OMPVV_NUM_THREADS_DEVICE/OMPVV_NUM_TEAMS_DEVICE;\n\n\tif (testing_thread_limit == 1)\n\t  testing_thread_limit = 2;\n\n\tOMPVV_TEST_OFFLOADING;\n      \n\n         for (i = 0; i<OMPVV_NUM_TEAMS_DEVICE; i++){\n              errors[i] = 0;\n         }\n \n\t#pragma omp target map(tofrom:num_teams,errors)\n\t{\n\t\t#pragma omp teams num_teams(OMPVV_NUM_TEAMS_DEVICE) thread_limit(testing_thread_limit)\n\t\t{\n\t\t\t#pragma omp parallel\n\t\t\t{\n\t\t\t\tif (omp_get_team_num() == 0 && omp_get_thread_num() == 0) {\n\t\t\t\t\tnum_teams = omp_get_num_teams();\n\t\t\t\t}\n\n\t\t\t\tif ((omp_get_thread_num() == 0) && (omp_get_team_num() < OMPVV_NUM_TEAMS_DEVICE)) {\n\t\t\t\t\tif (omp_get_num_threads() > testing_thread_limit) {\n\t\t\t\t\t\terrors[omp_get_team_num()] += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\tfor (i = 0; i<OMPVV_NUM_TEAMS_DEVICE; i++){\n             sum_errors += errors[i];\n        }\n\n\tOMPVV_WARNING_IF(num_teams != OMPVV_NUM_TEAMS_DEVICE, \"The number of teams was unexpected, the test results are likely inconclusive\");\n\tOMPVV_WARNING_IF(testing_thread_limit == 1, \"Only one thread was allocated to each team, the test results are likely inconclusive\");\n\n\tOMPVV_REPORT_AND_RETURN(sum_errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nfloat uczemtswep = 157;\ndouble mmohlwcura = 178;\nlong tvxvxbrabx = 233;\nint nhaqsnvskk = 129;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_loop_reduction_bitand.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp parallel\" with directive \"#pragma omp teams\" at position 1500",
        "issue_id": 0,
        "original_code": "//===--- test_loop_reduction_bitand.c ---------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the reduction clause on a loop directive, testing that the\n// variable in the reduction clause is properly reduced using the bitand\n// operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n#define THRESHOLD 512\n\nint test_bitand() {\n  unsigned int a[N];\n  double false_margin = pow(exp(1), log(.5)/N); // See the 'and' operator test for\n  int errors = 0;                               // an exaplantion of this math.\n  int num_threads[N];\n  int num_attempts = 0;\n  int have_true = 0, have_false = 0;\n  srand(1);\n\n  while ((!have_true || !have_false) && (num_attempts < THRESHOLD)) {\n    have_true = 0;\n    have_false = 0;\n    for (int x = 0; x < N; ++x) {\n      if( num_attempts == 0 ) {\n        a[x] = 0;\n      }\n      for (int y = 0; y < 16; ++y) {\n        if (rand() / (double) RAND_MAX < false_margin) {\n          a[x] += (1 << y);\n          have_true = 1;\n        } else {\n          have_false = 1;\n        }\n      }\n      num_threads[x] = -x;\n    }\n    num_attempts++;\n  }\n\n  OMPVV_WARNING_IF(!have_true, \"No true bits were generated to test\");\n  OMPVV_WARNING_IF(!have_false, \"No false bits were generated to test\");\n\n  unsigned int b = 0;\n  for (int x = 0; x < 16; ++x) {\n    b = b + (1 << x);\n  }\n\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST)\n  {\n#pragma omp loop reduction(&:b)\n    for (int x = 0; x < N; ++x) {\n      b = b & a[x];\n    }\n#pragma omp for\n    for (int x = 0; x < N; ++x) {\n      num_threads[x] = omp_get_num_threads();\n    }\n  }\n\n  unsigned int host_b = a[0];\n\n  for (int x = 0; x < N; ++x) {\n    host_b = host_b & a[x];\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_threads[x - 1] != num_threads[x], \"Test reported differing numbers of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_threads[0] == 1, \"Test operated with one thread.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_threads[0] <= 0, \"Test reported invalid number of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, b != host_b);\n  OMPVV_ERROR_IF(host_b != b, \"Bit from loop directive is %d but expected bit is %d.\", b, host_b);\n\n  return errors;\n}\n\nint main() {\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_bitand() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n",
        "error_code": "//===--- test_loop_reduction_bitand.c ---------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the reduction clause on a loop directive, testing that the\n// variable in the reduction clause is properly reduced using the bitand\n// operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n#define THRESHOLD 512\n\nint test_bitand() {\n  unsigned int a[N];\n  double false_margin = pow(exp(1), log(.5)/N); // See the 'and' operator test for\n  int errors = 0;                               // an exaplantion of this math.\n  int num_threads[N];\n  int num_attempts = 0;\n  int have_true = 0, have_false = 0;\n  srand(1);\n\n  while ((!have_true || !have_false) && (num_attempts < THRESHOLD)) {\n    have_true = 0;\n    have_false = 0;\n    for (int x = 0; x < N; ++x) {\n      if( num_attempts == 0 ) {\n        a[x] = 0;\n      }\n      for (int y = 0; y < 16; ++y) {\n        if (rand() / (double) RAND_MAX < false_margin) {\n          a[x] += (1 << y);\n          have_true = 1;\n        } else {\n          have_false = 1;\n        }\n      }\n      num_threads[x] = -x;\n    }\n    num_attempts++;\n  }\n\n  OMPVV_WARNING_IF(!have_true, \"No true bits were generated to test\");\n  OMPVV_WARNING_IF(!have_false, \"No false bits were generated to test\");\n\n  unsigned int b = 0;\n  for (int x = 0; x < 16; ++x) {\n    b = b + (1 << x);\n  }\n\n#pragma omp teams num_threads(OMPVV_NUM_THREADS_HOST)\n  {\n#pragma omp loop reduction(&:b)\n    for (int x = 0; x < N; ++x) {\n      b = b & a[x];\n    }\n#pragma omp for\n    for (int x = 0; x < N; ++x) {\n      num_threads[x] = omp_get_num_threads();\n    }\n  }\n\n  unsigned int host_b = a[0];\n\n  for (int x = 0; x < N; ++x) {\n    host_b = host_b & a[x];\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_threads[x - 1] != num_threads[x], \"Test reported differing numbers of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_threads[0] == 1, \"Test operated with one thread.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_threads[0] <= 0, \"Test reported invalid number of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, b != host_b);\n  OMPVV_ERROR_IF(host_b != b, \"Bit from loop directive is %d but expected bit is %d.\", b, host_b);\n\n  return errors;\n}\n\nint main() {\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_bitand() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_parallel_loop_lastprivate.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n    OMPVV_TEST_OFFLOADING;\n    int errors = 0;\n\n    OMPVV_TEST_AND_SET_VERBOSE(errors, \n\t\t    test_target_parallel_loop_collapse_lastprivate());\n\n    OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 1616",
        "issue_id": 4,
        "original_code": "//===---------------test_target_parallel_loop_lastprivate.c---------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Description - This is a test program to demonstrate how lastprivate clause\n// is used with target parallel loop construct.\n//\n////===----------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define DIM_1 10\n#define DIM_2 10\n#define DIM_3 12\n\nint test_target_parallel_loop_collapse_lastprivate() {\n    OMPVV_INFOMSG(\"test_target_parallel_loop_collapse_lastprivate\");\n    int arr[DIM_1][DIM_2][DIM_3];\n    int errors = 0;\n    int i, j, k;\n    int temp = 0;\n\n    // arr initialization\n    for (i = 0; i < DIM_1; i++) {\n        for (j = 0; j < DIM_2; j++) {\n            for (k = 0; k < DIM_3; k++) {\n                arr[i][j][k] = 1;\n            }\n        }\n    }\n\n    #pragma omp target parallel loop collapse(3) lastprivate(i, j, k) \\\n                map(tofrom: arr)\n    for (i = 0; i < DIM_1; i++) {\n        for (j = 0; j < DIM_2; j++) {\n            for (k = i; k < DIM_3; k++) {\n                arr[i][j][k] += i+2*j+3*k;\n            }\n        }\n    }\n\n    OMPVV_TEST_AND_SET_VERBOSE(errors, i != DIM_1);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, j != DIM_2);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, k != DIM_3);\n\n    // validation\n    for (i = 0; i < DIM_1; i++) {\n        for (j = 0; j < DIM_2; j++) {\n            for (k = i; k < DIM_3; k++) {\n                temp = 1 + i + 2*j + 3*k;\n\n                OMPVV_TEST_AND_SET(errors, arr[i][j][k] != temp);\n            }\n        }\n    }\n\n    return errors;\n}\n\nint main() {\n    OMPVV_TEST_OFFLOADING;\n    int errors = 0;\n\n    OMPVV_TEST_AND_SET_VERBOSE(errors, \n\t\t    test_target_parallel_loop_collapse_lastprivate());\n\n    OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---------------test_target_parallel_loop_lastprivate.c---------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Description - This is a test program to demonstrate how lastprivate clause\n// is used with target parallel loop construct.\n//\n////===----------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define DIM_1 10\n#define DIM_2 10\n#define DIM_3 12\n\nint test_target_parallel_loop_collapse_lastprivate() {\n    OMPVV_INFOMSG(\"test_target_parallel_loop_collapse_lastprivate\");\n    int arr[DIM_1][DIM_2][DIM_3];\n    int errors = 0;\n    int i, j, k;\n    int temp = 0;\n\n    // arr initialization\n    for (i = 0; i < DIM_1; i++) {\n        for (j = 0; j < DIM_2; j++) {\n            for (k = 0; k < DIM_3; k++) {\n                arr[i][j][k] = 1;\n            }\n        }\n    }\n\n    #pragma omp target parallel loop collapse(3) lastprivate(i, j, k) \\\n                map(tofrom: arr)\n    for (i = 0; i < DIM_1; i++) {\n        for (j = 0; j < DIM_2; j++) {\n            for (k = i; k < DIM_3; k++) {\n                arr[i][j][k] += i+2*j+3*k;\n            }\n        }\n    }\n\n    OMPVV_TEST_AND_SET_VERBOSE(errors, i != DIM_1);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, j != DIM_2);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, k != DIM_3);\n\n    // validation\n    for (i = 0; i < DIM_1; i++) {\n        for (j = 0; j < DIM_2; j++) {\n            for (k = i; k < DIM_3; k++) {\n                temp = 1 + i + 2*j + 3*k;\n\n                OMPVV_TEST_AND_SET(errors, arr[i][j][k] != temp);\n            }\n        }\n    }\n\n    return errors;\n}\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_depend_list.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 1256",
        "issue_id": 2,
        "original_code": "//===--- test_target_teams_distribute_depend_list.c---------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks for dependency between multiple out-dependent tasks by\n// checking order-dependent results from pairs of possibly asynchronous loops\n// The test fails if any required dependency is broken.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_target_teams_distribute_depend_list() {\n  int isOffloading = 0;\n  int errors = 0;\n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int e[N];\n  int f[N];\n  int g[N];\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n    b[x] = 2 * x;\n    c[x] = 0;\n    d[x] = 0;\n    e[x] = 0;\n    f[x] = 0;\n    g[x] = 0;\n  }\n\n#pragma omp target data map(to: a[0:N], b[0:N]) map(alloc: c[0:N], d[0:N], e[0:N]) map(from: f[0:N], g[0:N])\n  {\n#pragma omp target teams distribute nowait depend(out: c) map(alloc: a[0:N], b[0:N], c[0:N])\n    for (int x = 0; x < N; ++x) {\n      c[x] = a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(out: d) map(alloc: a[0:N], b[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n      d[x] = a[x] + b[x] + x;\n    }\n#pragma omp target teams distribute nowait depend(out: c, d, e) map(alloc: c[0:N], d[0:N], e[0:N])\n    for (int x = 0; x < N; ++x) {\n      e[x] = c[x] + d[x];\n    }\n#pragma omp target teams distribute nowait depend(out: e) map(alloc: a[0:N], e[0:N], f[0:N])\n    for (int x = 0; x < N; ++x) {\n      f[x] = e[x] + a[x];\n    }\n#pragma omp target teams distribute nowait depend(out: e) map(alloc: b[0:N], e[0:N], g[0:N])\n    for (int x = 0; x < N; ++x) {\n      g[x] = e[x] + b[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_ERROR_IF(f[x] != 8*x || g[x] != 9*x, \"Test of depend clause using multiple dependencies did not pass with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n    OMPVV_TEST_AND_SET_VERBOSE(errors, f[x] != 8*x || g[x] != 9*x);\n  }\n\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  errors += test_target_teams_distribute_depend_list();\n  OMPVV_INFOMSG_IF(errors != 0, \"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_depend_list.c---------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks for dependency between multiple out-dependent tasks by\n// checking order-dependent results from pairs of possibly asynchronous loops\n// The test fails if any required dependency is broken.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_target_teams_distribute_depend_list() {\n  int isOffloading = 0;\n  int errors = 0;\n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int e[N];\n  int f[N];\n  int g[N];\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n    b[x] = 2 * x;\n    c[x] = 0;\n    d[x] = 0;\n    e[x] = 0;\n    f[x] = 0;\n    g[x] = 0;\n  }\n\n#pragma omp target data map(to: a[0:N], b[0:N]) map(alloc: c[0:N], d[0:N], e[0:N]) map(from: f[0:N], g[0:N])\n  {\n#pragma omp target teams distribute nowait depend(out: c) map(alloc: a[0:N], b[0:N], c[0:N])\n    for (int x = 0; x < N; ++x) {\n      c[x] = a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(out: d) map(alloc: a[0:N], b[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n      d[x] = a[x] + b[x] + x;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n    }\n#pragma omp target teams distribute nowait depend(out: c, d, e) map(alloc: c[0:N], d[0:N], e[0:N])\n    for (int x = 0; x < N; ++x) {\n      e[x] = c[x] + d[x];\n    }\n#pragma omp target teams distribute nowait depend(out: e) map(alloc: a[0:N], e[0:N], f[0:N])\n    for (int x = 0; x < N; ++x) {\n      f[x] = e[x] + a[x];\n    }\n#pragma omp target teams distribute nowait depend(out: e) map(alloc: b[0:N], e[0:N], g[0:N])\n    for (int x = 0; x < N; ++x) {\n      g[x] = e[x] + b[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_ERROR_IF(f[x] != 8*x || g[x] != 9*x, \"Test of depend clause using multiple dependencies did not pass with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n    OMPVV_TEST_AND_SET_VERBOSE(errors, f[x] != 8*x || g[x] != 9*x);\n  }\n\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  errors += test_target_teams_distribute_depend_list();\n  OMPVV_INFOMSG_IF(errors != 0, \"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_requires_unified_shared_memory.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 695",
        "issue_id": 2,
        "original_code": "//===---test_requires_unified_shared_memory.c -------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n// \n// This test just uses requries unified_shared_memory in a simple target region\n// and it is intended to show that this would not break anything in the compiler\n//\n////===----------------------------------------------------------------------===//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp requires unified_shared_memory\n\nint unified_shared_memory() {\n  OMPVV_INFOMSG(\"Unified shared memory testing\");\n  int errors = 0;\n  \n  int aVariable = 0;\n#pragma omp target map(tofrom:aVariable)\n  {\n    aVariable += 10;\n  }\n\n  aVariable += 10;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, aVariable != 20);\n  return errors;\n}\n\nint main() {\n  int isOffloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"With no offloading, unified shared memory is guaranteed due to host execution\");\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, unified_shared_memory());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---test_requires_unified_shared_memory.c -------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n// \n// This test just uses requries unified_shared_memory in a simple target region\n// and it is intended to show that this would not break anything in the compiler\n//\n////===----------------------------------------------------------------------===//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp requires unified_shared_memory\n\nint unified_shared_memory() {\n  OMPVV_INFOMSG(\"Unified shared memory testing\");\n  int errors = 0;\n  \n  int aVariable = 0;\n#pragma omp target map(tofrom:aVariable)\n  {\n    aVariable += 10;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n  }\n\n  aVariable += 10;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, aVariable != 20);\n  return errors;\n}\n\nint main() {\n  int isOffloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"With no offloading, unified shared memory is guaranteed due to host execution\");\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, unified_shared_memory());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_update_to.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===--- test_target_update_to.c ------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks target update with the 'to' clause by checking that\n// after a target update to is applied to an array, the device reads and\n// uses the expected, new value rather than the previous value.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint a[N];\nint b[N];\nint c[N];\n\nvoid update_b() {\n  int i;\n  for (i = 0; i < N; i++) {\n    b[i] = b[i] * 2;\n  }\n}\n\n// Test for OpenMP 4.5 target update with to\nint main() {\n  int errors= 0;\n  int i = 0;\n\n  OMPVV_TEST_OFFLOADING;\n\n  for (i = 0; i < N; i++) {\n    a[i] = 10;\n    b[i] = 2;\n    c[i] = 0;\n  }\n\n#pragma omp target data map(to: a[:N], b[:N]) map(from: c)\n  {\n#pragma omp target\n    {\n      int j = 0;\n      for (j = 0; j < N; j++) {\n        c[j] = (a[j] + b[j]);        // c = 12\n      }\n    }\n\n    update_b();\n\n#pragma omp target update to(b[:N])  // update b = 4\n\n#pragma omp target\n    {\n      int j = 0;\n      for (j = 0; j < N; j++) {\n        c[j] = (c[j] + b[j]);        // c = 16\n      }\n    }\n  }\n\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, c[i] != 16);\n  }\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nint acckslkztq = 140;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_declare_indirect.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 1286",
        "issue_id": 2,
        "original_code": "//----------------test_target_declare_indirect.c-----------------\n//\n// OpenMP API Version 5.1 Mar 2023\n//\n// This test intends to test the functionality of an indirect\n// declare target region. A random int is chosen that correlates\n// to a function pointer. That function is then chosen and the \n// test ensures it runs as expected.\n// --------------------------------------------------------------\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\ntypedef int(*funcptr)();\n\nint fun1(){\n\treturn 5;\n}\n\nint fun2(){\n\treturn 10;\n}\n\nint fun3(){\n\treturn 15;\n}\n#pragma omp declare target to(fun1, fun2, fun3) indirect\n\nint test_declare_target_indirect(){\n\n        funcptr fptr;\n\tint errors = 0;\n        int fun_choice = rand() % 3; //will give either 0, 1 or 2\n\tint ret_val, result;\n        \n\tif(!fun_choice){\n\t  fptr = &fun1;\n\t  result = 5;\n\t}\n\t  \n\tif(fun_choice == 1){\n\t  fptr = &fun2;\n\t  result = 10;\n\t}\n\t  \n\tif(fun_choice == 3){\n\t  fptr = &fun3;\n\t  result = 15;\n\t}\t\n\t  \n\t#pragma omp target map(from: ret_val)\n\t  ret_val = fptr();\n\t  \n        OMPVV_TEST_AND_SET(errors, ret_val != result);\n\treturn errors;\n}\n\n\n\nint main(){\n\n  int errors = 0;\n  OMPVV_TEST_OFFLOADING;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_declare_target_indirect() != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n\t\n}\n",
        "error_code": "//----------------test_target_declare_indirect.c-----------------\n//\n// OpenMP API Version 5.1 Mar 2023\n//\n// This test intends to test the functionality of an indirect\n// declare target region. A random int is chosen that correlates\n// to a function pointer. That function is then chosen and the \n// test ensures it runs as expected.\n// --------------------------------------------------------------\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\ntypedef int(*funcptr)();\n\nint fun1(){\n\treturn 5;\n}\n\nint fun2(){\n\treturn 10;\n}\n\nint fun3(){\n\treturn 15;\n}\n#pragma omp declare target to(fun1, fun2, fun3) indirect\n\nint test_declare_target_indirect(){\n\n        funcptr fptr;\n\tint errors = 0;\n        int fun_choice = rand() % 3; //will give either 0, 1 or 2\n\tint ret_val, result;\n        \n\tif(!fun_choice){\n\t  fptr = &fun1;\n\t  result = 5;\n\t}\n\t  \n\tif(fun_choice == 1){\n\t  fptr = &fun2;\n\t  result = 10;\n\t}\n\t  \n\tif(fun_choice == 3){\n\t  fptr = &fun3;\n\t  result = 15;\n\t}\t\n\t  \n\t#pragma omp target map(from: ret_val)\n\t  ret_val = fptr();\n\t  \n        OMPVV_TEST_AND_SET(errors, ret_val != result);\n\treturn errors;\n}\n\n\n\nint main(){\n\n  int errors = 0;\n  OMPVV_TEST_OFFLOADING;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_declare_target_indirect() != 0);yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n  OMPVV_REPORT_AND_RETURN(errors);\n\t\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_parallel_for_map_tofrom.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp single\" at position 1121",
        "issue_id": 0,
        "original_code": "//===---- test_target_teams_distribute_parallel_for_map_tofrom.c - combined consutrct -===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// Testing the map clause with the tofrom map-modifier, for the combined construct\n// target teams distribute parallel for.\n// Scalar mapping has to be divided between to and from. Otherwise there will be \n// data races between the threads that are writting the scalar and those that are reading\n// from it\n//\n//===-----------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define N 2000\n\nint test_target_teams_distribute_parallel_for_map_tofrom() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_map_tofrom\");\n  \n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int scalar_to = 50; //to avoid datarace on the scalar due to read and write in the loop\n  int scalar_from = 50;\n  int errors = 0;\n  int i, j, dev;\n\n\n  // variables initialization\n  scalar_to = 50;\n  scalar_from = 50;\n  for (i = 0; i < N; i++) {\n    a[i] = 1;\n    b[i] = i;\n    c[i] = 2*i;\n    d[i] = 0;\n  }\n\n    // Tests\n#pragma omp target teams distribute parallel for map(tofrom: a, b, c, d, scalar_to, scalar_from)\n  for (j = 0; j < N; ++j) {\n    d[j] += c[j] * (a[j] + b[j] + scalar_to);\n    a[j] = 10;\n    b[j] = 11;\n    c[j] = 12;\n#pragma omp atomic write\n    scalar_from = 13; // This is to avoid data races on a single scalar\n  }\n\n  // Checking the results\n  OMPVV_TEST_AND_SET(errors, scalar_from != 13);\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, a[i] != 10);\n    OMPVV_TEST_AND_SET(errors, b[i] != 11);\n    OMPVV_TEST_AND_SET(errors, c[i] != 12);\n    OMPVV_TEST_AND_SET(errors, d[i] != (1 + i + 50) * 2*i);\n  }\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_map_tofrom());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_teams_distribute_parallel_for_map_tofrom.c - combined consutrct -===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// Testing the map clause with the tofrom map-modifier, for the combined construct\n// target teams distribute parallel for.\n// Scalar mapping has to be divided between to and from. Otherwise there will be \n// data races between the threads that are writting the scalar and those that are reading\n// from it\n//\n//===-----------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define N 2000\n\nint test_target_teams_distribute_parallel_for_map_tofrom() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_map_tofrom\");\n  \n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int scalar_to = 50; //to avoid datarace on the scalar due to read and write in the loop\n  int scalar_from = 50;\n  int errors = 0;\n  int i, j, dev;\n\n\n  // variables initialization\n  scalar_to = 50;\n  scalar_from = 50;\n  for (i = 0; i < N; i++) {\n    a[i] = 1;\n    b[i] = i;\n    c[i] = 2*i;\n    d[i] = 0;\n  }\n\n    // Tests\n#pragma omp single teams distribute parallel for map(tofrom: a, b, c, d, scalar_to, scalar_from)\n  for (j = 0; j < N; ++j) {\n    d[j] += c[j] * (a[j] + b[j] + scalar_to);\n    a[j] = 10;\n    b[j] = 11;\n    c[j] = 12;\n#pragma omp atomic write\n    scalar_from = 13; // This is to avoid data races on a single scalar\n  }\n\n  // Checking the results\n  OMPVV_TEST_AND_SET(errors, scalar_from != 13);\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, a[i] != 10);\n    OMPVV_TEST_AND_SET(errors, b[i] != 11);\n    OMPVV_TEST_AND_SET(errors, c[i] != 12);\n    OMPVV_TEST_AND_SET(errors, d[i] != (1 + i + 50) * 2*i);\n  }\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_map_tofrom());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_depend_array_section.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp parallel\" at position 846",
        "issue_id": 0,
        "original_code": "//===--- test_target_teams_distribute_depend_array_section.c-----------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks if out-out dependency works even if the data in the list\n// is an array section. Both tasks are given the nowait clause to allow\n// for the possibility that they will be incorrectly run out of order. If the\n// two target teams ditribute loops run out of order, the test fails.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_target_teams_distribute_depend_array_section() {\n  int isOffloading = 0;\n  int errors = 0;\n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n    b[x] = 2 * x;\n    c[x] = 0;\n    d[x] = 0;\n  }\n\n#pragma omp target data map(to: a[0:N], b[0:N]) map(alloc: c[0:N]) map(from: d[0:N])\n  {\n#pragma omp target teams distribute nowait depend(out: c[0:N]) map(alloc: a[0:N], b[0:N], c[0:N])\n    for (int x = 0; x < N; ++x) {\n      c[x] = a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(out: c[0:N]) map(alloc: b[0:N], c[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n      d[x] = c[x] + b[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_ERROR_IF(d[x] != 5*x, \"Test of depend clause using array sections did not pass with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n    OMPVV_TEST_AND_SET_VERBOSE(errors, d[x] != 5*x);\n    if (d[x] != 5*x) {\n      break;\n    }\n  }\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  errors += test_target_teams_distribute_depend_array_section();\n  OMPVV_INFOMSG_IF(errors != 0, \"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_depend_array_section.c-----------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks if out-out dependency works even if the data in the list\n// is an array section. Both tasks are given the nowait clause to allow\n// for the possibility that they will be incorrectly run out of order. If the\n// two target teams ditribute loops run out of order, the test fails.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_target_teams_distribute_depend_array_section() {\n  int isOffloading = 0;\n  int errors = 0;\n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n    b[x] = 2 * x;\n    c[x] = 0;\n    d[x] = 0;\n  }\n\n#pragma omp parallel data map(to: a[0:N], b[0:N]) map(alloc: c[0:N]) map(from: d[0:N])\n  {\n#pragma omp target teams distribute nowait depend(out: c[0:N]) map(alloc: a[0:N], b[0:N], c[0:N])\n    for (int x = 0; x < N; ++x) {\n      c[x] = a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(out: c[0:N]) map(alloc: b[0:N], c[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n      d[x] = c[x] + b[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_ERROR_IF(d[x] != 5*x, \"Test of depend clause using array sections did not pass with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n    OMPVV_TEST_AND_SET_VERBOSE(errors, d[x] != 5*x);\n    if (d[x] != 5*x) {\n      break;\n    }\n  }\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  errors += test_target_teams_distribute_depend_array_section();\n  OMPVV_INFOMSG_IF(errors != 0, \"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_full_loop_unroll.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1470",
        "issue_id": 1,
        "original_code": "//===--- test_full_loop_unroll.c -----------------------------------------------===//\n//\n// OpenMP API Version 5.1 August 2021 \n//\n// This test checks the behavior of the 5.1 unroll construct (2.11.9.2 in 5.1 spec). \n// \"The unroll construct fully or partially unrolls a loop\", which is more of a code generation\n// compiler feature. \n// This test specifically checks the unroll construct with the full clause, in which the \n// loop will be completely unrolled.\n// Referenced 5.1 Example Doc 7.2 \n////===--------------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n# define N 1024\n\nint errors; \n\nint test_full_loop_unroll() {\n\tint arr[N];\n\tint parallel_arr[N];\n\tint sum = 0;\n\tint parallel_sum = 0;\n\n\t// sequential loop\n\tfor (int i = 0; i < N; i++) {\n\t\tarr[i] = i;\n\t\tsum += arr[i];\n\t}\n\n\t// omp unroll full loop\n# pragma omp unroll full\n\tfor (int i = 0; i < N; i++) {\n\t\tparallel_arr[i] = i;\n\t}\n\n\t// sequential sum of parallel array\n\tfor (int i = 0; i < N; i++) {\n\t\tparallel_sum += parallel_arr[i];\n\t}\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, parallel_sum != sum);\n\tOMPVV_INFOMSG_IF(sum == 0, \"Array was not initialized.\");\n\tOMPVV_INFOMSG_IF(parallel_sum == 0, \"Something went wrong with loop unroll.\");\n\tOMPVV_INFOMSG_IF(parallel_sum == sum, \"Test passed.\");\n\tOMPVV_INFOMSG_IF(parallel_sum != sum, \"Test did not pass.\");\n\treturn errors;\n}\n\nint main() {\n\terrors = 0;\n\tOMPVV_TEST_OFFLOADING;\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_full_loop_unroll() != 0);\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_full_loop_unroll.c -----------------------------------------------===//\n//\n// OpenMP API Version 5.1 August 2021 \n//\n// This test checks the behavior of the 5.1 unroll construct (2.11.9.2 in 5.1 spec). \n// \"The unroll construct fully or partially unrolls a loop\", which is more of a code generation\n// compiler feature. \n// This test specifically checks the unroll construct with the full clause, in which the \n// loop will be completely unrolled.\n// Referenced 5.1 Example Doc 7.2 \n////===--------------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n# define N 1024\n\nint errors; \n\nint test_full_loop_unroll() {\n\tint arr[N];\n\tint parallel_arr[N];\n\tint sum = 0;\n\tint parallel_sum = 0;\n\n\t// sequential loop\n\tfor (int i = 0; i < N; i++) {\n\t\tarr[i] = i;\n\t\tsum += arr[i];\n\t}\n\n\t// omp unroll full loop\n# pragma omp unroll full\n\tfor (int i = 0; i < N; i++) {\n\t\tparallel_arr[i] = i;\n\t}\n\n\t// sequential sum of parallel array\n\tfor (int i = 0; i < N; i++) {\n\t\tparallel_sum += parallel_arr[i];\n\t}\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, parallel_sum != sum);\n\tOMPVV_INFOMSG_IF(sum == 0, \"Array was not initialized.\");\n\tOMPVV_INFOMSG_IF(parallel_sum == 0, \"Something went wrong with loop unroll.\");\n\tOMPVV_INFOMSG_IF(parallel_sum == sum, \"Test passed.\");\n\tOMPVV_INFOMSG_IF(parallel_sum != sum, \"Test did not pass.\");\n\treturn errors;\n}\n\nint main() \n\terrors = 0;\n\tOMPVV_TEST_OFFLOADING;\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_full_loop_unroll() != 0);\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_allocate_allocator_align.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp allocate(x)\" with directive \"#pragma omp master\" at position 784",
        "issue_id": 0,
        "original_code": "//===------ test_allocate_allocator_align.c ------------------------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// Tests the allocate directive with allocator and align clause.\n// The declarative allocator statement uses the omp_default_mem_alloc handle\n// for default memory allocation for \"x\", aligned to 64-byte alignment via the \n// align clause. Parallel region checks that 64-byte alignment is correct \n// and that the memory can be written to in and the values\n// were written correctly, and then frees the memory.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_allocate_allocator_align() {\n  int errors = 0;\n\n  int x[N];\n\n#pragma omp allocate(x) allocator(omp_default_mem_alloc) align(64)\n\n\n#pragma omp target map(from:x[:N])\n{\t\n#pragma omp parallel for simd simdlen(16) aligned(x: 64)\n  for (int i = 0; i < N; i++) {\n    x[i] = i;\n  }\n}\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != i);\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_allocate_allocator_align() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===------ test_allocate_allocator_align.c ------------------------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// Tests the allocate directive with allocator and align clause.\n// The declarative allocator statement uses the omp_default_mem_alloc handle\n// for default memory allocation for \"x\", aligned to 64-byte alignment via the \n// align clause. Parallel region checks that 64-byte alignment is correct \n// and that the memory can be written to in and the values\n// were written correctly, and then frees the memory.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_allocate_allocator_align() {\n  int errors = 0;\n\n  int x[N];\n\n#pragma omp master allocator(omp_default_mem_alloc) align(64)\n\n\n#pragma omp target map(from:x[:N])\n{\t\n#pragma omp parallel for simd simdlen(16) aligned(x: 64)\n  for (int i = 0; i < N; i++) {\n    x[i] = i;\n  }\n}\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != i);\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_allocate_allocator_align() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_loop_order_reproducible.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n    \t\tOMPVV_TEST_AND_SET(errors, y[i] != i + 4);\n\t}\" at position 1054",
        "issue_id": 4,
        "original_code": "//===------------ test_loop_for_order_reproducible.c -------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// This test checks that the order(reproducible:concurrent) clause is properly handled.\n// Leverages the previous array item to determine if the same threads executed\n// in the same order over the array. If both arrays match the test passes, \n// if not it fails as the reproducible clause failed.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main() {\n\tint errors = 0;\n\tint x[N];\n\tint y[N];\n\n\tfor (int i = 0; i < N; i++) {\n\t\tx[i] = i;\n\t\ty[i] = i;\n\t}\n\n\tOMPVV_TEST_OFFLOADING;\n\n\t#pragma omp target map(tofrom: x,y)\n\t{\n\n\t   #pragma omp parallel \n\t   {\n\t\t#pragma omp loop order(reproducible:concurrent) \n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tx[i] = x[i] + 2;\t\n\t\t}\n\n\t\t#pragma omp loop order(reproducible:concurrent)\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\ty[i] = x[i] + 2;\n\t\t}\n\t    }\n\t}\n\n\tfor (int i = 0; i < N; i++) {\n    \t\tOMPVV_TEST_AND_SET(errors, y[i] != i + 4);\n\t}\n\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===------------ test_loop_for_order_reproducible.c -------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// This test checks that the order(reproducible:concurrent) clause is properly handled.\n// Leverages the previous array item to determine if the same threads executed\n// in the same order over the array. If both arrays match the test passes, \n// if not it fails as the reproducible clause failed.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main() {\n\tint errors = 0;\n\tint x[N];\n\tint y[N];\n\n\tfor (int i = 0; i < N; i++) {\n\t\tx[i] = i;\n\t\ty[i] = i;\n\t}\n\n\tOMPVV_TEST_OFFLOADING;\n\n\t#pragma omp target map(tofrom: x,y)\n\t{\n\n\t   #pragma omp parallel \n\t   {\n\t\t#pragma omp loop order(reproducible:concurrent) \n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tx[i] = x[i] + 2;\t\n\t\t}\n\n\t\t#pragma omp loop order(reproducible:concurrent)\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\ty[i] = x[i] + 2;\n\t\t}\n\t    }\n\t}\n\n\tfor (int i = 0; i < N; i++) \n\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_declare_target_end_declare_target.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp declare\" with directive \"#pragma omp flush\" at position 564",
        "issue_id": 0,
        "original_code": "//===------ test_declare_target_end_declare_target.c ----------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// The test verifies that the variable and function enclosed between declare \n// target and end declare target are available inside the target region.\n// Updates using the enclosed function are made inside the target region and\n// results are verified on the host.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp declare target\nint aint = 10;\nvoid compute_array(int a[N], int b[N], int c[N]) {\n  for (int i = 0; i < N; i++) {\n    a[i] = b[i]*c[i] + aint * i;\n  }\n  return;\n}\n#pragma omp end declare target\n\nint test_declare_target() {\n\n  OMPVV_INFOMSG(\"test_declare_target_end_declare_target\");\n\n  int errors = 0;\n  int x[N];\n  int y[N];\n  int z[N];\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 0;\n    y[i] = 1;\n    z[i] = i;\n  }\n\n#pragma omp target map(tofrom: x) map(to:y, z)\n  {\n    compute_array(x, y, z);\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != (y[i] * z[i] + 10 * i));\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_declare_target() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===------ test_declare_target_end_declare_target.c ----------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// The test verifies that the variable and function enclosed between declare \n// target and end declare target are available inside the target region.\n// Updates using the enclosed function are made inside the target region and\n// results are verified on the host.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp flush target\nint aint = 10;\nvoid compute_array(int a[N], int b[N], int c[N]) {\n  for (int i = 0; i < N; i++) {\n    a[i] = b[i]*c[i] + aint * i;\n  }\n  return;\n}\n#pragma omp end declare target\n\nint test_declare_target() {\n\n  OMPVV_INFOMSG(\"test_declare_target_end_declare_target\");\n\n  int errors = 0;\n  int x[N];\n  int y[N];\n  int z[N];\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 0;\n    y[i] = 1;\n    z[i] = i;\n  }\n\n#pragma omp target map(tofrom: x) map(to:y, z)\n  {\n    compute_array(x, y, z);\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != (y[i] * z[i] + 10 * i));\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_declare_target() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_loop_reduction_subtract.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp parallel\" with directive \"#pragma omp teams\" at position 706",
        "issue_id": 0,
        "original_code": "//===--- test_loop_reduction_subtract.c --------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the reduction clause on a loop directive, testing that the\n// variable in the reduction clause is properly reduced using the subtract\n// operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_subtraction() {\n  int a[N];\n  int b[N];\n  int total = 0;\n  int host_total = 0;\n  int errors = 0;\n  int num_threads[N];\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    num_threads[x] = -x;\n  }\n\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST)\n  {\n#pragma omp loop reduction(-:total)\n    for (int x = 0; x < N; ++x) {\n      total -= a[x] + b[x];\n    }\n#pragma omp for\n    for (int x = 0; x < N; ++x) {\n      num_threads[x] = omp_get_num_threads();\n    }\n  }\n\n  for (int x = 0; x < N; ++x) {\n    host_total -= a[x] + b[x];\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_threads[x - 1] != num_threads[x], \"Test reported differing numbers of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_threads[0] == 1, \"Test operated with one thread.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_threads[0] <= 0, \"Test reported invalid number of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, host_total != total);\n  OMPVV_ERROR_IF(host_total != total, \"Total from loop directive is %d but expected total is %d.\", total, host_total);\n\n  return errors;\n}\n\nint main() {\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_subtraction() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n",
        "error_code": "//===--- test_loop_reduction_subtract.c --------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the reduction clause on a loop directive, testing that the\n// variable in the reduction clause is properly reduced using the subtract\n// operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_subtraction() {\n  int a[N];\n  int b[N];\n  int total = 0;\n  int host_total = 0;\n  int errors = 0;\n  int num_threads[N];\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    num_threads[x] = -x;\n  }\n\n#pragma omp teams num_threads(OMPVV_NUM_THREADS_HOST)\n  {\n#pragma omp loop reduction(-:total)\n    for (int x = 0; x < N; ++x) {\n      total -= a[x] + b[x];\n    }\n#pragma omp for\n    for (int x = 0; x < N; ++x) {\n      num_threads[x] = omp_get_num_threads();\n    }\n  }\n\n  for (int x = 0; x < N; ++x) {\n    host_total -= a[x] + b[x];\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_threads[x - 1] != num_threads[x], \"Test reported differing numbers of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_threads[0] == 1, \"Test operated with one thread.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_threads[0] <= 0, \"Test reported invalid number of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, host_total != total);\n  OMPVV_ERROR_IF(host_total != total, \"Total from loop directive is %d but expected total is %d.\", total, host_total);\n\n  return errors;\n}\n\nint main() {\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_subtraction() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_private.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===--- test_target_teams_distribute_private.c------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the private clause on a target teams distribute directive to\n// indicate that the variable in the private clause should be made private to\n// each team executing the teams distribute region.  The test then operates on\n// the privatized variable in such a way that would most likely cause competing\n// operations if the variable is not privatized.  If the computation completes\n// without errors, we assume that the privatization occured.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define SIZE 1024\n\nint main() {\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  int a[SIZE];\n  int b[SIZE];\n  int c[SIZE];\n  int d[SIZE];\n  int privatized;\n  int errors = 0;\n  int num_teams = -1;\n\n  for (int x = 0; x < SIZE; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    c[x] = 2*x;\n    d[x] = 0;\n  }\n\n#pragma omp target data map(from: d[0:SIZE]) map(to: a[0:SIZE], b[0:SIZE], c[0:SIZE])\n  {\n#pragma omp target teams distribute private(privatized) map(alloc: a[0:SIZE], b[0:SIZE], c[0:SIZE], d[0:SIZE]) map(tofrom: num_teams) num_teams(OMPVV_NUM_TEAMS_DEVICE)\n    for (int x = 0; x < SIZE; ++x) {\n      if (omp_get_team_num() == 0) {\n        num_teams = omp_get_num_teams();\n      }\n      privatized = 0;\n      for (int y = 0; y < a[x] + b[x]; ++y) {\n        privatized++;\n      }\n      d[x] = c[x] * privatized;\n    }\n  }\n\n  for (int x = 0; x < SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, d[x] != (1 + x)*2*x);\n    if (d[x] != (1 + x)*2*x) {\n      break;\n    }\n  }\n\n  OMPVV_WARNING_IF(num_teams == 1, \"Test ran with one team. Results of private test are inconclusive.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_teams < 1);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nfloat nnqfsvzajc = 86;\nfloat zvymjxlkzm = 117;\ndouble hwhkcwrfpb = 18;\nint ptyerzwbtm = 243;\ndouble ytbhbkjemz = 113;\nfloat ddlztexlql = 61;\nbyte iztuhltsko = 248;\ndouble hfyxxobhau = 87;\ndouble lqlaujgbrb = 134;\nshort vvdpunimkk = 251;\nbyte cldievcdnu = 204;\ndouble omzynwfxzf = 224;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_loop_reduction_bitand_device.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 2592",
        "issue_id": 1,
        "original_code": "//===--- test_loop_reduction_bitand_device.c --------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the reduction clause on a loop directive, testing that the\n// variable in the reduction clause is properly reduced using the bitand\n// operator. This test checks the above in a target context.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n#define THRESHOLD 512\n\nint test_bitand() {\n  unsigned int a[N];\n  double false_margin = pow(exp(1), log(.5)/N); // See the 'and' operator test for\n  int errors = 0;                               // an exaplantion of this math.\n  int num_threads[N];\n  int num_attempts = 0;\n  int have_true = 0, have_false = 0;\n  srand(1);\n\n  while ((!have_true || !have_false) && (num_attempts < THRESHOLD)) {\n    have_true = 0;\n    have_false = 0;\n    for (int x = 0; x < N; ++x) {\n      if( num_attempts == 0 ) {\n        a[x] = 0;\n      }\n      for (int y = 0; y < 16; ++y) {\n        if (rand() / (double) RAND_MAX < false_margin) {\n          a[x] += (1 << y);\n          have_true = 1;\n        } else {\n          have_false = 1;\n        }\n      }\n      num_threads[x] = -x;\n    }\n    num_attempts++;\n  }\n\n  OMPVV_WARNING_IF(!have_true, \"No true bits were generated to test\");\n  OMPVV_WARNING_IF(!have_false, \"No false bits were generated to test\");\n\n  unsigned int b = 0;\n  for (int x = 0; x < 16; ++x) {\n    b = b + (1 << x);\n  }\n\n#pragma omp target parallel num_threads(OMPVV_NUM_THREADS_DEVICE) map(tofrom: a, b, num_threads)\n  {\n#pragma omp loop reduction(&:b)\n    for (int x = 0; x < N; ++x) {\n      b = b & a[x];\n    }\n#pragma omp for\n    for (int x = 0; x < N; ++x) {\n      num_threads[x] = omp_get_num_threads();\n    }\n  }\n\n  unsigned int host_b = a[0];\n\n  for (int x = 0; x < N; ++x) {\n    host_b = host_b & a[x];\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_threads[x - 1] != num_threads[x], \"Test reported differing numbers of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_threads[0] == 1, \"Test operated with one thread.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_threads[0] <= 0, \"Test reported invalid number of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, b != host_b);\n  OMPVV_ERROR_IF(host_b != b, \"Bit from loop directive is %d but expected bit is %d.\", b, host_b);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_bitand() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n",
        "error_code": "//===--- test_loop_reduction_bitand_device.c --------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the reduction clause on a loop directive, testing that the\n// variable in the reduction clause is properly reduced using the bitand\n// operator. This test checks the above in a target context.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n#define THRESHOLD 512\n\nint test_bitand() {\n  unsigned int a[N];\n  double false_margin = pow(exp(1), log(.5)/N); // See the 'and' operator test for\n  int errors = 0;                               // an exaplantion of this math.\n  int num_threads[N];\n  int num_attempts = 0;\n  int have_true = 0, have_false = 0;\n  srand(1);\n\n  while ((!have_true || !have_false) && (num_attempts < THRESHOLD)) {\n    have_true = 0;\n    have_false = 0;\n    for (int x = 0; x < N; ++x) {\n      if( num_attempts == 0 ) {\n        a[x] = 0;\n      }\n      for (int y = 0; y < 16; ++y) {\n        if (rand() / (double) RAND_MAX < false_margin) {\n          a[x] += (1 << y);\n          have_true = 1;\n        } else {\n          have_false = 1;\n        }\n      }\n      num_threads[x] = -x;\n    }\n    num_attempts++;\n  }\n\n  OMPVV_WARNING_IF(!have_true, \"No true bits were generated to test\");\n  OMPVV_WARNING_IF(!have_false, \"No false bits were generated to test\");\n\n  unsigned int b = 0;\n  for (int x = 0; x < 16; ++x) {\n    b = b + (1 << x);\n  }\n\n#pragma omp target parallel num_threads(OMPVV_NUM_THREADS_DEVICE) map(tofrom: a, b, num_threads)\n  {\n#pragma omp loop reduction(&:b)\n    for (int x = 0; x < N; ++x) {\n      b = b & a[x];\n    }\n#pragma omp for\n    for (int x = 0; x < N; ++x) {\n      num_threads[x] = omp_get_num_threads();\n    }\n  }\n\n  unsigned int host_b = a[0];\n\n  for (int x = 0; x < N; ++x) {\n    host_b = host_b & a[x];\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_threads[x - 1] != num_threads[x], \"Test reported differing numbers of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_threads[0] == 1, \"Test operated with one thread.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_threads[0] <= 0, \"Test reported invalid number of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, b != host_b);\n  OMPVV_ERROR_IF(host_b != b, \"Bit from loop directive is %d but expected bit is %d.\", b, host_b);\n\n  return errors;\n}\n\nint main() \n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_bitand() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/declare_target_base_class.cpp",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp declare\" with directive \"#pragma omp target\" at position 542",
        "issue_id": 0,
        "original_code": "//===--- declare_target_base_class.cpp --------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// This test was suggested by members of NERSC. This test defines a declare\n// target region which includes only a base class and a 'concrete' device\n// pointer. \n// \n// Test suggestion comes from Chris Daily and Rahulkumar Gayatri from NERSC\n////===----------------------------------------------------------------------===//\n\n#include <new>\n#include <vector>\n#include <iostream>\n#include \"ompvv.h\"\n#include <omp.h>\n\n#pragma omp declare target\nclass S {\npublic:\n  S() : _devPtr(nullptr) {}\n  double sag(double x, double y) {\n    return x + y;\n  }\n  S* cloneToDevice() {\n    S* ptr;\n#pragma omp target map(ptr)\n    {\n      ptr = new S();\n    }\n    _devPtr = ptr;\n    return ptr;\n  }\nprivate:\n  S* _devPtr;\n};\n#pragma omp end declare target\n\nint main() {\n  int errors = 0;\n  \n  OMPVV_TEST_OFFLOADING;\n\n  S s;\n  S* devPtr = s.cloneToDevice();\n\n  std::vector<double> in(10, 0.0);\n  for(int i = 0; i < 10; i++) {\n    in[i] = i;\n  }\n\n  std::vector<double> out(10, 0.0);\n\n  double* inptr = in.data();\n  double* outptr = out.data();\n\n#pragma omp target teams distribute parallel for map(inptr[:10], outptr[:10]) is_device_ptr(devPtr)\n  for(int i = 0; i < 10; i++) {\n    outptr[i] = devPtr->sag(inptr[i], inptr[i]);\n  }\n\n  for(int i = 0; i < 10; i++) {\n    OMPVV_TEST_AND_SET(errors, out[i] != i*2)\n  }\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- declare_target_base_class.cpp --------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// This test was suggested by members of NERSC. This test defines a declare\n// target region which includes only a base class and a 'concrete' device\n// pointer. \n// \n// Test suggestion comes from Chris Daily and Rahulkumar Gayatri from NERSC\n////===----------------------------------------------------------------------===//\n\n#include <new>\n#include <vector>\n#include <iostream>\n#include \"ompvv.h\"\n#include <omp.h>\n\n#pragma omp target target\nclass S {\npublic:\n  S() : _devPtr(nullptr) {}\n  double sag(double x, double y) {\n    return x + y;\n  }\n  S* cloneToDevice() {\n    S* ptr;\n#pragma omp target map(ptr)\n    {\n      ptr = new S();\n    }\n    _devPtr = ptr;\n    return ptr;\n  }\nprivate:\n  S* _devPtr;\n};\n#pragma omp end declare target\n\nint main() {\n  int errors = 0;\n  \n  OMPVV_TEST_OFFLOADING;\n\n  S s;\n  S* devPtr = s.cloneToDevice();\n\n  std::vector<double> in(10, 0.0);\n  for(int i = 0; i < 10; i++) {\n    in[i] = i;\n  }\n\n  std::vector<double> out(10, 0.0);\n\n  double* inptr = in.data();\n  double* outptr = out.data();\n\n#pragma omp target teams distribute parallel for map(inptr[:10], outptr[:10]) is_device_ptr(devPtr)\n  for(int i = 0; i < 10; i++) {\n    outptr[i] = devPtr->sag(inptr[i], inptr[i]);\n  }\n\n  for(int i = 0; i < 10; i++) {\n    OMPVV_TEST_AND_SET(errors, out[i] != i*2)\n  }\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_enter_exit_data_depend.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp task\" with directive \"#pragma omp for\" at position 1291",
        "issue_id": 0,
        "original_code": "//===---test_target_enter_exit_data_depend.c --------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// This test checks functionality of target enter data and target exit data \n// to depend 'in' and 'out' using two separate functions. The first function \n// test_async_between_task_target() mixes host-based tasks with target-based\n// tasks, while the second function test_async_between_target() is testing \n// for target enter exit data to depend 'in' and 'out' respectively, while also\n// checking that a nowait clause can be used to ensure asynchronous behavior.\n//\n//===------------------------------------------------------------------------===//\n\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\n/*\n * Test if it is possible to:\n * 1. target enter data to depend 'in' and 'out'\n * 2. target exit data to depend 'in' and 'out'\n * 3. Mix target-based tasks with host tasks.\n */\nint test_async_between_task_target() {\n  OMPVV_INFOMSG(\"test_async_between_task_target\");\n\n  int errors = 0;\n  double sum = 0.0;\n  double* h_array = (double *) malloc(N * sizeof(double));\n  double* in_1 = (double *) malloc(N * sizeof(double));\n  double* in_2 = (double *) malloc(N * sizeof(double));\n  \n  // host task\n#pragma omp task depend(out: in_1) shared(in_1)\n  {\n    for (int i = 0; i < N; ++i) {\n      in_1[i] = 1;\n    }\n  }\n\n  // host task\n#pragma omp task depend(out: in_2) shared(in_2)\n  {\n    for (int i = 0; i < N; ++i) {\n      in_2[i] = 2;\n    }\n  }\n\n  // target enter data\n#pragma omp target enter data map(alloc: h_array[0:N]) map(to: in_1[0:N]) map(to: in_2[0:N]) depend(out: h_array) depend(in: in_1) depend(in: in_2) \n\n  // target task to compute on the device\n  // adding redundant depends on in_1 + in_2 to make the test work if compiled for the host\n#pragma omp task shared (h_array, in_1, in_2) depend(inout: h_array) depend(in: in_1) depend(in: in_2)\n  {\n#pragma omp target  \n    {\n      for (int i = 0; i < N; ++i) {\n        h_array[i] = in_1[i]*in_2[i];\n      }\n    }\n  }\n\n  // target exit data\n#pragma omp target exit data map(from: h_array[0:N]) depend(inout: h_array) \n\n  // host task\n#pragma omp task depend(in: h_array) shared(sum, h_array)\n  {\n    // checking results\n    for (int i = 0; i < N; ++i) {\n      sum += h_array[i];\n    }\n  }\n#pragma omp taskwait\n\n  errors = 2.0*N != sum;\n\n#pragma omp target exit data map(release: h_array[0:N], in_1[0:N], in_2[0:N])\n  free(h_array);\n  free(in_1);\n  free(in_2);\n  return errors;\n}\n\n/*\n * Test if it is possible to:\n * 1. target enter data to depend 'out'\n * 2. target exit data to depend 'in'\n * 3. use nowait for async\n */\nint test_async_between_target() {\n  OMPVV_INFOMSG(\"test_async_between_target\");\n\n  int errors = 0;\n  int sum = 0;\n  int* h_array = (int *) malloc(N * sizeof(int));\n  int val = 2;\n\n  // target enter data\n#pragma omp target enter data map(alloc: h_array[0:N]) depend(out: h_array) \n\n#pragma omp target enter data map(to: val) depend(out: val) \n\n#pragma omp target depend(inout: h_array) depend(in: val) \n  {\n    for (int i = 0; i < N; ++i) {\n      h_array[i] = val;\n    }\n  }\n\n  // target exit data\n#pragma omp target exit data map(from: h_array[0:N]) depend(in: h_array) \n\n#pragma omp taskwait\n\n  // checking results\n  for (int i = 0; i < N; ++i) {\n    sum += h_array[i];\n  }\n  \n  OMPVV_TEST_AND_SET(errors, 2*N != sum);\n\n#pragma omp target exit data map(release: h_array[0:N], val)\n  free(h_array);\n  return errors;\n}\n\nint main(){\n  int errors = 0;\n \n  // We test for offloading\n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_async_between_target());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_async_between_task_target());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---test_target_enter_exit_data_depend.c --------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// This test checks functionality of target enter data and target exit data \n// to depend 'in' and 'out' using two separate functions. The first function \n// test_async_between_task_target() mixes host-based tasks with target-based\n// tasks, while the second function test_async_between_target() is testing \n// for target enter exit data to depend 'in' and 'out' respectively, while also\n// checking that a nowait clause can be used to ensure asynchronous behavior.\n//\n//===------------------------------------------------------------------------===//\n\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\n/*\n * Test if it is possible to:\n * 1. target enter data to depend 'in' and 'out'\n * 2. target exit data to depend 'in' and 'out'\n * 3. Mix target-based tasks with host tasks.\n */\nint test_async_between_task_target() {\n  OMPVV_INFOMSG(\"test_async_between_task_target\");\n\n  int errors = 0;\n  double sum = 0.0;\n  double* h_array = (double *) malloc(N * sizeof(double));\n  double* in_1 = (double *) malloc(N * sizeof(double));\n  double* in_2 = (double *) malloc(N * sizeof(double));\n  \n  // host task\n#pragma omp for depend(out: in_1) shared(in_1)\n  {\n    for (int i = 0; i < N; ++i) {\n      in_1[i] = 1;\n    }\n  }\n\n  // host task\n#pragma omp task depend(out: in_2) shared(in_2)\n  {\n    for (int i = 0; i < N; ++i) {\n      in_2[i] = 2;\n    }\n  }\n\n  // target enter data\n#pragma omp target enter data map(alloc: h_array[0:N]) map(to: in_1[0:N]) map(to: in_2[0:N]) depend(out: h_array) depend(in: in_1) depend(in: in_2) \n\n  // target task to compute on the device\n  // adding redundant depends on in_1 + in_2 to make the test work if compiled for the host\n#pragma omp task shared (h_array, in_1, in_2) depend(inout: h_array) depend(in: in_1) depend(in: in_2)\n  {\n#pragma omp target  \n    {\n      for (int i = 0; i < N; ++i) {\n        h_array[i] = in_1[i]*in_2[i];\n      }\n    }\n  }\n\n  // target exit data\n#pragma omp target exit data map(from: h_array[0:N]) depend(inout: h_array) \n\n  // host task\n#pragma omp task depend(in: h_array) shared(sum, h_array)\n  {\n    // checking results\n    for (int i = 0; i < N; ++i) {\n      sum += h_array[i];\n    }\n  }\n#pragma omp taskwait\n\n  errors = 2.0*N != sum;\n\n#pragma omp target exit data map(release: h_array[0:N], in_1[0:N], in_2[0:N])\n  free(h_array);\n  free(in_1);\n  free(in_2);\n  return errors;\n}\n\n/*\n * Test if it is possible to:\n * 1. target enter data to depend 'out'\n * 2. target exit data to depend 'in'\n * 3. use nowait for async\n */\nint test_async_between_target() {\n  OMPVV_INFOMSG(\"test_async_between_target\");\n\n  int errors = 0;\n  int sum = 0;\n  int* h_array = (int *) malloc(N * sizeof(int));\n  int val = 2;\n\n  // target enter data\n#pragma omp target enter data map(alloc: h_array[0:N]) depend(out: h_array) \n\n#pragma omp target enter data map(to: val) depend(out: val) \n\n#pragma omp target depend(inout: h_array) depend(in: val) \n  {\n    for (int i = 0; i < N; ++i) {\n      h_array[i] = val;\n    }\n  }\n\n  // target exit data\n#pragma omp target exit data map(from: h_array[0:N]) depend(in: h_array) \n\n#pragma omp taskwait\n\n  // checking results\n  for (int i = 0; i < N; ++i) {\n    sum += h_array[i];\n  }\n  \n  OMPVV_TEST_AND_SET(errors, 2*N != sum);\n\n#pragma omp target exit data map(release: h_array[0:N], val)\n  free(h_array);\n  return errors;\n}\n\nint main(){\n  int errors = 0;\n \n  // We test for offloading\n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_async_between_target());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_async_between_task_target());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_declare_target_nested.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1720",
        "issue_id": 1,
        "original_code": "//===---- test_declare_target_nested.c ---------------------------------------------===//\n// \n// OpenMP API Version 5.0 \n//\n// The declaration-definition-seq defined by a declare target directive and an end\n// declare target directive may contain declare target directives. If a device_type\n// clause is present on the contained declare target directive, then its argument \n// determines which versions are made available. If a list item appears both in an\n// implicit and explicit list, the explicit list determines which versions are made\n// available. \n// \n// @Todo's 1. Test if wrapper is necessary\n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp declare target\nint a[N], b[N], c[N]; // implicit map 3 variables \nint errors = 0;\nint i = 0;\n  #pragma omp declare target\n     int test_target();\n  #pragma omp end declare target\n#pragma omp end declare target\n\nint test_target() { //function in declare target statement \n\n//change values on device\n#pragma omp parallel for \n  for (i = 0; i < N; i++) {\n    a[i] = 5;\n    b[i] = 10;\n    c[i] = 15;\n  }\n\n  for (i = 0; i < N; i++) {\n    if ( a[i] != 5 || b[i] != 10 || c[i] != 15) {\n      errors++;  \n    } \n  }\n  return errors; \n} \n\nint test_wrapper() { //wrapper for declare target function\n  \n  #pragma omp target \n  {\n    test_target();\n  }\n  #pragma omp target update from(errors, a, b, c)\n  \n  for (i = 0; i < N; i++) { //check array values on host\n    if ( a[i] != 5 || b[i] != 10 || c[i] != 15) {\n      errors++;  \n    } \n  }\n  return errors;\n}\n\nint main () {\n  \n  //initalize arrays on host\n  for (i = 0; i < N; i++) {\n    a[i] = i;\n    b[i] = 2*i;\n    c[i] = 3*i;\n  }\n\n  #pragma omp target update to(a,b,c) //update values on device (5.0 examples pp.172)\n  OMPVV_TEST_OFFLOADING;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_wrapper());\n  OMPVV_REPORT_AND_RETURN(errors);\n}  \n",
        "error_code": "//===---- test_declare_target_nested.c ---------------------------------------------===//\n// \n// OpenMP API Version 5.0 \n//\n// The declaration-definition-seq defined by a declare target directive and an end\n// declare target directive may contain declare target directives. If a device_type\n// clause is present on the contained declare target directive, then its argument \n// determines which versions are made available. If a list item appears both in an\n// implicit and explicit list, the explicit list determines which versions are made\n// available. \n// \n// @Todo's 1. Test if wrapper is necessary\n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp declare target\nint a[N], b[N], c[N]; // implicit map 3 variables \nint errors = 0;\nint i = 0;\n  #pragma omp declare target\n     int test_target();\n  #pragma omp end declare target\n#pragma omp end declare target\n\nint test_target() { //function in declare target statement \n\n//change values on device\n#pragma omp parallel for \n  for (i = 0; i < N; i++) {\n    a[i] = 5;\n    b[i] = 10;\n    c[i] = 15;\n  }\n\n  for (i = 0; i < N; i++) {\n    if ( a[i] != 5 || b[i] != 10 || c[i] != 15) {\n      errors++;  \n    } \n  }\n  return errors; \n} \n\nint test_wrapper() { //wrapper for declare target function\n  \n  #pragma omp target \n  {\n    test_target();\n  }\n  #pragma omp target update from(errors, a, b, c)\n  \n  for (i = 0; i < N; i++) { //check array values on host\n    if ( a[i] != 5 || b[i] != 10 || c[i] != 15) {\n      errors++;  \n    } \n  }\n  return errors;\n}\n\nint main () {\n  \n  //initalize arrays on host\n  for (i = 0; i < N; i++) \n    a[i] = i;\n    b[i] = 2*i;\n    c[i] = 3*i;\n  }\n\n  #pragma omp target update to(a,b,c) //update values on device (5.0 examples pp.172)\n  OMPVV_TEST_OFFLOADING;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_wrapper());\n  OMPVV_REPORT_AND_RETURN(errors);\n}  \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_parallel_for_collapse.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===---- test_target_teams_distribute_parallel_for_collapse.c - combined consutrct -===//\n// \n// OpenMP API Version 5.0 Nov 2018\n// \n// Testing loop collapse with multiple loops. Trying to mimic lsms kernel.\n//\n//===--------------------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define SIZE_N 10\n#define SIZE_M 12\n\nint test_target_teams_distribute_parallel_for_collapse() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_collapse\");\n  \n  int a[SIZE_N][SIZE_M][SIZE_N][SIZE_M];\n  int errors = 0;\n  int i,j,k,l;\n\n  // a array initialization\n  for (i = 0; i < SIZE_N; i++) {\n    for (j = 0; j < SIZE_M; j++) {\n      for (k = 0; k < SIZE_N; k++) {\n        for (l = 0; l < SIZE_M; l++) {\n          a[i][j][k][l] = 1;\n        }\n      }\n    }\n  }\n\n#pragma omp target teams distribute parallel for collapse(4) map(tofrom: a) private(i,j,k,l)\n  for (i = 0; i < SIZE_N; i++) {\n    for (j = 0; j < SIZE_M; j++) {\n      for (k = i; k < SIZE_N; k++) {\n        for (l = 0; l < SIZE_M; l++) {\n          a[i][j][k][l] += i+2*j+3*k+4*l;\n        }\n      }\n    }\n  }\n\n  for (i = 0; i < SIZE_N; i++) {\n    for (j = 0; j < SIZE_M; j++) {\n      for (k = i; k < SIZE_N; k++) {\n        for (l = 0; l < SIZE_M; l++) {\n          int temp = 1+ i + 2*j + 3*k + 4*l;\n          OMPVV_TEST_AND_SET(errors, a[i][j][k][l] != temp);\n        }\n      }\n    }\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_collapse());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nbyte miufwrdote = 238;\nlong lcaymlmyhc = 149;\nint ayznngcaog = 117;\nshort aklcmzwnpq = 223;\nshort psuhmlrnpk = 122;\nint mdnayqpoth = 82;\nint cwmnqlgtko = 53;\nshort nmwbqubfsh = 190;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_get_mapped_ptr.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 602",
        "issue_id": 2,
        "original_code": "//===--- test_get_mapped_ptr.c -----------------------------------------------===//\n//\n//  OpenMP API Version 5.1 Aug 2021\n//\n//Test for the omp_get_mapped_ptr memory routine. This routine returns the device pointer associated with a host pointer for a given device. \n//===--------------------------------------------------------------------------------------===//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint errors;\n\nint test_get_mapped_ptr() {\nint * device_ptr;\nint x = 4;\nint num_devices = omp_get_num_devices(); \nint * arr_ptrs;\nOMPVV_INFOMSG_IF(num_devices == 0, \"No devices available. \");\n// test to make sure it is NULL if no devices exist\nif (num_devices == 0) {\n\tdevice_ptr = (int *) omp_get_mapped_ptr(&x, omp_get_initial_device());\n\tOMPVV_TEST_AND_SET(errors, device_ptr != &x);\n\tOMPVV_INFOMSG_IF(device_ptr != &x, \"get_mapped_ptr() did not work with 0 devices.\");\n\tOMPVV_INFOMSG_IF(device_ptr == &x, \"get_mapped_ptr() worked with 0 devices. \");\n}\nfor (int i = 0; i < num_devices; i ++) {\n# pragma omp target enter data device(i) map(to:x)\n\tarr_ptrs = (int *) omp_get_mapped_ptr(&x, i);\n\n\tOMPVV_TEST_AND_SET(errors, arr_ptrs == NULL);\n\tOMPVV_INFOMSG_IF(arr_ptrs == NULL, \"get_mapped_ptr() failed on getting device pointer. \");\n\tOMPVV_INFOMSG_IF(arr_ptrs != NULL, \"get_mapped_ptr() mapped pointer to device. \");\n# pragma omp target exit data map(from:x)\n}\n\n\nreturn 0;\n}\n\nint main() {\n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_get_mapped_ptr() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_get_mapped_ptr.c -----------------------------------------------===//\n//\n//  OpenMP API Version 5.1 Aug 2021\n//\n//Test for the omp_get_mapped_ptr memory routine. This routine returns the device pointer associated with a host pointer for a given device. \n//===--------------------------------------------------------------------------------------===//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint errors;\n\nint test_get_mapped_ptr() {\nint * device_ptr;\nint x = 4;\nint num_devices = omp_get_num_devices(); \nint * arr_ptrs;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\nOMPVV_INFOMSG_IF(num_devices == 0, \"No devices available. \");\n// test to make sure it is NULL if no devices exist\nif (num_devices == 0) {\n\tdevice_ptr = (int *) omp_get_mapped_ptr(&x, omp_get_initial_device());\n\tOMPVV_TEST_AND_SET(errors, device_ptr != &x);\n\tOMPVV_INFOMSG_IF(device_ptr != &x, \"get_mapped_ptr() did not work with 0 devices.\");\n\tOMPVV_INFOMSG_IF(device_ptr == &x, \"get_mapped_ptr() worked with 0 devices. \");\n}\nfor (int i = 0; i < num_devices; i ++) {\n# pragma omp target enter data device(i) map(to:x)\n\tarr_ptrs = (int *) omp_get_mapped_ptr(&x, i);\n\n\tOMPVV_TEST_AND_SET(errors, arr_ptrs == NULL);\n\tOMPVV_INFOMSG_IF(arr_ptrs == NULL, \"get_mapped_ptr() failed on getting device pointer. \");\n\tOMPVV_INFOMSG_IF(arr_ptrs != NULL, \"get_mapped_ptr() mapped pointer to device. \");\n# pragma omp target exit data map(from:x)\n}\n\n\nreturn 0;\n}\n\nint main() {\n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_get_mapped_ptr() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_loop_reduction_max.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 1168",
        "issue_id": 2,
        "original_code": "//===--- test_loop_reduction_max.c ------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the reduction clause on a loop directive, testing that the\n// variable in the reduction clause is properly reduced using the max\n// operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_max() {\n  int a[N];\n  int b[N];\n  int errors = 0;\n  int num_threads[N];\n  srand(1);\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = (int) rand() / (double)(RAND_MAX / 100);\n    b[x] = (int) rand() / (double)(RAND_MAX / 100);\n    num_threads[x] = -x;\n  }\n\n  int result = 0;\n\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST)\n  {\n#pragma omp loop reduction(max:result)\n    for (int x = 0; x < N; ++x) {\n      result = fmax(a[x] + b[x], result);\n    }\n#pragma omp for\n    for (int x = 0; x < N; ++x) {\n      num_threads[x] = omp_get_num_threads();\n    }\n  }\n\n  int host_max = 0;\n\n  for (int x = 0; x < N; ++x) {\n    host_max = fmax(host_max, a[x] + b[x]);\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_threads[x - 1] != num_threads[x], \"Test reported differing numbers of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_threads[0] == 1, \"Test operated with one thread.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_threads[0] <= 0, \"Test reported invalid number of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != host_max);\n  OMPVV_ERROR_IF(host_max != result, \"Max from loop directive is %d but expected max is %d.\", result, host_max);\n\n  return errors;\n}\n\nint main() {\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_max() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n",
        "error_code": "//===--- test_loop_reduction_max.c ------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the reduction clause on a loop directive, testing that the\n// variable in the reduction clause is properly reduced using the max\n// operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_max() {\n  int a[N];\n  int b[N];\n  int errors = 0;\n  int num_threads[N];\n  srand(1);\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = (int) rand() / (double)(RAND_MAX / 100);\n    b[x] = (int) rand() / (double)(RAND_MAX / 100);\n    num_threads[x] = -x;\n  }\n\n  int result = 0;\n\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST)\n  {\n#pragma omp loop reduction(max:result)\n    for (int x = 0; x < N; ++x) {\n      result = fmax(a[x] + b[x], result);\n    }\n#pragma omp for\n    for (int x = 0; x < N; ++x) {\n      num_threads[x] = omp_get_num_threads();\n    }\n  }\n\n  int host_max = 0;\n\n  for (int x = 0; x < N; ++x) {\n    host_max = fmax(host_max, a[x] + b[x]);\n  }\n\n  for (int x = 1;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_threads[x - 1] != num_threads[x], \"Test reported differing numbers of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_threads[0] == 1, \"Test operated with one thread.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_threads[0] <= 0, \"Test reported invalid number of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != host_max);\n  OMPVV_ERROR_IF(host_max != result, \"Max from loop directive is %d but expected max is %d.\", result, host_max);\n\n  return errors;\n}\n\nint main() {\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_max() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_requires_unified_shared_memory_static_is_device_ptr.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp requires\" with directive \"#pragma omp teams\" at position 572",
        "issue_id": 0,
        "original_code": "//===---test_requires_unified_shared_memory_static_is_device_ptr.c ----------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// We request the use of unified_shared_memory in this program.\n// Checking for static arrays. The array is global and then accessed through \n// a pointer from the host and the device.\n//\n// We use is_device_ptr to guarantee that the host pointer is used in the device.\n//\n////===----------------------------------------------------------------------===//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp requires unified_shared_memory\n\n// STATIC ARRAY \nint anArray[N];\n\nint unified_shared_memory_static_is_device_ptr() {\n  OMPVV_INFOMSG(\"Unified shared memory testing - Static Array\");\n  int errors = 0;\n  \n  int anArrayCopy[N];\n  int * aPtr = anArray;\n\n  for (int i = 0; i < N; i++) {\n    anArray[i] = i;\n    anArrayCopy[i] = 0;\n  }\n\n  // Test for writes to this variable from device\n#pragma omp target is_device_ptr(aPtr)\n  {\n    for (int i = 0; i < N; i++) {\n      aPtr[i] += 10;\n    }\n  }\n  // Modify again on the host\n  for (int i = 0; i < N; i++) {\n    aPtr[i] += 10;\n  }\n\n  // Test for reads to this variable from device\n#pragma omp target is_device_ptr(aPtr)\n  {\n    for (int i = 0; i < N; i++) {\n      anArrayCopy[i] = aPtr[i];\n    }\n  }\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArray[i] != i + 20);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArrayCopy[i] != i + 20);\n    if (errors) break;\n  }\n  return errors;\n}\n\nint main() {\n  int isOffloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"With no offloading, unified shared memory is guaranteed due to host execution\");\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, unified_shared_memory_static_is_device_ptr());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---test_requires_unified_shared_memory_static_is_device_ptr.c ----------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// We request the use of unified_shared_memory in this program.\n// Checking for static arrays. The array is global and then accessed through \n// a pointer from the host and the device.\n//\n// We use is_device_ptr to guarantee that the host pointer is used in the device.\n//\n////===----------------------------------------------------------------------===//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp teams unified_shared_memory\n\n// STATIC ARRAY \nint anArray[N];\n\nint unified_shared_memory_static_is_device_ptr() {\n  OMPVV_INFOMSG(\"Unified shared memory testing - Static Array\");\n  int errors = 0;\n  \n  int anArrayCopy[N];\n  int * aPtr = anArray;\n\n  for (int i = 0; i < N; i++) {\n    anArray[i] = i;\n    anArrayCopy[i] = 0;\n  }\n\n  // Test for writes to this variable from device\n#pragma omp target is_device_ptr(aPtr)\n  {\n    for (int i = 0; i < N; i++) {\n      aPtr[i] += 10;\n    }\n  }\n  // Modify again on the host\n  for (int i = 0; i < N; i++) {\n    aPtr[i] += 10;\n  }\n\n  // Test for reads to this variable from device\n#pragma omp target is_device_ptr(aPtr)\n  {\n    for (int i = 0; i < N; i++) {\n      anArrayCopy[i] = aPtr[i];\n    }\n  }\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArray[i] != i + 20);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArrayCopy[i] != i + 20);\n    if (errors) break;\n  }\n  return errors;\n}\n\nint main() {\n  int isOffloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"With no offloading, unified shared memory is guaranteed due to host execution\");\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, unified_shared_memory_static_is_device_ptr());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_scope_reduction_construct.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp parallel\" with directive \"#pragma omp teams\" at position 682",
        "issue_id": 0,
        "original_code": "//--------------- test_scope_reduction_construct.c-----------------------//\n//\n// OpenMP API Version 5.1 Aug 2021\n//\n// The objective of this test is ensure the scope construct works as \n// intended. The scope construct defines a structured block that is\n// executed by all threads in a team but where additional OpenMP operation\n// can be specified. This test follows the example given by the OpenMP\n// 5.1 Specification Example sheet. \n//-----------------------------------------------------------------------//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_scope(int n, int a[], int s){\n\tint errors = 0;\n\t#pragma omp parallel shared(s)\n\t{\n\t\tint loc_s = 0;\n\t\t#pragma omp for\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tloc_s += a[i];\n\t\t#pragma omp single\n\t\t{\n\t\t\ts = 0;\n\t\t}\n\t\t#pragma omp scope reduction(+:s)\n\t\t{\n\t\t\ts += loc_s;\n\t\t}\n\t}\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, s != 1024);\n\tOMPVV_INFOMSG_IF(s == 0, \"sum was not set\");\n\treturn errors;\t\n}\t\n\nint main(){\n\tint a[N];\n\tint s = 0;\n\tint errors = 0;\n\tfor (int i = 0; i < N; i++){\n\t\ta[i] = 1;\n\t}\n\tOMPVV_TEST_OFFLOADING;\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_scope(N,a,s) != 0);\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//--------------- test_scope_reduction_construct.c-----------------------//\n//\n// OpenMP API Version 5.1 Aug 2021\n//\n// The objective of this test is ensure the scope construct works as \n// intended. The scope construct defines a structured block that is\n// executed by all threads in a team but where additional OpenMP operation\n// can be specified. This test follows the example given by the OpenMP\n// 5.1 Specification Example sheet. \n//-----------------------------------------------------------------------//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_scope(int n, int a[], int s){\n\tint errors = 0;\n\t#pragma omp teams shared(s)\n\t{\n\t\tint loc_s = 0;\n\t\t#pragma omp for\n\t\t\tfor (int i = 0; i < n; i++)\n\t\t\t\tloc_s += a[i];\n\t\t#pragma omp single\n\t\t{\n\t\t\ts = 0;\n\t\t}\n\t\t#pragma omp scope reduction(+:s)\n\t\t{\n\t\t\ts += loc_s;\n\t\t}\n\t}\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, s != 1024);\n\tOMPVV_INFOMSG_IF(s == 0, \"sum was not set\");\n\treturn errors;\t\n}\t\n\nint main(){\n\tint a[N];\n\tint s = 0;\n\tint errors = 0;\n\tfor (int i = 0; i < N; i++){\n\t\ta[i] = 1;\n\t}\n\tOMPVV_TEST_OFFLOADING;\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_scope(N,a,s) != 0);\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_parallel_master_taskloop.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 663",
        "issue_id": 2,
        "original_code": "//===--- test_parallel_master_taskloop.c -------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the parallel master taskloop directive. The test performs\n// simple operations on an int array which are then checked for correctness.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_parallel_master_taskloop() {\n  OMPVV_INFOMSG(\"test_parallel_master_taskloop\");\n  int errors = 0;\n  int num_threads = -1;\n  int x[N];\n  int y[N];\n  int z[N];\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 1;\n    y[i] = i + 1;\n    z[i] = 2*(i + 1);\n  }\n\n#pragma omp parallel master taskloop num_threads(OMPVV_NUM_THREADS_HOST) shared(x, y, z, num_threads)\n  for (int i = 0; i < N; i++) {\n    x[i] += y[i]*z[i];\n    if (i == 0) {\n      num_threads = omp_get_num_threads();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != 1 + (y[i]*z[i]));\n  }\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of taskloop can't be guaranteed.\");\n  OMPVV_ERROR_IF(num_threads < 1, \"Test returned an invalid number of threads.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n\n  return errors;\n}\n\n\nint main() {\n  int errors = 0;\n\n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_parallel_master_taskloop());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_parallel_master_taskloop.c -------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the parallel master taskloop directive. The test performs\n// simple operations on an int array which are then checked for correctness.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_parallel_master_taskloop() {\n  OMPVV_INFOMSG(\"test_parallel_master_taskloop\");\n  int errors = 0;\n  int num_threads = -1;\n  int x[N];\n  int y[N];\n  int z[N];\n\n  for (int i = 0; i < N;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1; i++) {\n    x[i] = 1;\n    y[i] = i + 1;\n    z[i] = 2*(i + 1);\n  }\n\n#pragma omp parallel master taskloop num_threads(OMPVV_NUM_THREADS_HOST) shared(x, y, z, num_threads)\n  for (int i = 0; i < N; i++) {\n    x[i] += y[i]*z[i];\n    if (i == 0) {\n      num_threads = omp_get_num_threads();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != 1 + (y[i]*z[i]));\n  }\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of taskloop can't be guaranteed.\");\n  OMPVV_ERROR_IF(num_threads < 1, \"Test returned an invalid number of threads.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n\n  return errors;\n}\n\n\nint main() {\n  int errors = 0;\n\n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_parallel_master_taskloop());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_declare_target_enter_device_type_nohost1.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 2091",
        "issue_id": 1,
        "original_code": "//===---- test_declare_target_enter_device_type_nohost1.c  ----------------------------------===//\n// \n// OpenMP API Version 5.2 \n//\n// If a device_type clause is present on the declare target directive, then its argument \n// determines which versions are made available. If device_type(nohost) is present \n// only a device version of the procedure is made available. In case of fallback host version \n// required. The host version of the function is specified via declare variant.The test also \n// uses enter instead of the (depricated) clause to.\n// \n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 10\nint errors = 0;\nint a[N], b[N], c[N];  \nint i = 0, dev=-9;\n\nvoid fun();\nvoid host_function();\n\n#pragma omp declare target enter(fun) device_type(nohost)\n\n#pragma omp declare target enter(a,b,c,i,dev)\n\n#pragma omp declare variant(host_function) match(device={kind(host)})\nvoid fun(){\n  for (i = 0; i < N; i++) {\n    a[i] += 1;\n    b[i] += 2;\n    c[i] += 3;\n  }\n} \n\nvoid host_function() {\n  for (i = 0; i < N; i++) {\n    a[i] += 5;\n    b[i] += 5;\n    c[i] += 5;\n  }\n}\n\nint test_declare_target_device_type_nohost() { \n\n  fun(); //should call host_function()\n\n  #pragma omp target update to(a,b,c)\n\n  #pragma omp target \n  {\n    fun(); //Will call fun() on device OR host_function() in case of fall-back\n    dev = omp_get_device_num();\n  }\n\n  #pragma omp target update from (a,b,c,dev)\n  \n  if (dev != omp_get_initial_device()) {\n    for (i = 0; i < N; i++) { //check array values on host\n      if ( a[i] != 6 || b[i] != 7 || c[i] != 8 ) {\n        errors++;\n      }\n    }\n  } else {\n    OMPVV_WARNING(\"Default device is the host device. Target region executed on host.\");\n    for (i = 0; i < N; i++) { //check array values on host\n      if ( a[i] != 10 || b[i] != 10 || c[i] != 10 ) {\n        errors++;\n      }\n    }\n  }\n  \n  return errors;\n}\n\nint main () {\n\n  OMPVV_TEST_OFFLOADING;\n  \n  //initalize arrays on host\n  for (i = 0; i < N; i++) {\n    a[i] = 0;\n    b[i] = 0;\n    c[i] = 0;\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_declare_target_device_type_nohost());\n  OMPVV_REPORT_AND_RETURN(errors);\n}  \n",
        "error_code": "//===---- test_declare_target_enter_device_type_nohost1.c  ----------------------------------===//\n// \n// OpenMP API Version 5.2 \n//\n// If a device_type clause is present on the declare target directive, then its argument \n// determines which versions are made available. If device_type(nohost) is present \n// only a device version of the procedure is made available. In case of fallback host version \n// required. The host version of the function is specified via declare variant.The test also \n// uses enter instead of the (depricated) clause to.\n// \n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 10\nint errors = 0;\nint a[N], b[N], c[N];  \nint i = 0, dev=-9;\n\nvoid fun();\nvoid host_function();\n\n#pragma omp declare target enter(fun) device_type(nohost)\n\n#pragma omp declare target enter(a,b,c,i,dev)\n\n#pragma omp declare variant(host_function) match(device={kind(host)})\nvoid fun(){\n  for (i = 0; i < N; i++) {\n    a[i] += 1;\n    b[i] += 2;\n    c[i] += 3;\n  }\n} \n\nvoid host_function() {\n  for (i = 0; i < N; i++) {\n    a[i] += 5;\n    b[i] += 5;\n    c[i] += 5;\n  }\n}\n\nint test_declare_target_device_type_nohost() { \n\n  fun(); //should call host_function()\n\n  #pragma omp target update to(a,b,c)\n\n  #pragma omp target \n  {\n    fun(); //Will call fun() on device OR host_function() in case of fall-back\n    dev = omp_get_device_num();\n  }\n\n  #pragma omp target update from (a,b,c,dev)\n  \n  if (dev != omp_get_initial_device()) {\n    for (i = 0; i < N; i++) { //check array values on host\n      if ( a[i] != 6 || b[i] != 7 || c[i] != 8 ) {\n        errors++;\n      }\n    }\n  } else {\n    OMPVV_WARNING(\"Default device is the host device. Target region executed on host.\");\n    for (i = 0; i < N; i++) { //check array values on host\n      if ( a[i] != 10 || b[i] != 10 || c[i] != 10 ) {\n        errors++;\n      }\n    }\n  }\n  \n  return errors;\n}\n\nint main () {\n\n  OMPVV_TEST_OFFLOADING;\n  \n  //initalize arrays on host\n  for (i = 0; i < N; i++) \n    a[i] = 0;\n    b[i] = 0;\n    c[i] = 0;\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_declare_target_device_type_nohost());\n  OMPVV_REPORT_AND_RETURN(errors);\n}  \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_taskgroup_task_reduction_device.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n    temp = root->next;\n    free (root);\n    root = temp;\n  }\" at position 2495",
        "issue_id": 4,
        "original_code": "//===--- test_taskgroup_task_reduction_device.c -----------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the taskgroup construct with the task_reduction clause.\n// It uses a linked list data structure which is then traversed and reduced\n// over by a taskgroup. This test is based on a OpenMP 5.0 official example.\n// This test checks the above in a target context.\n//\n////===----------------------------------------------------------------------===//\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 128\n\ntypedef struct node_tag {\n  struct node_tag *next;\n  int val;\n} node_t;\n\n#pragma omp declare target\nint linked_list_sum(node_t *p)\n{\n  int result = 0;\n#pragma omp taskgroup task_reduction(+: result)\n  {\n    node_t* temp = p;\n    while(temp != 0) {\n#pragma omp task in_reduction(+: result)\n      result += temp->val;\n      temp = temp->next;\n    }\n  }\n  return result;\n}\n#pragma omp end declare target\n\n\nint seq_linked_list_sum(node_t *p)\n{\n  int result = 0;\n  node_t* temp = p;\n  while(temp != 0) {\n    result += temp->val;\n    temp = temp->next;\n  }\n  return result;\n}\n\n\nint main(int argc, char *argv[]) {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0, result = -1;\n  node_t* root = (node_t*) malloc(sizeof(node_t));\n  root->val = 1;\n\n  node_t* temp = root;\n\n  for(int i = 2; i <= N; ++i) {\n    temp->next = (node_t*) malloc(sizeof(node_t));\n    temp = temp->next;\n    temp->val = i;\n  }\n  temp->next = NULL;\n\n  // Copy linked list to the device\n  temp = root;\n  while(temp != NULL) {\n#pragma omp target enter data map(to:temp[:1])\n    temp = temp->next;\n  }\n\n  // And update the next pointer on the device side,\n  temp = root;\n  while(temp != NULL) {\n    node_t* next = temp->next;\n    if (!next)\n      break;\n#pragma omp target data use_device_ptr(temp, next)\n    {\n      intptr_t var = (intptr_t) next;\n      omp_target_memcpy (temp, &var, sizeof (void*), 0, 0,\n                        omp_get_default_device(), omp_get_initial_device());\n    }\n    temp = temp->next;\n  }\n\n#pragma omp target parallel shared(result) num_threads(OMPVV_NUM_THREADS_DEVICE) defaultmap(tofrom) map(root[:1])\n#pragma omp single\n  {\n    result = linked_list_sum(root);\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != seq_linked_list_sum(root));\n\n  // Free linked list to the device\n  temp = root;\n  while(temp != 0) {\n#pragma omp target exit data map(release:temp[:1])\n    temp = temp->next;\n  }\n\n  while (root) {\n    temp = root->next;\n    free (root);\n    root = temp;\n  }\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_taskgroup_task_reduction_device.c -----------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the taskgroup construct with the task_reduction clause.\n// It uses a linked list data structure which is then traversed and reduced\n// over by a taskgroup. This test is based on a OpenMP 5.0 official example.\n// This test checks the above in a target context.\n//\n////===----------------------------------------------------------------------===//\n#include <stdlib.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 128\n\ntypedef struct node_tag {\n  struct node_tag *next;\n  int val;\n} node_t;\n\n#pragma omp declare target\nint linked_list_sum(node_t *p)\n{\n  int result = 0;\n#pragma omp taskgroup task_reduction(+: result)\n  {\n    node_t* temp = p;\n    while(temp != 0) {\n#pragma omp task in_reduction(+: result)\n      result += temp->val;\n      temp = temp->next;\n    }\n  }\n  return result;\n}\n#pragma omp end declare target\n\n\nint seq_linked_list_sum(node_t *p)\n{\n  int result = 0;\n  node_t* temp = p;\n  while(temp != 0) {\n    result += temp->val;\n    temp = temp->next;\n  }\n  return result;\n}\n\n\nint main(int argc, char *argv[]) {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0, result = -1;\n  node_t* root = (node_t*) malloc(sizeof(node_t));\n  root->val = 1;\n\n  node_t* temp = root;\n\n  for(int i = 2; i <= N; ++i) {\n    temp->next = (node_t*) malloc(sizeof(node_t));\n    temp = temp->next;\n    temp->val = i;\n  }\n  temp->next = NULL;\n\n  // Copy linked list to the device\n  temp = root;\n  while(temp != NULL) {\n#pragma omp target enter data map(to:temp[:1])\n    temp = temp->next;\n  }\n\n  // And update the next pointer on the device side,\n  temp = root;\n  while(temp != NULL) {\n    node_t* next = temp->next;\n    if (!next)\n      break;\n#pragma omp target data use_device_ptr(temp, next)\n    {\n      intptr_t var = (intptr_t) next;\n      omp_target_memcpy (temp, &var, sizeof (void*), 0, 0,\n                        omp_get_default_device(), omp_get_initial_device());\n    }\n    temp = temp->next;\n  }\n\n#pragma omp target parallel shared(result) num_threads(OMPVV_NUM_THREADS_DEVICE) defaultmap(tofrom) map(root[:1])\n#pragma omp single\n  {\n    result = linked_list_sum(root);\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != seq_linked_list_sum(root));\n\n  // Free linked list to the device\n  temp = root;\n  while(temp != 0) {\n#pragma omp target exit data map(release:temp[:1])\n    temp = temp->next;\n  }\n\n  while (root) \n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_enter_exit_data_map_malloced_array.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1795",
        "issue_id": 1,
        "original_code": "//===--- test_target_enter_exit_data_map_malloced_array.c -------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n// \n// This tests the mapping of a pointer to and from the device using target \n// enter data map and target exit data map. Additionally, this test checks\n// that the use of the delete map-type-modifier on a target data construct\n// with a map clause is supported.\n//\n////===----------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 10\n\nint *x;\nint *y;\n\nint test_tofrom() {\n  int i, errors = 0;\n  int *A;\n\n  A = (int *) malloc(N*sizeof(int));\n  if (NULL == A) {\n    OMPVV_ERROR(\"Malloc returned NULL.\");\n    exit(-1);\n  }\n\n  for (i = 0; i < N; ++i) {\n    A[i] = 0;\n  }\n\n  x = A;\n\n#pragma omp target enter data map(to: x[:N])\n\n#pragma omp target\n  {\n    for (i = 0; i < N; i++) {\n      x[i] = N;\n    }\n  }\n\n#pragma omp target exit data map(from: x[:N])\n\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, A[i] != N);\n  }\n  free(A);\n  return errors;\n}\n\nint test_delete() {\n  int i, errors = 0;\n  int *A, *B;\n\n  A = (int *) malloc(N*sizeof(int));\n  B = (int *) malloc(N*sizeof(int));\n  if (NULL == A || NULL == B) {\n    OMPVV_ERROR(\"Malloc returned NULL.\");\n    exit(-1);\n  }\n\n  for (i = 0; i < N; ++i) {\n    A[i] = N;\n  }\n\n  x = A;\n  y = B;\n\n#pragma omp target data map(tofrom: x[:N]) map(from: y[:N])\n  {\n#pragma omp target exit data map(delete: x[:N])\n    for (i = 0; i < N; ++i) {\n      x[i] = 0;\n    }\n#pragma omp target map(to: x[:N])\n    {\n      for (i = 0; i < N; i++) {\n        y[i] = x[i];\n      }\n    }\n  }\n\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, B[i] != 0);\n  }\n  free(A);\n  free(B);\n\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n\n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_tofrom());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_delete());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_enter_exit_data_map_malloced_array.c -------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n// \n// This tests the mapping of a pointer to and from the device using target \n// enter data map and target exit data map. Additionally, this test checks\n// that the use of the delete map-type-modifier on a target data construct\n// with a map clause is supported.\n//\n////===----------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 10\n\nint *x;\nint *y;\n\nint test_tofrom() {\n  int i, errors = 0;\n  int *A;\n\n  A = (int *) malloc(N*sizeof(int));\n  if (NULL == A) {\n    OMPVV_ERROR(\"Malloc returned NULL.\");\n    exit(-1);\n  }\n\n  for (i = 0; i < N; ++i) {\n    A[i] = 0;\n  }\n\n  x = A;\n\n#pragma omp target enter data map(to: x[:N])\n\n#pragma omp target\n  {\n    for (i = 0; i < N; i++) {\n      x[i] = N;\n    }\n  }\n\n#pragma omp target exit data map(from: x[:N])\n\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, A[i] != N);\n  }\n  free(A);\n  return errors;\n}\n\nint test_delete() {\n  int i, errors = 0;\n  int *A, *B;\n\n  A = (int *) malloc(N*sizeof(int));\n  B = (int *) malloc(N*sizeof(int));\n  if (NULL == A || NULL == B) {\n    OMPVV_ERROR(\"Malloc returned NULL.\");\n    exit(-1);\n  }\n\n  for (i = 0; i < N; ++i) {\n    A[i] = N;\n  }\n\n  x = A;\n  y = B;\n\n#pragma omp target data map(tofrom: x[:N]) map(from: y[:N])\n  {\n#pragma omp target exit data map(delete: x[:N])\n    for (i = 0; i < N; ++i) {\n      x[i] = 0;\n    }\n#pragma omp target map(to: x[:N])\n    {\n      for (i = 0; i < N; i++) {\n        y[i] = x[i];\n      }\n    }\n  }\n\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, B[i] != 0);\n  }\n  free(A);\n  free(B);\n\n  return errors;\n}\n\nint main() \n  int errors = 0;\n\n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_tofrom());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_delete());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_parallel_default.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n#pragma omp atomic\n      IfTstPassed--;\n    }\" at position 884",
        "issue_id": 4,
        "original_code": "//===------ test_target_default.c --------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Tests the target directive with parallel for + default clause.\n//\n//===------------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include \"omp.h\"\n#include \"ompvv.h\"\n\n#define N 100\n\n\nint IfTstPassed = 1; // 1 is passed 0 is failed\n\nint main(int argc, char** argv) {\n  OMPVV_TEST_OFFLOADING;\n  int count = 123, errors = 0;\n#pragma omp target data map(tofrom: count)\n#pragma omp target parallel for shared(count, IfTstPassed) default(none)\\\n        map(tofrom: IfTstPassed)\n  for (int i = 0; i < N; ++i) {\n    if (count != 123) {\n#pragma omp atomic\n      IfTstPassed--;\n    }  \n  }\n\n  count = 123;\n#pragma omp target parallel for default(shared) map(tofrom: IfTstPassed)\n  for (int i = 0; i < N; ++i) {\n    if (count != 123) {\n#pragma omp atomic\n      IfTstPassed--;\n    }\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, IfTstPassed != 1);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n",
        "error_code": "//===------ test_target_default.c --------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Tests the target directive with parallel for + default clause.\n//\n//===------------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include \"omp.h\"\n#include \"ompvv.h\"\n\n#define N 100\n\n\nint IfTstPassed = 1; // 1 is passed 0 is failed\n\nint main(int argc, char** argv) {\n  OMPVV_TEST_OFFLOADING;\n  int count = 123, errors = 0;\n#pragma omp target data map(tofrom: count)\n#pragma omp target parallel for shared(count, IfTstPassed) default(none)\\\n        map(tofrom: IfTstPassed)\n  for (int i = 0; i < N; ++i) {\n    if (count != 123) {\n#pragma omp atomic\n      IfTstPassed--;\n    }  \n  }\n\n  count = 123;\n#pragma omp target parallel for default(shared) map(tofrom: IfTstPassed)\n  for (int i = 0; i < N; ++i) {\n    if (count != 123) \n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, IfTstPassed != 1);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_loop_bind.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 780",
        "issue_id": 2,
        "original_code": "//===--- test_loop_bind.c ---------------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the loop directive with the bind(binding) clause. The bind\n// clause indicates that the loop construct should apply in the context of the\n// given binding, one of teams, parallel, or thread. Each of these bindings\n// is tested in an appropriate context and the correctness of results of\n// array operations in the nested loop is checked.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 32\n\nint test_loop_bind_teams() {\n  OMPVV_INFOMSG(\"test_loop_bind_teams\");\n  int errors = 0;\n  int x[N][N];\n  int y[N];\n  int z[N];\n  int num_teams = -1;\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      x[i][j] = 1;\n    }\n    y[i] = i;\n    z[i] = 2*i;\n  }\n\n#pragma omp teams num_teams(OMPVV_NUM_TEAMS_DEVICE) thread_limit(OMPVV_NUM_THREADS_HOST)\n  {\n#pragma omp loop bind(teams)\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        x[i][j] += y[i]*z[i];\n      }\n    }\n    #pragma omp parallel if(0)\n    if (omp_get_team_num() == 0) {\n      num_teams = omp_get_num_teams();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, x[i][j] != (1 + (y[i]*z[i])));\n    }\n  }\n\n\n  OMPVV_WARNING_IF(num_teams == 1, \"Test ran with one team, so parallelism of loop construct with bind(teams) can't be guaranteed.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_teams < 1);\n  OMPVV_ERROR_IF(num_teams < 1, \"omp_get_num_teams() returned an invalid number of teams.\");\n\n  return errors;\n}\n\nint test_loop_bind_parallel() {\n  OMPVV_INFOMSG(\"test_loop_bind_parallel\");\n  int errors = 0;\n  int x[N][N];\n  int y[N];\n  int z[N];\n  int num_threads = -1;\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      x[i][j] = 1;\n    }\n    y[i] = i;\n    z[i] = 2*i;\n  }\n\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST)\n  {\n#pragma omp loop bind(parallel)\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        x[i][j] += y[i]*z[i];\n      }\n    }\n    if (omp_get_thread_num() == 0 && omp_get_team_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, x[i][j] != (1 + (y[i]*z[i])));\n    }\n  }\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of loop construct can't be guaranteed.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n  OMPVV_ERROR_IF(num_threads < 1, \"omp_get_num_threads() returned an invalid number of threads.\");\n\n  return errors;\n}\n\nint test_loop_bind_thread_teams() {\n  OMPVV_INFOMSG(\"test_loop_bind_thread_teams\");\n  int errors = 0;\n  int y[N];\n  int z[N];\n  int result[N][N][OMPVV_NUM_TEAMS_DEVICE];\n  int num_teams = -1;\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      for (int k = 0; k < OMPVV_NUM_TEAMS_DEVICE; k++) {\n        result[i][j][k] = 1;\n      }\n    }\n    y[i] = i;\n    z[i] = 2*i;\n  }\n\n#pragma omp teams num_teams(OMPVV_NUM_TEAMS_DEVICE) thread_limit(OMPVV_NUM_THREADS_HOST)\n  {\n    int x[N][N];\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        x[i][j] = 1;\n      }\n    }\n#pragma omp loop bind(thread)\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        x[i][j] += y[i]*z[i];\n      }\n    }\n#pragma omp parallel if(0)\n    if (omp_get_team_num() == 0) {\n      num_teams = omp_get_num_teams();\n    }\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        result[i][j][omp_get_team_num()] = x[i][j];\n      }\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      for (int k = 0; k < num_teams; k++) {\n        OMPVV_TEST_AND_SET_VERBOSE(errors, result[i][j][k] != (1 + (y[i]*z[i])));\n      }\n    }\n  }\n\n  OMPVV_WARNING_IF(num_teams == 1, \"Test ran with one team, so parallelism of loop construct can't be guaranteed.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_teams < 1);\n  OMPVV_ERROR_IF(num_teams < 1, \"omp_get_num_teams() returned an invalid number of teams.\");\n\n  return errors;\n}\n\nint test_loop_bind_thread_parallel() {\n  OMPVV_INFOMSG(\"test_loop_bind_thread_parallel\");\n  int errors = 0;\n  int y[N];\n  int z[N];\n  int result[N][N][OMPVV_NUM_THREADS_HOST];\n  int num_threads = -1;\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      for (int k = 0; k < OMPVV_NUM_THREADS_HOST; k++) {\n        result[i][j][k] = 1;\n      }\n    }\n    y[i] = i;\n    z[i] = 2*i;\n  }\n\n#pragma omp parallel shared(result) num_threads(OMPVV_NUM_THREADS_HOST)\n  {\n    int x[N][N];\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        x[i][j] = 1;\n      }\n    }\n#pragma omp loop bind(thread)\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        x[i][j] += y[i]*z[i];\n      }\n    }\n    if (omp_get_thread_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        result[i][j][omp_get_thread_num()] = x[i][j];\n      }\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      for (int k = 0; k < num_threads; k++) {\n        OMPVV_TEST_AND_SET_VERBOSE(errors, result[i][j][k] != (1 + (y[i]*z[i])));\n      }\n    }\n  }\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of loop construct can't be guaranteed.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n  OMPVV_ERROR_IF(num_threads < 1, \"omp_get_num_threads() returned an invalid number of threads.\");\n\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_loop_bind_teams());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_loop_bind_parallel());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_loop_bind_thread_teams());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_loop_bind_thread_parallel());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_loop_bind.c ---------------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the loop directive with the bind(binding) clause. The bind\n// clause indicates that the loop construct should apply in the context of the\n// given binding, one of teams, parallel, or thread. Each of these bindings\n// is tested in an appropriate context and the correctness of results of\n// array operations in the nested loop is checked.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 32\n\nint test_loop_bind_teams() {\n  OMPVV_INFOMSG(\"test_loop_bind_teams\");\n  int errors = 0;\n  int x[N][N];yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n  int y[N];\n  int z[N];\n  int num_teams = -1;\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      x[i][j] = 1;\n    }\n    y[i] = i;\n    z[i] = 2*i;\n  }\n\n#pragma omp teams num_teams(OMPVV_NUM_TEAMS_DEVICE) thread_limit(OMPVV_NUM_THREADS_HOST)\n  {\n#pragma omp loop bind(teams)\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        x[i][j] += y[i]*z[i];\n      }\n    }\n    #pragma omp parallel if(0)\n    if (omp_get_team_num() == 0) {\n      num_teams = omp_get_num_teams();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, x[i][j] != (1 + (y[i]*z[i])));\n    }\n  }\n\n\n  OMPVV_WARNING_IF(num_teams == 1, \"Test ran with one team, so parallelism of loop construct with bind(teams) can't be guaranteed.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_teams < 1);\n  OMPVV_ERROR_IF(num_teams < 1, \"omp_get_num_teams() returned an invalid number of teams.\");\n\n  return errors;\n}\n\nint test_loop_bind_parallel() {\n  OMPVV_INFOMSG(\"test_loop_bind_parallel\");\n  int errors = 0;\n  int x[N][N];\n  int y[N];\n  int z[N];\n  int num_threads = -1;\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      x[i][j] = 1;\n    }\n    y[i] = i;\n    z[i] = 2*i;\n  }\n\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST)\n  {\n#pragma omp loop bind(parallel)\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        x[i][j] += y[i]*z[i];\n      }\n    }\n    if (omp_get_thread_num() == 0 && omp_get_team_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, x[i][j] != (1 + (y[i]*z[i])));\n    }\n  }\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of loop construct can't be guaranteed.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n  OMPVV_ERROR_IF(num_threads < 1, \"omp_get_num_threads() returned an invalid number of threads.\");\n\n  return errors;\n}\n\nint test_loop_bind_thread_teams() {\n  OMPVV_INFOMSG(\"test_loop_bind_thread_teams\");\n  int errors = 0;\n  int y[N];\n  int z[N];\n  int result[N][N][OMPVV_NUM_TEAMS_DEVICE];\n  int num_teams = -1;\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      for (int k = 0; k < OMPVV_NUM_TEAMS_DEVICE; k++) {\n        result[i][j][k] = 1;\n      }\n    }\n    y[i] = i;\n    z[i] = 2*i;\n  }\n\n#pragma omp teams num_teams(OMPVV_NUM_TEAMS_DEVICE) thread_limit(OMPVV_NUM_THREADS_HOST)\n  {\n    int x[N][N];\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        x[i][j] = 1;\n      }\n    }\n#pragma omp loop bind(thread)\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        x[i][j] += y[i]*z[i];\n      }\n    }\n#pragma omp parallel if(0)\n    if (omp_get_team_num() == 0) {\n      num_teams = omp_get_num_teams();\n    }\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        result[i][j][omp_get_team_num()] = x[i][j];\n      }\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      for (int k = 0; k < num_teams; k++) {\n        OMPVV_TEST_AND_SET_VERBOSE(errors, result[i][j][k] != (1 + (y[i]*z[i])));\n      }\n    }\n  }\n\n  OMPVV_WARNING_IF(num_teams == 1, \"Test ran with one team, so parallelism of loop construct can't be guaranteed.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_teams < 1);\n  OMPVV_ERROR_IF(num_teams < 1, \"omp_get_num_teams() returned an invalid number of teams.\");\n\n  return errors;\n}\n\nint test_loop_bind_thread_parallel() {\n  OMPVV_INFOMSG(\"test_loop_bind_thread_parallel\");\n  int errors = 0;\n  int y[N];\n  int z[N];\n  int result[N][N][OMPVV_NUM_THREADS_HOST];\n  int num_threads = -1;\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      for (int k = 0; k < OMPVV_NUM_THREADS_HOST; k++) {\n        result[i][j][k] = 1;\n      }\n    }\n    y[i] = i;\n    z[i] = 2*i;\n  }\n\n#pragma omp parallel shared(result) num_threads(OMPVV_NUM_THREADS_HOST)\n  {\n    int x[N][N];\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        x[i][j] = 1;\n      }\n    }\n#pragma omp loop bind(thread)\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        x[i][j] += y[i]*z[i];\n      }\n    }\n    if (omp_get_thread_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        result[i][j][omp_get_thread_num()] = x[i][j];\n      }\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      for (int k = 0; k < num_threads; k++) {\n        OMPVV_TEST_AND_SET_VERBOSE(errors, result[i][j][k] != (1 + (y[i]*z[i])));\n      }\n    }\n  }\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of loop construct can't be guaranteed.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n  OMPVV_ERROR_IF(num_threads < 1, \"omp_get_num_threads() returned an invalid number of threads.\");\n\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_loop_bind_teams());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_loop_bind_parallel());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_loop_bind_thread_teams());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_loop_bind_thread_parallel());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_requires_unified_shared_memory_malloc_is_device_ptr.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp requires\" with directive \"#pragma omp parallel\" at position 543",
        "issue_id": 0,
        "original_code": "//===---test_requires_unified_shared_memory_malloc_is_device_ptr.c -----------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n// \n// This test Checks for unified shared memory of an array that is allocated using \n// malloc and that is accessed from host and device with the same pointer\n//\n// To guarantee the use of the device pointer, we use the is_device_ptr clause\n//\n////===----------------------------------------------------------------------===//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp requires unified_shared_memory\n\nint unified_shared_memory_malloc() {\n  OMPVV_INFOMSG(\"Unified shared memory testing - Array on malloc\");\n  int errors = 0;\n\n  int *anArray;\n  int *anArrayCopy;\n\n  anArray = (int*)malloc(sizeof(int)*N);\n  anArrayCopy = (int*)malloc(sizeof(int)*N);\n\n  if( anArray == NULL ) {\n    OMPVV_ERROR(\"Memory for anArray was not allocated\");\n    OMPVV_RETURN(1);\n  }\n\n  if( anArrayCopy == NULL ) {\n    OMPVV_ERROR(\"Memory for anArrayCopy was not allocated\");\n    OMPVV_RETURN(1);\n  }\n\n  for (int i = 0; i < N; i++) {\n    anArray[i] = i;\n    anArrayCopy[i] = 0;\n  }\n  // Modify in the device\n#pragma omp target is_device_ptr(anArray)\n  {\n    for (int i = 0; i < N; i++) {\n      anArray[i] += 10;\n    }\n  }\n  // Modify again on the host\n  for (int i = 0; i < N; i++) {\n    anArray[i] += 10;\n  }\n\n  // Get the value the device is seeing\n#pragma omp target is_device_ptr(anArray)\n  {\n    for (int i = 0; i < N; i++) {\n      anArrayCopy[i] = anArray[i];\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArray[i] != i + 20);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArrayCopy[i] != i + 20);\n    if (errors) break;\n  }\n\n  free(anArray);\n  free(anArrayCopy);\n  return errors;\n}\nint main() {\n  int isOffloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"With no offloading, unified shared memory is guaranteed due to host execution\");\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, unified_shared_memory_malloc());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n",
        "error_code": "//===---test_requires_unified_shared_memory_malloc_is_device_ptr.c -----------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n// \n// This test Checks for unified shared memory of an array that is allocated using \n// malloc and that is accessed from host and device with the same pointer\n//\n// To guarantee the use of the device pointer, we use the is_device_ptr clause\n//\n////===----------------------------------------------------------------------===//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp parallel unified_shared_memory\n\nint unified_shared_memory_malloc() {\n  OMPVV_INFOMSG(\"Unified shared memory testing - Array on malloc\");\n  int errors = 0;\n\n  int *anArray;\n  int *anArrayCopy;\n\n  anArray = (int*)malloc(sizeof(int)*N);\n  anArrayCopy = (int*)malloc(sizeof(int)*N);\n\n  if( anArray == NULL ) {\n    OMPVV_ERROR(\"Memory for anArray was not allocated\");\n    OMPVV_RETURN(1);\n  }\n\n  if( anArrayCopy == NULL ) {\n    OMPVV_ERROR(\"Memory for anArrayCopy was not allocated\");\n    OMPVV_RETURN(1);\n  }\n\n  for (int i = 0; i < N; i++) {\n    anArray[i] = i;\n    anArrayCopy[i] = 0;\n  }\n  // Modify in the device\n#pragma omp target is_device_ptr(anArray)\n  {\n    for (int i = 0; i < N; i++) {\n      anArray[i] += 10;\n    }\n  }\n  // Modify again on the host\n  for (int i = 0; i < N; i++) {\n    anArray[i] += 10;\n  }\n\n  // Get the value the device is seeing\n#pragma omp target is_device_ptr(anArray)\n  {\n    for (int i = 0; i < N; i++) {\n      anArrayCopy[i] = anArray[i];\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArray[i] != i + 20);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArrayCopy[i] != i + 20);\n    if (errors) break;\n  }\n\n  free(anArray);\n  free(anArrayCopy);\n  return errors;\n}\nint main() {\n  int isOffloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"With no offloading, unified shared memory is guaranteed due to host execution\");\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, unified_shared_memory_malloc());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_atomic_compare.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp parallel\" with directive \"#pragma omp teams\" at position 805",
        "issue_id": 0,
        "original_code": "//===--- test_atomic_compare.c ---===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// Adapted from OpenMP example video https://www.youtube.com/watch?v=iS6IG7nzCSo\n// Creates an array with random numbers, and uses atomic compare to find the max,\n// testing against non-parallel maximum.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 100\n\nint test_atomic_compare() {\n  OMPVV_INFOMSG(\"test_atomic_compare\");\n\n  int arr[N];\n  int errors = 0;\n  int pmax = 0, smax = 0;\n\n   for(int i=0; i<N; i++){\n      arr[i] = rand()%1000;\n   }\n   for(int i = 0; i<N; i++){ // Sets max through non-parallel methods\n      if(arr[i] > smax){\n         smax = arr[i];\n      }\n   }\n   #pragma omp parallel for shared(pmax)// Sets max using parallel for loop, using atomic to ensure max is correct\n   for(int i = 0; i<N; i++){\n      #pragma omp atomic compare\n      if(arr[i] > pmax){\n         pmax = arr[i];\n      }\n   }\n   OMPVV_TEST_AND_SET(errors, pmax != smax);\n   return errors;\n}\n\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_atomic_compare());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_atomic_compare.c ---===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// Adapted from OpenMP example video https://www.youtube.com/watch?v=iS6IG7nzCSo\n// Creates an array with random numbers, and uses atomic compare to find the max,\n// testing against non-parallel maximum.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 100\n\nint test_atomic_compare() {\n  OMPVV_INFOMSG(\"test_atomic_compare\");\n\n  int arr[N];\n  int errors = 0;\n  int pmax = 0, smax = 0;\n\n   for(int i=0; i<N; i++){\n      arr[i] = rand()%1000;\n   }\n   for(int i = 0; i<N; i++){ // Sets max through non-parallel methods\n      if(arr[i] > smax){\n         smax = arr[i];\n      }\n   }\n   #pragma omp teams for shared(pmax)// Sets max using parallel for loop, using atomic to ensure max is correct\n   for(int i = 0; i<N; i++){\n      #pragma omp atomic compare\n      if(arr[i] > pmax){\n         pmax = arr[i];\n      }\n   }\n   OMPVV_TEST_AND_SET(errors, pmax != smax);\n   return errors;\n}\n\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_atomic_compare());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_allocate.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===----------------- test_allocate.c ------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Tests the allocate directive. A variable 'x' is allocated using \n// the omp_alloc call. If no clause is specified then the memory allocator s\n// pecified by the def-allocator-var ICV will be used. The tests \n// checks that the values were written correctly, and then frees the memory.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_allocate() {\n  int errors = 0;\n  int x[N];\n\n#pragma omp allocate(x) \n\n#pragma omp parallel for \n  for (int i = 0; i < N; i++) {\n    x[i] = i;\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != i);\n  }\n\n\n  return errors;\n}\n\nint main() {\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_allocate() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nfloat zgatcdxbwv = 210;\nlong xjrfxhbqhh = 43;\nbyte otzrkzpiyv = 8;\nlong tczqypisvd = 100;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_error_message.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 980",
        "issue_id": 1,
        "original_code": "//===--- test_error_message.c ----------------------------===//\n//\n//  OpenMP API Version 5.1 Aug 2021\n//\n//  Test uses error directive with message clause to print a message,\n//  if error condition is reached then \"runtime error!\" is printed,\n//  otherwise is simply used to print a message. \n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\nint errors, i;\n\nint test_error_message() {\n    i = 0;\n    OMPVV_INFOMSG(\"If successful, test should print an \\\"error message success\\\" at the beginning of the test\");\n    #pragma omp parallel\n    {\n        #pragma omp single\n        {\n            #pragma omp error severity(warning) message(\"error message success\")\n            i+=5;\n        }\n    }\n    OMPVV_TEST_AND_SET_VERBOSE(errors, i != 5);\n    OMPVV_ERROR_IF(errors > 0, \"Error directive caused execution error\");\n    return errors;\n}\n\nint main() {\n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_error_message() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_error_message.c ----------------------------===//\n//\n//  OpenMP API Version 5.1 Aug 2021\n//\n//  Test uses error directive with message clause to print a message,\n//  if error condition is reached then \"runtime error!\" is printed,\n//  otherwise is simply used to print a message. \n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\nint errors, i;\n\nint test_error_message() {\n    i = 0;\n    OMPVV_INFOMSG(\"If successful, test should print an \\\"error message success\\\" at the beginning of the test\");\n    #pragma omp parallel\n    {\n        #pragma omp single\n        {\n            #pragma omp error severity(warning) message(\"error message success\")\n            i+=5;\n        }\n    }\n    OMPVV_TEST_AND_SET_VERBOSE(errors, i != 5);\n    OMPVV_ERROR_IF(errors > 0, \"Error directive caused execution error\");\n    return errors;\n}\n\nint main() \n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_error_message() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_loop_nowait.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 820",
        "issue_id": 1,
        "original_code": "#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <time.h>\n\n#define N 1024\n\n/**\n  This is a basic test to demonstrate nowait clause used\n  with \"omp target teams loop\".\n*/\nint main() {\n  int *a, *b, *c;\n  a = (int*) malloc(N*sizeof(int));\n  b = (int*) malloc(N*sizeof(int));\n  c = (int*) malloc(N*sizeof(int));\n  if ((a == NULL) || (b == NULL) || (c == NULL)) {\n    OMPVV_REPORT_AND_RETURN(1);\n  }\n  int errors = 0;\n  srand(time(NULL));\n  // Data Inititalize\n  for (int i = 0; i < N; i++) {\n    a[i] = (rand() % 1024) + 1;\n    b[i] = (rand() % 1024) + 1;\n    c[i] = 0;\n  }\n  // Execute on target\n#pragma omp target teams loop map(to: a[0:N], b[0:N]) map(from: c[0:N]) nowait\n  for (int i = 0; i < N; i++) {\n    c[i] = a[i] + b[i];\n  }\n#pragma omp taskwait\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, c[i] != a[i] + b[i]);\n  }\n  free(a);\n  free(b);\n  free(c);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <time.h>\n\n#define N 1024\n\n/**\n  This is a basic test to demonstrate nowait clause used\n  with \"omp target teams loop\".\n*/\nint main() {\n  int *a, *b, *c;\n  a = (int*) malloc(N*sizeof(int));\n  b = (int*) malloc(N*sizeof(int));\n  c = (int*) malloc(N*sizeof(int));\n  if ((a == NULL) || (b == NULL) || (c == NULL)) {\n    OMPVV_REPORT_AND_RETURN(1);\n  }\n  int errors = 0;\n  srand(time(NULL));\n  // Data Inititalize\n  for (int i = 0; i < N; i++) {\n    a[i] = (rand() % 1024) + 1;\n    b[i] = (rand() % 1024) + 1;\n    c[i] = 0;\n  }\n  // Execute on target\n#pragma omp target teams loop map(to: a[0:N], b[0:N]) map(from: c[0:N]) nowait\n  for (int i = 0; i < N; i++) {\n    c[i] = a[i] + b[i];\n  }\n#pragma omp taskwait\n  for (int i = 0; i < N; i++) \n    OMPVV_TEST_AND_SET_VERBOSE(errors, c[i] != a[i] + b[i]);\n  }\n  free(a);\n  free(b);\n  free(c);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_collapse.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===------ test_target_collapse.c --------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Tests the target directive with collapse clause.\n//\n//===------------------------------------------------------------------------===//\n\n\n#include <stdio.h>\n#include \"omp.h\"\n#include \"ompvv.h\"\n\n#define N 5\nint Runtst(int gpu) {\n  int A[N], B[N] = {0};\n  int errors = 0;\n  for (int i = 0; i < N; ++i) {\n    A[i] = 0;\n    B[i] = i + 1;\n  }\n#pragma omp target data map(tofrom: A, B) device(gpu)\n#pragma omp target parallel for collapse(2) shared(A, B) device(gpu)\n  for (int i = 0; i < N; ++i) {\n    for (int j = 0; j < N; ++j) {\n#pragma omp atomic\n      A[i] += B[j];\n    }\n  }\n\n  // verifying the result\n  for (int i = 0; i < N; ++i) {\n    if (A[i] != N * (N + 1)/2) {\n      errors++;\n    }\n  }\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int TotGpus = omp_get_num_devices();\n  int errors = 0;\n  for (int gpu = 0; gpu < TotGpus; ++gpu) {\n    OMPVV_TEST_AND_SET(errors, Runtst(gpu) != 0);\n  }\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nint ptcapuathr = 237;\nlong thtxsouamo = 149;\nshort dfbnvidfuv = 146;\nfloat evzpmvcxec = 207;\nshort oyjdvdvzrm = 79;\nint fltvatghrk = 113;\nlong zuszccrsoh = 213;\nlong dwubdxhkxh = 146;\nbyte ezytwztfqi = 190;\nshort almznpmwtg = 178;\ndouble hdqrboipes = 121;\nlong whzzgodnjm = 18;\nlong wfisxkkqfe = 150;\nfloat hslnqlzoad = 179;\ndouble ipplvjndkt = 73;\nshort eyvldircnf = 186;\nbyte qrwwpbkhuq = 53;\nshort nnzirbwjcr = 205;\nfloat tdtxyphcxw = 218;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_task_depend_mutexinoutset.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===--- test_task_depend_mutexinoutset.c ------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//  \n// This test verifies the working of the mutexinout on the depend clause.\n// Here task T5 will be scheduled after tasks T1 and T3 are completed. Due to \n// the mutexinoutset dependence type on c, T4 and T5 may be scheduled\n// in any order with respect to each other, but not at the same time. Tasks \n// T6 will be scheduled after both T4 and T5 are completed.\n//\n// Adapted from OpenMP Examples 5.0.\n////===----------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_task_depend_mutexinoutset() {\n  OMPVV_INFOMSG(\"test_task_mutexinoutset\");\n  int errors = 0;\n  int a, b, c, d;\n\n#pragma omp parallel\n#pragma omp single\n  {\n#pragma omp task depend(out: c)\n   c = 1; /* Task T1 */\n #pragma omp task depend(out: a)\n   a = 2; /* Task T2 */\n #pragma omp task depend(out: b)\n   b = 3; /* Task T3 */\n #pragma omp task depend(in: a) depend(mutexinoutset: c)\n   c += a; /* Task T4 */\n #pragma omp task depend(in: b) depend(mutexinoutset: c)\n   c += b; /* Task T5 */\n #pragma omp task depend(in: c)\n   d = c; /* Task T6 */\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, d != 6);\n\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_task_depend_mutexinoutset());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nshort flzhwzqbxu = 120;\ndouble kwokscaydv = 30;\nlong mzyfjkiogl = 115;\nfloat sxxeffqwey = 249;\nshort asinvpuxvu = 110;\nfloat puvvlwlgsk = 23;\nbyte tslkhvpzgv = 12;\nlong jbbcvsdcbi = 248;\ndouble btdshhnula = 12;\nlong ttaurmzixv = 33;\ndouble bibkyxbgjp = 69;\ndouble ndqeyemyac = 0;\nint xgxrpsyxrd = 21;\nlong tnnfpvwolp = 68;\nlong hbdtheyujr = 230;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_defaultmap.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 13133",
        "issue_id": 1,
        "original_code": "//===--- test_target_teams_distribute_defaultmap.c---------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the defaultmap clause on a target teams distribute directive.\n// This tests the following scalars: char, short, int, float, double, and enum.\n// Both using the clause defaultmap(tofrom:scalar) is used. When it is used,\n// the test tests the to nature by setting arrays to the value.  Then it is also\n// tested that, as opposed to the default action on scalars which is to first-\n// privatize them, they are shared and returned to the host.\n//\n// It also tests the default operation of treating scalars without the defaultmap\n// clause.  The test first tests the privatization of the firstprivatized\n// scalars and then separately tests the proper initialization of them separately\n//\n////===----------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define ARRAY_SIZE 1024\nenum enum_type { VAL1 = 1, VAL2, VAL3, VAL4};\n\nint test_defaultmap_on() {\n  OMPVV_INFOMSG(\"test_defaultmap_on\");\n\n  int errors = 0;\n\n  // we try with all the scalars\n  char scalar_char = 'a';\n  char char_array[ARRAY_SIZE];\n  short scalar_short = 10;\n  short short_array[ARRAY_SIZE];\n  int scalar_int = 11;\n  int int_array[ARRAY_SIZE];\n  float scalar_float = 5.5f;\n  float float_array[ARRAY_SIZE];\n  double scalar_double = 10.45;\n  double double_array[ARRAY_SIZE];\n  enum enum_type scalar_enum = VAL1;\n  enum enum_type enum_array[ARRAY_SIZE];\n\n#pragma omp target teams distribute defaultmap(tofrom: scalar) map(from: char_array[0:ARRAY_SIZE], \\\n                                                                   short_array[0:ARRAY_SIZE], \\\n                                                                   int_array[0:ARRAY_SIZE], \\\n                                                                   float_array[0:ARRAY_SIZE], \\\n                                                                   double_array[0:ARRAY_SIZE], \\\n                                                                   enum_array[0:ARRAY_SIZE])\n  for (int x = 0; x < ARRAY_SIZE; ++x){\n    char_array[x] = scalar_char;\n    short_array[x] = scalar_short;\n    int_array[x] = scalar_int;\n    float_array[x] = scalar_float;\n    double_array[x] = scalar_double;\n    enum_array[x] = scalar_enum;\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x){\n    OMPVV_TEST_AND_SET_VERBOSE(errors, char_array[x] != 'a');\n    if (char_array[x] != 1){\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x){\n    OMPVV_TEST_AND_SET_VERBOSE(errors, short_array[x] != 10);\n    if (short_array[x] != 2){\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x){\n    OMPVV_TEST_AND_SET_VERBOSE(errors, int_array[x] != 11);\n    if (int_array[x] != 3){\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x){\n    OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(float_array[x] - 5.5f) > .0000001);\n    if (fabs(float_array[x] - .4) > .0000000001){\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x){\n    OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(double_array[x] - 10.45) > .0000000001);\n    if (fabs(double_array[x] - .5) > .0000000001){\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x){\n    OMPVV_TEST_AND_SET_VERBOSE(errors, enum_array[x] != VAL1);\n    if (enum_array[x] != VAL2){\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x){\n    char_array[x] = 1;\n    short_array[x] = 2;\n    int_array[x] = 3;\n    float_array[x] = .4;\n    double_array[x] = .5;\n    enum_array[x] = VAL2;\n  }\n\n#pragma omp target teams distribute defaultmap(tofrom: scalar) map(tofrom: char_array[0:ARRAY_SIZE], \\\n                                                                   short_array[0:ARRAY_SIZE], \\\n                                                                   int_array[0:ARRAY_SIZE], \\\n                                                                   float_array[0:ARRAY_SIZE], \\\n                                                                   double_array[0:ARRAY_SIZE], \\\n                                                                   enum_array[0:ARRAY_SIZE])\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    if (omp_get_team_num() == 0) {\n      scalar_char = char_array[x];\n      scalar_short = short_array[x];\n      scalar_int = int_array[x];\n      scalar_float = float_array[x];\n      scalar_double = double_array[x];\n      scalar_enum = enum_array[x];\n    }\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_char != char_array[0]);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_short != short_array[0]);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_int != int_array[0]);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(scalar_float - float_array[0]) > .0000001);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(scalar_double - double_array[0]) > .0000000001);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_enum != enum_array[0]);\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, char_array[x] != 1);\n    if (char_array[x] != 1) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, short_array[x] != 2);\n    if (short_array[x] != 2) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, int_array[x] != 3);\n    if (int_array[x] != 3) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(float_array[x] - .4) > .0000001);\n    if (fabs(float_array[x] - .4) > .0000000001) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(double_array[x] - .5) > .0000000001);\n    if (fabs(double_array[x] - .5) > .0000000001) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, enum_array[x] != VAL2);\n    if (enum_array[x] != VAL2) {\n      break;\n    }\n  }\n\n  return errors;\n}\n\nint test_defaultmap_off() {\n  OMPVV_INFOMSG(\"test_defaultmap_off\");\n\n  int errors = 0;\n\n  // we try with all the scalars\n  char scalar_char = 'a';\n  char scalar_char_copy;\n  char char_array_a[ARRAY_SIZE];\n  char char_array_b[ARRAY_SIZE];\n  short scalar_short = 10;\n  short scalar_short_copy;\n  short short_array_a[ARRAY_SIZE];\n  short short_array_b[ARRAY_SIZE];\n  int scalar_int = 11;\n  int scalar_int_copy;\n  int int_array_a[ARRAY_SIZE];\n  int int_array_b[ARRAY_SIZE];\n  float scalar_float = 5.5f;\n  float scalar_float_copy;\n  float float_array_a[ARRAY_SIZE];\n  float float_array_b[ARRAY_SIZE];\n  double scalar_double = 10.45;\n  double scalar_double_copy;\n  double double_array_a[ARRAY_SIZE];\n  double double_array_b[ARRAY_SIZE];\n  enum enum_type scalar_enum = VAL1;\n  enum enum_type scalar_enum_copy;\n  enum enum_type enum_array_a[ARRAY_SIZE];\n  enum enum_type enum_array_b[ARRAY_SIZE];\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    char_array_a[x] = x%10;\n    char_array_b[x] = 0;\n    short_array_a[x] = x%20;\n    short_array_b[x] = 0;\n    int_array_a[x] = x%30;\n    int_array_b[x] = 0;\n    float_array_a[x] = x / 40.0;\n    float_array_b[x] = 0;\n    double_array_a[x] = x / 50.0;\n    double_array_b[x] = 0;\n    enum_array_a[x] = (enum enum_type)(x%4 + 1);\n    enum_array_b[x] = VAL1;\n  }\n\n\n  //Testing the privatization nature of firstprivate default action\n#pragma omp target teams distribute map(tofrom: char_array_a[0:ARRAY_SIZE], char_array_b[0:ARRAY_SIZE], \\\n                                        short_array_a[0:ARRAY_SIZE], short_array_b[0:ARRAY_SIZE], \\\n                                        int_array_a[0:ARRAY_SIZE], int_array_b[0:ARRAY_SIZE], \\\n                                        float_array_a[0:ARRAY_SIZE], float_array_b[0:ARRAY_SIZE], \\\n                                        double_array_a[0:ARRAY_SIZE], double_array_b[0:ARRAY_SIZE], \\\n                                        enum_array_a[0:ARRAY_SIZE], enum_array_b[0:ARRAY_SIZE])\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    scalar_char = 0;\n    for (int y = 0; y < char_array_a[x]; ++y) {\n      scalar_char += 1;\n    }\n    char_array_b[x] = scalar_char;\n    scalar_short = 0;\n    for (int y = 0; y < short_array_a[x]; ++y) {\n      scalar_short += 1;\n    }\n    short_array_b[x] = scalar_short;\n    scalar_int = 0;\n    for (int y = 0; y < int_array_a[x]; ++y) {\n      scalar_int += 1;\n    }\n    int_array_b[x] = scalar_int;\n    scalar_float = 0;\n    for (int y = 0; y < ((int)float_array_a[x]); ++y) {\n      scalar_float += .7f;\n    }\n    float_array_b[x] = scalar_float;\n    scalar_double = 0;\n    for (int y = 0; y < ((int)double_array_a[x]); ++y) {\n      scalar_double += .9;\n    }\n    double_array_b[x] = scalar_double;\n    scalar_enum = VAL1;\n    for (int y = 1; y < enum_array_a[x]; ++y) {\n      scalar_enum = (enum enum_type)(scalar_enum + 1);\n    }\n    enum_array_b[x] = scalar_enum;\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, char_array_b[x] != char_array_a[x]);\n    if (char_array_b[x] != char_array_a[x]) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, short_array_b[x] != short_array_a[x]);\n    if (short_array_b[x] != short_array_a[x]) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, int_array_b[x] != int_array_a[x]);\n    if (int_array_b[x] != int_array_a[x]) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(float_array_b[x] - (((int) float_array_a[x]) * .7)) > .00001);\n    if (fabs(float_array_b[x] - (((int) float_array_a[x]) * .7)) > .00001) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(double_array_b[x] - (((int) double_array_a[x]) * .9)) > .000000001);\n    if (fabs(double_array_b[x] - (((int) double_array_a[x]) * .9)) > .000000001) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, enum_array_b[x] != enum_array_a[x]);\n    if (enum_array_b[x] != enum_array_a[x]) {\n      break;\n    }\n  }\n\n  scalar_char = 26;\n  scalar_short = 126;\n  scalar_int = 5126;\n  scalar_float = 5.126;\n  scalar_double = 51.26;\n  scalar_enum = VAL2;\n\n  scalar_char_copy = scalar_char;\n  scalar_short_copy = scalar_short;\n  scalar_int_copy = scalar_int;\n  scalar_float_copy = scalar_float;\n  scalar_double_copy = scalar_double;\n  scalar_enum_copy = scalar_enum;\n\n  // Testing the copy of scalar values to the device\n#pragma omp target teams distribute map(tofrom: char_array_a[0:ARRAY_SIZE], short_array_a[0:ARRAY_SIZE], \\\n                                        int_array_a[0:ARRAY_SIZE], float_array_a[0:ARRAY_SIZE], \\\n                                        double_array_a[0:ARRAY_SIZE], enum_array_a[0:ARRAY_SIZE])\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    char_array_a[x] = scalar_char;\n    short_array_a[x] = scalar_short;\n    int_array_a[x] = scalar_int;\n    float_array_a[x] = scalar_float;\n    double_array_a[x] = scalar_double;\n    enum_array_a[x] = scalar_enum;\n  }\n\n  // Testing the fact that values should not be modified\n  // at the host (unless shared memory or running on the host)\n#pragma omp target teams distribute\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    scalar_char = 0;\n    scalar_short = 0;\n    scalar_int = 0;\n    scalar_float = 0;\n    scalar_double = 0;\n    scalar_enum = VAL3;\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, char_array_a[x] != scalar_char_copy);\n    if (char_array_a[x] != scalar_char_copy) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, short_array_a[x] != scalar_short_copy);\n    if (short_array_a[x] != scalar_short_copy) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, int_array_a[x] != scalar_int_copy);\n    if (int_array_a[x] != scalar_int_copy) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(float_array_a[x] - scalar_float_copy) > .00001);\n    if (fabs(float_array_a[x] - scalar_float_copy) > .00001) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(double_array_a[x] - scalar_double_copy) > .000000001);\n    if (fabs(double_array_a[x] - scalar_double_copy) > .000000001) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, enum_array_a[x] != scalar_enum_copy);\n    if (enum_array_a[x] != scalar_enum_copy) {\n      break;\n    }\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_char != scalar_char_copy);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_short != scalar_short_copy);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_int != scalar_int_copy);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(scalar_float - scalar_float_copy) > .00001);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(scalar_double - scalar_double_copy) > .000000001);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_enum != scalar_enum_copy);\n\n  return errors;\n}\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_defaultmap_on());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_defaultmap_off());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_defaultmap.c---------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the defaultmap clause on a target teams distribute directive.\n// This tests the following scalars: char, short, int, float, double, and enum.\n// Both using the clause defaultmap(tofrom:scalar) is used. When it is used,\n// the test tests the to nature by setting arrays to the value.  Then it is also\n// tested that, as opposed to the default action on scalars which is to first-\n// privatize them, they are shared and returned to the host.\n//\n// It also tests the default operation of treating scalars without the defaultmap\n// clause.  The test first tests the privatization of the firstprivatized\n// scalars and then separately tests the proper initialization of them separately\n//\n////===----------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define ARRAY_SIZE 1024\nenum enum_type { VAL1 = 1, VAL2, VAL3, VAL4};\n\nint test_defaultmap_on() {\n  OMPVV_INFOMSG(\"test_defaultmap_on\");\n\n  int errors = 0;\n\n  // we try with all the scalars\n  char scalar_char = 'a';\n  char char_array[ARRAY_SIZE];\n  short scalar_short = 10;\n  short short_array[ARRAY_SIZE];\n  int scalar_int = 11;\n  int int_array[ARRAY_SIZE];\n  float scalar_float = 5.5f;\n  float float_array[ARRAY_SIZE];\n  double scalar_double = 10.45;\n  double double_array[ARRAY_SIZE];\n  enum enum_type scalar_enum = VAL1;\n  enum enum_type enum_array[ARRAY_SIZE];\n\n#pragma omp target teams distribute defaultmap(tofrom: scalar) map(from: char_array[0:ARRAY_SIZE], \\\n                                                                   short_array[0:ARRAY_SIZE], \\\n                                                                   int_array[0:ARRAY_SIZE], \\\n                                                                   float_array[0:ARRAY_SIZE], \\\n                                                                   double_array[0:ARRAY_SIZE], \\\n                                                                   enum_array[0:ARRAY_SIZE])\n  for (int x = 0; x < ARRAY_SIZE; ++x){\n    char_array[x] = scalar_char;\n    short_array[x] = scalar_short;\n    int_array[x] = scalar_int;\n    float_array[x] = scalar_float;\n    double_array[x] = scalar_double;\n    enum_array[x] = scalar_enum;\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x){\n    OMPVV_TEST_AND_SET_VERBOSE(errors, char_array[x] != 'a');\n    if (char_array[x] != 1){\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x){\n    OMPVV_TEST_AND_SET_VERBOSE(errors, short_array[x] != 10);\n    if (short_array[x] != 2){\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x){\n    OMPVV_TEST_AND_SET_VERBOSE(errors, int_array[x] != 11);\n    if (int_array[x] != 3){\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x){\n    OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(float_array[x] - 5.5f) > .0000001);\n    if (fabs(float_array[x] - .4) > .0000000001){\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x){\n    OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(double_array[x] - 10.45) > .0000000001);\n    if (fabs(double_array[x] - .5) > .0000000001){\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x){\n    OMPVV_TEST_AND_SET_VERBOSE(errors, enum_array[x] != VAL1);\n    if (enum_array[x] != VAL2){\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x){\n    char_array[x] = 1;\n    short_array[x] = 2;\n    int_array[x] = 3;\n    float_array[x] = .4;\n    double_array[x] = .5;\n    enum_array[x] = VAL2;\n  }\n\n#pragma omp target teams distribute defaultmap(tofrom: scalar) map(tofrom: char_array[0:ARRAY_SIZE], \\\n                                                                   short_array[0:ARRAY_SIZE], \\\n                                                                   int_array[0:ARRAY_SIZE], \\\n                                                                   float_array[0:ARRAY_SIZE], \\\n                                                                   double_array[0:ARRAY_SIZE], \\\n                                                                   enum_array[0:ARRAY_SIZE])\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    if (omp_get_team_num() == 0) {\n      scalar_char = char_array[x];\n      scalar_short = short_array[x];\n      scalar_int = int_array[x];\n      scalar_float = float_array[x];\n      scalar_double = double_array[x];\n      scalar_enum = enum_array[x];\n    }\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_char != char_array[0]);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_short != short_array[0]);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_int != int_array[0]);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(scalar_float - float_array[0]) > .0000001);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(scalar_double - double_array[0]) > .0000000001);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_enum != enum_array[0]);\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, char_array[x] != 1);\n    if (char_array[x] != 1) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, short_array[x] != 2);\n    if (short_array[x] != 2) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, int_array[x] != 3);\n    if (int_array[x] != 3) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(float_array[x] - .4) > .0000001);\n    if (fabs(float_array[x] - .4) > .0000000001) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(double_array[x] - .5) > .0000000001);\n    if (fabs(double_array[x] - .5) > .0000000001) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, enum_array[x] != VAL2);\n    if (enum_array[x] != VAL2) {\n      break;\n    }\n  }\n\n  return errors;\n}\n\nint test_defaultmap_off() {\n  OMPVV_INFOMSG(\"test_defaultmap_off\");\n\n  int errors = 0;\n\n  // we try with all the scalars\n  char scalar_char = 'a';\n  char scalar_char_copy;\n  char char_array_a[ARRAY_SIZE];\n  char char_array_b[ARRAY_SIZE];\n  short scalar_short = 10;\n  short scalar_short_copy;\n  short short_array_a[ARRAY_SIZE];\n  short short_array_b[ARRAY_SIZE];\n  int scalar_int = 11;\n  int scalar_int_copy;\n  int int_array_a[ARRAY_SIZE];\n  int int_array_b[ARRAY_SIZE];\n  float scalar_float = 5.5f;\n  float scalar_float_copy;\n  float float_array_a[ARRAY_SIZE];\n  float float_array_b[ARRAY_SIZE];\n  double scalar_double = 10.45;\n  double scalar_double_copy;\n  double double_array_a[ARRAY_SIZE];\n  double double_array_b[ARRAY_SIZE];\n  enum enum_type scalar_enum = VAL1;\n  enum enum_type scalar_enum_copy;\n  enum enum_type enum_array_a[ARRAY_SIZE];\n  enum enum_type enum_array_b[ARRAY_SIZE];\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    char_array_a[x] = x%10;\n    char_array_b[x] = 0;\n    short_array_a[x] = x%20;\n    short_array_b[x] = 0;\n    int_array_a[x] = x%30;\n    int_array_b[x] = 0;\n    float_array_a[x] = x / 40.0;\n    float_array_b[x] = 0;\n    double_array_a[x] = x / 50.0;\n    double_array_b[x] = 0;\n    enum_array_a[x] = (enum enum_type)(x%4 + 1);\n    enum_array_b[x] = VAL1;\n  }\n\n\n  //Testing the privatization nature of firstprivate default action\n#pragma omp target teams distribute map(tofrom: char_array_a[0:ARRAY_SIZE], char_array_b[0:ARRAY_SIZE], \\\n                                        short_array_a[0:ARRAY_SIZE], short_array_b[0:ARRAY_SIZE], \\\n                                        int_array_a[0:ARRAY_SIZE], int_array_b[0:ARRAY_SIZE], \\\n                                        float_array_a[0:ARRAY_SIZE], float_array_b[0:ARRAY_SIZE], \\\n                                        double_array_a[0:ARRAY_SIZE], double_array_b[0:ARRAY_SIZE], \\\n                                        enum_array_a[0:ARRAY_SIZE], enum_array_b[0:ARRAY_SIZE])\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    scalar_char = 0;\n    for (int y = 0; y < char_array_a[x]; ++y) {\n      scalar_char += 1;\n    }\n    char_array_b[x] = scalar_char;\n    scalar_short = 0;\n    for (int y = 0; y < short_array_a[x]; ++y) {\n      scalar_short += 1;\n    }\n    short_array_b[x] = scalar_short;\n    scalar_int = 0;\n    for (int y = 0; y < int_array_a[x]; ++y) {\n      scalar_int += 1;\n    }\n    int_array_b[x] = scalar_int;\n    scalar_float = 0;\n    for (int y = 0; y < ((int)float_array_a[x]); ++y) {\n      scalar_float += .7f;\n    }\n    float_array_b[x] = scalar_float;\n    scalar_double = 0;\n    for (int y = 0; y < ((int)double_array_a[x]); ++y) {\n      scalar_double += .9;\n    }\n    double_array_b[x] = scalar_double;\n    scalar_enum = VAL1;\n    for (int y = 1; y < enum_array_a[x]; ++y) {\n      scalar_enum = (enum enum_type)(scalar_enum + 1);\n    }\n    enum_array_b[x] = scalar_enum;\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, char_array_b[x] != char_array_a[x]);\n    if (char_array_b[x] != char_array_a[x]) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, short_array_b[x] != short_array_a[x]);\n    if (short_array_b[x] != short_array_a[x]) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, int_array_b[x] != int_array_a[x]);\n    if (int_array_b[x] != int_array_a[x]) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(float_array_b[x] - (((int) float_array_a[x]) * .7)) > .00001);\n    if (fabs(float_array_b[x] - (((int) float_array_a[x]) * .7)) > .00001) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(double_array_b[x] - (((int) double_array_a[x]) * .9)) > .000000001);\n    if (fabs(double_array_b[x] - (((int) double_array_a[x]) * .9)) > .000000001) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, enum_array_b[x] != enum_array_a[x]);\n    if (enum_array_b[x] != enum_array_a[x]) {\n      break;\n    }\n  }\n\n  scalar_char = 26;\n  scalar_short = 126;\n  scalar_int = 5126;\n  scalar_float = 5.126;\n  scalar_double = 51.26;\n  scalar_enum = VAL2;\n\n  scalar_char_copy = scalar_char;\n  scalar_short_copy = scalar_short;\n  scalar_int_copy = scalar_int;\n  scalar_float_copy = scalar_float;\n  scalar_double_copy = scalar_double;\n  scalar_enum_copy = scalar_enum;\n\n  // Testing the copy of scalar values to the device\n#pragma omp target teams distribute map(tofrom: char_array_a[0:ARRAY_SIZE], short_array_a[0:ARRAY_SIZE], \\\n                                        int_array_a[0:ARRAY_SIZE], float_array_a[0:ARRAY_SIZE], \\\n                                        double_array_a[0:ARRAY_SIZE], enum_array_a[0:ARRAY_SIZE])\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    char_array_a[x] = scalar_char;\n    short_array_a[x] = scalar_short;\n    int_array_a[x] = scalar_int;\n    float_array_a[x] = scalar_float;\n    double_array_a[x] = scalar_double;\n    enum_array_a[x] = scalar_enum;\n  }\n\n  // Testing the fact that values should not be modified\n  // at the host (unless shared memory or running on the host)\n#pragma omp target teams distribute\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    scalar_char = 0;\n    scalar_short = 0;\n    scalar_int = 0;\n    scalar_float = 0;\n    scalar_double = 0;\n    scalar_enum = VAL3;\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, char_array_a[x] != scalar_char_copy);\n    if (char_array_a[x] != scalar_char_copy) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, short_array_a[x] != scalar_short_copy);\n    if (short_array_a[x] != scalar_short_copy) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, int_array_a[x] != scalar_int_copy);\n    if (int_array_a[x] != scalar_int_copy) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(float_array_a[x] - scalar_float_copy) > .00001);\n    if (fabs(float_array_a[x] - scalar_float_copy) > .00001) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(double_array_a[x] - scalar_double_copy) > .000000001);\n    if (fabs(double_array_a[x] - scalar_double_copy) > .000000001) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, enum_array_a[x] != scalar_enum_copy);\n    if (enum_array_a[x] != scalar_enum_copy) {\n      break;\n    }\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_char != scalar_char_copy);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_short != scalar_short_copy);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_int != scalar_int_copy);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(scalar_float - scalar_float_copy) > .00001);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(scalar_double - scalar_double_copy) > .000000001);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_enum != scalar_enum_copy);\n\n  return errors;\n}\nint main() \n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_defaultmap_on());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_defaultmap_off());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_master_taskloop_simd_device.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1633",
        "issue_id": 1,
        "original_code": "//===--- test_master_taskloop_simd_device.c ---------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the master taskloop simd directive in a parallel region.\n// The test performs simple operations on an int array which are then checked\n// for correctness. This test checks the above in a target region.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_master_taskloop_simd_device() {\n  OMPVV_INFOMSG(\"test_master_taskloop_simd_device\");\n  int errors = 0;\n  int num_threads = -1;\n  int x[N];\n  int y[N];\n  int z[N];\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 1;\n    y[i] = i + 1;\n    z[i] = 2*(i + 1);\n  }\n\n#pragma omp target parallel num_threads(OMPVV_NUM_THREADS_DEVICE) shared(x, y, z, num_threads) map(tofrom: x, num_threads) map(to: y, z)\n  {\n#pragma omp master taskloop simd\n    for (int i = 0; i < N; i++) {\n      x[i] += y[i]*z[i];\n    }\n    if (omp_get_thread_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != 1 + (y[i]*z[i]));\n  }\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of taskloop can't be guaranteed.\");\n  OMPVV_ERROR_IF(num_threads < 1, \"Test returned an invalid number of threads.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n  OMPVV_INFOMSG(\"This test does not guarantee vector instructions were generated for the simd construct.\");\n\n  return errors;\n}\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_master_taskloop_simd_device());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_master_taskloop_simd_device.c ---------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the master taskloop simd directive in a parallel region.\n// The test performs simple operations on an int array which are then checked\n// for correctness. This test checks the above in a target region.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_master_taskloop_simd_device() {\n  OMPVV_INFOMSG(\"test_master_taskloop_simd_device\");\n  int errors = 0;\n  int num_threads = -1;\n  int x[N];\n  int y[N];\n  int z[N];\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 1;\n    y[i] = i + 1;\n    z[i] = 2*(i + 1);\n  }\n\n#pragma omp target parallel num_threads(OMPVV_NUM_THREADS_DEVICE) shared(x, y, z, num_threads) map(tofrom: x, num_threads) map(to: y, z)\n  {\n#pragma omp master taskloop simd\n    for (int i = 0; i < N; i++) {\n      x[i] += y[i]*z[i];\n    }\n    if (omp_get_thread_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != 1 + (y[i]*z[i]));\n  }\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of taskloop can't be guaranteed.\");\n  OMPVV_ERROR_IF(num_threads < 1, \"Test returned an invalid number of threads.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n  OMPVV_INFOMSG(\"This test does not guarantee vector instructions were generated for the simd construct.\");\n\n  return errors;\n}\n\n\nint main() \n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_master_taskloop_simd_device());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_ordered_doacross_omp_cur_iteration.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp parallel\" with directive \"#pragma omp target\" at position 1160",
        "issue_id": 0,
        "original_code": "//===---- test_ordered_doacross_omp_cur_iteration.c -------------------------------------===//\n//\n// OpenMP API Version 5.2\n//\n// This example has been adapted from the 5.2 OpenMP Examples document:\n// \"9.10 Doacross Loop Nest\"\n// \n// OpenMP specification states that \"the doacross clause identifies cross-iteration\n// dependences that imply additional constraints on the scheduling of loop iterations.\"\n// This test uses the arrays a, b, and c to test before the sink, after the sink, and\n// after the source. Array b relies on the previous iteration, which changes array a,\n// which would normally be a race condition. Doacross ensures that the previous iteration\n// has already reached this point before changing b[i].\n//\n// The specification states that if the vector for source is ommited, it assumed to be\n// omp_cur_iteration.\n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint errors;\nint arr[N];\n\nint ordered_doacross(){\n\n  int a[N];\n  int b[N];\n  int c[N];\n  a[0] = 0;\n  b[0] = 0;\n  c[0] = 0;\n\n  #pragma omp parallel for ordered\n  for(int i = 1; i < N; i++){\n    a[i] = i;\n    #pragma omp ordered doacross(sink: i-1)\n    b[i] = a[i-1];\n    #pragma omp ordered doacross(source:omp_cur_iteration)\n    c[i] = a[i] + b[i];\n  }\n  for(int i = 1; i < N; i++){\n    OMPVV_TEST_AND_SET(errors, a[i] != i);\n    OMPVV_TEST_AND_SET(errors, b[i] != i-1)\n    OMPVV_TEST_AND_SET(errors, c[i] != (i-1) + i);\n  }\n  return errors;\n\n}\n\nint main() {\n   errors = 0;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, ordered_doacross() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n   \n}\n",
        "error_code": "//===---- test_ordered_doacross_omp_cur_iteration.c -------------------------------------===//\n//\n// OpenMP API Version 5.2\n//\n// This example has been adapted from the 5.2 OpenMP Examples document:\n// \"9.10 Doacross Loop Nest\"\n// \n// OpenMP specification states that \"the doacross clause identifies cross-iteration\n// dependences that imply additional constraints on the scheduling of loop iterations.\"\n// This test uses the arrays a, b, and c to test before the sink, after the sink, and\n// after the source. Array b relies on the previous iteration, which changes array a,\n// which would normally be a race condition. Doacross ensures that the previous iteration\n// has already reached this point before changing b[i].\n//\n// The specification states that if the vector for source is ommited, it assumed to be\n// omp_cur_iteration.\n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint errors;\nint arr[N];\n\nint ordered_doacross(){\n\n  int a[N];\n  int b[N];\n  int c[N];\n  a[0] = 0;\n  b[0] = 0;\n  c[0] = 0;\n\n  #pragma omp target for ordered\n  for(int i = 1; i < N; i++){\n    a[i] = i;\n    #pragma omp ordered doacross(sink: i-1)\n    b[i] = a[i-1];\n    #pragma omp ordered doacross(source:omp_cur_iteration)\n    c[i] = a[i] + b[i];\n  }\n  for(int i = 1; i < N; i++){\n    OMPVV_TEST_AND_SET(errors, a[i] != i);\n    OMPVV_TEST_AND_SET(errors, b[i] != i-1)\n    OMPVV_TEST_AND_SET(errors, c[i] != (i-1) + i);\n  }\n  return errors;\n\n}\n\nint main() {\n   errors = 0;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, ordered_doacross() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n   \n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_mapping_before_alloc.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp master\" at position 887",
        "issue_id": 0,
        "original_code": "//===--- test_target_mapping_before_alloc.c ---------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// The description of the map clause was modified to clarify the mapping order \n// when multiple map-types are specified for a variable or structure members of\n// a variable on the same construct.\n//\n// For a given construct, the effect of a map clause with the to, from, or \n// tofrom map-type is ordered before the effect of a map clause with the alloc\n// map-type.\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n\nint to_before_alloc() {\n\n  int i;\n  int errors = 0;\n  int scalar = 80;\n  int a[N];\n\n  struct {\n  int var;\n  int b[N];\n  } member;\n\n  member.var = 1;\n\n  for (i = 0; i < N; i++) {\n    a[i] = i;\n    member.b[i] = i;\n  }\n\n#pragma omp target map(alloc: scalar, a, member) map(to: scalar, a, member) map(tofrom: errors) \n  {\n    if (scalar != 80 || a[2] != 2 || member.var != 1 || member.b[2] != 2) {\n        errors++;\n    }\t\n  }\n\n  return errors;\n}\n\nint main () {\n\n  int errors = 0;\n\n  OMPVV_TEST_OFFLOADING;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, to_before_alloc());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_mapping_before_alloc.c ---------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// The description of the map clause was modified to clarify the mapping order \n// when multiple map-types are specified for a variable or structure members of\n// a variable on the same construct.\n//\n// For a given construct, the effect of a map clause with the to, from, or \n// tofrom map-type is ordered before the effect of a map clause with the alloc\n// map-type.\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n\nint to_before_alloc() {\n\n  int i;\n  int errors = 0;\n  int scalar = 80;\n  int a[N];\n\n  struct {\n  int var;\n  int b[N];\n  } member;\n\n  member.var = 1;\n\n  for (i = 0; i < N; i++) {\n    a[i] = i;\n    member.b[i] = i;\n  }\n\n#pragma omp master map(alloc: scalar, a, member) map(to: scalar, a, member) map(tofrom: errors) \n  {\n    if (scalar != 80 || a[2] != 2 || member.var != 1 || member.b[2] != 2) {\n        errors++;\n    }\t\n  }\n\n  return errors;\n}\n\nint main () {\n\n  int errors = 0;\n\n  OMPVV_TEST_OFFLOADING;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, to_before_alloc());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_task_default_firstprivate.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 716",
        "issue_id": 2,
        "original_code": "//--------------- test_task_default_firstprivate.c -------------------------//\n//\n// OpenMP API Version 5.1 Aug 2021\n//\n// Tests the behavior of the default clause when the specified data-sharing \n// attribute is firstprivate. This test focuses on the use of the task construct. \n// Firstprivate should allow any data initialized outside the task region to \n// return to its original value after being manipulated within the task region.\n// -------------------------------------------------------------------------//\n\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint errors;\n\nint test_default_firstprivate_task(){\n\tint test_num = 1;\n\tint test_arr[N];\n\tint sum = 0;\n\tfor (int i = 0; i<N; i++){\n\t\ttest_arr[i] = i;\n\t\tsum += i;\n\t}\n\n\t#pragma omp task default(firstprivate)\n\t{\n\t\ttest_num += 1;\n\t\tfor (int i=0; i<N; i++){\n\t\t\ttest_arr[i] = 1;\n\t\t}\n\t}\n\tint new_sum = 0;\n\tint wrong_sum = 0;\n\tfor (int i = 0; i<N; i++){\n\t\tnew_sum += test_arr[i];\n\t\twrong_sum += 1;\n\t}\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_num != 1);\n\tOMPVV_INFOMSG_IF(test_num == 2, \"Scalar was not firstprivate, changes made in task affected original copy\");\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, sum != new_sum);\n\tOMPVV_INFOMSG_IF(new_sum == wrong_sum, \"Array was not first private, changes made in task affected original copy\");\n\treturn errors;\n}\n\nint main(){\n\terrors = 0;\n\tOMPVV_TEST_OFFLOADING;\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_default_firstprivate_task() != 0);\n\tOMPVV_REPORT_AND_RETURN(errors);\t\n}\n",
        "error_code": "//--------------- test_task_default_firstprivate.c -------------------------//\n//\n// OpenMP API Version 5.1 Aug 2021\n//\n// Tests the behavior of the default clause when the specified data-sharing \n// attribute is firstprivate. This test focuses on the use of the task construct. \n// Firstprivate should allow any data initialized outside the task region to \n// return to its original value after being manipulated within the task region.\n// -------------------------------------------------------------------------//\n\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint errors;\n\nint test_default_firstprivate_task(){\n\tint test_num = 1;\n\tint test_arr[N];yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n\tint sum = 0;\n\tfor (int i = 0; i<N; i++){\n\t\ttest_arr[i] = i;\n\t\tsum += i;\n\t}\n\n\t#pragma omp task default(firstprivate)\n\t{\n\t\ttest_num += 1;\n\t\tfor (int i=0; i<N; i++){\n\t\t\ttest_arr[i] = 1;\n\t\t}\n\t}\n\tint new_sum = 0;\n\tint wrong_sum = 0;\n\tfor (int i = 0; i<N; i++){\n\t\tnew_sum += test_arr[i];\n\t\twrong_sum += 1;\n\t}\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_num != 1);\n\tOMPVV_INFOMSG_IF(test_num == 2, \"Scalar was not firstprivate, changes made in task affected original copy\");\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, sum != new_sum);\n\tOMPVV_INFOMSG_IF(new_sum == wrong_sum, \"Array was not first private, changes made in task affected original copy\");\n\treturn errors;\n}\n\nint main(){\n\terrors = 0;\n\tOMPVV_TEST_OFFLOADING;\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_default_firstprivate_task() != 0);\n\tOMPVV_REPORT_AND_RETURN(errors);\t\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_ordered_doacross.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===---- test_ordered_doacross.c -------------------------------------===//\n//\n// OpenMP API Version 5.2\n//\n// This example has been adapted from the 5.2 OpenMP Examples document:\n// \"9.10 Doacross Loop Nest\"\n// \n// OpenMP specification states that \"the doacross clause identifies cross-iteration\n// dependences that imply additional constraints on the scheduling of loop iterations.\"\n// This test uses the arrays a, b, and c to test before the sink, after the sink, and\n// after the source. Array b relies on the previous iteration, which changes array a,\n// which would normally be a race condition. Doacross ensures that the previous iteration\n// has already reached this point before changing b[i].\n//\n// The specification states that if the vector for source is ommited, it assumed to be\n// omp_cur_iteration.\n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint errors;\nint arr[N];\n\nint ordered_doacross(){\n\n  int a[N];\n  int b[N];\n  int c[N];\n  a[0] = 0;\n  b[0] = 0;\n  c[0] = 0;\n\n  #pragma omp parallel for ordered\n  for(int i = 1; i < N; i++){\n    a[i] = i;\n    #pragma omp ordered doacross(sink: i-1)\n    b[i] = a[i-1];\n    #pragma omp ordered doacross(source:)\n    c[i] = a[i] + b[i];\n  }\n  for(int i = 1; i < N; i++){\n    OMPVV_TEST_AND_SET(errors, a[i] != i);\n    OMPVV_TEST_AND_SET(errors, b[i] != i-1)\n    OMPVV_TEST_AND_SET(errors, c[i] != (i-1) + i);\n  }\n  return errors;\n\n}\n\nint main() {\n   errors = 0;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, ordered_doacross() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n   \n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nshort hkeiakcqtp = 127;\ndouble ehjmkkqfth = 68;\nlong eigtxlqlva = 244;\nbyte efvpaqzohp = 102;\nfloat ryajkdssen = 86;\nbyte vgkcyfbkpu = 6;\ndouble hsqkqimsnb = 62;\ndouble zimsddwhdf = 201;\nbyte jylcvxhduz = 249;\ndouble lwwwlvfrwy = 247;\nbyte fkpngaevhk = 243;\nint aazdajdcha = 203;\nlong rjcmlrprul = 86;\nbyte niaowrfqsy = 209;\nbyte qdotpshqfk = 27;\nfloat gxfxlfomqs = 44;\nfloat wufjeqclat = 11;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_update_to_discontiguous.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp master\" at position 559",
        "issue_id": 0,
        "original_code": "//===--- test_target_update_to_discontiguous.c -----------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test seeks to ensure that target update with motion-clause \"to\" can properly\n// map array sections with stride expressions.\n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 64\n\nint i;\nint errors = 0;\n\nint target_update_to_discontiguous() {\n  \n  double *result;\n  result = (double *)calloc(N,sizeof(double));\n \n#pragma omp target data map(tofrom: result[0:N])\n  {\n    for (int i = 0; i < N; i++) {\n      result[i] += i;\n    }\n\n    #pragma omp target update to(result[0:N/2:2])\n\n    #pragma omp target map(alloc: result[0:N]) \n    {\n\n      for (int i = 0; i < N; i++) {\n        result[i] += i;\n      }\n    }//end target\n\n  }\n\n  for (i =0; i < N; i++) {\n    if(i%2){\n      OMPVV_TEST_AND_SET(errors, result[i] != i);\n    }\n    else{\n      OMPVV_TEST_AND_SET(errors, result[i] != 2*i);\n    }\n  } \n\n  return errors;\n}\n\nint main() {\n\n  OMPVV_TEST_OFFLOADING;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, target_update_to_discontiguous());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n",
        "error_code": "//===--- test_target_update_to_discontiguous.c -----------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test seeks to ensure that target update with motion-clause \"to\" can properly\n// map array sections with stride expressions.\n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 64\n\nint i;\nint errors = 0;\n\nint target_update_to_discontiguous() {\n  \n  double *result;\n  result = (double *)calloc(N,sizeof(double));\n \n#pragma omp master data map(tofrom: result[0:N])\n  {\n    for (int i = 0; i < N; i++) {\n      result[i] += i;\n    }\n\n    #pragma omp target update to(result[0:N/2:2])\n\n    #pragma omp target map(alloc: result[0:N]) \n    {\n\n      for (int i = 0; i < N; i++) {\n        result[i] += i;\n      }\n    }//end target\n\n  }\n\n  for (i =0; i < N; i++) {\n    if(i%2){\n      OMPVV_TEST_AND_SET(errors, result[i] != i);\n    }\n    else{\n      OMPVV_TEST_AND_SET(errors, result[i] != 2*i);\n    }\n  } \n\n  return errors;\n}\n\nint main() {\n\n  OMPVV_TEST_OFFLOADING;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, target_update_to_discontiguous());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_parallel_for_simd_atomic.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp flush\" at position 715",
        "issue_id": 0,
        "original_code": "//===--- test_target_teams_distribute_parallel_for_simd_atomic.c ------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks that the atomic construct can be used within the target\n// teams distribute parallel for construct with simd to avoid a race\n// condition in updating a shared variable, whose value is checked after\n// updating.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_target_teams_distribute_parallel_for_simd_atomic() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_simd_atomic\");\n  int errors = 0, x = 0;\n\n#pragma omp target teams distribute parallel for simd map(tofrom: x) shared(x) num_teams(OMPVV_NUM_TEAMS_DEVICE) num_threads(OMPVV_NUM_THREADS_DEVICE)\n  for (int i = 0; i < N; i++) {\n#pragma omp atomic update\n    x += 1;\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, x != N);\n\n  return errors;\n}\n\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_simd_atomic());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_parallel_for_simd_atomic.c ------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks that the atomic construct can be used within the target\n// teams distribute parallel for construct with simd to avoid a race\n// condition in updating a shared variable, whose value is checked after\n// updating.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_target_teams_distribute_parallel_for_simd_atomic() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_simd_atomic\");\n  int errors = 0, x = 0;\n\n#pragma omp flush teams distribute parallel for simd map(tofrom: x) shared(x) num_teams(OMPVV_NUM_TEAMS_DEVICE) num_threads(OMPVV_NUM_THREADS_DEVICE)\n  for (int i = 0; i < N; i++) {\n#pragma omp atomic update\n    x += 1;\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, x != N);\n\n  return errors;\n}\n\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_simd_atomic());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_masked_filter.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_masked_filter() != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 1000",
        "issue_id": 4,
        "original_code": "//===------ test_masked_filter.c ------------------------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// This test utilizes the masked construct to ensure that a section of code\n// only runs on a certain thread. When the filter clause is not present, the\n// primary thread runs the structured block.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_masked_filter() {\n  int errors = 0;\n  int ct = 0;\n  int total = 10;\n  int threads = OMPVV_NUM_THREADS_HOST;\n\n#pragma omp parallel num_threads(threads)\nwhile(1){\n  int tot;\n  #pragma omp atomic read\n  tot = total;\n  if (tot <= 0)\n    break;\n  #pragma omp masked filter(3)\n  {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, omp_get_thread_num() != 3); // filter thread 3\n    ct++;\n    #pragma omp atomic\n    total = total-1;\n  }\n}\n  OMPVV_TEST_AND_SET_VERBOSE(errors, ct != 10);\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_masked_filter() != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===------ test_masked_filter.c ------------------------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// This test utilizes the masked construct to ensure that a section of code\n// only runs on a certain thread. When the filter clause is not present, the\n// primary thread runs the structured block.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_masked_filter() {\n  int errors = 0;\n  int ct = 0;\n  int total = 10;\n  int threads = OMPVV_NUM_THREADS_HOST;\n\n#pragma omp parallel num_threads(threads)\nwhile(1){\n  int tot;\n  #pragma omp atomic read\n  tot = total;\n  if (tot <= 0)\n    break;\n  #pragma omp masked filter(3)\n  {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, omp_get_thread_num() != 3); // filter thread 3\n    ct++;\n    #pragma omp atomic\n    total = total-1;\n  }\n}\n  OMPVV_TEST_AND_SET_VERBOSE(errors, ct != 10);\n  return errors;\n}\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_declare_mapper_present.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp declare\" with directive \"#pragma omp cancel\" at position 1484",
        "issue_id": 0,
        "original_code": "//===---- test_declare_mapper_present.c -------------------------------------===//\n// \n// OpenMP API Version 5.2 \n//\n// This example has been adapted from the 5.2 OpenMP Examples document:\n// \"declare mapper Directive\", and \"OpenMP Directive Syntax -> complex iterator\"\n// The declare mapper directive will be used to automatically map variables\n// according to its prescription:  full structure, plus the dynamic storage of the\n// data element. These variable should be present on the device.\n//\n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\ntypedef struct myvec{\n    size_t len;\n    int *data;\n} myvec_t;\n\n// In addition to the present modifier, the always is requiered\n// Given that the present and default modifiers are to be tested\n// the struct has to be in the GPU prior to the default mapper\n// is tested, therefore the \"omp target enter data\" with \"to\"\n// is used. Furthermore, given that it is the \"from\" that is to be\n// checked, the \"omp target exit data\" is set to \"delete\"\n// in this scenario if the always is not on the declare mapper\n// the \"omp target\" is inside the \"omp target enter data\"\n// with the \"map to\", which would prevent the effect of the\n// declared mapped to have effects outside. Therefore, by adding\n// the always, the mapper force the update of the declared mapper\n// to be seen outside the \"target data region\"\n\n#pragma omp declare mapper(default:myvec_t v) map(always, present, from: v, v.len, v.data[0:v.len]) \n\n\nvoid init( myvec_t *s )\n{ \n  for(int i = 0; i < s->len; i++)\n    s->data[i] = i; \n}\n\n\nint test_declare_mapper_present() { \n\n  OMPVV_INFOMSG(\"test_declare_mapper_present\");\n  int errors = 0;\n\n  myvec_t s;\n  s.data = (int *)calloc(N,sizeof(int));\n  s.len  = N;\n\n  #pragma omp target enter data map(to: s.len, s.data[0:s.len])\n\n  #pragma omp target\n  {\n    init(&s);\n  }\n\n  #pragma omp target exit data map(delete: s.len, s.data[0:s.len])\n\n  for (int i = 0; i < N; ++i) {\n    OMPVV_TEST_AND_SET(errors, s.data[i] != i);\n  }\t\n  \n  return errors;\n}\n\nint main () {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_declare_mapper_present());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}  \n",
        "error_code": "//===---- test_declare_mapper_present.c -------------------------------------===//\n// \n// OpenMP API Version 5.2 \n//\n// This example has been adapted from the 5.2 OpenMP Examples document:\n// \"declare mapper Directive\", and \"OpenMP Directive Syntax -> complex iterator\"\n// The declare mapper directive will be used to automatically map variables\n// according to its prescription:  full structure, plus the dynamic storage of the\n// data element. These variable should be present on the device.\n//\n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\ntypedef struct myvec{\n    size_t len;\n    int *data;\n} myvec_t;\n\n// In addition to the present modifier, the always is requiered\n// Given that the present and default modifiers are to be tested\n// the struct has to be in the GPU prior to the default mapper\n// is tested, therefore the \"omp target enter data\" with \"to\"\n// is used. Furthermore, given that it is the \"from\" that is to be\n// checked, the \"omp target exit data\" is set to \"delete\"\n// in this scenario if the always is not on the declare mapper\n// the \"omp target\" is inside the \"omp target enter data\"\n// with the \"map to\", which would prevent the effect of the\n// declared mapped to have effects outside. Therefore, by adding\n// the always, the mapper force the update of the declared mapper\n// to be seen outside the \"target data region\"\n\n#pragma omp cancel mapper(default:myvec_t v) map(always, present, from: v, v.len, v.data[0:v.len]) \n\n\nvoid init( myvec_t *s )\n{ \n  for(int i = 0; i < s->len; i++)\n    s->data[i] = i; \n}\n\n\nint test_declare_mapper_present() { \n\n  OMPVV_INFOMSG(\"test_declare_mapper_present\");\n  int errors = 0;\n\n  myvec_t s;\n  s.data = (int *)calloc(N,sizeof(int));\n  s.len  = N;\n\n  #pragma omp target enter data map(to: s.len, s.data[0:s.len])\n\n  #pragma omp target\n  {\n    init(&s);\n  }\n\n  #pragma omp target exit data map(delete: s.len, s.data[0:s.len])\n\n  for (int i = 0; i < N; ++i) {\n    OMPVV_TEST_AND_SET(errors, s.data[i] != i);\n  }\t\n  \n  return errors;\n}\n\nint main () {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_declare_mapper_present());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}  \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_map_present_ordering.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp master\" at position 762",
        "issue_id": 0,
        "original_code": "//===------------------------- test_target_map_present_ordering.c ----------------------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// This test checks tests the present map-type-modifier on a map clause. This checks to verify\n// that when two map clauses are added, the one with a present modifier is processed first.\n// This is a black box test, however this should compile properly and the to map should be\n// handled first.\n//\n////===--------------------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint errors; \n\nint test_present_map_reordering() {\n  int x[N];\n\n  for (int i = 0; i < N; i++) { \n    x[i] = i;\n  }\n\n\n  #pragma omp target data map(tofrom: x) \n  {\n    #pragma omp target map(present, to: x) map(from: x)\n    {\n      for (int i = 0; i < N; i++) {\n        x[i] += i;\n      }\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, x[i] != i*2);\n  }\n \n  return errors;  \t \n}\n\nint main () {\n  \n  errors = 0;\n  \n  OMPVV_TEST_OFFLOADING;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_present_map_reordering());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===------------------------- test_target_map_present_ordering.c ----------------------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// This test checks tests the present map-type-modifier on a map clause. This checks to verify\n// that when two map clauses are added, the one with a present modifier is processed first.\n// This is a black box test, however this should compile properly and the to map should be\n// handled first.\n//\n////===--------------------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint errors; \n\nint test_present_map_reordering() {\n  int x[N];\n\n  for (int i = 0; i < N; i++) { \n    x[i] = i;\n  }\n\n\n  #pragma omp master data map(tofrom: x) \n  {\n    #pragma omp target map(present, to: x) map(from: x)\n    {\n      for (int i = 0; i < N; i++) {\n        x[i] += i;\n      }\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, x[i] != i*2);\n  }\n \n  return errors;  \t \n}\n\nint main () {\n  \n  errors = 0;\n  \n  OMPVV_TEST_OFFLOADING;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_present_map_reordering());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_omp_target_aligned_alloc_device.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===------ test_omp_target_aligned_alloc_device.c ------------------------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// Tests the omp_aligned_alloc routine properly requests a memory allocation\n// aligned to the passed byte parameter. Starts by initializing some memory\n// in the omp_default_mem_space and then checks if this memory is aligned\n// and can be properly written to and read from. Checks on device.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_omp_aligned_alloc_on_device() {\n  int errors = 0;\n  \n  omp_memspace_handle_t  memspace = omp_default_mem_space;\n  omp_alloctrait_t       traits[1] = {{omp_atk_alignment, 64}};\n  omp_allocator_handle_t alloc = omp_init_allocator(memspace,1,traits);\n\n  #pragma omp target map(tofrom: errors) uses_allocators(alloc(traits)) \n  {\n    int *x;\n    int not_correct_array_values = 0;\n\n    x = (int *)omp_aligned_alloc(64, N*sizeof(int), alloc);\n    \n    if (x == NULL) { \n      OMPVV_ERROR(\"omp_aligned_alloc returned null\"); \n      errors++;\n    } else {\n      // As OMPVV_TEST_AND_SET_VERBOSE uses printf,\n      // which is confused by the '%', use the following:\n      OMPVV_TEST_AND_SET(errors, ((intptr_t)(x))%64 != 0);\n      OMPVV_ERROR_IF(((intptr_t)(x))%64 != 0, \" Condition ((intptr_t)(x))%%64 != 0 failed \");\n\n      #pragma omp parallel for simd simdlen(16) aligned(x: 64)\n      for (int i = 0; i < N; i++) {\n        x[i] = i;\n      }\n\n      #pragma omp parallel for simd simdlen(16) aligned(x: 64)\n      for (int i = 0; i < N; i++) {\n        if (x[i] != i) {\n          #pragma omp atomic write\n          not_correct_array_values = 1; \n        }\n      }\n\n      if (not_correct_array_values) {\n        OMPVV_ERROR(\"Values in the array did NOT match the expected values. Changes may not have persisted.\");\n        errors++;\n      }\n\n      omp_free(x, alloc);\n    }\n  }\n\n  omp_destroy_allocator(alloc);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_omp_aligned_alloc_on_device() != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nint ubmcmfodgx = 8;\nint lnjgwxbofg = 223;\ndouble yufasijruu = 141;\nshort mivullknbq = 74;\nint ujsiiycuso = 57;\nint hiefpfkxlb = 115;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_update_mapper_to_discontiguous.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  \n  OMPVV_TEST_OFFLOADING;\n  \n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, target_update_to_mapper());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n}\" at position 1691",
        "issue_id": 4,
        "original_code": "//===--- test_target_update_mapper_to_discontiguous.c -----------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test seeks to ensure that target update with motion-clause \"to\" can properly\n// map data to the device by specifying a user-defined mapper. Additionally, the test\n// checks a new addition to target update in OpenMP 5.0 that states \"List items in the\n// to or from clauses may include array sections with stride expressions.\" \n//\n// Adopted from OpenMP 5.0 Example target_mapper.1.c\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\ntypedef struct newvec {\n  size_t len;\n  double *data;\n} newvec_t;\n\nsize_t i;\nint errors = 0;\n\n#pragma omp declare mapper(newvec_t v) map(v, v.data[0:v.len])\n\nint target_update_to_mapper() {\n  \n  OMPVV_TEST_OFFLOADING;\n\n  newvec_t s;\n\n  s.data = (double *)calloc(N,sizeof(double));\n  s.len = N;\n  #pragma omp target data map(tofrom: s)\n  { \n    //update array in host values\n    for (i = 0; i < s.len; i++) {\n      s.data[i] = i;\n    }\n    // update even array position values from host\n    // This should set them to i  \n    #pragma omp target update to(s.data[0:s.len/2:2])\n\n    //update array on the device\n    #pragma omp target \n    for (i = 0; i < s.len; i++) {\n      s.data[i] += i;\n    }\n  } //end target\n\n  for (i =0; i < N; i++) { \n    if(i%2){ //odd positions should be result[i] = i\n      OMPVV_TEST_AND_SET(errors, s.data[i] != i);\n    }\n    else{   //even positions should be result[i] = 2i\n      OMPVV_TEST_AND_SET(errors, s.data[i] != 2*i);\n    }\n  } \n  return errors;\n  \n}\n\nint main() {\n  \n  OMPVV_TEST_OFFLOADING;\n  \n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, target_update_to_mapper());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n}\n",
        "error_code": "//===--- test_target_update_mapper_to_discontiguous.c -----------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test seeks to ensure that target update with motion-clause \"to\" can properly\n// map data to the device by specifying a user-defined mapper. Additionally, the test\n// checks a new addition to target update in OpenMP 5.0 that states \"List items in the\n// to or from clauses may include array sections with stride expressions.\" \n//\n// Adopted from OpenMP 5.0 Example target_mapper.1.c\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\ntypedef struct newvec {\n  size_t len;\n  double *data;\n} newvec_t;\n\nsize_t i;\nint errors = 0;\n\n#pragma omp declare mapper(newvec_t v) map(v, v.data[0:v.len])\n\nint target_update_to_mapper() {\n  \n  OMPVV_TEST_OFFLOADING;\n\n  newvec_t s;\n\n  s.data = (double *)calloc(N,sizeof(double));\n  s.len = N;\n  #pragma omp target data map(tofrom: s)\n  { \n    //update array in host values\n    for (i = 0; i < s.len; i++) {\n      s.data[i] = i;\n    }\n    // update even array position values from host\n    // This should set them to i  \n    #pragma omp target update to(s.data[0:s.len/2:2])\n\n    //update array on the device\n    #pragma omp target \n    for (i = 0; i < s.len; i++) {\n      s.data[i] += i;\n    }\n  } //end target\n\n  for (i =0; i < N; i++) { \n    if(i%2){ //odd positions should be result[i] = i\n      OMPVV_TEST_AND_SET(errors, s.data[i] != i);\n    }\n    else{   //even positions should be result[i] = 2i\n      OMPVV_TEST_AND_SET(errors, s.data[i] != 2*i);\n    }\n  } \n  return errors;\n  \n}\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_masked.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_masked() != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 989",
        "issue_id": 4,
        "original_code": "//===--- test_masked.c ----------------------------------------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n// \n// This test utilizes the masked construct to ensure that a section of code\n// only runs on a certain thread. When the filter clause is not present, the\n// primary thread runs the structured block.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_masked() {\n  int errors = 0;\n  int ct = 0;\n  int total = 10;\n  int threads = OMPVV_NUM_THREADS_HOST;\n\n#pragma omp parallel num_threads(threads)\nwhile(1){\n  int tot;\n  #pragma omp atomic read\n  tot = total;\n  if (tot <= 0)\n    break;\n  #pragma omp masked\n  {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, omp_get_thread_num() != 0); // primary thread\n    ct++;\n    #pragma omp atomic\n    total = total-1;\n  }\n}\n  OMPVV_TEST_AND_SET_VERBOSE(errors, ct != 10);\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_masked() != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_masked.c ----------------------------------------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n// \n// This test utilizes the masked construct to ensure that a section of code\n// only runs on a certain thread. When the filter clause is not present, the\n// primary thread runs the structured block.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_masked() {\n  int errors = 0;\n  int ct = 0;\n  int total = 10;\n  int threads = OMPVV_NUM_THREADS_HOST;\n\n#pragma omp parallel num_threads(threads)\nwhile(1){\n  int tot;\n  #pragma omp atomic read\n  tot = total;\n  if (tot <= 0)\n    break;\n  #pragma omp masked\n  {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, omp_get_thread_num() != 0); // primary thread\n    ct++;\n    #pragma omp atomic\n    total = total-1;\n  }\n}\n  OMPVV_TEST_AND_SET_VERBOSE(errors, ct != 10);\n  return errors;\n}\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_parallel_for_map_default.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_map_default());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 1470",
        "issue_id": 4,
        "original_code": "//===---- test_target_teams_distribute_parallel_for_map_default.c -----------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// test the mapping of arrays by default. The expected behavior is that all \n// the arrays are mapped tofrom by default.\n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define N 2000\n\nint test_target_teams_distribute_parallel_for_map_default() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_devices\");\n  \n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int scalar = 20;\n  int scalar2 = -1;\n  int errors = 0;\n  int i, j, dev;\n\n  // array initialization\n  for (i = 0; i < N; i++) {\n    a[i] = 1;\n    b[i] = i;\n    c[i] = 2*i;\n    d[i] = 0;\n  }\n\n\n#pragma omp target teams distribute parallel for\n  for (j = 0; j < N; ++j) {\n    // scalar is firstprivate for the target region, but \n    // in a parallel construct, if not default clause is present\n    // the variable is shared. Hence scalar = any other value \n    // could cause a data race.\n    // See page 182, line 1.\n    d[j] += c[j] * (a[j] + b[j] + scalar);\n#pragma omp atomic write\n    scalar2 = j;\n  } // atomic prevents indeterminacy from simultaneous writes\n    // since scalar2 is shared implicitly.\n\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, d[i] != (1 + i + 20) * 2*i);\n  }\n\n  return errors;\n}\n\n// Test for OpenMP 4.5 target enter data with if\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_map_default());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_teams_distribute_parallel_for_map_default.c -----------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// test the mapping of arrays by default. The expected behavior is that all \n// the arrays are mapped tofrom by default.\n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define N 2000\n\nint test_target_teams_distribute_parallel_for_map_default() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_devices\");\n  \n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int scalar = 20;\n  int scalar2 = -1;\n  int errors = 0;\n  int i, j, dev;\n\n  // array initialization\n  for (i = 0; i < N; i++) {\n    a[i] = 1;\n    b[i] = i;\n    c[i] = 2*i;\n    d[i] = 0;\n  }\n\n\n#pragma omp target teams distribute parallel for\n  for (j = 0; j < N; ++j) {\n    // scalar is firstprivate for the target region, but \n    // in a parallel construct, if not default clause is present\n    // the variable is shared. Hence scalar = any other value \n    // could cause a data race.\n    // See page 182, line 1.\n    d[j] += c[j] * (a[j] + b[j] + scalar);\n#pragma omp atomic write\n    scalar2 = j;\n  } // atomic prevents indeterminacy from simultaneous writes\n    // since scalar2 is shared implicitly.\n\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, d[i] != (1 + i + 20) * 2*i);\n  }\n\n  return errors;\n}\n\n// Test for OpenMP 4.5 target enter data with if\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_loop_private.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n      break;\n    }\" at position 1452",
        "issue_id": 4,
        "original_code": "//===--- test_loop_private.c ------------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the private clause on a loop directive to indicate that the\n// variable in the private clause should be made private to each thread\n// executing the loop region.  The test then operates on the privatized\n// variable in such a way that would most likely cause competing operations\n// if the variable is not privatized.  If the computation completes without\n// errors, we assume that the privatization occured.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define SIZE 1024\n\nint main() {\n  int a[SIZE];\n  int b[SIZE];\n  int c[SIZE];\n  int d[SIZE];\n  int privatized;\n  int errors = 0;\n  int num_threads = -1;\n\n  for (int x = 0; x < SIZE; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    c[x] = 2*x;\n    d[x] = 0;\n  }\n\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST)\n  {\n#pragma omp loop private(privatized)\n    for (int x = 0; x < SIZE; ++x) {\n      privatized = 0;\n      for (int y = 0; y < a[x] + b[x]; ++y) {\n        privatized++;\n      }\n      d[x] = c[x] * privatized;\n    }\n    if (omp_get_thread_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n  }\n\n  for (int x = 0; x < SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, d[x] != (1 + x)*2*x);\n    if (d[x] != (1 + x)*2*x) {\n      break;\n    }\n  }\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread. Results of private test are inconclusive.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_loop_private.c ------------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the private clause on a loop directive to indicate that the\n// variable in the private clause should be made private to each thread\n// executing the loop region.  The test then operates on the privatized\n// variable in such a way that would most likely cause competing operations\n// if the variable is not privatized.  If the computation completes without\n// errors, we assume that the privatization occured.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define SIZE 1024\n\nint main() {\n  int a[SIZE];\n  int b[SIZE];\n  int c[SIZE];\n  int d[SIZE];\n  int privatized;\n  int errors = 0;\n  int num_threads = -1;\n\n  for (int x = 0; x < SIZE; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    c[x] = 2*x;\n    d[x] = 0;\n  }\n\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST)\n  {\n#pragma omp loop private(privatized)\n    for (int x = 0; x < SIZE; ++x) {\n      privatized = 0;\n      for (int y = 0; y < a[x] + b[x]; ++y) {\n        privatized++;\n      }\n      d[x] = c[x] * privatized;\n    }\n    if (omp_get_thread_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n  }\n\n  for (int x = 0; x < SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, d[x] != (1 + x)*2*x);\n    if (d[x] != (1 + x)*2*x) \n  }\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread. Results of private test are inconclusive.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_omp_cancellation_env_true.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 591",
        "issue_id": 2,
        "original_code": "//===--- test_omp_cancellation_env_1.c ------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the cancel directive for the taskloop directive\n// The omp cancel requires OMP_CANCELLATION enviromental variable to be set\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_taskloop_reduction() {\n\n   int errors = 0;\n   int a[N];\n   int b[N]; \n   int sum = 0;\n   int num_threads = -1;\n   int real_sum = 0;\n\n   for (int i = 0; i < N; i++) {\n      a[i] = 5;\n      b[i] = i * 2; \n   }\n\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST) shared(a, b, num_threads, sum) \n{\n   #pragma omp single\n   #pragma omp taskloop reduction(+:sum)\n   for (int i = 0; i < N; i++) {\n      sum += a[i]*b[i]; \n   }\n   num_threads = omp_get_num_threads();\n\n   #pragma omp single\n   #pragma omp taskloop reduction(+:sum)\n   for (int i = 0; i < N; i++) {\n      #pragma omp cancel taskgroup\n      sum++;\n   }\n}\n   \n   real_sum += N;\n   \n   for (int i = 0; i < N; i++) {\n      real_sum += a[i]*b[i];\n   }\n\n   if (omp_get_cancellation()) {\n     OMPVV_TEST_AND_SET_VERBOSE(errors, sum == real_sum);\n   } else {\n     OMPVV_WARNING(\"Enviromental Variable OMP_CANCELLATION not set, omp cancel cannot be tested\");\n   }\n\n   OMPVV_ERROR_IF(num_threads < 1, \"Test returned an invalid number of threads.\");\n   OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n\n   return errors;            \n}\n\n\nint main() {\n \n   int errors = 0;\n  \n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_taskloop_reduction());\n\n   OMPVV_REPORT_AND_RETURN(errors);\n\n}\n",
        "error_code": "//===--- test_omp_cancellation_env_1.c ------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the cancel directive for the taskloop directive\n// The omp cancel requires OMP_CANCELLATION enviromental variable to be set\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_taskloop_reduction() {\n\n   int errors = 0;\n   int a[N];\n   int b[N]; \n   int sum = 0;\n   int num_threads = -1;\n   int real_sum = 0;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n\n   for (int i = 0; i < N; i++) {\n      a[i] = 5;\n      b[i] = i * 2; \n   }\n\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST) shared(a, b, num_threads, sum) \n{\n   #pragma omp single\n   #pragma omp taskloop reduction(+:sum)\n   for (int i = 0; i < N; i++) {\n      sum += a[i]*b[i]; \n   }\n   num_threads = omp_get_num_threads();\n\n   #pragma omp single\n   #pragma omp taskloop reduction(+:sum)\n   for (int i = 0; i < N; i++) {\n      #pragma omp cancel taskgroup\n      sum++;\n   }\n}\n   \n   real_sum += N;\n   \n   for (int i = 0; i < N; i++) {\n      real_sum += a[i]*b[i];\n   }\n\n   if (omp_get_cancellation()) {\n     OMPVV_TEST_AND_SET_VERBOSE(errors, sum == real_sum);\n   } else {\n     OMPVV_WARNING(\"Enviromental Variable OMP_CANCELLATION not set, omp cancel cannot be tested\");\n   }\n\n   OMPVV_ERROR_IF(num_threads < 1, \"Test returned an invalid number of threads.\");\n   OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n\n   return errors;            \n}\n\n\nint main() {\n \n   int errors = 0;\n  \n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_taskloop_reduction());\n\n   OMPVV_REPORT_AND_RETURN(errors);\n\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_loop_nested.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_loop_nested_teams());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_loop_nested_parallel());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 2772",
        "issue_id": 4,
        "original_code": "//===--- test_loop_nested.c -------------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the loop directive without any clauses with nested loops.\n// The construct is applied in a teams and a parallel construct and the\n// correctness of array operations in the nested loops in the loop construct\n// is checked. Compare with test_loop_bind.c, which performs the same\n// operations in a nested loop with a bind clause.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 32\n\nint test_loop_nested_teams() {\n  OMPVV_INFOMSG(\"test_loop_nested_teams\");\n  int errors = 0;\n  int x[N][N];\n  int y[N];\n  int z[N];\n  int num_teams = -1;\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      x[i][j] = 1;\n    }\n    y[i] = i;\n    z[i] = 2*i;\n  }\n\n#pragma omp teams num_teams(OMPVV_NUM_TEAMS_DEVICE) thread_limit(OMPVV_NUM_THREADS_HOST)\n  {\n#pragma omp loop\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        x[i][j] += y[i]*z[i];\n      }\n    }\n    #pragma omp parallel if(0)\n    if (omp_get_team_num() == 0) {\n      num_teams = omp_get_num_teams();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, x[i][j] != 1 + (y[i]*z[i]));\n    }\n  }\n\n\n  OMPVV_WARNING_IF(num_teams == 1, \"Test ran with one team, so parallelism of loop construct can't be guaranteed.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_teams < 1);\n  OMPVV_ERROR_IF(num_teams < 1, \"omp_get_num_teams() returned an invalid number of teams.\");\n\n  return errors;\n}\n\nint test_loop_nested_parallel() {\n  OMPVV_INFOMSG(\"test_loop_nested_parallel\");\n  int errors = 0;\n  int x[N][N];\n  int y[N];\n  int z[N];\n  int num_threads = -1;\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      x[i][j] = 1;\n    }\n    y[i] = i;\n    z[i] = 2*i;\n  }\n\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST)\n  {\n#pragma omp loop\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        x[i][j] += y[i]*z[i];\n      }\n    }\n    if (omp_get_thread_num() == 0 && omp_get_team_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, x[i][j] != 1 + (y[i]*z[i]));\n    }\n  }\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of loop construct can't be guaranteed.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n  OMPVV_ERROR_IF(num_threads < 1, \"omp_get_num_threads() returned an invalid number of threads.\");\n\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_loop_nested_teams());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_loop_nested_parallel());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_loop_nested.c -------------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the loop directive without any clauses with nested loops.\n// The construct is applied in a teams and a parallel construct and the\n// correctness of array operations in the nested loops in the loop construct\n// is checked. Compare with test_loop_bind.c, which performs the same\n// operations in a nested loop with a bind clause.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 32\n\nint test_loop_nested_teams() {\n  OMPVV_INFOMSG(\"test_loop_nested_teams\");\n  int errors = 0;\n  int x[N][N];\n  int y[N];\n  int z[N];\n  int num_teams = -1;\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      x[i][j] = 1;\n    }\n    y[i] = i;\n    z[i] = 2*i;\n  }\n\n#pragma omp teams num_teams(OMPVV_NUM_TEAMS_DEVICE) thread_limit(OMPVV_NUM_THREADS_HOST)\n  {\n#pragma omp loop\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        x[i][j] += y[i]*z[i];\n      }\n    }\n    #pragma omp parallel if(0)\n    if (omp_get_team_num() == 0) {\n      num_teams = omp_get_num_teams();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, x[i][j] != 1 + (y[i]*z[i]));\n    }\n  }\n\n\n  OMPVV_WARNING_IF(num_teams == 1, \"Test ran with one team, so parallelism of loop construct can't be guaranteed.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_teams < 1);\n  OMPVV_ERROR_IF(num_teams < 1, \"omp_get_num_teams() returned an invalid number of teams.\");\n\n  return errors;\n}\n\nint test_loop_nested_parallel() {\n  OMPVV_INFOMSG(\"test_loop_nested_parallel\");\n  int errors = 0;\n  int x[N][N];\n  int y[N];\n  int z[N];\n  int num_threads = -1;\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      x[i][j] = 1;\n    }\n    y[i] = i;\n    z[i] = 2*i;\n  }\n\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST)\n  {\n#pragma omp loop\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        x[i][j] += y[i]*z[i];\n      }\n    }\n    if (omp_get_thread_num() == 0 && omp_get_team_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, x[i][j] != 1 + (y[i]*z[i]));\n    }\n  }\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of loop construct can't be guaranteed.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n  OMPVV_ERROR_IF(num_threads < 1, \"omp_get_num_threads() returned an invalid number of threads.\");\n\n  return errors;\n}\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/gemv_target_many_matrices.cpp",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===-- gemv_target_many_matrices.cpp - GEMV on many matrices in parallel ---===!\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// Taken from the suggestions of the QMCPack team. This test uses a target teams\n// distribute combined construct Additionally, it spawns multiple target \n// regions in parallel. Each on a different matrix\n//!===----------------------------------------------------------------------===!\n#include <chrono>\n#include <string>\n#include <vector>\n#include <cmath>\n#include \"ompvv.h\"\n#include \"omp.h\"\n\n#define N 4096\n#define NUM_CALC 8\n\nclass Timer\n{\n  const std::chrono::time_point<std::chrono::system_clock> start;\n  const std::string name;\n\npublic:\n  Timer(const std::string& name_in): start(std::chrono::system_clock::now()), name(name_in) {};\n  ~Timer()\n  {\n    auto end = std::chrono::system_clock::now();\n    OMPVV_INFOMSG(\"Function %s takes %lf us \",name.c_str(), std::chrono::duration_cast<std::chrono::duration<double, std::micro>>(end - start).count());\n  }\n};\n\ntemplate <typename T>\nvoid gemv(int n, T alpha, const T*  A, const T*  V, T*  Vout)\n{\n  #pragma omp target teams distribute map(to:A[:n*n], V[:n]) map(from:Vout[:n])\n  for(int row=0; row<n; row++)\n  {\n    T sum = T(0);\n    const T * A_row = A+row*n;\n    for(int col=0; col<n; col++) {\n      sum += A_row[col]*V[col];\n    }\n    Vout[row] = sum*alpha;\n  }\n}\n\ntemplate <class T>\nT* allocate(size_t n)\n{\n  T* ptr = new T[n];\n  std::fill_n(ptr, n, T(1));\n  #pragma omp target enter data map(to:ptr[:n])\n  return ptr;\n}\n\ntemplate <class T>\nvoid deallocate(T* ptr, size_t n)\n{\n  #pragma omp target exit data map(delete:ptr[:n])\n  delete[] ptr;\n}\n\nint main()\n{\n  OMPVV_TEST_OFFLOADING;\n  std::vector<float*> manyA;\n  std::vector<float*> manyV;\n  std::vector<float*> manyVout;\n  int errors = 0;\n\n  // Initializing matrices \n  for(int i=0; i < NUM_CALC; i++)\n  {\n    manyA.push_back(allocate<float>(N*N));\n    manyV.push_back(allocate<float>(N));\n    manyVout.push_back(allocate<float>(N));\n  }\n\n  // Doing the computation\n  {\n    Timer local(\"GEMV\");\n    #pragma omp parallel for\n    for(int i=0; i < NUM_CALC; i++) {\n      gemv(N, 1.0f, manyA[i], manyV[i], manyVout[i]);\n    }\n  }\n\n  for(int i=0; i < NUM_CALC; i++) {\n    auto*  Vout = manyVout[i];\n    #pragma omp target update from(Vout[:N])\n    for(int i=0; i<N; i++)\n    {\n      OMPVV_TEST_AND_SET(errors, std::abs(Vout[i]-N) > 0.0001);\n      OMPVV_ERROR_IF( std::abs(Vout[i]-N) > 0.0001, \"Error for Vout[%d] = %f, Should be %d\", i, Vout[i], N);\n    }\n    deallocate(manyA[i], N*N);\n    deallocate(manyV[i], N);\n    deallocate(manyVout[i], N);\n  }\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <iostream>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nfloat vngicfzwcg = 60;\nint zjilmlfdgl = 62;\ndouble ctaazurhat = 104;\nfloat rdfipirjul = 168;\nshort yjbuxyuupf = 106;\nint zmbscnicac = 225;\nshort mzrojeqtpr = 43;\nint knqhhkxhqp = 88;\nlong vekztmmpar = 33;\nbyte jvxrslaakx = 70;\nbyte zioopetbko = 211;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    std::cout << \"Sum of \" << num1 << \" and \" << num2 << \" is \" << sum << std::endl;\n    return 0;\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_partial_loop_unroll.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n\terrors = 0;\n\tOMPVV_TEST_OFFLOADING;\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_partial_loop_unroll() != 0);\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\" at position 1654",
        "issue_id": 4,
        "original_code": "//===--- test_partial_loop_unroll.c -----------------------------------------------===//\n//\n// OpenMP API Version 5.1 August 2021 \n//\n// This test checks the behavior of the 5.1 unroll construct (2.11.9.2 in 5.1 spec). \n// \"The unroll construct fully or partially unrolls a loop\", which is more of a code generation\n// compiler feature. \n// This test specifically checks the unroll construct with the partial clause, \n// with a loop-unroll factor which specifies: \n// \"specifies that the number of iterations will be reduced\n//  multiplicatively by the factor while the number of blocks \n//  will be increased by the same factor.\" \n// Referenced 5.1 Example Doc 7.2 \n////===--------------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n# define N 1024\n\nint errors; \n\nint test_partial_loop_unroll() {\n\tint arr[N];\n\tint parallel_arr[N];\n\tint sum = 0;\n\tint parallel_sum = 0;\n\n\t// sequential loop\n\tfor (int i = 0; i < N; i++) {\n\t\tarr[i] = i;\n\t\tsum += arr[i];\n\t}\n\n\t// omp unroll loop partially\n# pragma omp unroll partial(4)\n\tfor (int i = 0; i < N; i++) {\n\t\tparallel_arr[i] = i;\n\t}\n\n\t// sequential sum of parallel array\n\tfor (int i = 0; i < N; i++) {\n\t\tparallel_sum += parallel_arr[i];\n\t}\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, parallel_sum != sum);\n\tOMPVV_INFOMSG_IF(sum == 0, \"Array was not initialized.\");\n\tOMPVV_INFOMSG_IF(parallel_sum == 0, \"Something went wrong with loop unroll.\");\n\tOMPVV_INFOMSG_IF(parallel_sum == sum, \"Test passed.\");\n\tOMPVV_INFOMSG_IF(parallel_sum != sum, \"Test did not pass.\");\n\treturn errors;\n}\n\nint main() {\n\terrors = 0;\n\tOMPVV_TEST_OFFLOADING;\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_partial_loop_unroll() != 0);\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_partial_loop_unroll.c -----------------------------------------------===//\n//\n// OpenMP API Version 5.1 August 2021 \n//\n// This test checks the behavior of the 5.1 unroll construct (2.11.9.2 in 5.1 spec). \n// \"The unroll construct fully or partially unrolls a loop\", which is more of a code generation\n// compiler feature. \n// This test specifically checks the unroll construct with the partial clause, \n// with a loop-unroll factor which specifies: \n// \"specifies that the number of iterations will be reduced\n//  multiplicatively by the factor while the number of blocks \n//  will be increased by the same factor.\" \n// Referenced 5.1 Example Doc 7.2 \n////===--------------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n# define N 1024\n\nint errors; \n\nint test_partial_loop_unroll() {\n\tint arr[N];\n\tint parallel_arr[N];\n\tint sum = 0;\n\tint parallel_sum = 0;\n\n\t// sequential loop\n\tfor (int i = 0; i < N; i++) {\n\t\tarr[i] = i;\n\t\tsum += arr[i];\n\t}\n\n\t// omp unroll loop partially\n# pragma omp unroll partial(4)\n\tfor (int i = 0; i < N; i++) {\n\t\tparallel_arr[i] = i;\n\t}\n\n\t// sequential sum of parallel array\n\tfor (int i = 0; i < N; i++) {\n\t\tparallel_sum += parallel_arr[i];\n\t}\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, parallel_sum != sum);\n\tOMPVV_INFOMSG_IF(sum == 0, \"Array was not initialized.\");\n\tOMPVV_INFOMSG_IF(parallel_sum == 0, \"Something went wrong with loop unroll.\");\n\tOMPVV_INFOMSG_IF(parallel_sum == sum, \"Test passed.\");\n\tOMPVV_INFOMSG_IF(parallel_sum != sum, \"Test did not pass.\");\n\treturn errors;\n}\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_requires_atomic_default_mem_order_seq_cst.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp requires\" with directive \"#pragma omp cancel\" at position 677",
        "issue_id": 0,
        "original_code": "//===---test_target_requires_atomic_default_mem_order_seq_cst.c--------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks for support of the atomic_default_mem_order clause on the \n// requires directive. This clause determines the default memory behavior for\n// atomic constructs. These behaviors are seq_cst, acq_rel, and relaxed.\n// This test checks the seq_cst behavior, which is also the default.\n//\n// Adapted from 5.0 OpenMP example acquire_release.2.c\n////===----------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp requires atomic_default_mem_order(seq_cst)\n\nint test_target_atomic_seq_cst() {\n  OMPVV_INFOMSG(\"test_target_atomic_seq_cst\");\n\n  int x = 0, y = 0;\n  int errors = 0;\n\n#pragma omp target parallel num_threads(2) map(tofrom: x, y, errors)\n   {\n      int thrd = omp_get_thread_num();\n       if (thrd == 0) {\n          x = 10;\n          #pragma omp atomic write \n          y = 1;\n       } else {\n          int tmp = 0;\n          while (tmp == 0) {\n            #pragma omp atomic read \n            tmp = y;\n          }\n          OMPVV_TEST_AND_SET(errors, x != 10);\n       }\n   }\n   OMPVV_ERROR_IF(errors > 0, \"Requires atomic_default_mem_order(seq_cst) test failed\");\n   return errors;\n}\n\nint main() {\n\n  int errors = 0;\n\n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_atomic_seq_cst());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---test_target_requires_atomic_default_mem_order_seq_cst.c--------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks for support of the atomic_default_mem_order clause on the \n// requires directive. This clause determines the default memory behavior for\n// atomic constructs. These behaviors are seq_cst, acq_rel, and relaxed.\n// This test checks the seq_cst behavior, which is also the default.\n//\n// Adapted from 5.0 OpenMP example acquire_release.2.c\n////===----------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp cancel atomic_default_mem_order(seq_cst)\n\nint test_target_atomic_seq_cst() {\n  OMPVV_INFOMSG(\"test_target_atomic_seq_cst\");\n\n  int x = 0, y = 0;\n  int errors = 0;\n\n#pragma omp target parallel num_threads(2) map(tofrom: x, y, errors)\n   {\n      int thrd = omp_get_thread_num();\n       if (thrd == 0) {\n          x = 10;\n          #pragma omp atomic write \n          y = 1;\n       } else {\n          int tmp = 0;\n          while (tmp == 0) {\n            #pragma omp atomic read \n            tmp = y;\n          }\n          OMPVV_TEST_AND_SET(errors, x != 10);\n       }\n   }\n   OMPVV_ERROR_IF(errors > 0, \"Requires atomic_default_mem_order(seq_cst) test failed\");\n   return errors;\n}\n\nint main() {\n\n  int errors = 0;\n\n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_atomic_seq_cst());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_requires_atomic_default_mem_order_relaxed.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 833",
        "issue_id": 2,
        "original_code": "//===---test_requires_atomic_default_mem_order_relaxed.c---------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n// \n// This test checks for support of the atomic_default_mem_order clause on the \n// requires directive. This clause determines the default memory behavior for\n// atomic constructs. These behaviors are seq_cst, acq_rel, and relaxed.\n// This test checks for relaxed as the memory-order-clause.\n//\n// Adapted from 5.0 OpenMP example acquire_release.3.c\n////===----------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#pragma omp requires atomic_default_mem_order(relaxed)\n\nint test_requires_atomic_relaxed() {\n  OMPVV_INFOMSG(\"test_requires_atomic_relaxed\");\n\n  int x = 0, y = 0;\n  int errors = 0;\n  \n  omp_set_dynamic(0);\n  omp_set_num_threads(2);\n  \n#pragma omp parallel \n   {\n      int thrd = omp_get_thread_num();\n       if (thrd == 0) {\n          x = 10;\n          #pragma omp flush\n          #pragma omp atomic write \n          y = 1;\n       } else {\n          int tmp = 0;\n          while (tmp == 0) {\n            #pragma omp atomic read \n            tmp = y;\n          }\n          #pragma omp flush\n          OMPVV_TEST_AND_SET_VERBOSE(errors, x != 10);\n       }\n   }\n   return errors;\n}\n\n\nint main() {\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_requires_atomic_relaxed());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---test_requires_atomic_default_mem_order_relaxed.c---------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n// \n// This test checks for support of the atomic_default_mem_order clause on the \n// requires directive. This clause determines the default memory behavior for\n// atomic constructs. These behaviors are seq_cst, acq_rel, and relaxed.\n// This test checks for relaxed as the memory-order-clause.\n//\n// Adapted from 5.0 OpenMP example acquire_release.3.c\n////===----------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#pragma omp requires atomic_default_mem_order(relaxed)\n\nint test_requires_atomic_relaxed() {\n  OMPVV_INFOMSG(\"test_requires_atomic_relaxed\");\n\n  int x = 0, y = 0;\n  int errors = 0;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n  \n  omp_set_dynamic(0);\n  omp_set_num_threads(2);\n  \n#pragma omp parallel \n   {\n      int thrd = omp_get_thread_num();\n       if (thrd == 0) {\n          x = 10;\n          #pragma omp flush\n          #pragma omp atomic write \n          y = 1;\n       } else {\n          int tmp = 0;\n          while (tmp == 0) {\n            #pragma omp atomic read \n            tmp = y;\n          }\n          #pragma omp flush\n          OMPVV_TEST_AND_SET_VERBOSE(errors, x != 10);\n       }\n   }\n   return errors;\n}\n\n\nint main() {\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_requires_atomic_relaxed());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_taskloop_reduction.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1431",
        "issue_id": 1,
        "original_code": "//===--- test_taskloop_reduction.c ------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the taskloop directive with the reduction clause specified.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_taskloop_reduction() {\n\n   int errors = 0;\n   int a[N];\n   int b[N]; \n   int sum = 0;\n   int num_threads = -1;\n   int real_sum = 0;\n\n   for (int i = 0; i < N; i++) {\n      a[i] = 5;\n      b[i] = i * 2; \n   }\n\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST) shared(a, b, num_threads, sum) \n{\n   #pragma omp single\n   #pragma omp taskloop reduction(+:sum)\n   for (int i = 0; i < N; i++) {\n      sum += a[i]*b[i]; \n   }\n   num_threads = omp_get_num_threads();\n\n   #pragma omp single\n   #pragma omp taskloop reduction(+:sum)\n   for (int i = 0; i < N; i++) {\n      sum++;\n   }\n}\n   \n   real_sum += N;\n   \n   for (int i = 0; i < N; i++) {\n      real_sum += a[i]*b[i];\n   }\n   \n\n   OMPVV_TEST_AND_SET_VERBOSE(errors, sum != real_sum);\n\n   OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of taskloop can't be guaranteed.\");\n   OMPVV_ERROR_IF(num_threads < 1, \"Test returned an invalid number of threads.\");\n   OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n\n   return errors;            \n}\n\n\nint main() {\n \n   int errors = 0;\n  \n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_taskloop_reduction());\n\n   OMPVV_REPORT_AND_RETURN(errors);\n\n}\n",
        "error_code": "//===--- test_taskloop_reduction.c ------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the taskloop directive with the reduction clause specified.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_taskloop_reduction() {\n\n   int errors = 0;\n   int a[N];\n   int b[N]; \n   int sum = 0;\n   int num_threads = -1;\n   int real_sum = 0;\n\n   for (int i = 0; i < N; i++) {\n      a[i] = 5;\n      b[i] = i * 2; \n   }\n\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST) shared(a, b, num_threads, sum) \n{\n   #pragma omp single\n   #pragma omp taskloop reduction(+:sum)\n   for (int i = 0; i < N; i++) {\n      sum += a[i]*b[i]; \n   }\n   num_threads = omp_get_num_threads();\n\n   #pragma omp single\n   #pragma omp taskloop reduction(+:sum)\n   for (int i = 0; i < N; i++) {\n      sum++;\n   }\n}\n   \n   real_sum += N;\n   \n   for (int i = 0; i < N; i++) {\n      real_sum += a[i]*b[i];\n   }\n   \n\n   OMPVV_TEST_AND_SET_VERBOSE(errors, sum != real_sum);\n\n   OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of taskloop can't be guaranteed.\");\n   OMPVV_ERROR_IF(num_threads < 1, \"Test returned an invalid number of threads.\");\n   OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n\n   return errors;            \n}\n\n\nint main() \n \n   int errors = 0;\n  \n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_taskloop_reduction());\n\n   OMPVV_REPORT_AND_RETURN(errors);\n\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_omp_teams_thread_limit_env_2.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 731",
        "issue_id": 2,
        "original_code": "//--------------- test_omp_team_thread_limit_env_2.c---------------------//\n//\n// OpenMP API Version 5.1 Aug 2021\n//\n// The objective of this test is to check that the team_thread_limit env\n// var is set properly. It is important to note that the name of the test\n// is very important to the env var being set. It follows a convention set\n// up for testing env variables in run.sh. This test itself simply checks\n// that the threadlimit is set to the appropriate variable value specified\n// in the test name. \n//-----------------------------------------------------------------------//\n\n\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\nint test_case(){\n\tint errors = 0;\n\tint env = 10;\n\tenv = omp_get_teams_thread_limit();\n\tOMPVV_TEST_AND_SET(errors, env != 2);\n\tOMPVV_INFOMSG_IF(env == 0, \"Environment variable not set\");\n\tOMPVV_INFOMSG_IF(env == 10, \"Call to omp_get_teams_thread_limit() did not update local var.\");\n\treturn errors;\n}\n\n\nint main(){\n\tint errors = 0;\n\tOMPVV_TEST_OFFLOADING;\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_case() != 0);\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//--------------- test_omp_team_thread_limit_env_2.c---------------------//\n//\n// OpenMP API Version 5.1 Aug 2021\n//\n// The objective of this test is to check that the team_thread_limit env\n// var is set properly. It is important to note that the name of the test\n// is very important to the env var being set. It follows a convention set\n// up for testing env variables in run.sh. This test itself simply checks\n// that the threadlimit is set to the appropriate variable value specified\n// in the test name. \n//-----------------------------------------------------------------------//\n\n\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\nint test_case(){\n\tint errors = 0;\n\tint env = 10;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n\tenv = omp_get_teams_thread_limit();\n\tOMPVV_TEST_AND_SET(errors, env != 2);\n\tOMPVV_INFOMSG_IF(env == 0, \"Environment variable not set\");\n\tOMPVV_INFOMSG_IF(env == 10, \"Call to omp_get_teams_thread_limit() did not update local var.\");\n\treturn errors;\n}\n\n\nint main(){\n\tint errors = 0;\n\tOMPVV_TEST_OFFLOADING;\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_case() != 0);\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_mul_inheritence1.cpp",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp requires\" with directive \"#pragma omp parallel\" at position 452",
        "issue_id": 0,
        "original_code": "//===-- test_target_mul_inheritence1.cpp ---------------------------------===//\n//\n// OpenMP API Version 5.2\n//\n// Description\n// This test case tests the working of the following aspects:\n// 1) Working of \"requires unified_shared_memory\"\n// 2) Working of diamond pattern of inheritence on gpu\n//===----------------------------------------------------------------------===//\n\n#include <iostream>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1024*10\n\n#pragma omp requires unified_shared_memory\n\nclass A {\n  int *Ax = new int[N];\n  public:\n  static int StatVar;\n  int GetAx(int Indx) {\n    return Ax[Indx];\n  }\n  static void IncrStatVar(int x = 1) {\n    StatVar += x;\n  }\n  void SetAx(int Val) {\n    for (int i = 0; i < N; ++i) {\n      Ax[i] = Val;\n        }\n  }\n  A() {\n    IncrStatVar();\n    for (int i = 0; i < N; ++i) {\n      Ax[i] = 10;\n    }\n  }\n  A(int x) {\n    IncrStatVar(x);\n    for (int i = 0; i < N; ++i) {\n      Ax[i] = 10;\n    }\n  }\n\n  ~A() {\n    delete[] Ax;\n  }\n};\nint A::StatVar = 0;\n\nclass B : virtual public A {\n  int *Bx = new int[N];\n        public:\n  int GetBx(int Indx) {\n    return Bx[Indx];\n  }\n\n  void SetBx(int Val) {\n    for (int i = 0; i < N; ++i) {\n      Bx[i] = Val;\n    }\n  }\n\n  B() {\n    for (int i = 0; i < N; ++i) {\n      Bx[i] = 20;\n    }\n  }\n  ~B() {\n    delete[] Bx;\n  }\n};\n\nclass C : virtual public A {\n  int *Cx = new int[N];\n        public:\n  C() {\n    for (int i = 0; i < N; ++i) {\n      Cx[i] = 30;\n    }\n  }\n  ~C() {\n    delete[] Cx;\n  }\n\n  int GetCx(int Indx) {\n    return Cx[Indx];\n  }\n  void SetCx(int Val) {\n    for (int i = 0; i < N; ++i) {\n      Cx[i] = Val;\n    }\n  }\n};\n\nclass D : public B, public C  {\n  int Dx;\n        public:\n  int GetDx() {\n    return Dx;\n  }\n  D(int x) {\n    Dx = x;\n  }\n};\n\nclass D_PC : public B, public C  {\n  int Dx;\n        public:\n  int GetDx() {\n    return Dx;\n  }\n  D_PC(int x):A(x) {\n    Dx = x;\n  }\n};\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  D dx(40);\n  int Errors = 0, errors = 0;\n  int TotGpus = omp_get_num_devices();\n  for (int dev = 0; dev < TotGpus; ++dev) {\n  #pragma omp target data map(tofrom: Errors) device(dev)\n  #pragma omp target device(dev)\n    {\n      if (dx.GetDx() != 40) {\n        Errors++;\n      }\n      // Setting value to an array in class A through class C object\n      dx.SetAx(123);\n      // Verifying if the value is set\n      if ((dx.GetAx(0) != 123) || (dx.GetAx(N/2) != 123) ||\n          (dx.GetAx(N-1) != 123)) {\n        Errors++;\n      }\n      dx.SetBx(333);\n      // Verifying if the value is set\n      if ((dx.GetBx(0) != 333) || (dx.GetBx(N/2) != 333) ||\n          (dx.GetBx(N-1) != 333)) {\n          Errors++;\n      }\n      dx.SetCx(444);\n      // Verifying if the value is set\n      if ((dx.GetCx(0) != 444) || (dx.GetCx(N/2) != 444) ||\n          (dx.GetCx(N-1) != 444)) {\n          Errors++;\n      }\n      if (A::StatVar != 1) {\n        Errors++;\n      }\n    }\n  }\n\n  D_PC DPCx(999);\n  for (int dev = 0; dev < TotGpus; ++dev) {\n  #pragma omp target data map(tofrom: Errors) device(dev)\n  #pragma omp target device(dev)\n    {\n      if (A::StatVar != 999) {\n        Errors++;\n      }\n    }\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (Errors != 0));\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===-- test_target_mul_inheritence1.cpp ---------------------------------===//\n//\n// OpenMP API Version 5.2\n//\n// Description\n// This test case tests the working of the following aspects:\n// 1) Working of \"requires unified_shared_memory\"\n// 2) Working of diamond pattern of inheritence on gpu\n//===----------------------------------------------------------------------===//\n\n#include <iostream>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1024*10\n\n#pragma omp parallel unified_shared_memory\n\nclass A {\n  int *Ax = new int[N];\n  public:\n  static int StatVar;\n  int GetAx(int Indx) {\n    return Ax[Indx];\n  }\n  static void IncrStatVar(int x = 1) {\n    StatVar += x;\n  }\n  void SetAx(int Val) {\n    for (int i = 0; i < N; ++i) {\n      Ax[i] = Val;\n        }\n  }\n  A() {\n    IncrStatVar();\n    for (int i = 0; i < N; ++i) {\n      Ax[i] = 10;\n    }\n  }\n  A(int x) {\n    IncrStatVar(x);\n    for (int i = 0; i < N; ++i) {\n      Ax[i] = 10;\n    }\n  }\n\n  ~A() {\n    delete[] Ax;\n  }\n};\nint A::StatVar = 0;\n\nclass B : virtual public A {\n  int *Bx = new int[N];\n        public:\n  int GetBx(int Indx) {\n    return Bx[Indx];\n  }\n\n  void SetBx(int Val) {\n    for (int i = 0; i < N; ++i) {\n      Bx[i] = Val;\n    }\n  }\n\n  B() {\n    for (int i = 0; i < N; ++i) {\n      Bx[i] = 20;\n    }\n  }\n  ~B() {\n    delete[] Bx;\n  }\n};\n\nclass C : virtual public A {\n  int *Cx = new int[N];\n        public:\n  C() {\n    for (int i = 0; i < N; ++i) {\n      Cx[i] = 30;\n    }\n  }\n  ~C() {\n    delete[] Cx;\n  }\n\n  int GetCx(int Indx) {\n    return Cx[Indx];\n  }\n  void SetCx(int Val) {\n    for (int i = 0; i < N; ++i) {\n      Cx[i] = Val;\n    }\n  }\n};\n\nclass D : public B, public C  {\n  int Dx;\n        public:\n  int GetDx() {\n    return Dx;\n  }\n  D(int x) {\n    Dx = x;\n  }\n};\n\nclass D_PC : public B, public C  {\n  int Dx;\n        public:\n  int GetDx() {\n    return Dx;\n  }\n  D_PC(int x):A(x) {\n    Dx = x;\n  }\n};\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  D dx(40);\n  int Errors = 0, errors = 0;\n  int TotGpus = omp_get_num_devices();\n  for (int dev = 0; dev < TotGpus; ++dev) {\n  #pragma omp target data map(tofrom: Errors) device(dev)\n  #pragma omp target device(dev)\n    {\n      if (dx.GetDx() != 40) {\n        Errors++;\n      }\n      // Setting value to an array in class A through class C object\n      dx.SetAx(123);\n      // Verifying if the value is set\n      if ((dx.GetAx(0) != 123) || (dx.GetAx(N/2) != 123) ||\n          (dx.GetAx(N-1) != 123)) {\n        Errors++;\n      }\n      dx.SetBx(333);\n      // Verifying if the value is set\n      if ((dx.GetBx(0) != 333) || (dx.GetBx(N/2) != 333) ||\n          (dx.GetBx(N-1) != 333)) {\n          Errors++;\n      }\n      dx.SetCx(444);\n      // Verifying if the value is set\n      if ((dx.GetCx(0) != 444) || (dx.GetCx(N/2) != 444) ||\n          (dx.GetCx(N-1) != 444)) {\n          Errors++;\n      }\n      if (A::StatVar != 1) {\n        Errors++;\n      }\n    }\n  }\n\n  D_PC DPCx(999);\n  for (int dev = 0; dev < TotGpus; ++dev) {\n  #pragma omp target data map(tofrom: Errors) device(dev)\n  #pragma omp target device(dev)\n    {\n      if (A::StatVar != 999) {\n        Errors++;\n      }\n    }\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (Errors != 0));\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_loop_collapse_device.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 3065",
        "issue_id": 2,
        "original_code": "//===--- test_loop_collapse_device.c ---------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the collapse clause with the loop directive and tests that\n// for loops out of the scope of the collapsed loops are not parallelized.\n// This test tests using one and two collapsed loops. This test checks these\n// features in an offloading (target) context.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 128 //Array Size of 128 uses 16MB target memory and\n                       //scales n^3 in test_collapse2()\n\nint test_collapse1() {\n\n  int * a_mem = (int *)malloc(N*N*sizeof(int));\n  int * b_mem = (int *)malloc(N*(N+1)*sizeof(int));\n  int (*a)[N] = (int (*)[N])a_mem;\n  int (*b)[N + 1] = (int (*)[N+1])b_mem;\n  int errors = 0;\n\n  // a and b array initialization\n  for (int x = 0; x < N; ++x) {\n    b[x][0] = 0;\n    for (int y = 0; y < N; ++y) {\n      a[x][y] = x + y;\n      b[x][y+1] = 0;\n    }\n  }\n\n#pragma omp target parallel num_threads(OMPVV_NUM_THREADS_DEVICE) map(tofrom: a[:N][:N], b[:N][:N+1])\n  {\n#pragma omp loop collapse(1)\n    for (int x = 0; x < N; ++x) {\n      for (int y = 0; y < N; ++y) {\n        b[x][y + 1] = b[x][y] + a[x][y];\n      }\n    }\n  }\n\n  int temp_total;\n  for (int x = 0; x < N; ++x) {\n    temp_total = 0;\n    for (int y = 0; y < N+1; ++y) {\n      OMPVV_TEST_AND_SET(errors, ((temp_total - b[x][y]) != 0));\n      if (y != N) {\n        temp_total = temp_total + a[x][y];\n      }\n    }\n  }\n  free (a_mem);\n  free (b_mem);\n  return errors;\n}\n\nint test_collapse2() {\n  int * a_mem = (int *)malloc(N*N*N*sizeof(int));\n  int * b_mem = (int *)malloc(N*N*(N+1)*sizeof(int));\n  int (*a)[N][N] = (int (*)[N][N])a_mem;\n  int (*b)[N][N + 1] = (int (*)[N][N+1])b_mem;\n  int errors = 0;\n  int num_threads = 0;\n\n  // a and b array initialization\n  for (int x = 0; x < N; ++x) {\n    for (int y = 0; y < N; ++y) {\n      b[x][y][0] = 0;\n      for (int z = 0; z < N; ++z) {\n        a[x][y][z] = x + y + z;\n        b[x][y][z+1] = 0;\n      }\n    }\n  }\n\n#pragma omp target parallel num_threads(OMPVV_NUM_THREADS_DEVICE) map(tofrom: a[:N][:N][:N], b[:N][:N][:N+1], num_threads)\n  {\n    if (omp_get_thread_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n#pragma omp loop collapse(2)\n    for (int x = 0; x < N; ++x) {\n      for (int y = 0; y < N; ++y) {\n        for (int z = 0; z < N; ++z) {\n          b[x][y][z + 1] = b[x][y][z] + a[x][y][z];\n        }\n      }\n    }\n  }\n\n  int temp_total;\n  for (int x = 0; x < N; ++x) {\n    for (int y = 0; y < N; ++y) {\n      temp_total = 0;\n      for (int z = 0; z < N + 1; ++z) {\n        OMPVV_TEST_AND_SET(errors, ((temp_total - b[x][y][z]) != 0));\n        if (z != N) {\n          temp_total = temp_total + a[x][y][z];\n        }\n      }\n    }\n  }\n\n  if (num_threads == 1) {\n    OMPVV_WARNING(\"Test operated with one thread.  Parallelism of loop directive in parallel region can't be guaranteed.\");\n  }\n\n  free (a_mem);\n  free (b_mem);\n  return errors;\n}\n\nint main() {\n\n  //Check for offloading\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_collapse1() != 0);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_collapse2() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n}\n",
        "error_code": "//===--- test_loop_collapse_device.c ---------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the collapse clause with the loop directive and tests that\n// for loops out of the scope of the collapsed loops are not parallelized.\n// This test tests using one and two collapsed loops. This test checks these\n// features in an offloading (target) context.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 128 //Array Size of 128 uses 16MB target memory and\n                       //scales n^3 in test_collapse2()\n\nint test_collapse1() {\n\n  int * a_mem = (int *)malloc(N*N*sizeof(int));\n  int * b_mem = (int *)malloc(N*(N+1)*sizeof(int));\n  int (*a)[N] = (int (*)[N])a_mem;\n  int (*b)[N + 1] = (int (*)[N+1])b_mem;\n  int errors = 0;\n\n  // a and b array initialization\n  for (int x = 0; x < N; ++x) {\n    b[x][0] = 0;\n    for (int y = 0; y < N; ++y) {\n      a[x][y] = x + y;\n      b[x][y+1] = 0;\n    }\n  }\n\n#pragma omp target parallel num_threads(OMPVV_NUM_THREADS_DEVICE) map(tofrom: a[:N][:N], b[:N][:N+1])\n  {\n#pragma omp loop collapse(1)\n    for (int x = 0; x < N; ++x) {\n      for (int y = 0; y < N; ++y) {\n        b[x][y + 1] = b[x][y] + a[x][y];\n      }\n    }\n  }\n\n  int temp_total;\n  for (int x = 0; x < N; ++x) {\n    temp_total = 0;\n    for (int y = 0; y < N+1; ++y) {\n      OMPVV_TEST_AND_SET(errors, ((temp_total - b[x][y]) != 0));\n      if (y != N) {\n        temp_total = temp_total + a[x][y];\n      }\n    }\n  }\n  free (a_mem);\n  free (b_mem);\n  return errors;\n}\n\nint test_collapse2() {\n  int * a_mem = (int *)malloc(N*N*N*sizeof(int));\n  int * b_mem = (int *)malloc(N*N*(N+1)*sizeof(int));\n  int (*a)[N][N] = (int (*)[N][N])a_mem;\n  int (*b)[N][N + 1] = (int (*)[N][N+1])b_mem;\n  int errors = 0;\n  int num_threads = 0;\n\n  // a and b array initialization\n  for (int x = 0; x < N; ++x) {\n    for (int y = 0; y < N; ++y) {\n      b[x][y][0] = 0;\n      for (int z = 0; z < N; ++z) {\n        a[x][y][z] = x + y + z;\n        b[x][y][z+1] = 0;\n      }\n    }\n  }\n\n#pragma omp target parallel num_threads(OMPVV_NUM_THREADS_DEVICE) map(tofrom: a[:N][:N][:N], b[:N][:N][:N+1], num_threads)\n  {\n    if (omp_get_thread_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n#pragma omp loop collapse(2)\n    for (int x = 0; x < N; ++x) {\n      for (int y = 0; y < N; ++y) {\n        for (int z = 0; z < N; ++z) {\n          b[x][y][z + 1] = b[x][y][z] + a[x][y][z];\n        }\n      }\n    }\n  }\n\n  int temp_total;\n  for (int x = 0; x < N; ++x) {\n    for (int y = 0; y < N; ++y) {\n      temp_total = 0;\n      for (int z = 0; z < N + 1; ++z) {\n        OMPVV_TEST_AND_SET(errors, ((temp_total - b[x][y][z]) != 0));\n        if (z != N) {\n          temp_total = temp_total + a[x][y][z];\n        }\n      }\n    }\n  }\n\n  if (num_threads == 1) {\n    OMPVV_WARNING(\"Test operated with one thread.  Parallelism of loop directive in parallel region can't be guaranteed.\");\n  }\n\n  free (a_mem);\n  free (b_mem);yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n  return errors;\n}\n\nint main() {\n\n  //Check for offloading\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_collapse1() != 0);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_collapse2() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_declare_variant.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===--- test_declare_variant.c ---------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the declare variant clause to create two variants of a\n// simple base function, one for use in a parallel region, and one for use\n// in a target region. The function sets each element of an array to its\n// index. Each variant is called on a separate array and the results are\n// checked.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nvoid p_fn(int *arr);\nvoid t_fn(int *arr);\n\n#pragma omp declare variant(p_fn) match(construct = {parallel})\n#pragma omp declare variant(t_fn) match(construct = {target})\nvoid fn(int *arr) {              // base for use on the host in sequence\n  for (int i = 0; i < N; i++) {\n    arr[i] = i;\n  }\n}\n\nvoid p_fn(int *arr) {            // variant for use on host in parallel\n#pragma omp for\n  for (int i = 0; i < N; i++) {\n    arr[i] = i + 1;\n  }\n}\n\n#pragma omp declare target\nvoid t_fn(int *arr) {            // variant for use on target\n#pragma omp distribute\n  for (int i = 0; i < N; i++) {\n    arr[i] = i + 2;\n  }\n}\n#pragma omp end declare target\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int default_errors = 0;\n  int p_errors = 0;\n  int t_errors = 0;\n  int a[N], b[N], c[N];\n\n  for (int i = 0; i < N; i++) {\n    a[i] = 0;\n    b[i] = 0;\n    c[i] = 0;\n  }\n\n  fn(a);\n\n#pragma omp parallel\n  {\n    fn(b);\n  }\n\n#pragma omp target teams map(tofrom: c[0:N])\n  {\n    fn(c);\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(default_errors, a[i] != i);\n    OMPVV_TEST_AND_SET_VERBOSE(p_errors, b[i] != (i + 1));\n    OMPVV_TEST_AND_SET_VERBOSE(t_errors, c[i] != (i + 2));\n  }\n\n  OMPVV_ERROR_IF(default_errors, \"Did not use default variant of test function when expected.\");\n  OMPVV_ERROR_IF(p_errors, \"Did not use parallel variant of test function when expected.\");\n  OMPVV_ERROR_IF(t_errors, \"Did not use target variant of test function when expected.\");\n\n  OMPVV_REPORT_AND_RETURN(default_errors + p_errors + t_errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nshort swktyibnou = 229;\ndouble ngsvobgssv = 16;\nint yuzeuksqrb = 236;\nbyte bfdglkrolm = 165;\nbyte ibwyclgwuj = 224;\nfloat oxtzcuujcq = 171;\nbyte huoacrlanu = 188;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_parallel_for_if_parallel_modifier.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===---- test_target_teams_distribute_parallel_for_if_parallel_modifier.c ------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n// \n// In this test we want to try to check if the if clause is working \n// when used with the combined construct target teams distribute parallel for\n// and the parallel modifier is specified.\n// To do this we check if offloading is working, if it is not, it won't be\n// possible for us to tell if the test passed or not, since it depends on \n// offloading capabilities. \n//\n// The if has a directive-name-modifier that specifies to which directive the \n// if applies to (either both directives, to the target or to the parallel). \n// we create three test, one for no directive, another one for the target directive\n// and another one for the parallel directive \n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define ATTEMPT_THRESHOLD 70\n#define NUM_ATTEMPTS 100\n#define N 1024\n\nvoid checkPreconditions() {\n  // We test if offloading is enable, and if \n  // the number of threads is not 1. Having \n  // the number of threads equal to 1 is legal, but \n  // we won't be able to test if the if is \n  // affecting this or not\n\n  // Testing for offloading\n  int isOffloading = 0;\n  int i;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"With offloading off, it is not possible to test that if(parallel:) is not affecting the target offloading\");\n\n  // Testing for number of threads\n  int init_num_threads_dev[N], init_num_threads_host[N];\n  // init_num_threads_dev and init_num_threads_host arrays initialization\n  for (i = 0; i < N; i++) {\n    init_num_threads_dev[i] = 0;\n    init_num_threads_host[i] = 0;\n  }\n\n  // Get the init_num_threads for host and device. If it is 1, then we \n  // cannot test the if parallel \n  // See section 2.5.1 of the ref manual\n#pragma omp target teams distribute parallel for num_threads(OMPVV_NUM_THREADS_DEVICE)\n  for (i = 0; i < N; i++) {\n    init_num_threads_dev[i] = omp_get_num_threads();\n  }\n\n#pragma omp parallel for num_threads(OMPVV_NUM_THREADS_DEVICE)\n  for (i = 0; i < N; i++) {\n    init_num_threads_host[i] = omp_get_num_threads();\n  }\n  \n  // We check that not all the values are 1. This would make the test of if parallel\n  // not possible. \n  int raiseWarningDevice = 0, raiseWarningHost = 0;\n  for (i = 0; i < N; i++) {\n    if (init_num_threads_dev[i] > 1 ) {\n      raiseWarningDevice +=  1;\n    }\n    if ( init_num_threads_host[i] > 1) {\n      raiseWarningHost += 1;\n    }\n  }\n  OMPVV_WARNING_IF(raiseWarningDevice == 0, \"Initial number of threads in device was 1. It is not possible to test the if for the parallel directive\");\n  OMPVV_WARNING_IF(raiseWarningHost == 0, \"Initial number of threads in host was 1. It is not possible to test the if for parallel\");\n\n}\n\n\nint test_target_teams_distribute_if_parallel_modifier() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_if_parallel_modifier\");\n  \n  int a[N];\n  int warning[N] ; // num_threads = 1 is not technically an error\n  int attempt = 0;\n  int errors = 0;\n  int i;\n  \n  checkPreconditions();\n  // Initialize a and warning\n  for (i = 0; i < N; i++) {\n    a[i] = 0;\n    warning[i] = 0;\n  }\n\n  // We iterates NUM_ATTEMPTS times. When the iteration value is >= ATTEMPT_THRESHOLD the \n  // number of threads is expected to be greater than 1, (although if it is not, this is \n  // not an error, just warning)\n  // If the iteration variable attempt < ATTEMPT_THRESHOLD, the if condition evaluates \n  // to false, and then the number of threads should be 1. Regardless of the value of \n  // the condition the execution should always occur in the device. \n  // We check that when we are never executing on the host, and we check that when the \n  // condition evaluates to false, the number of threads is always 1. We also raise a \n  // warning if the number of threads is 1 when the condition evaluates to true. \n  for (attempt = 0; attempt < NUM_ATTEMPTS; ++attempt) {\n#pragma omp target teams distribute parallel for if(parallel: attempt >= ATTEMPT_THRESHOLD)\\\n    map(tofrom: a, warning) num_threads(OMPVV_NUM_THREADS_DEVICE)\n    for (i = 0; i < N; i++) {\n      if (omp_is_initial_device())\n        a[i] += 10; // This +10 should not happen\n\n      if (attempt >= ATTEMPT_THRESHOLD) {\n        // This is not an error, but we should mention it\n        if (omp_get_num_threads() == 1) {\n          warning[i] += 1;\n        }\n      } else {\n        a[i] += (omp_get_num_threads() != 1) ? 10 : 1;  \n      }\n    }\n  }\n\n  int raiseWarning = 0;\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, a[i] != ATTEMPT_THRESHOLD);\n    if (warning[i] != 0) {\n      raiseWarning++;\n    }\n  }\n\n  OMPVV_WARNING_IF(raiseWarning == N * (NUM_ATTEMPTS - ATTEMPT_THRESHOLD), \"The number of threads was 1 when a number > 1 was expected. if(parallel:true). Not a compliance error in the specs\");\n  OMPVV_ERROR_IF(errors, \"error in if(parallel: modifier). Possible causes are: the execution occurred in the host even though it should not affect the target region. The number of threads was > 1 when if(false).\");\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_if_parallel_modifier());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nlong xduqoikyxk = 152;\nint sbqpkwewcm = 144;\nshort xgtfwxoqin = 25;\nbyte gafgdesjxe = 46;\ndouble wardfkslbr = 67;\nint iyirzihjqz = 193;\nint qyilpmolmo = 82;\nshort awnnxmzbvo = 176;\ndouble izxlqpagdh = 219;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_reduction_subtract.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1645",
        "issue_id": 1,
        "original_code": "//===--- test_target_teams_distribute_reduction_subtract.c----------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the reduction clause on a target teams distribute directive,\n// testing that the variable in the reduction clause is properly reduced using\n// the subtract operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_subtraction() {\n  int a[N];\n  int b[N];\n  int total = 0;\n  int host_total = 0;\n  int errors = 0;\n  int num_teams[N];\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    num_teams[x] = -x;\n  }\n\n#pragma omp target teams distribute reduction(-:total) defaultmap(tofrom:scalar)\n  for (int x = 0; x < N; ++x) {\n    num_teams[x] = omp_get_num_teams();\n    total -= a[x] + b[x];\n  }\n\n  for (int x = 0; x < N; ++x) {\n    host_total -= a[x] + b[x];\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_teams[x - 1] != num_teams[x], \"Kernel reported differing numbers of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_teams[0] == 1, \"Test operated with one team.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_teams[0] <= 0, \"Test reported invalid number of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, host_total != total);\n  OMPVV_ERROR_IF(host_total != total, \"Total on device is %d but expected total from host is %d.\", total, host_total);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_subtraction() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_reduction_subtract.c----------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the reduction clause on a target teams distribute directive,\n// testing that the variable in the reduction clause is properly reduced using\n// the subtract operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_subtraction() {\n  int a[N];\n  int b[N];\n  int total = 0;\n  int host_total = 0;\n  int errors = 0;\n  int num_teams[N];\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    num_teams[x] = -x;\n  }\n\n#pragma omp target teams distribute reduction(-:total) defaultmap(tofrom:scalar)\n  for (int x = 0; x < N; ++x) {\n    num_teams[x] = omp_get_num_teams();\n    total -= a[x] + b[x];\n  }\n\n  for (int x = 0; x < N; ++x) {\n    host_total -= a[x] + b[x];\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_teams[x - 1] != num_teams[x], \"Kernel reported differing numbers of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_teams[0] == 1, \"Test operated with one team.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_teams[0] <= 0, \"Test reported invalid number of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, host_total != total);\n  OMPVV_ERROR_IF(host_total != total, \"Total on device is %d but expected total from host is %d.\", total, host_total);\n\n  return errors;\n}\n\nint main() \n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_subtraction() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_taskloop_in_reduction.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_taskloop_in_reduction());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 1531",
        "issue_id": 4,
        "original_code": "//===--- test_taskloop_in_reduction.c -------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the taskloop directive with the `in_reduction` reduction\n// participation clause. It performs simple array operations which are added\n// to a reduction variable in a taskloop with the in_reduction clause.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_taskloop_in_reduction() {\n  OMPVV_INFOMSG(\"test_taskloop_in_reduction\");\n  int errors = 0;\n  int num_threads = -1;\n  int y[N];\n  int z[N];\n  int sum = 0;\n  int expected_sum = 0;\n\n  for (int i = 0; i < N; i++) {\n    y[i] = i + 1;\n    z[i] = 2*(i + 1);\n  }\n\n#pragma omp parallel reduction(task, +: sum) num_threads(OMPVV_NUM_THREADS_HOST) shared(y, z, num_threads)\n  {\n#pragma omp master\n    {\n#pragma omp taskloop in_reduction(+: sum)\n      for (int i = 0; i < N; i++) {\n        sum += y[i]*z[i];\n      }\n      num_threads = omp_get_num_threads();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    expected_sum += y[i]*z[i];\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, sum != expected_sum);\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of taskloop can't be guaranteed.\");\n  OMPVV_ERROR_IF(num_threads < 1, \"Test returned an invalid number of threads.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n\n  return errors;\n}\n\n\nint main() {\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_taskloop_in_reduction());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_taskloop_in_reduction.c -------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the taskloop directive with the `in_reduction` reduction\n// participation clause. It performs simple array operations which are added\n// to a reduction variable in a taskloop with the in_reduction clause.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_taskloop_in_reduction() {\n  OMPVV_INFOMSG(\"test_taskloop_in_reduction\");\n  int errors = 0;\n  int num_threads = -1;\n  int y[N];\n  int z[N];\n  int sum = 0;\n  int expected_sum = 0;\n\n  for (int i = 0; i < N; i++) {\n    y[i] = i + 1;\n    z[i] = 2*(i + 1);\n  }\n\n#pragma omp parallel reduction(task, +: sum) num_threads(OMPVV_NUM_THREADS_HOST) shared(y, z, num_threads)\n  {\n#pragma omp master\n    {\n#pragma omp taskloop in_reduction(+: sum)\n      for (int i = 0; i < N; i++) {\n        sum += y[i]*z[i];\n      }\n      num_threads = omp_get_num_threads();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    expected_sum += y[i]*z[i];\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, sum != expected_sum);\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of taskloop can't be guaranteed.\");\n  OMPVV_ERROR_IF(num_threads < 1, \"Test returned an invalid number of threads.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n\n  return errors;\n}\n\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_requires_unified_shared_memory_heap_map.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp requires\" with directive \"#pragma omp parallel\" at position 582",
        "issue_id": 0,
        "original_code": "//===---test_requires_unified_shared_memory_heap_map.c ----------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n// \n// This test checks for unified shared memory of an array that is allocated on \n// the heap and that is accessed from host and device with the same pointer.\n//\n// The mapping of a pointer under shared memory should allow for the pointer to\n// have the same value as in the host.\n//\n////===----------------------------------------------------------------------===//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp requires unified_shared_memory\n\nint unified_shared_memory_heap_map() {\n  OMPVV_INFOMSG(\"Unified shared memory testing - Array on heap\");\n  int errors = 0;\n  \n  int *anArray;\n  int anArrayCopy[N];\n\n  anArray = (int*)malloc(sizeof(int)*N);\n  if( anArray == NULL ) {\n    OMPVV_ERROR(\"Memory was not properly allocated\");\n    OMPVV_RETURN(1);\n  }\n\n  for (int i = 0; i < N; i++) {\n    anArray[i] = i;\n    anArrayCopy[i] = 0;\n  }\n  // Modify in the device\n#pragma omp target map(anArray)\n  {\n    for (int i = 0; i < N; i++) {\n      anArray[i] += 10;\n    }\n  }\n  // Modify again on the host\n  for (int i = 0; i < N; i++) {\n    anArray[i] += 10;\n  }\n\n  // Get the value the device is seeing\n#pragma omp target map(anArray)\n  {\n    for (int i = 0; i < N; i++) {\n      anArrayCopy[i] = anArray[i];\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArray[i] != i + 20);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArrayCopy[i] != i + 20);\n    if (errors) break;\n  }\n\n  free(anArray);\n  return errors;\n}\nint main() {\n  int isOffloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"With no offloading, unified shared memory is guaranteed due to host execution\");\n  int errors = 0;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, unified_shared_memory_heap_map());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---test_requires_unified_shared_memory_heap_map.c ----------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n// \n// This test checks for unified shared memory of an array that is allocated on \n// the heap and that is accessed from host and device with the same pointer.\n//\n// The mapping of a pointer under shared memory should allow for the pointer to\n// have the same value as in the host.\n//\n////===----------------------------------------------------------------------===//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp parallel unified_shared_memory\n\nint unified_shared_memory_heap_map() {\n  OMPVV_INFOMSG(\"Unified shared memory testing - Array on heap\");\n  int errors = 0;\n  \n  int *anArray;\n  int anArrayCopy[N];\n\n  anArray = (int*)malloc(sizeof(int)*N);\n  if( anArray == NULL ) {\n    OMPVV_ERROR(\"Memory was not properly allocated\");\n    OMPVV_RETURN(1);\n  }\n\n  for (int i = 0; i < N; i++) {\n    anArray[i] = i;\n    anArrayCopy[i] = 0;\n  }\n  // Modify in the device\n#pragma omp target map(anArray)\n  {\n    for (int i = 0; i < N; i++) {\n      anArray[i] += 10;\n    }\n  }\n  // Modify again on the host\n  for (int i = 0; i < N; i++) {\n    anArray[i] += 10;\n  }\n\n  // Get the value the device is seeing\n#pragma omp target map(anArray)\n  {\n    for (int i = 0; i < N; i++) {\n      anArrayCopy[i] = anArray[i];\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArray[i] != i + 20);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArrayCopy[i] != i + 20);\n    if (errors) break;\n  }\n\n  free(anArray);\n  return errors;\n}\nint main() {\n  int isOffloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"With no offloading, unified shared memory is guaranteed due to host execution\");\n  int errors = 0;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, unified_shared_memory_heap_map());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_parallel_for_firstprivate.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_firstprivate());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 3028",
        "issue_id": 4,
        "original_code": "//===---- test_target_teams_distribute_parallel_for_firstprivate.c - combined consutrct -===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// This test check for a private variable within a pragma omp target teams distribute \n// parallel for that is initialized from the host through firstprivate clause\n// We use a private variable within a for loop and asign it every iteration\n// hoping that we won't get into data races. We do this multiple times to improve\n// test\n//\n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define SIZE_N 1024\n\nint test_target_teams_distribute_parallel_for_firstprivate() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_firstprivate\");\n  \n  int a[SIZE_N];\n  int b[SIZE_N];\n  int c[SIZE_N];\n  int d[SIZE_N];\n  int firstized = 10;\n  int privatized;\n  int reported_num_teams[SIZE_N];\n  int reported_team_num[SIZE_N];\n  int reported_num_threads[SIZE_N];\n  int errors = 0;\n  int i, j, dev;\n\n  // array initialization\n  for (i = 0; i < SIZE_N; i++) {\n    a[i] = 1;\n    b[i] = i;\n    c[i] = 2*i;\n    d[i] = 0;\n  }\n\n  // check multiple sizes. \n#pragma omp target data map(to: a[0:SIZE_N], b[0:SIZE_N], c[0:SIZE_N])\n  {\n#pragma omp target teams distribute parallel for firstprivate(privatized, firstized, i) num_teams(OMPVV_NUM_TEAMS_DEVICE) num_threads(OMPVV_NUM_THREADS_DEVICE)\n      for (j = 0; j < SIZE_N; ++j) {\n        reported_num_teams[j] = omp_get_num_teams();\n        reported_num_threads[j] = omp_get_num_threads();\n        reported_team_num[j] = omp_get_team_num();\n        privatized = 0;\n        for (i = 0; i < a[j] + b[j]; ++i) {\n          privatized++;\n        }\n        privatized += firstized;\n        d[j] = c[j] * privatized;\n      }\n  }\n\n  // Checking for reported teams and number of threads\n  OMPVV_WARNING_IF(reported_num_teams[0] == 1, \"Number of teams reported was 1, test cannot assert privatization across teams\");\n  // To have a single warning for threds. diff teams could have different number of threads, we warn if all are 1\n  int warning_threads = 0;\n  for (i = 0; i < SIZE_N; i++) {\n    if (reported_num_threads[i] == 1)\n      warning_threads++;\n    if (i > 0) {\n      OMPVV_ERROR_IF(reported_num_teams[i] != reported_num_teams[i-1], \"Discrepancy in the reported number of teams across teams\");\n      if (reported_team_num[i] == reported_team_num[i-1] && reported_num_threads[i] != reported_num_threads[i-1])\n        OMPVV_ERROR(\"Discrepancy in the reported number of threads inside a single team\");\n    }\n  }\n  OMPVV_WARNING_IF(warning_threads == SIZE_N, \"Number of threads was 1 for all teams. test cannot assert privatization across teams\");\n  // Checking for the expected values \n  for (i = 0; i < SIZE_N; i++) {\n    // 10 = initial value of privatized + 1 initial value of a[i] \n    // + i initial value of b[i]\n    OMPVV_TEST_AND_SET(errors, d[i] != (10 + 1 + i)*2*i);\n  }\n\n  return errors;\n}\n\n// Test for OpenMP 4.5 target enter data with if\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_firstprivate());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_teams_distribute_parallel_for_firstprivate.c - combined consutrct -===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// This test check for a private variable within a pragma omp target teams distribute \n// parallel for that is initialized from the host through firstprivate clause\n// We use a private variable within a for loop and asign it every iteration\n// hoping that we won't get into data races. We do this multiple times to improve\n// test\n//\n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define SIZE_N 1024\n\nint test_target_teams_distribute_parallel_for_firstprivate() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_firstprivate\");\n  \n  int a[SIZE_N];\n  int b[SIZE_N];\n  int c[SIZE_N];\n  int d[SIZE_N];\n  int firstized = 10;\n  int privatized;\n  int reported_num_teams[SIZE_N];\n  int reported_team_num[SIZE_N];\n  int reported_num_threads[SIZE_N];\n  int errors = 0;\n  int i, j, dev;\n\n  // array initialization\n  for (i = 0; i < SIZE_N; i++) {\n    a[i] = 1;\n    b[i] = i;\n    c[i] = 2*i;\n    d[i] = 0;\n  }\n\n  // check multiple sizes. \n#pragma omp target data map(to: a[0:SIZE_N], b[0:SIZE_N], c[0:SIZE_N])\n  {\n#pragma omp target teams distribute parallel for firstprivate(privatized, firstized, i) num_teams(OMPVV_NUM_TEAMS_DEVICE) num_threads(OMPVV_NUM_THREADS_DEVICE)\n      for (j = 0; j < SIZE_N; ++j) {\n        reported_num_teams[j] = omp_get_num_teams();\n        reported_num_threads[j] = omp_get_num_threads();\n        reported_team_num[j] = omp_get_team_num();\n        privatized = 0;\n        for (i = 0; i < a[j] + b[j]; ++i) {\n          privatized++;\n        }\n        privatized += firstized;\n        d[j] = c[j] * privatized;\n      }\n  }\n\n  // Checking for reported teams and number of threads\n  OMPVV_WARNING_IF(reported_num_teams[0] == 1, \"Number of teams reported was 1, test cannot assert privatization across teams\");\n  // To have a single warning for threds. diff teams could have different number of threads, we warn if all are 1\n  int warning_threads = 0;\n  for (i = 0; i < SIZE_N; i++) {\n    if (reported_num_threads[i] == 1)\n      warning_threads++;\n    if (i > 0) {\n      OMPVV_ERROR_IF(reported_num_teams[i] != reported_num_teams[i-1], \"Discrepancy in the reported number of teams across teams\");\n      if (reported_team_num[i] == reported_team_num[i-1] && reported_num_threads[i] != reported_num_threads[i-1])\n        OMPVV_ERROR(\"Discrepancy in the reported number of threads inside a single team\");\n    }\n  }\n  OMPVV_WARNING_IF(warning_threads == SIZE_N, \"Number of threads was 1 for all teams. test cannot assert privatization across teams\");\n  // Checking for the expected values \n  for (i = 0; i < SIZE_N; i++) {\n    // 10 = initial value of privatized + 1 initial value of a[i] \n    // + i initial value of b[i]\n    OMPVV_TEST_AND_SET(errors, d[i] != (10 + 1 + i)*2*i);\n  }\n\n  return errors;\n}\n\n// Test for OpenMP 4.5 target enter data with if\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_map_device_pointer.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp atomic\" at position 1883",
        "issue_id": 0,
        "original_code": "//--------------- test_target_map_device_pointer.c ---------------------------//\n// OpenMP API Version 5.2 Nov 2021\n// Pg. 627, line 24\n// This test ensures that--paraphrase of Section 5.8.6--a pointer that is\n// implicitly mapped or explicitely mapped to the device, predetermined to be\n// firstprivate in the device data environment, will retain its original value\n// (attained prior to the target region) and follow the semantics of the\n// firstprivate clause. This is true if a matching mapped list item, as defined\n// in Section 5.8.6, is not found for the pointer. In the test, the pointer p1\n// is initialized with the base array address of arr2. When p1 is implicitly\n// mapped to the device, it should retain the same base array address, as the\n// array itself is not mapped (a matching mapped list item is not found). This\n// check is made in the target region with a mapped integer variable holding the\n// base address of arr2. The pointer p2 is initialized to NULL, and is checked\n// to remain NULL after being initialized on a device. Following the checks, p1\n// is changed to NULL on the device and checked outside of the target region if\n// it was not changed from its initial value of the base address of arr2 (per\n// firstprivate semnatics). p2 is given an arbitrary value for the purpose of\n// ensuring that it too retains its original value after the target region. A\n// defaultmap clause is present on the target construct to explicitely ensure\n// that the default semantics of mapping apply to all mapped (implicit/explicit)\n// pointer types.\n//----------------------------------------------------------------------------//\n#include \"ompvv.h\"\n#include <omp.h>\n#include <stdint.h> //includes intptr_t\n\n#define N 16\n\nint test_target_pointer() {\n  int errors = 0;\n  int arr2[N];\n  int *p1 = &arr2[0];\n  int *p2 = NULL;\n  intptr_t hold_arr2 = (intptr_t)&arr2[0];\n\n  #pragma omp target map(tofrom:errors) map(to:hold_arr2) defaultmap(default:pointer)\n  {\n    OMPVV_TEST_AND_SET(errors, ((intptr_t) p1 != hold_arr2) || (p2 != NULL));\n    \n    p1 = NULL;\n    p2 = (int *) 0x12345;\n  }\n\n  OMPVV_TEST_OFFLOADING_PROBE;\n  OMPVV_TEST_SHARED_ENVIRONMENT_PROBE;\n\n  if (_ompvv_isOffloadingOn && !_ompvv_isSharedEnv){\n    OMPVV_ERROR_IF(errors != 0,\n                   \"At least one pointer did not retain its original value\");\n    OMPVV_ERROR_IF(p1 != &arr2[0],\n                   \"The value of p1 was updated, p1 was not firstprivate\");\n    OMPVV_ERROR_IF(p2 != NULL,\n                   \"The value of p2 was updated, p2 was not firstprivate\");\n    OMPVV_TEST_AND_SET(errors, (p1 != &arr2[0]) || (p2 != NULL))\n  }else{\n    OMPVV_WARNING(\"_ompvv_isOffloadingOn: %i, _ompvv_isSharedEnv: %i, test is invalid\",\n        _ompvv_isOffloadingOn, _ompvv_isSharedEnv)\n  }\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET(errors, test_target_pointer() != 0)\n  OMPVV_REPORT_AND_RETURN(errors);\n  return errors;\n}\n",
        "error_code": "//--------------- test_target_map_device_pointer.c ---------------------------//\n// OpenMP API Version 5.2 Nov 2021\n// Pg. 627, line 24\n// This test ensures that--paraphrase of Section 5.8.6--a pointer that is\n// implicitly mapped or explicitely mapped to the device, predetermined to be\n// firstprivate in the device data environment, will retain its original value\n// (attained prior to the target region) and follow the semantics of the\n// firstprivate clause. This is true if a matching mapped list item, as defined\n// in Section 5.8.6, is not found for the pointer. In the test, the pointer p1\n// is initialized with the base array address of arr2. When p1 is implicitly\n// mapped to the device, it should retain the same base array address, as the\n// array itself is not mapped (a matching mapped list item is not found). This\n// check is made in the target region with a mapped integer variable holding the\n// base address of arr2. The pointer p2 is initialized to NULL, and is checked\n// to remain NULL after being initialized on a device. Following the checks, p1\n// is changed to NULL on the device and checked outside of the target region if\n// it was not changed from its initial value of the base address of arr2 (per\n// firstprivate semnatics). p2 is given an arbitrary value for the purpose of\n// ensuring that it too retains its original value after the target region. A\n// defaultmap clause is present on the target construct to explicitely ensure\n// that the default semantics of mapping apply to all mapped (implicit/explicit)\n// pointer types.\n//----------------------------------------------------------------------------//\n#include \"ompvv.h\"\n#include <omp.h>\n#include <stdint.h> //includes intptr_t\n\n#define N 16\n\nint test_target_pointer() {\n  int errors = 0;\n  int arr2[N];\n  int *p1 = &arr2[0];\n  int *p2 = NULL;\n  intptr_t hold_arr2 = (intptr_t)&arr2[0];\n\n  #pragma omp atomic map(tofrom:errors) map(to:hold_arr2) defaultmap(default:pointer)\n  {\n    OMPVV_TEST_AND_SET(errors, ((intptr_t) p1 != hold_arr2) || (p2 != NULL));\n    \n    p1 = NULL;\n    p2 = (int *) 0x12345;\n  }\n\n  OMPVV_TEST_OFFLOADING_PROBE;\n  OMPVV_TEST_SHARED_ENVIRONMENT_PROBE;\n\n  if (_ompvv_isOffloadingOn && !_ompvv_isSharedEnv){\n    OMPVV_ERROR_IF(errors != 0,\n                   \"At least one pointer did not retain its original value\");\n    OMPVV_ERROR_IF(p1 != &arr2[0],\n                   \"The value of p1 was updated, p1 was not firstprivate\");\n    OMPVV_ERROR_IF(p2 != NULL,\n                   \"The value of p2 was updated, p2 was not firstprivate\");\n    OMPVV_TEST_AND_SET(errors, (p1 != &arr2[0]) || (p2 != NULL))\n  }else{\n    OMPVV_WARNING(\"_ompvv_isOffloadingOn: %i, _ompvv_isSharedEnv: %i, test is invalid\",\n        _ompvv_isOffloadingOn, _ompvv_isSharedEnv)\n  }\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET(errors, test_target_pointer() != 0)\n  OMPVV_REPORT_AND_RETURN(errors);\n  return errors;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_defaultmap_default.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_defaultmap_with_default() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 1975",
        "issue_id": 4,
        "original_code": "//===--- test_target_defaultmap_default.c --------------------------------------------------------------===//\n//\n//  OpenMP API Version 5.0 Nov 2018\n//\n//  This test checks behavior of the defaultmap clause when the specified implicit-behavior  \n//  is default. The variable-categories avaiable for defaultmap are scalar, aggregate, and pointer.\n//  When no mapping is specified, the implicit-behavior of these variable-categories are\n//  firstprivate, tofrom, and firstprivate, respectively. This test specifies the default implicit-behavior \n//  for the three variable-categories and expects the same behavior as when there is no\n//  explicit mapping.\n//\n////===-------------------------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint errors, i;\n\nint test_defaultmap_with_default() {\n   \n   struct test_struct {\n     int s; \n     int S[N]; \n   }; \n\n   int scalar; // scalar \n   int A[N]; // aggregate \n   struct test_struct new_struct; // aggregate\n   int *ptr = NULL; // scalar, pointer\n\n   scalar = 1; \n   new_struct.s = 0;\n\n   for (i = 0; i < N; i++) {\n      A[i] = 0;\n      new_struct.S[i] = 0;\n   }\n\n   #pragma omp target defaultmap(default) \n   {     \n      scalar = 17;    // scalar firstprivate, value not returned\n      A[0] = 5; A[1] = 5; // aggregate array, default is tofrom\n      new_struct.s = 10; new_struct.S[0] = 10; new_struct.S[1] = 10; // aggregate structure, default is tofrom\n      ptr = &A[0]; // Pointer, default is firstprivate\n      ptr[50] = 50; ptr[51] = 51;\n   }\n\n   OMPVV_TEST_AND_SET_VERBOSE(errors, scalar != 1);\n   OMPVV_TEST_AND_SET_VERBOSE(errors, A[0] != 5 || A[1] != 5);\n   OMPVV_TEST_AND_SET_VERBOSE(errors, A[50] != 50 || A[51] != 51);\n   OMPVV_TEST_AND_SET_VERBOSE(errors, new_struct.s != 10);\n   OMPVV_TEST_AND_SET_VERBOSE(errors, new_struct.S[0] != 10);\n\n  return errors;\n}\n\nint main() {\n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_defaultmap_with_default() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}           \n",
        "error_code": "//===--- test_target_defaultmap_default.c --------------------------------------------------------------===//\n//\n//  OpenMP API Version 5.0 Nov 2018\n//\n//  This test checks behavior of the defaultmap clause when the specified implicit-behavior  \n//  is default. The variable-categories avaiable for defaultmap are scalar, aggregate, and pointer.\n//  When no mapping is specified, the implicit-behavior of these variable-categories are\n//  firstprivate, tofrom, and firstprivate, respectively. This test specifies the default implicit-behavior \n//  for the three variable-categories and expects the same behavior as when there is no\n//  explicit mapping.\n//\n////===-------------------------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint errors, i;\n\nint test_defaultmap_with_default() {\n   \n   struct test_struct {\n     int s; \n     int S[N]; \n   }; \n\n   int scalar; // scalar \n   int A[N]; // aggregate \n   struct test_struct new_struct; // aggregate\n   int *ptr = NULL; // scalar, pointer\n\n   scalar = 1; \n   new_struct.s = 0;\n\n   for (i = 0; i < N; i++) {\n      A[i] = 0;\n      new_struct.S[i] = 0;\n   }\n\n   #pragma omp target defaultmap(default) \n   {     \n      scalar = 17;    // scalar firstprivate, value not returned\n      A[0] = 5; A[1] = 5; // aggregate array, default is tofrom\n      new_struct.s = 10; new_struct.S[0] = 10; new_struct.S[1] = 10; // aggregate structure, default is tofrom\n      ptr = &A[0]; // Pointer, default is firstprivate\n      ptr[50] = 50; ptr[51] = 51;\n   }\n\n   OMPVV_TEST_AND_SET_VERBOSE(errors, scalar != 1);\n   OMPVV_TEST_AND_SET_VERBOSE(errors, A[0] != 5 || A[1] != 5);\n   OMPVV_TEST_AND_SET_VERBOSE(errors, A[50] != 50 || A[51] != 51);\n   OMPVV_TEST_AND_SET_VERBOSE(errors, new_struct.s != 10);\n   OMPVV_TEST_AND_SET_VERBOSE(errors, new_struct.S[0] != 10);\n\n  return errors;\n}\n\nint main()            \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_PureVirDestr.cpp",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n      derived *d = new derived(ForBase, ForChild);\n      base *b = d;\n      delete b;\n      Errs = *ForChild;\n    }\" at position 1757",
        "issue_id": 4,
        "original_code": "//===--test_target_PureVirDestr.cpp -------------------------------------===//\n//\n// OpenMP API Version 5.2\n//\n// Description\n// This test case tests the working of the following aspects:\n// 1) Working of \"requires unified_shared_memory\"\n// 2) Testing pure virtual destructor on gpu\n//===----------------------------------------------------------------------===//\n\n#include <iostream>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1024*1024\n\n#pragma omp requires unified_shared_memory\n#pragma omp begin declare target\nclass base {\n  int *x = nullptr;\n  public:\n    int *BaseMem = nullptr;\n    int *ChildMem = nullptr;\n    base(int *ptr1 = nullptr, int *ptr2 = nullptr) {\n      x = new int[N];\n      for (int i = 0; i < N; ++i) {\n        x[i] = 10;\n      }\n    }\n    virtual ~base() = 0;\n};\n\nbase::~base() {\n  delete[] x;\n  if (*ChildMem == 1) {\n    *BaseMem = 1;\n  } else {\n    *BaseMem = -1;\n  }\n}\n\nclass derived: public base {\n  int *y = nullptr;\n  public:\n    derived(int *ptr1 = nullptr, int *ptr2 = nullptr) {\n      BaseMem = ptr1;\n      *BaseMem = 0;\n      ChildMem = ptr2;\n      *ChildMem = 0;\n      y = new int[N];\n      for (int i = 0; i < N; ++i) {\n        y[i] = 20;\n      }\n    }\n    ~derived() {\n      delete[] y;\n      *ChildMem = 1;\n    }\n};\n#pragma omp end declare target\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int *ForChild = nullptr, *ForBase = nullptr, errors = 0;\n  int TotGpus = omp_get_num_devices(), Errs;\n  for (int dev = 0; dev < TotGpus; ++dev) {\n    Errs = -17;\n    ForChild = reinterpret_cast<int*>(omp_target_alloc(sizeof(int), dev));\n    ForBase = reinterpret_cast<int*>(omp_target_alloc(sizeof(int), dev));\n\n#pragma omp target device(dev) map(tofrom: Errs)\n    {\n      derived *d = new derived(ForBase, ForChild);\n      base *b = d;\n      delete b;\n      Errs = *ForChild;\n    }\n    omp_target_free(ForChild, dev);\n    omp_target_free(ForBase, dev);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (Errs != 1));\n  }\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--test_target_PureVirDestr.cpp -------------------------------------===//\n//\n// OpenMP API Version 5.2\n//\n// Description\n// This test case tests the working of the following aspects:\n// 1) Working of \"requires unified_shared_memory\"\n// 2) Testing pure virtual destructor on gpu\n//===----------------------------------------------------------------------===//\n\n#include <iostream>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1024*1024\n\n#pragma omp requires unified_shared_memory\n#pragma omp begin declare target\nclass base {\n  int *x = nullptr;\n  public:\n    int *BaseMem = nullptr;\n    int *ChildMem = nullptr;\n    base(int *ptr1 = nullptr, int *ptr2 = nullptr) {\n      x = new int[N];\n      for (int i = 0; i < N; ++i) {\n        x[i] = 10;\n      }\n    }\n    virtual ~base() = 0;\n};\n\nbase::~base() {\n  delete[] x;\n  if (*ChildMem == 1) {\n    *BaseMem = 1;\n  } else {\n    *BaseMem = -1;\n  }\n}\n\nclass derived: public base {\n  int *y = nullptr;\n  public:\n    derived(int *ptr1 = nullptr, int *ptr2 = nullptr) {\n      BaseMem = ptr1;\n      *BaseMem = 0;\n      ChildMem = ptr2;\n      *ChildMem = 0;\n      y = new int[N];\n      for (int i = 0; i < N; ++i) {\n        y[i] = 20;\n      }\n    }\n    ~derived() {\n      delete[] y;\n      *ChildMem = 1;\n    }\n};\n#pragma omp end declare target\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int *ForChild = nullptr, *ForBase = nullptr, errors = 0;\n  int TotGpus = omp_get_num_devices(), Errs;\n  for (int dev = 0; dev < TotGpus; ++dev) {\n    Errs = -17;\n    ForChild = reinterpret_cast<int*>(omp_target_alloc(sizeof(int), dev));\n    ForBase = reinterpret_cast<int*>(omp_target_alloc(sizeof(int), dev));\n\n#pragma omp target device(dev) map(tofrom: Errs)\n    \n    omp_target_free(ForChild, dev);\n    omp_target_free(ForBase, dev);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (Errs != 1));\n  }\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_declare_target_enter.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1329",
        "issue_id": 1,
        "original_code": "//===---- test_declare_target_enter.c -------------------------------------===//\n// \n// OpenMP API Version 5.2 \n//\n// The enter clause was added as a synonym for the to clause on the declare target directive.\n// If the device_type clause is not specified, the behavior is as if the device_type clause \n// appears with any specified.\n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\nint errors = 0;\n\nint a[N], b[N], c[N];  \nint i = 0;\n#pragma omp declare target enter(a,b,c,i)\n\nvoid update() { \n  for (i = 0; i < N; i++) {\n    a[i] += 1;\n    b[i] += 2;\n    c[i] += 3;\n  }\n}\n\n#pragma omp declare target enter(update)  \n\nint test_declare_target_enter() { \n  \n  #pragma omp target update to(a,b,c) \n  #pragma omp target \n  {\n    update();\n  }\n  #pragma omp target update from( a, b, c)\n  \n\n  for (i = 0; i < N; i++) { //check array values on host\n    if ( a[i] != i + 1 || b[i] != i + 3 || c[i] != i + 5) {\n      errors++;  \n    } \n  }\n\n  //on host\n  update();\n\n  for (i = 0; i < N; i++) { //check array values on host\n    if ( a[i] != i + 2 || b[i] != i + 5 || c[i] != i + 8) {\n      errors++;\n    }\n  }\n  \n  return errors;\n}\n\nint main () {\n  \n  //initalize arrays on host\n  for (i = 0; i < N; i++) {\n    a[i] = i;\n    b[i] = i + 1;\n    c[i] = i + 2;\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_declare_target_enter());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}  \n",
        "error_code": "//===---- test_declare_target_enter.c -------------------------------------===//\n// \n// OpenMP API Version 5.2 \n//\n// The enter clause was added as a synonym for the to clause on the declare target directive.\n// If the device_type clause is not specified, the behavior is as if the device_type clause \n// appears with any specified.\n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\nint errors = 0;\n\nint a[N], b[N], c[N];  \nint i = 0;\n#pragma omp declare target enter(a,b,c,i)\n\nvoid update() { \n  for (i = 0; i < N; i++) {\n    a[i] += 1;\n    b[i] += 2;\n    c[i] += 3;\n  }\n}\n\n#pragma omp declare target enter(update)  \n\nint test_declare_target_enter() { \n  \n  #pragma omp target update to(a,b,c) \n  #pragma omp target \n  {\n    update();\n  }\n  #pragma omp target update from( a, b, c)\n  \n\n  for (i = 0; i < N; i++) { //check array values on host\n    if ( a[i] != i + 1 || b[i] != i + 3 || c[i] != i + 5) {\n      errors++;  \n    } \n  }\n\n  //on host\n  update();\n\n  for (i = 0; i < N; i++) { //check array values on host\n    if ( a[i] != i + 2 || b[i] != i + 5 || c[i] != i + 8) {\n      errors++;\n    }\n  }\n  \n  return errors;\n}\n\nint main () {\n  \n  //initalize arrays on host\n  for (i = 0; i < N; i++) \n    a[i] = i;\n    b[i] = i + 1;\n    c[i] = i + 2;\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_declare_target_enter());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}  \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_error_message_at_execution.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp parallel\" with directive \"#pragma omp for\" at position 659",
        "issue_id": 0,
        "original_code": "//===--- test_error_message_at_execution.c ----------------------------===//\n//\n//  OpenMP API Version 5.1 Aug 2021\n//\n//  Test uses error directive with message clause to print a message,\n//  if error condition is reached then \"runtime error!\" is printed,\n//  otherwise is simply used to print a message. \n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\nint errors, i;\n\nint test_error_message() {\n    i = 0;\n    OMPVV_INFOMSG(\"If successful, test should print an \\\"error message success\\\" at the beginning of the test\");\n    #pragma omp parallel\n    {\n        #pragma omp single\n        {\n            #pragma omp error severity(warning) at(execution) message(\"error message success\")\n            i+=5;\n        }\n    }\n    OMPVV_TEST_AND_SET_VERBOSE(errors, i != 5);\n    OMPVV_ERROR_IF(errors > 0, \"Error directive caused execution error\");\n    return errors;\n}\n\nint main() {\n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_error_message() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_error_message_at_execution.c ----------------------------===//\n//\n//  OpenMP API Version 5.1 Aug 2021\n//\n//  Test uses error directive with message clause to print a message,\n//  if error condition is reached then \"runtime error!\" is printed,\n//  otherwise is simply used to print a message. \n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\nint errors, i;\n\nint test_error_message() {\n    i = 0;\n    OMPVV_INFOMSG(\"If successful, test should print an \\\"error message success\\\" at the beginning of the test\");\n    #pragma omp for\n    {\n        #pragma omp single\n        {\n            #pragma omp error severity(warning) at(execution) message(\"error message success\")\n            i+=5;\n        }\n    }\n    OMPVV_TEST_AND_SET_VERBOSE(errors, i != 5);\n    OMPVV_ERROR_IF(errors > 0, \"Error directive caused execution error\");\n    return errors;\n}\n\nint main() {\n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_error_message() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_parallel_master_taskloop_simd_device.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_parallel_master_taskloop_simd_device());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 1598",
        "issue_id": 4,
        "original_code": "//===--- test_parallel_master_taskloop_simd_device.c ------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the parallel master taskloop simd directive. The test\n// performs simple operations on an int array which are then checked for\n// correctness. This test checks the construct in a target context.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_parallel_master_taskloop_simd_device() {\n  OMPVV_INFOMSG(\"test_parallel_master_taskloop_simd_device\");\n  int errors = 0;\n  int x[N];\n  int y[N];\n  int z[N];\n  int num_threads = -1;\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 1;\n    y[i] = i + 1;\n    z[i] = 2*(i + 1);\n  }\n\n#pragma omp target map(tofrom: x, num_threads) map(to: y, z)\n  {\n#pragma omp parallel master taskloop simd num_threads(OMPVV_NUM_THREADS_DEVICE) shared(x, y, z, num_threads)\n    for (int i = 0; i < N; i++) {\n      x[i] += y[i]*z[i];\n      if (i == 0) {\n         num_threads = omp_get_num_threads();\n      }\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != 1 + (y[i]*z[i]));\n  }\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of parallel master with taskloop can't be guaranteed.\");\n  OMPVV_ERROR_IF(num_threads < 1, \"Test returned an invalid number of threads.\");\n  OMPVV_INFOMSG(\"This test does not guarantee vector instructions were generated for the simd construct.\");\n\n  return errors;\n}\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_parallel_master_taskloop_simd_device());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_parallel_master_taskloop_simd_device.c ------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the parallel master taskloop simd directive. The test\n// performs simple operations on an int array which are then checked for\n// correctness. This test checks the construct in a target context.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_parallel_master_taskloop_simd_device() {\n  OMPVV_INFOMSG(\"test_parallel_master_taskloop_simd_device\");\n  int errors = 0;\n  int x[N];\n  int y[N];\n  int z[N];\n  int num_threads = -1;\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 1;\n    y[i] = i + 1;\n    z[i] = 2*(i + 1);\n  }\n\n#pragma omp target map(tofrom: x, num_threads) map(to: y, z)\n  {\n#pragma omp parallel master taskloop simd num_threads(OMPVV_NUM_THREADS_DEVICE) shared(x, y, z, num_threads)\n    for (int i = 0; i < N; i++) {\n      x[i] += y[i]*z[i];\n      if (i == 0) {\n         num_threads = omp_get_num_threads();\n      }\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != 1 + (y[i]*z[i]));\n  }\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of parallel master with taskloop can't be guaranteed.\");\n  OMPVV_ERROR_IF(num_threads < 1, \"Test returned an invalid number of threads.\");\n  OMPVV_INFOMSG(\"This test does not guarantee vector instructions were generated for the simd construct.\");\n\n  return errors;\n}\n\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_is_device_ptr.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 1053",
        "issue_id": 2,
        "original_code": "//===------test_target_teams_is_device_ptr.c--------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Description:\n// This is a basic test to demonstrate\n// clause with target teams construct.\n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n/**\n  This is a basic test to demonstrate \n  clause with target teams construct.\n*/\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  int device_data[N], host_data[N];\n  for (int i = 0; i < N; i++) {\n    device_data[i] = i;\n    host_data[i] = 0;\n  }\n#pragma omp target data map(to: device_data[0:N])\n  {\n    int *dev_ptr;\n#pragma omp target data use_device_addr(device_data)\n    {\n      dev_ptr = device_data;\n    }\n#pragma omp target teams map(from: host_data[0:N]) is_device_ptr(dev_ptr)\n    {\n      for (int i = 0; i < N; i++) {\n        host_data[i] = dev_ptr[i];\n      }\n    }\n  } // end target data\n  // checking results\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, host_data[i] != device_data[i]);\n  }\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===------test_target_teams_is_device_ptr.c--------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Description:\n// This is a basic test to demonstrate\n// clause with target teams construct.\n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n/**\n  This is a basic test to demonstrate \n  clause with target teams construct.\n*/\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  int device_data[N], host_data[N];\n  for (int i = 0; i < N; i++) {\n    device_data[i] = i;\n    host_data[i] = 0;\n  }\n#pragma omp target data map(to: device_data[0:N])\n  {\n    int *dev_ptr;\n#pragma omp target data use_device_addr(device_data)\n    {\n      dev_ptr = device_data;\n    }\n#pragma omp target teams map(from: host_data[0:N]) is_device_ptr(dev_ptr)\n    {\n      for (int i = 0; i < N; i++) {\n        host_data[i] = dev_ptr[i];\n      }\n    }\n  } // end target data\n  // checking results\n  for (int i = 0;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, host_data[i] != device_data[i]);\n  }\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/offloading_success.cpp",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 147",
        "issue_id": 2,
        "original_code": "#include <stdio.h>\n#include <omp.h>\n\nint main(void) {\n  int isHost = 0;\n\n#pragma omp target map(from: isHost)\n  { isHost = omp_is_initial_device(); }\n\n  if (isHost < 0) {\n    printf(\"Runtime error, isHost=%d\\n\", isHost);\n  }\n\n  // CHECK: Target region executed on the device\n  printf(\"Target region executed on the %s\\n\", isHost ? \"host\" : \"device\");\n\n  return isHost;\n}\n",
        "error_code": "#include <stdio.h>\n#include <omp.h>\n\nint main(void) {\n  int isHost = 0;\n\n#pragma omp target map(from: isHost)\n  { isHost = omp_is_initial_device();yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1; }\n\n  if (isHost < 0) {\n    printf(\"Runtime error, isHost=%d\\n\", isHost);\n  }\n\n  // CHECK: Target region executed on the device\n  printf(\"Target region executed on the %s\\n\", isHost ? \"host\" : \"device\");\n\n  return isHost;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_taskloop_simd_shared.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1045",
        "issue_id": 1,
        "original_code": "//===--test_taskloop_simd_shared.c ----------------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// Test uses a value within a taskloop & an atomic construct to update the value of\n// s_val. The taskloop then uses SIMD to update the A array using the values from the \n// other 2 arrays & s_val.\n//\n////===--------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint taskloop_simd_shared() {\n\n  int errors = 0;\n  int i;\n  int A[N], B[N], C[N];\n  for(int i = 0; i < N; i++){\n    A[i] = 1;\n    B[i] = 2;\n    C[i] = 3;\n  }\n\n#pragma omp parallel\n  {\n    int s_val=4;\n    #pragma omp single\n    #pragma omp taskloop simd shared(s_val)\n      for (i = 0; i < N; i++){\n        A[i] *= B[i] * C[i] * s_val;\n      }\n    #pragma omp barrier\n    #pragma omp single\n    for(int i = 0; i < N; i++){\n      OMPVV_TEST_AND_SET_VERBOSE(errors, A[i] != B[i] * C[i] * s_val);\n    }\n  } //end parallel\n  return errors;\n\n}\n\nint main() {\n    int errors = 0;\n    OMPVV_TEST_AND_SET_VERBOSE(errors, taskloop_simd_shared());\n    OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--test_taskloop_simd_shared.c ----------------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// Test uses a value within a taskloop & an atomic construct to update the value of\n// s_val. The taskloop then uses SIMD to update the A array using the values from the \n// other 2 arrays & s_val.\n//\n////===--------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint taskloop_simd_shared() {\n\n  int errors = 0;\n  int i;\n  int A[N], B[N], C[N];\n  for(int i = 0; i < N; i++){\n    A[i] = 1;\n    B[i] = 2;\n    C[i] = 3;\n  }\n\n#pragma omp parallel\n  {\n    int s_val=4;\n    #pragma omp single\n    #pragma omp taskloop simd shared(s_val)\n      for (i = 0; i < N; i++){\n        A[i] *= B[i] * C[i] * s_val;\n      }\n    #pragma omp barrier\n    #pragma omp single\n    for(int i = 0; i < N; i++){\n      OMPVV_TEST_AND_SET_VERBOSE(errors, A[i] != B[i] * C[i] * s_val);\n    }\n  } //end parallel\n  return errors;\n\n}\n\nint main() \n    int errors = 0;\n    OMPVV_TEST_AND_SET_VERBOSE(errors, taskloop_simd_shared());\n    OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_loop_reduction_and_device.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp single\" at position 1296",
        "issue_id": 0,
        "original_code": "//===--- test_loop_reduction_and_device.c -----------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the reduction clause on a loop directive, testing that the\n// variable in the reduction clause is properly reduced using the and\n// operator. This test checks the above in a target context.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n#define THRESHOLD 512\n\nint test_and() {\n  char a[N];\n  // The below calculation is meant to ensure about half the arrays we will\n  // test will come out to true under the 'and' operator, and the rest false.\n  // For the and operator, a test array that comes out true requires every\n  // entry to be false, which is why this margin is so close to 100%.\n  double false_margin = pow(exp(1), log(.5)/N);\n  int errors = 0;\n  int num_threads[N];\n  int tested_true = 0;\n  int tested_false = 0;\n  int itr_count = 0;\n  srand(1);\n\n  while ((!tested_true || !tested_false) && (itr_count < THRESHOLD)) {\n    for (int x = 0; x < N; ++x) {\n      a[x] = (rand() / (double) (RAND_MAX) < false_margin);\n      num_threads[x] = -x;\n    }\n\n    char result = 1;\n    char host_result = 1;\n\n#pragma omp target parallel num_threads(OMPVV_NUM_THREADS_DEVICE) map(tofrom: result, a, num_threads)\n    {\n#pragma omp loop reduction(&&:result)\n      for (int x = 0; x < N; ++x) {\n        result = result && a[x];\n      }\n#pragma omp for\n      for (int x = 0; x < N; ++x) {\n        num_threads[x] = omp_get_num_threads();\n      }\n    }\n\n    for (int x = 0; x < N; ++x) {\n      host_result = host_result && a[x];\n    }\n\n    if (itr_count == 0) {\n      for (int x = 1; x < N; ++x) {\n        OMPVV_WARNING_IF(num_threads[x - 1] != num_threads[x], \"Test reported differing numbers of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n      }\n      OMPVV_WARNING_IF(num_threads[0] == 1, \"Test operated with one thread.  Reduction clause cannot be tested.\");\n      OMPVV_WARNING_IF(num_threads[0] <= 0, \"Test reported invalid number of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n    }\n\n    OMPVV_TEST_AND_SET_VERBOSE(errors, host_result != result);\n    OMPVV_ERROR_IF(host_result != result, \"Actual result is %d but expected result is %d.\", result, host_result);\n\n    if (host_result) {\n      tested_true = 1;\n    } else {\n      tested_false = 1;\n    }\n\n    if (host_result != result) {\n      break;\n    }\n\n    itr_count++;\n  }\n\n  OMPVV_WARNING_IF(!tested_true, \"Did not test a case in which final result was true.\");\n  OMPVV_WARNING_IF(!tested_false, \"Did not test a case in which final result was false.\");\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_and() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n",
        "error_code": "//===--- test_loop_reduction_and_device.c -----------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the reduction clause on a loop directive, testing that the\n// variable in the reduction clause is properly reduced using the and\n// operator. This test checks the above in a target context.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n#define THRESHOLD 512\n\nint test_and() {\n  char a[N];\n  // The below calculation is meant to ensure about half the arrays we will\n  // test will come out to true under the 'and' operator, and the rest false.\n  // For the and operator, a test array that comes out true requires every\n  // entry to be false, which is why this margin is so close to 100%.\n  double false_margin = pow(exp(1), log(.5)/N);\n  int errors = 0;\n  int num_threads[N];\n  int tested_true = 0;\n  int tested_false = 0;\n  int itr_count = 0;\n  srand(1);\n\n  while ((!tested_true || !tested_false) && (itr_count < THRESHOLD)) {\n    for (int x = 0; x < N; ++x) {\n      a[x] = (rand() / (double) (RAND_MAX) < false_margin);\n      num_threads[x] = -x;\n    }\n\n    char result = 1;\n    char host_result = 1;\n\n#pragma omp single parallel num_threads(OMPVV_NUM_THREADS_DEVICE) map(tofrom: result, a, num_threads)\n    {\n#pragma omp loop reduction(&&:result)\n      for (int x = 0; x < N; ++x) {\n        result = result && a[x];\n      }\n#pragma omp for\n      for (int x = 0; x < N; ++x) {\n        num_threads[x] = omp_get_num_threads();\n      }\n    }\n\n    for (int x = 0; x < N; ++x) {\n      host_result = host_result && a[x];\n    }\n\n    if (itr_count == 0) {\n      for (int x = 1; x < N; ++x) {\n        OMPVV_WARNING_IF(num_threads[x - 1] != num_threads[x], \"Test reported differing numbers of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n      }\n      OMPVV_WARNING_IF(num_threads[0] == 1, \"Test operated with one thread.  Reduction clause cannot be tested.\");\n      OMPVV_WARNING_IF(num_threads[0] <= 0, \"Test reported invalid number of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n    }\n\n    OMPVV_TEST_AND_SET_VERBOSE(errors, host_result != result);\n    OMPVV_ERROR_IF(host_result != result, \"Actual result is %d but expected result is %d.\", result, host_result);\n\n    if (host_result) {\n      tested_true = 1;\n    } else {\n      tested_false = 1;\n    }\n\n    if (host_result != result) {\n      break;\n    }\n\n    itr_count++;\n  }\n\n  OMPVV_WARNING_IF(!tested_true, \"Did not test a case in which final result was true.\");\n  OMPVV_WARNING_IF(!tested_false, \"Did not test a case in which final result was false.\");\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_and() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_depends.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 2136",
        "issue_id": 1,
        "original_code": "//===----- test_target_depends.c -----------------------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks functionality of the depend clause with various dependence types\n// and map-type-modifiers. Two arrays are initalized on the host and updated within\n// several target regions that all utilize the depend clause with varying specified\n// dependence types. At the end, array values are verified on the host to ensure that \n// synchronization did not result in data races and values were mapped back to device.\n//\n////===-------------------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nint test_all_dependencies() {\n  OMPVV_INFOMSG(\"test_all_dependencies\");\n\n  int errors = 0;\n  int dep_1[N], dep_2[N];\n\n  // Initialize dep_1 and dep_2\n  for (int i = 0; i < N; ++i) {\n    dep_1[i] = 0;\n    dep_2[i] = 0;\n  }\n\n#pragma omp target depend(out: dep_1) map(tofrom: dep_1[0:N])\n  {\n    for (int i = 0; i < N; i++) {\n      dep_1[i] = 1;\n    }\n  } // end of omp target \n\n#pragma omp target depend(out: dep_2) map(tofrom: dep_2[0:N])\n  {\n    for (int i = 0; i < N; i++) {\n      dep_2[i] = 1;\n    }\n  } // end of omp target \n\n  #pragma omp task depend(inout: dep_1) depend(inout: dep_2) \\\n              shared(dep_1, dep_2)\n  {\n    for (int i = 0; i < N; ++i) {\n      dep_1[i]++;\n      dep_2[i]++;\n    }\n  }\n\n  #pragma omp target depend(inout: dep_1) depend(inout: dep_2) \\\n              map(tofrom: dep_1[0:N])  map(tofrom: dep_2[0:N])\n  {\n    for (int i = 0; i < N; i++) {\n      dep_1[i]++;\n      dep_2[i]++;\n    }\n  } // end of omp target \n\n  #pragma omp target depend(in: dep_1) depend(in: dep_2) \\\n              map(tofrom: dep_1[0:N])  map(tofrom: dep_2[0:N])\n  {\n    for (int i = 0; i < N; i++) {\n      dep_1[i]++;\n      dep_2[i]++;\n    }\n  } // end of omp target \n\n  #pragma omp taskwait\n  \n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, dep_1[i] != 4);\n    OMPVV_TEST_AND_SET(errors, dep_2[i] != 4);    \n  }\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_all_dependencies());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n",
        "error_code": "//===----- test_target_depends.c -----------------------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks functionality of the depend clause with various dependence types\n// and map-type-modifiers. Two arrays are initalized on the host and updated within\n// several target regions that all utilize the depend clause with varying specified\n// dependence types. At the end, array values are verified on the host to ensure that \n// synchronization did not result in data races and values were mapped back to device.\n//\n////===-------------------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nint test_all_dependencies() {\n  OMPVV_INFOMSG(\"test_all_dependencies\");\n\n  int errors = 0;\n  int dep_1[N], dep_2[N];\n\n  // Initialize dep_1 and dep_2\n  for (int i = 0; i < N; ++i) {\n    dep_1[i] = 0;\n    dep_2[i] = 0;\n  }\n\n#pragma omp target depend(out: dep_1) map(tofrom: dep_1[0:N])\n  {\n    for (int i = 0; i < N; i++) {\n      dep_1[i] = 1;\n    }\n  } // end of omp target \n\n#pragma omp target depend(out: dep_2) map(tofrom: dep_2[0:N])\n  {\n    for (int i = 0; i < N; i++) {\n      dep_2[i] = 1;\n    }\n  } // end of omp target \n\n  #pragma omp task depend(inout: dep_1) depend(inout: dep_2) \\\n              shared(dep_1, dep_2)\n  {\n    for (int i = 0; i < N; ++i) {\n      dep_1[i]++;\n      dep_2[i]++;\n    }\n  }\n\n  #pragma omp target depend(inout: dep_1) depend(inout: dep_2) \\\n              map(tofrom: dep_1[0:N])  map(tofrom: dep_2[0:N])\n  {\n    for (int i = 0; i < N; i++) {\n      dep_1[i]++;\n      dep_2[i]++;\n    }\n  } // end of omp target \n\n  #pragma omp target depend(in: dep_1) depend(in: dep_2) \\\n              map(tofrom: dep_1[0:N])  map(tofrom: dep_2[0:N])\n  {\n    for (int i = 0; i < N; i++) {\n      dep_1[i]++;\n      dep_2[i]++;\n    }\n  } // end of omp target \n\n  #pragma omp taskwait\n  \n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, dep_1[i] != 4);\n    OMPVV_TEST_AND_SET(errors, dep_2[i] != 4);    \n  }\n  return errors;\n}\n\nint main() \n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_all_dependencies());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_memcpy_rect_async_depobj.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 2857",
        "issue_id": 1,
        "original_code": "//===--- test_target_memcpy_rect_async_depobj.c ----------------------------===//\n//\n//  OpenMP API Version 5.1 Nov 2020\n//\n//  Inspired from OpenMP 5.1 Examples Doc, 5.16.4 & 8.9\n//  This test utilizes the omp_target_memcpy_rect_async construct to\n//  allocate 2D memory on the device asynchronously. The construct\n//  uses 'obj' for dependency, so that memory is only copied once\n//  the variable listed in the depend clause is changed.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 5\n#define M 10\n\nint errors, i, j;\n\nint test_target_memcpy_async_depobj() {\n\n    const size_t volume[2] = {5, 10};\n    const size_t offsets[2] = {0, 0};\n    const size_t dimensions[2] = {N, M};\n\n    int h, t;\n    errors = 0;\n    h = omp_get_initial_device();\n    t = omp_get_default_device();\n\n    double hostRect[N][M]; // 5x10 2D array\n    double *devRect = (double *)omp_target_alloc(sizeof(double)*N*M, t);\n\n    OMPVV_ERROR_IF(devRect == NULL, \"Error: omp_target_alloc() failed\");\n    if (devRect == NULL)\n      return ++errors;\n\n    for(i = 0; i < N; i++){             //each index is set to number of their row\n        for (j = 0; j < M; j++){\n            hostRect[i][j] = i + j;\n        }\n    }\n    omp_depend_t obj;\n    #pragma omp depobj(obj) depend(inout: devRect)\n    omp_depend_t obj_arr[1] = {obj};\n\n    /* copy to device memory */\n    omp_target_memcpy_rect_async(devRect, hostRect, \n                                sizeof(double), 2, \n                                volume, //5 by 10\n                                offsets,          offsets,\n                                dimensions, dimensions,\n                                t,          h,\n                                1,          obj_arr);\n\n    #pragma omp taskwait depend(depobj: obj)\n    #pragma omp target is_device_ptr(devRect) device(t) depend(depobj: obj)\n    {\n        for(i = 0; i < N; i++){\n            for (j = 0; j < M; j++){\n                devRect[i*M + j] = devRect[i*M + j]*2; // initialize data\n            }\n        }\n    }\n\n    /* copy to host memory */\n    omp_target_memcpy_rect_async(hostRect, devRect,\n                                sizeof(double), 2,\n                                volume, //5 by 10\n                                offsets,          offsets,\n                                dimensions, dimensions,\n                                h,          t,\n                                1,          obj_arr);\n\n    #pragma omp taskwait depend(depobj: obj)\n    for(i = 0; i < N; i++){\n        for(j = 0; j < N; j++){\n            OMPVV_TEST_AND_SET(errors, hostRect[i][j]!=(i+j)*2);\n        }\n    }\n    // free resources\n    omp_target_free(devRect, t);\n    #pragma omp depobj(obj) destroy\n    return errors;\n}\n\nint main() {\n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_memcpy_async_depobj() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_memcpy_rect_async_depobj.c ----------------------------===//\n//\n//  OpenMP API Version 5.1 Nov 2020\n//\n//  Inspired from OpenMP 5.1 Examples Doc, 5.16.4 & 8.9\n//  This test utilizes the omp_target_memcpy_rect_async construct to\n//  allocate 2D memory on the device asynchronously. The construct\n//  uses 'obj' for dependency, so that memory is only copied once\n//  the variable listed in the depend clause is changed.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 5\n#define M 10\n\nint errors, i, j;\n\nint test_target_memcpy_async_depobj() {\n\n    const size_t volume[2] = {5, 10};\n    const size_t offsets[2] = {0, 0};\n    const size_t dimensions[2] = {N, M};\n\n    int h, t;\n    errors = 0;\n    h = omp_get_initial_device();\n    t = omp_get_default_device();\n\n    double hostRect[N][M]; // 5x10 2D array\n    double *devRect = (double *)omp_target_alloc(sizeof(double)*N*M, t);\n\n    OMPVV_ERROR_IF(devRect == NULL, \"Error: omp_target_alloc() failed\");\n    if (devRect == NULL)\n      return ++errors;\n\n    for(i = 0; i < N; i++){             //each index is set to number of their row\n        for (j = 0; j < M; j++){\n            hostRect[i][j] = i + j;\n        }\n    }\n    omp_depend_t obj;\n    #pragma omp depobj(obj) depend(inout: devRect)\n    omp_depend_t obj_arr[1] = {obj};\n\n    /* copy to device memory */\n    omp_target_memcpy_rect_async(devRect, hostRect, \n                                sizeof(double), 2, \n                                volume, //5 by 10\n                                offsets,          offsets,\n                                dimensions, dimensions,\n                                t,          h,\n                                1,          obj_arr);\n\n    #pragma omp taskwait depend(depobj: obj)\n    #pragma omp target is_device_ptr(devRect) device(t) depend(depobj: obj)\n    {\n        for(i = 0; i < N; i++){\n            for (j = 0; j < M; j++){\n                devRect[i*M + j] = devRect[i*M + j]*2; // initialize data\n            }\n        }\n    }\n\n    /* copy to host memory */\n    omp_target_memcpy_rect_async(hostRect, devRect,\n                                sizeof(double), 2,\n                                volume, //5 by 10\n                                offsets,          offsets,\n                                dimensions, dimensions,\n                                h,          t,\n                                1,          obj_arr);\n\n    #pragma omp taskwait depend(depobj: obj)\n    for(i = 0; i < N; i++){\n        for(j = 0; j < N; j++){\n            OMPVV_TEST_AND_SET(errors, hostRect[i][j]!=(i+j)*2);\n        }\n    }\n    // free resources\n    omp_target_free(devRect, t);\n    #pragma omp depobj(obj) destroy\n    return errors;\n}\n\nint main() \n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_memcpy_async_depobj() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_enter_data_devices.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET(errors, test_set_default_dev());\n  OMPVV_TEST_AND_SET(errors, test_device());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 4760",
        "issue_id": 4,
        "original_code": "//===--- test_target_enter_data_devices.c ---------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n// \n// This file tests the target enter data directive when the device clause is\n// specified, and also when the device is set by omp_set_default_device().\n// The first function test_set_default_dev() does not specify the device\n// clause, but instead uses omp_set_default_device() to set device.\n// The second function test_device() uses the device clause on the target\n// enter data directive.\n// \n//===----------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nint test_set_default_dev() {\n\n  OMPVV_INFOMSG(\"test_set_default_dev\");\n\n  // Get number of devices\n  int num_dev = omp_get_num_devices();\n  OMPVV_INFOMSG(\"num_devices: %d\", num_dev);\n\n  int def_dev = omp_get_default_device();\n  OMPVV_INFOMSG(\"initial device: %d\", omp_get_initial_device());\n  OMPVV_INFOMSG(\"default device: %d\", def_dev);\n\n  // Allocate num_devices + 1 to avoid zero-sized VLA if num_devices == 0\n  int sum[num_dev+1], errors = 0, isHost[num_dev+1];\n  int h_matrix[num_dev+1][N], h_matrix_copy[num_dev+1][N];\n\n  // Initialize all the matrices\n  for (int dev = 0; dev < num_dev; ++dev) {\n    sum[dev] = 0;\n    isHost[dev] = 0;\n  }\n\n  for (int dev = 0; dev < num_dev; ++dev) {\n    omp_set_default_device(dev);\n    \n    // unstructured mapping\n    {\n#pragma omp target enter data map(alloc: h_matrix[dev][0:N]) // omp_target_alloc sets ref to infinity. alloc: has effect only if ref is zero (page 217 line 21 - Version 4.5 November 2015)\n      printf(\"\"); // forcing the compiler to not moving out of the scope\n    }\n#pragma omp target map(alloc: h_matrix[dev][0:N]) map(tofrom: isHost[dev:1]) // map(alloc: ) to avoid target to map the entire matrix h_matrix[dev][:]\n    {\n      isHost[dev] = omp_is_initial_device();\n      for (int i = 0; i < N; ++i) {\n        h_matrix[dev][i] = dev;\n      }\n    }\n  // Since we don't do enter exit data we copy the values from the device\n#pragma omp target map(from: h_matrix_copy[dev][0:N]) map(alloc: h_matrix[dev][0:N])\n    {\n      for (int i = 0; i < N; ++i) {\n        h_matrix_copy[dev][i] = h_matrix[dev][i];\n      }\n    }\n}\n\n  // checking results\n  for (int dev = 0; dev < num_dev; ++dev) {\n    OMPVV_INFOMSG(\"device %d ran on the %s\", dev, (isHost[dev])? \"host\" : \"device\");\n    for (int i = 0; i < N; ++i)\n      sum[dev] += h_matrix_copy[dev][i];\n    OMPVV_TEST_AND_SET(errors, (dev * N != sum[dev]));\n  }\n\n  omp_set_default_device(def_dev);\n\n  // Avoiding memory leaks this is outside of testing area\n  // Iterate over all the devices and delete the memory\n  for (int dev = 0; dev < num_dev; ++dev) {\n#pragma omp target exit data map(delete: h_matrix[dev][0:N]) device(dev)\n  }\n\n  return errors;\n}\n\nint test_device() {\n\n  OMPVV_INFOMSG(\"test_device\");\n\n  // Get number of devices\n  int num_dev = omp_get_num_devices();\n  OMPVV_INFOMSG(\"num_devices: %d\", num_dev);\n\n  OMPVV_INFOMSG(\"initial device: %d\", omp_get_initial_device());\n  OMPVV_INFOMSG(\"default device: %d\", omp_get_default_device());\n\n  // Allocate num_devices + 1 to avoid zero-sized VLA if num_devices == 0\n  int sum[num_dev+1], errors = 0, isHost[num_dev+1];\n  int h_matrix[num_dev+1][N], h_matrix_copy[num_dev+1][N];\n\n  // Initialize all the matrices\n  for (int dev = 0; dev < num_dev; ++dev) {\n    sum[dev] = 0;\n    isHost[dev] = 0;\n  }\n  for (int dev = 0; dev < num_dev; ++dev) {\n    // unstructured mapping\n    {\n#pragma omp target enter data map(alloc: h_matrix[dev][0:N]) device(dev)\n        printf(\"\");\n    }\n    // operation\n#pragma omp target map(alloc: h_matrix[dev][0:N]) map(tofrom: isHost[dev:1]) device(dev) // map(alloc: ) to avoid target to map the entire matrix h_matrix[dev][:]\n    {\n      isHost[dev] = omp_is_initial_device();\n      for (int i = 0; i < N; ++i)\n        h_matrix[dev][i] = dev;\n    }\n  // Since we don't do enter exit data we copy the values from the device\n#pragma omp target map(from: h_matrix_copy[dev][0:N])  map(alloc: h_matrix[dev][0:N]) device(dev)\n    {\n      for (int i = 0; i < N; ++i) {\n        h_matrix_copy[dev][i] = h_matrix[dev][i];\n      }\n    }\n  }\n\n  // checking results\n  for (int dev = 0; dev < num_dev; ++dev) {\n    OMPVV_INFOMSG(\"device %d ran on the %s\", dev, (isHost[dev])? \"host\" : \"device\");\n    for (int i = 0; i < N; ++i)\n      sum[dev] += h_matrix_copy[dev][i];\n    OMPVV_TEST_AND_SET(errors, (dev * N != sum[dev]));\n  }\n\n  // Avoiding memory leaks\n  // Iterate over all the devices and delete the memory\n  for (int dev = 0; dev < num_dev; ++dev) {\n#pragma omp target exit data map(delete: h_matrix[dev][0:N]) device(dev)\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET(errors, test_set_default_dev());\n  OMPVV_TEST_AND_SET(errors, test_device());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_enter_data_devices.c ---------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n// \n// This file tests the target enter data directive when the device clause is\n// specified, and also when the device is set by omp_set_default_device().\n// The first function test_set_default_dev() does not specify the device\n// clause, but instead uses omp_set_default_device() to set device.\n// The second function test_device() uses the device clause on the target\n// enter data directive.\n// \n//===----------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nint test_set_default_dev() {\n\n  OMPVV_INFOMSG(\"test_set_default_dev\");\n\n  // Get number of devices\n  int num_dev = omp_get_num_devices();\n  OMPVV_INFOMSG(\"num_devices: %d\", num_dev);\n\n  int def_dev = omp_get_default_device();\n  OMPVV_INFOMSG(\"initial device: %d\", omp_get_initial_device());\n  OMPVV_INFOMSG(\"default device: %d\", def_dev);\n\n  // Allocate num_devices + 1 to avoid zero-sized VLA if num_devices == 0\n  int sum[num_dev+1], errors = 0, isHost[num_dev+1];\n  int h_matrix[num_dev+1][N], h_matrix_copy[num_dev+1][N];\n\n  // Initialize all the matrices\n  for (int dev = 0; dev < num_dev; ++dev) {\n    sum[dev] = 0;\n    isHost[dev] = 0;\n  }\n\n  for (int dev = 0; dev < num_dev; ++dev) {\n    omp_set_default_device(dev);\n    \n    // unstructured mapping\n    {\n#pragma omp target enter data map(alloc: h_matrix[dev][0:N]) // omp_target_alloc sets ref to infinity. alloc: has effect only if ref is zero (page 217 line 21 - Version 4.5 November 2015)\n      printf(\"\"); // forcing the compiler to not moving out of the scope\n    }\n#pragma omp target map(alloc: h_matrix[dev][0:N]) map(tofrom: isHost[dev:1]) // map(alloc: ) to avoid target to map the entire matrix h_matrix[dev][:]\n    {\n      isHost[dev] = omp_is_initial_device();\n      for (int i = 0; i < N; ++i) {\n        h_matrix[dev][i] = dev;\n      }\n    }\n  // Since we don't do enter exit data we copy the values from the device\n#pragma omp target map(from: h_matrix_copy[dev][0:N]) map(alloc: h_matrix[dev][0:N])\n    {\n      for (int i = 0; i < N; ++i) {\n        h_matrix_copy[dev][i] = h_matrix[dev][i];\n      }\n    }\n}\n\n  // checking results\n  for (int dev = 0; dev < num_dev; ++dev) {\n    OMPVV_INFOMSG(\"device %d ran on the %s\", dev, (isHost[dev])? \"host\" : \"device\");\n    for (int i = 0; i < N; ++i)\n      sum[dev] += h_matrix_copy[dev][i];\n    OMPVV_TEST_AND_SET(errors, (dev * N != sum[dev]));\n  }\n\n  omp_set_default_device(def_dev);\n\n  // Avoiding memory leaks this is outside of testing area\n  // Iterate over all the devices and delete the memory\n  for (int dev = 0; dev < num_dev; ++dev) {\n#pragma omp target exit data map(delete: h_matrix[dev][0:N]) device(dev)\n  }\n\n  return errors;\n}\n\nint test_device() {\n\n  OMPVV_INFOMSG(\"test_device\");\n\n  // Get number of devices\n  int num_dev = omp_get_num_devices();\n  OMPVV_INFOMSG(\"num_devices: %d\", num_dev);\n\n  OMPVV_INFOMSG(\"initial device: %d\", omp_get_initial_device());\n  OMPVV_INFOMSG(\"default device: %d\", omp_get_default_device());\n\n  // Allocate num_devices + 1 to avoid zero-sized VLA if num_devices == 0\n  int sum[num_dev+1], errors = 0, isHost[num_dev+1];\n  int h_matrix[num_dev+1][N], h_matrix_copy[num_dev+1][N];\n\n  // Initialize all the matrices\n  for (int dev = 0; dev < num_dev; ++dev) {\n    sum[dev] = 0;\n    isHost[dev] = 0;\n  }\n  for (int dev = 0; dev < num_dev; ++dev) {\n    // unstructured mapping\n    {\n#pragma omp target enter data map(alloc: h_matrix[dev][0:N]) device(dev)\n        printf(\"\");\n    }\n    // operation\n#pragma omp target map(alloc: h_matrix[dev][0:N]) map(tofrom: isHost[dev:1]) device(dev) // map(alloc: ) to avoid target to map the entire matrix h_matrix[dev][:]\n    {\n      isHost[dev] = omp_is_initial_device();\n      for (int i = 0; i < N; ++i)\n        h_matrix[dev][i] = dev;\n    }\n  // Since we don't do enter exit data we copy the values from the device\n#pragma omp target map(from: h_matrix_copy[dev][0:N])  map(alloc: h_matrix[dev][0:N]) device(dev)\n    {\n      for (int i = 0; i < N; ++i) {\n        h_matrix_copy[dev][i] = h_matrix[dev][i];\n      }\n    }\n  }\n\n  // checking results\n  for (int dev = 0; dev < num_dev; ++dev) {\n    OMPVV_INFOMSG(\"device %d ran on the %s\", dev, (isHost[dev])? \"host\" : \"device\");\n    for (int i = 0; i < N; ++i)\n      sum[dev] += h_matrix_copy[dev][i];\n    OMPVV_TEST_AND_SET(errors, (dev * N != sum[dev]));\n  }\n\n  // Avoiding memory leaks\n  // Iterate over all the devices and delete the memory\n  for (int dev = 0; dev < num_dev; ++dev) {\n#pragma omp target exit data map(delete: h_matrix[dev][0:N]) device(dev)\n  }\n\n  return errors;\n}\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/mmm_target_parallel_for_simd.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===--- mmm_target_parallel_for_simd.c--- MM on a target parallel for simd--===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n//  DESCRIPTION:  \n//    OpenMp Example - Matrix Multiply - C Version\n//    Demonstrates a matrix multiply using OpenMP. Threads share row iterations\n//  \n//  Last modified by Jose M Monsalve Diaz, December 25, 2019\n//\n////===----------------------------------------------------------------------===//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/time.h>\n#include \"ompvv.h\"\n\n#define rowA 500        \n#define colA 500        \n#define colB 500        \n\n\nint main (int argc, char *argv[]) \n{\n  OMPVV_TEST_OFFLOADING;\n  int tid, nthreads, i, j, k;\n  int\t*a = (int*) malloc(sizeof(int) * rowA * colA);           // matrix A to be multiplied\n  int\t*b = (int*) malloc(sizeof(int) * colA * colB);           // matrix B to be multiplied \n  int\t*c = (int*) malloc(sizeof(int) * rowA * colB);           // result matrix C \n\n  // Initialize matrices\n  for (i = 0; i < rowA; i++)\n    for (j = 0; j < colA; j++)\n      a[i*rowA+j] = 10; // i+j;\n  for (i = 0; i < colA; i++)\n    for (j = 0; j < colB; j++)\n      b[i*colA+j] = 50; //i*j;\n  for (i = 0; i < rowA; i++)\n    for (j = 0; j < colB; j++)\n      c[i*rowA+j] = 0;\n\n  int DimA = rowA*colA;\n  int DimB = colB*colA;\n  int DimC = rowA*colA;\n\n#pragma omp target map(to: a[0:DimA], b[0:DimB]) map(from: c[0:DimC])\n  {\n#pragma omp teams distribute parallel for simd collapse(2) private(k)\n    for (i = 0; i < rowA; i++)\n      for(j = 0; j < colB; j++)\n        for(k = 0; k < colA; k++)\n          c[i*rowA+j] = a[i*rowA+j] * b[k*colA+j];\n  }//end-target\n\n  // Check results\n  int error = 0;\n  for (i = 0; i < rowA; i++)\n  {\n    for (j = 0; j < colB; j++) {\n      OMPVV_TEST_AND_SET(error, 500 != c[i*rowA+j]);\n      OMPVV_ERROR_IF(500 != c[i*rowA+j], \"Error: [%d][%d] should be 500 is %d\",i,j,c[i*rowA+j]);\n    }\n  }\n  free(a);\n  free(b);\n  free(c);\n\n  OMPVV_REPORT_AND_RETURN(error);\n}\n\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_update_to_from_map_lvalue_func.cpp",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp declare\" with directive \"#pragma omp master\" at position 518",
        "issue_id": 0,
        "original_code": "//===----------- test_target_update_to_from_map_lvalue_func.cpp ----------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test evaluates the target update directive using to and from clauses, \n// supporting various lvalue expressions, such as functions that return references.\n//  Additionally, it examines the map clause and its handling of lvalue expressions. \n//===--------------------------------------------------------------------------===//\n#include <omp.h>\n#include <iostream>\n#include \"ompvv.h\"\n\n#pragma omp declare target\n//Global Variable\nint var;\n\n//Function that will return a reference to the variable var\nint& returnRef() {\n\treturn var;\n}\n#pragma omp end declare target\n\n\nint test_target_update(){\n\tint errors = 0;\n\tint before_value;\n\tint after_value;\n\n\t// Initialize var\n\tvar = -1;\n\n\t//Set var to the initial value of before_value from the device\n\t#pragma omp target map(from: before_value) map(returnRef())\n\t{\n\t\tbefore_value = returnRef();\n\t}\n\n\t//Update the value of var on the host\n\tvar = 1;\n\n\t//Update the device with the new value of var from the host\n\t#pragma omp target update to(returnRef())\n\n\t//Set after_value with the update value of var and update var on the device\n\t#pragma omp target map(from: after_value)\n\t{\n\t\tafter_value = returnRef();\n\t\treturnRef() = 2;\n\t}\n\n\t//Update the host with the new value of var form the device\n\t#pragma omp target update from(returnRef())\n\n\t//Check for Errors\n\tif (var != 2){\n\t\terrors++;\n\t}\n\tif (before_value != -1){\n\t\terrors++;\n\t}\n\tif (after_value != 1){\n\t\terrors++;\n\t}\n\n\tOMPVV_TEST_AND_SET(errors, errors != 0);\n\n\treturn errors;\n}\n\n\tint main() {\n\t\tOMPVV_TEST_OFFLOADING;\n\t\tint errors = 0;\n\n\t\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_target_update() != 0);\n\t\tOMPVV_REPORT_AND_RETURN(errors);\n\t}\n",
        "error_code": "//===----------- test_target_update_to_from_map_lvalue_func.cpp ----------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test evaluates the target update directive using to and from clauses, \n// supporting various lvalue expressions, such as functions that return references.\n//  Additionally, it examines the map clause and its handling of lvalue expressions. \n//===--------------------------------------------------------------------------===//\n#include <omp.h>\n#include <iostream>\n#include \"ompvv.h\"\n\n#pragma omp master target\n//Global Variable\nint var;\n\n//Function that will return a reference to the variable var\nint& returnRef() {\n\treturn var;\n}\n#pragma omp end declare target\n\n\nint test_target_update(){\n\tint errors = 0;\n\tint before_value;\n\tint after_value;\n\n\t// Initialize var\n\tvar = -1;\n\n\t//Set var to the initial value of before_value from the device\n\t#pragma omp target map(from: before_value) map(returnRef())\n\t{\n\t\tbefore_value = returnRef();\n\t}\n\n\t//Update the value of var on the host\n\tvar = 1;\n\n\t//Update the device with the new value of var from the host\n\t#pragma omp target update to(returnRef())\n\n\t//Set after_value with the update value of var and update var on the device\n\t#pragma omp target map(from: after_value)\n\t{\n\t\tafter_value = returnRef();\n\t\treturnRef() = 2;\n\t}\n\n\t//Update the host with the new value of var form the device\n\t#pragma omp target update from(returnRef())\n\n\t//Check for Errors\n\tif (var != 2){\n\t\terrors++;\n\t}\n\tif (before_value != -1){\n\t\terrors++;\n\t}\n\tif (after_value != 1){\n\t\terrors++;\n\t}\n\n\tOMPVV_TEST_AND_SET(errors, errors != 0);\n\n\treturn errors;\n}\n\n\tint main() {\n\t\tOMPVV_TEST_OFFLOADING;\n\t\tint errors = 0;\n\n\t\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_target_update() != 0);\n\t\tOMPVV_REPORT_AND_RETURN(errors);\n\t}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_depend_lvalue_ternary.cpp",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===--- test_target_depend_lvalue_ternary.cpp -------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the depend clause on task generating constructs are extended to\n// allow any lvalue such as ternary operators.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <iostream>\n#include <cstdlib>\n#include \"ompvv.h\"\n\nint test_task_depend_ternary() {\n\tint errors = 0;\n\tint a = 1;\n\tint b = 0;\n\tint c = -1;\n\tint value = 0;\n\n\t#pragma omp target parallel map(to:a,b,c) map(from: value)\n\t{\n\t\t#pragma omp single\n\t\t{\n\t\t\t// Task should run first and set b = 1\n\t\t\t#pragma omp task depend(out: (a > b) ? b : c) shared(a,b)\n\t\t\t{\n\t\t\t\tif ( a > b) {\n\t\t\t\t\tb = 1;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tc = 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Task should compute (a > b) ? b : c -> this will return\n\t\t\t// false. It should set value = c => -1\n\t\t\t#pragma omp task depend(in: (a > b) ? b : c) shared(a, b)\n\t\t\t{\n\t\t\t\tvalue = (a > b) ? b : c;\n\t\t\t}\n\n\t\t\t#pragma omp taskwait\n\t\t}\n\t}\n\t\n\t// Check to make sure value was correctly set to -1\n\tOMPVV_TEST_AND_SET(errors, value != -1);\n\treturn errors;\n}\n\nint main() {\n\tOMPVV_TEST_OFFLOADING;\n\tint errors = 0;\n\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_task_depend_ternary() != 0);\n\n\tOMPVV_REPORT_AND_RETURN(errors);\n\n\treturn errors;\n}\n\n",
        "error_code": "#include <iostream>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nfloat wkeosgatsi = 58;\nint misfuxuyca = 245;\nbyte fdriiyvmai = 226;\ndouble gdqctihiwx = 241;\nlong azyebtlkjx = 28;\nfloat cdzqntoxpr = 175;\nshort tgzopdpskh = 57;\ndouble fepffsaruj = 180;\nint blxmlkuufc = 161;\nlong qosqyyqfnx = 140;\nshort bbstvttzla = 176;\ndouble amjddupczo = 229;\nfloat ptsaiwchap = 200;\nlong zniwzosqbs = 217;\nlong rkvlxhlwwx = 14;\nint kkmslujtti = 142;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    std::cout << \"Sum of \" << num1 << \" and \" << num2 << \" is \" << sum << std::endl;\n    return 0;\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_declare_target_enter_device_type_any.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1503",
        "issue_id": 1,
        "original_code": "//===---- test_declare_target_enter_device_type_any.c -------------------------------------===//\n// \n// OpenMP API Version 5.2 \n//\n// The enter clause was added as a synonym for the to clause on the declare target directive.\n// The device_type clause specifies if a version of the procedure or variable should be made\n//  available. If any is specified then both host device and non-host device versions of the \n// procedure or variable are made available.\n\n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\nint errors = 0;\n\n#pragma omp declare target \nint a[N], b[N], c[N];  \nint i = 0;\n#pragma omp end declare target\n\nvoid update() { \n  for (i = 0; i < N; i++) {\n    a[i] += 1;\n    b[i] += 2;\n    c[i] += 3;\n  }\n}\n\n#pragma omp declare target enter(update) device_type(any) \n\nint test_declare_target_enter_device_type_any() { \n  \n  #pragma omp target update to(a,b,c) \n  #pragma omp target \n  {\n    update();\n  }\n  #pragma omp target update from( a, b, c)\n  \n\n  for (i = 0; i < N; i++) { //check array values on host\n    if ( a[i] != i + 1 || b[i] != i + 3 || c[i] != i + 5) {\n      errors++;  \n    } \n  }\n\n  //on host\n  update();\n\n  for (i = 0; i < N; i++) { //check array values on host\n    if ( a[i] != i + 2 || b[i] != i + 5 || c[i] != i + 8) {\n      errors++;\n    }\n  }\n  \n  return errors;\n}\n\nint main () {\n  \n  //initalize arrays on host\n  for (i = 0; i < N; i++) {\n    a[i] = i;\n    b[i] = i + 1;\n    c[i] = i + 2;\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_declare_target_enter_device_type_any());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}  \n",
        "error_code": "//===---- test_declare_target_enter_device_type_any.c -------------------------------------===//\n// \n// OpenMP API Version 5.2 \n//\n// The enter clause was added as a synonym for the to clause on the declare target directive.\n// The device_type clause specifies if a version of the procedure or variable should be made\n//  available. If any is specified then both host device and non-host device versions of the \n// procedure or variable are made available.\n\n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\nint errors = 0;\n\n#pragma omp declare target \nint a[N], b[N], c[N];  \nint i = 0;\n#pragma omp end declare target\n\nvoid update() { \n  for (i = 0; i < N; i++) {\n    a[i] += 1;\n    b[i] += 2;\n    c[i] += 3;\n  }\n}\n\n#pragma omp declare target enter(update) device_type(any) \n\nint test_declare_target_enter_device_type_any() { \n  \n  #pragma omp target update to(a,b,c) \n  #pragma omp target \n  {\n    update();\n  }\n  #pragma omp target update from( a, b, c)\n  \n\n  for (i = 0; i < N; i++) { //check array values on host\n    if ( a[i] != i + 1 || b[i] != i + 3 || c[i] != i + 5) {\n      errors++;  \n    } \n  }\n\n  //on host\n  update();\n\n  for (i = 0; i < N; i++) { //check array values on host\n    if ( a[i] != i + 2 || b[i] != i + 5 || c[i] != i + 8) {\n      errors++;\n    }\n  }\n  \n  return errors;\n}\n\nint main () {\n  \n  //initalize arrays on host\n  for (i = 0; i < N; i++) \n    a[i] = i;\n    b[i] = i + 1;\n    c[i] = i + 2;\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_declare_target_enter_device_type_any());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}  \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_dispatch_device.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 1074",
        "issue_id": 2,
        "original_code": "//===---- test_dispatch_device.c -----------------------------------------===//\n// \n// OpenMP API Version 5.1\n//\n// Uses dispatch construct as context for variant directive. Uses device\n// clause on last device. While default device could be used, this would\n// not change omp_get_default_device, so using the last device is more\n// exhaustive. \n//\n// Inspired by \"OpenMP 5.1 Features: The Dispatch Construct\" video:\n// https://www.youtube.com/watch?v=ruugaX95gIs\n// \n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include \"ompvv.h\"\n#include <stdbool.h>\n\n#define N 1024\n\nint errors;\nint i = 0;\nint arr[N];\nvoid add_dev(int *arr);\n\n#pragma omp declare variant(add_dev) match(construct={dispatch}) \nvoid add(int *arr){\n   #pragma omp parallel for\n   for (int i = 0; i < N; i++){ // Base function adds 1 to array values\n      arr[i] = arr[i]+1;\n   }\n}\n\nvoid add_dev(int *arr){\n   for (int i = 0; i < N; i++){\n      arr[i] = arr[i]+2+omp_get_default_device(); // Variant function adds at least 2 to array values\n   }\n}\n\nint test_wrapper() { \n   errors = 0;\n   int device_num = omp_get_num_devices() ? omp_get_num_devices()-1 : 0;  // last available device. \n\n   add(arr);\n   for(i = 0; i < N; i++){\n      OMPVV_TEST_AND_SET(errors, arr[i] != 1);\n   } \n   OMPVV_ERROR_IF(errors > 0, \"Base function is not working properly\");\n\n   #pragma omp dispatch device(device_num)\n      add(arr);\n   \n   for(i = 0; i < N; i++){\n      OMPVV_TEST_AND_SET(errors, arr[i] != 2 && arr[i] != 3+device_num);\n   }\n   OMPVV_INFOMSG_IF(errors > 0 || arr[0] == 2,\n                   \"Dispatch is either not working or was not considered\"\n                   \" by the implementation as part of the context selector.\");\n\n   return errors;\n}\n\nint main () {\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_wrapper());\n   OMPVV_REPORT_AND_RETURN(errors);\n}  \n",
        "error_code": "//===---- test_dispatch_device.c -----------------------------------------===//\n// \n// OpenMP API Version 5.1\n//\n// Uses dispatch construct as context for variant directive. Uses device\n// clause on last device. While default device could be used, this would\n// not change omp_get_default_device, so using the last device is more\n// exhaustive. \n//\n// Inspired by \"OpenMP 5.1 Features: The Dispatch Construct\" video:\n// https://www.youtube.com/watch?v=ruugaX95gIs\n// \n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include \"ompvv.h\"\n#include <stdbool.h>\n\n#define N 1024\n\nint errors;\nint i = 0;\nint arr[N];\nvoid add_dev(int *arr);\n\n#pragma omp declare variant(add_dev) match(construct={dispatch}) \nvoid add(int *arr){\n   #pragma omp parallel for\n   for (int i = 0; i < N; i++){ // Base function adds 1 to array values\n      arr[i] = arr[i]+1;\n   }\n}\n\nvoid add_dev(int *arr){\n   for (int i = 0; i < N; i++){\n      arr[i] = arr[i]+2+omp_get_default_device();yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1; // Variant function adds at least 2 to array values\n   }\n}\n\nint test_wrapper() { \n   errors = 0;\n   int device_num = omp_get_num_devices() ? omp_get_num_devices()-1 : 0;  // last available device. \n\n   add(arr);\n   for(i = 0; i < N; i++){\n      OMPVV_TEST_AND_SET(errors, arr[i] != 1);\n   } \n   OMPVV_ERROR_IF(errors > 0, \"Base function is not working properly\");\n\n   #pragma omp dispatch device(device_num)\n      add(arr);\n   \n   for(i = 0; i < N; i++){\n      OMPVV_TEST_AND_SET(errors, arr[i] != 2 && arr[i] != 3+device_num);\n   }\n   OMPVV_INFOMSG_IF(errors > 0 || arr[0] == 2,\n                   \"Dispatch is either not working or was not considered\"\n                   \" by the implementation as part of the context selector.\");\n\n   return errors;\n}\n\nint main () {\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_wrapper());\n   OMPVV_REPORT_AND_RETURN(errors);\n}  \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/gemv_target_teams_dist_par_for.cpp",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp single\" at position 963",
        "issue_id": 0,
        "original_code": "//===-- gemv_target_teams_dist_par_for.cpp - GEMV using combined construct--===!\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// Taken from the suggestions of the QMCPack team. This test uses the combined\n// construct target teams distribute parallel for\n//!===----------------------------------------------------------------------===!\n#include <chrono>\n#include <string>\n#include <cmath>\n#include \"ompvv.h\"\n#include \"omp.h\"\n\n#define N 8192\n\nclass Timer\n{\n  const std::chrono::time_point<std::chrono::system_clock> start;\n  const std::string name;\n\npublic:\n  Timer(const std::string& name_in): start(std::chrono::system_clock::now()), name(name_in) {};\n  ~Timer()\n  {\n    auto end = std::chrono::system_clock::now();\n    OMPVV_INFOMSG(\"Function %s takes %lf us \",name.c_str(), std::chrono::duration_cast<std::chrono::duration<double, std::micro>>(end - start).count());\n  }\n};\n\ntemplate <typename T>\nvoid gemv(int n, T alpha, const T*  A, const T*  V, T*  Vout)\n{\n  #pragma omp target teams distribute parallel for map(to:A[:n*n], V[:n]) map(from:Vout[:n])\n  for(int row=0; row<n; row++)\n  {\n    T sum = T(0);\n    const T * A_row = A+row*n;\n    for(int col=0; col<n; col++) {\n      sum += A_row[col]*V[col];\n    }\n    Vout[row] = sum*alpha;\n  }\n}\n\ntemplate <class T>\nT* allocate(size_t n)\n{\n  T* ptr = new T[n];\n  std::fill_n(ptr, n, T(1));\n  return ptr;\n}\n\ntemplate <class T>\nvoid deallocate(T* ptr, size_t n)\n{\n  delete[] ptr;\n}\n\nint main()\n{\n  OMPVV_TEST_OFFLOADING;\n  auto* A = allocate<float>(N*N);\n  auto* V = allocate<float>(N);\n  auto* Vout = allocate<float>(N);\n  int errors = 0;\n\n  {\n    Timer local(\"GEMV\");\n    gemv(N, 1.0f, A, V, Vout);\n  }\n\n  for(int i=0; i<N; i++)\n  {\n    OMPVV_TEST_AND_SET(errors, std::abs(Vout[i]-N) > 0.0001);\n    OMPVV_ERROR_IF(std::abs(Vout[i]-N) > 0.0001, \"Error for Vout[%d] = %f, Should be %d\", i, Vout[i], N);\n  }\n\n  deallocate(A, N*N);\n  deallocate(V, N);\n  deallocate(Vout, N);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===-- gemv_target_teams_dist_par_for.cpp - GEMV using combined construct--===!\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// Taken from the suggestions of the QMCPack team. This test uses the combined\n// construct target teams distribute parallel for\n//!===----------------------------------------------------------------------===!\n#include <chrono>\n#include <string>\n#include <cmath>\n#include \"ompvv.h\"\n#include \"omp.h\"\n\n#define N 8192\n\nclass Timer\n{\n  const std::chrono::time_point<std::chrono::system_clock> start;\n  const std::string name;\n\npublic:\n  Timer(const std::string& name_in): start(std::chrono::system_clock::now()), name(name_in) {};\n  ~Timer()\n  {\n    auto end = std::chrono::system_clock::now();\n    OMPVV_INFOMSG(\"Function %s takes %lf us \",name.c_str(), std::chrono::duration_cast<std::chrono::duration<double, std::micro>>(end - start).count());\n  }\n};\n\ntemplate <typename T>\nvoid gemv(int n, T alpha, const T*  A, const T*  V, T*  Vout)\n{\n  #pragma omp single teams distribute parallel for map(to:A[:n*n], V[:n]) map(from:Vout[:n])\n  for(int row=0; row<n; row++)\n  {\n    T sum = T(0);\n    const T * A_row = A+row*n;\n    for(int col=0; col<n; col++) {\n      sum += A_row[col]*V[col];\n    }\n    Vout[row] = sum*alpha;\n  }\n}\n\ntemplate <class T>\nT* allocate(size_t n)\n{\n  T* ptr = new T[n];\n  std::fill_n(ptr, n, T(1));\n  return ptr;\n}\n\ntemplate <class T>\nvoid deallocate(T* ptr, size_t n)\n{\n  delete[] ptr;\n}\n\nint main()\n{\n  OMPVV_TEST_OFFLOADING;\n  auto* A = allocate<float>(N*N);\n  auto* V = allocate<float>(N);\n  auto* Vout = allocate<float>(N);\n  int errors = 0;\n\n  {\n    Timer local(\"GEMV\");\n    gemv(N, 1.0f, A, V, Vout);\n  }\n\n  for(int i=0; i<N; i++)\n  {\n    OMPVV_TEST_AND_SET(errors, std::abs(Vout[i]-N) > 0.0001);\n    OMPVV_ERROR_IF(std::abs(Vout[i]-N) > 0.0001, \"Error for Vout[%d] = %f, Should be %d\", i, Vout[i], N);\n  }\n\n  deallocate(A, N*N);\n  deallocate(V, N);\n  deallocate(Vout, N);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_declare_target_device_type_host.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n    a[i] = 0;\n    b[i] = 0;\n    c[i] = 0;\n  }\" at position 1489",
        "issue_id": 4,
        "original_code": "//===---- test_declare_target_device_type_host.c  ----------------------------------===//\n// \n// OpenMP API Version 5.0 \n//\n// The declare target directive specifies that variables, functions(C,C++ and Fortran),\n// and subroutines (Fortran) are mapped to a device. If a device_type\n// clause is present on the contained declare target directive, then its argument \n// determines which versions are made available. If device_type(host) is present \n// only a host version of the procedure is made available. \n// \n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\nint errors = 0;\n\n#pragma omp declare target\nint a[N], b[N], c[N];  \nint i = 0;\n#pragma omp end declare target\n\nvoid update() { \n  for (i = 0; i < N; i++) {\n    a[i] += 1;\n    b[i] += 2;\n    c[i] += 3;\n  }\n}\n\n#pragma omp declare target to(update) device_type(host) \n\nint test_declare_target_device_type_host() { \n\n\n  #pragma omp target update to(a,b,c)\n  #pragma omp target   \n  {\n    for (i = 0; i < N; i++) {\n      a[i] += i;\n      b[i] += 2 * i;\n      c[i] += 3 * i;\n    }\n  }\n  #pragma omp target update from( a, b, c)\n\n  //on host\n  update();\n\n  for (i = 0; i < N; i++) { //check array values on host\n    if ( a[i] != i + 1 || b[i] != 2 * i + 2 || c[i] != 3 * i + 3 ) {\n      errors++;\n    }\n   \n  }\n  return errors;\n}\n\nint main () {\n  \n  //initalize arrays on host\n  for (i = 0; i < N; i++) {\n    a[i] = 0;\n    b[i] = 0;\n    c[i] = 0;\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_declare_target_device_type_host());\n  OMPVV_REPORT_AND_RETURN(errors);\n}  \n",
        "error_code": "//===---- test_declare_target_device_type_host.c  ----------------------------------===//\n// \n// OpenMP API Version 5.0 \n//\n// The declare target directive specifies that variables, functions(C,C++ and Fortran),\n// and subroutines (Fortran) are mapped to a device. If a device_type\n// clause is present on the contained declare target directive, then its argument \n// determines which versions are made available. If device_type(host) is present \n// only a host version of the procedure is made available. \n// \n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\nint errors = 0;\n\n#pragma omp declare target\nint a[N], b[N], c[N];  \nint i = 0;\n#pragma omp end declare target\n\nvoid update() { \n  for (i = 0; i < N; i++) {\n    a[i] += 1;\n    b[i] += 2;\n    c[i] += 3;\n  }\n}\n\n#pragma omp declare target to(update) device_type(host) \n\nint test_declare_target_device_type_host() { \n\n\n  #pragma omp target update to(a,b,c)\n  #pragma omp target   \n  {\n    for (i = 0; i < N; i++) {\n      a[i] += i;\n      b[i] += 2 * i;\n      c[i] += 3 * i;\n    }\n  }\n  #pragma omp target update from( a, b, c)\n\n  //on host\n  update();\n\n  for (i = 0; i < N; i++) { //check array values on host\n    if ( a[i] != i + 1 || b[i] != 2 * i + 2 || c[i] != 3 * i + 3 ) {\n      errors++;\n    }\n   \n  }\n  return errors;\n}\n\nint main () {\n  \n  //initalize arrays on host\n  for (i = 0; i < N; i++) \n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_declare_target_device_type_host());\n  OMPVV_REPORT_AND_RETURN(errors);\n}  \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_taskgroup_task_reduction.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp taskgroup\" with directive \"#pragma omp flush\" at position 654",
        "issue_id": 0,
        "original_code": "//===--- test_taskgroup_task_reduction.c ------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the taskgroup construct with the task_reduction clause.\n// It uses a linked list data structure which is then traversed and reduced\n// over by a taskgroup. This test is based on a OpenMP 5.0 official example.\n//\n////===----------------------------------------------------------------------===//\n#include <stdlib.h>\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 128\n\ntypedef struct node_tag {\n  int val;\n  struct node_tag *next;\n} node_t;\n\nint linked_list_sum(node_t *p)\n{\n  int result = 0;\n#pragma omp taskgroup task_reduction(+: result)\n  {\n    node_t* temp = p;\n    while(temp != 0) {\n#pragma omp task in_reduction(+: result)\n      result += temp->val;\n      temp = temp->next;\n    }\n  }\n  return result;\n}\n\nint seq_linked_list_sum(node_t *p)\n{\n  int result = 0;\n  node_t* temp = p;\n  while(temp != 0) {\n    result += temp->val;\n    temp = temp->next;\n  }\n  return result;\n}\n\n\nint main(int argc, char *argv[]) {\n  int errors = 0, result = -1;\n  node_t* root = (node_t*) malloc(sizeof(node_t));\n  root->val = 1;\n\n  node_t* temp = root;\n\n  for(int i = 2; i <= N; ++i) {\n    temp->next = (node_t*) malloc(sizeof(node_t));\n    temp = temp->next;\n    temp->val = i;\n  }\n\n  temp->next = 0;\n\n#pragma omp parallel shared(result) num_threads(OMPVV_NUM_THREADS_HOST)\n#pragma omp single\n  {\n    result = linked_list_sum(root);\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != seq_linked_list_sum(root));\n\n  while (root) {\n    temp = root;\n    root = root->next;\n    free(temp);\n  }\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_taskgroup_task_reduction.c ------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the taskgroup construct with the task_reduction clause.\n// It uses a linked list data structure which is then traversed and reduced\n// over by a taskgroup. This test is based on a OpenMP 5.0 official example.\n//\n////===----------------------------------------------------------------------===//\n#include <stdlib.h>\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 128\n\ntypedef struct node_tag {\n  int val;\n  struct node_tag *next;\n} node_t;\n\nint linked_list_sum(node_t *p)\n{\n  int result = 0;\n#pragma omp flush task_reduction(+: result)\n  {\n    node_t* temp = p;\n    while(temp != 0) {\n#pragma omp task in_reduction(+: result)\n      result += temp->val;\n      temp = temp->next;\n    }\n  }\n  return result;\n}\n\nint seq_linked_list_sum(node_t *p)\n{\n  int result = 0;\n  node_t* temp = p;\n  while(temp != 0) {\n    result += temp->val;\n    temp = temp->next;\n  }\n  return result;\n}\n\n\nint main(int argc, char *argv[]) {\n  int errors = 0, result = -1;\n  node_t* root = (node_t*) malloc(sizeof(node_t));\n  root->val = 1;\n\n  node_t* temp = root;\n\n  for(int i = 2; i <= N; ++i) {\n    temp->next = (node_t*) malloc(sizeof(node_t));\n    temp = temp->next;\n    temp->val = i;\n  }\n\n  temp->next = 0;\n\n#pragma omp parallel shared(result) num_threads(OMPVV_NUM_THREADS_HOST)\n#pragma omp single\n  {\n    result = linked_list_sum(root);\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != seq_linked_list_sum(root));\n\n  while (root) {\n    temp = root;\n    root = root->next;\n    free(temp);\n  }\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_loop_unroll.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1452",
        "issue_id": 1,
        "original_code": "//===--- test_loop_unroll.c -----------------------------------------------===//\n//\n// OpenMP API Version 5.1 August 2021 \n//\n// This test checks the behavior of the 5.1 unroll construct (2.11.9.2 in 5.1 spec). \n// \"The unroll construct fully or partially unrolls a loop\", which is more of a code generation\n// compiler feature. \n// This test specifically checks the unroll construct without any clause, in which the compiler decides\n// how the loop unrolls.\n// Referenced 5.1 Example Doc 7.2 \n////===--------------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n# define N 1024\n\nint errors; \n\nint test_loop_unroll() {\n\tint arr[N];\n\tint parallel_arr[N];\n\tint sum = 0;\n\tint parallel_sum = 0;\n\n\t// sequential loop\n\tfor (int i = 0; i < N; i++) {\n\t\tarr[i] = i;\n\t\tsum += arr[i];\n\t}\n\n\t// omp unroll loop\n# pragma omp unroll\n\tfor (int i = 0; i < N; i++) {\n\t\tparallel_arr[i] = i;\n\t}\n\n\t// sequential sum of parallel array\n\tfor (int i = 0; i < N; i++) {\n\t\tparallel_sum += parallel_arr[i];\n\t}\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, parallel_sum != sum);\n\tOMPVV_INFOMSG_IF(sum == 0, \"Array was not initialized.\");\n\tOMPVV_INFOMSG_IF(parallel_sum == 0, \"Something went wrong with loop unroll.\");\n\tOMPVV_INFOMSG_IF(parallel_sum == sum, \"Test passed.\");\n\tOMPVV_INFOMSG_IF(parallel_sum != sum, \"Test did not pass.\");\n\treturn errors;\n}\n\nint main() {\n\terrors = 0;\n\tOMPVV_TEST_OFFLOADING;\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_loop_unroll() != 0);\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_loop_unroll.c -----------------------------------------------===//\n//\n// OpenMP API Version 5.1 August 2021 \n//\n// This test checks the behavior of the 5.1 unroll construct (2.11.9.2 in 5.1 spec). \n// \"The unroll construct fully or partially unrolls a loop\", which is more of a code generation\n// compiler feature. \n// This test specifically checks the unroll construct without any clause, in which the compiler decides\n// how the loop unrolls.\n// Referenced 5.1 Example Doc 7.2 \n////===--------------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n# define N 1024\n\nint errors; \n\nint test_loop_unroll() {\n\tint arr[N];\n\tint parallel_arr[N];\n\tint sum = 0;\n\tint parallel_sum = 0;\n\n\t// sequential loop\n\tfor (int i = 0; i < N; i++) {\n\t\tarr[i] = i;\n\t\tsum += arr[i];\n\t}\n\n\t// omp unroll loop\n# pragma omp unroll\n\tfor (int i = 0; i < N; i++) {\n\t\tparallel_arr[i] = i;\n\t}\n\n\t// sequential sum of parallel array\n\tfor (int i = 0; i < N; i++) {\n\t\tparallel_sum += parallel_arr[i];\n\t}\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, parallel_sum != sum);\n\tOMPVV_INFOMSG_IF(sum == 0, \"Array was not initialized.\");\n\tOMPVV_INFOMSG_IF(parallel_sum == 0, \"Something went wrong with loop unroll.\");\n\tOMPVV_INFOMSG_IF(parallel_sum == sum, \"Test passed.\");\n\tOMPVV_INFOMSG_IF(parallel_sum != sum, \"Test did not pass.\");\n\treturn errors;\n}\n\nint main() \n\terrors = 0;\n\tOMPVV_TEST_OFFLOADING;\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_loop_unroll() != 0);\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_is_device_ptr.c",
        "correct": "n",
        "issue": "Removed memory allocation line \"omp_target_alloc() API call. If this test runs on the\n//  host, we will warn that we won't be allocating on any device and the test \n//  will fail.\n//\n////===-------------------------------------------------------------------------===//\n\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"ompvv.h\"\n\n#define N 10000\n\nint main() {\n  \n\n  int isOffloading;\" at position 234",
        "issue_id": 0,
        "original_code": "//===--- test_target_is_device_ptr.c--is_device_ptr clause on target directive--===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n//  This test checks for the use of the is_device_ptr() clause on an array that \n//  is allocated with the omp_target_alloc() API call. If this test runs on the\n//  host, we will warn that we won't be allocating on any device and the test \n//  will fail.\n//\n////===-------------------------------------------------------------------------===//\n\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#include \"ompvv.h\"\n\n#define N 10000\n\nint main() {\n  \n\n  int isOffloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  \n  OMPVV_WARNING_IF(!isOffloading, \"This test is running on the host, the allocation of the memory returns a host pointer\");\n\n  int errors = 0;\n  int *array_device = NULL;\n  int *array_host = NULL;\n  \n\n  array_device = (int *) omp_target_alloc(N*sizeof(int), omp_get_default_device());\n  if (array_device == NULL) {\n    errors = 1; \n    OMPVV_ERROR(\"Array device is null: cannot allocate memory on device, is_device_ptr() cannot be properly tested\");\n    OMPVV_REPORT_AND_RETURN(errors);\n  } \n \n  array_host = (int *) malloc(N*sizeof(int));\n\n  for (int i = 0; i < N; ++i) {\n    array_host[i] = i;\n  }\n\n#pragma omp target is_device_ptr(array_device) map(tofrom: array_host[0:N]) \n{\n  for (int i = 0; i < N; ++i) {\n    array_device[i] = i;\n    array_host[i] += array_device[i];\n  } \n} // end target\n\n  // checking results\n  for (int i = 0; i < N; ++i) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, array_host[i] != 2*i);\n  }\n\n  omp_target_free(array_device, omp_get_default_device());\n  free(array_host);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_is_device_ptr.c--is_device_ptr clause on target directive--===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n//  This test checks for the use of the is_device_ptr() clause on an array that \n//  is allocated with the \n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  \n  OMPVV_WARNING_IF(!isOffloading, \"This test is running on the host, the allocation of the memory returns a host pointer\");\n\n  int errors = 0;\n  int *array_device = NULL;\n  int *array_host = NULL;\n  \n\n  array_device = (int *) omp_target_alloc(N*sizeof(int), omp_get_default_device());\n  if (array_device == NULL) {\n    errors = 1; \n    OMPVV_ERROR(\"Array device is null: cannot allocate memory on device, is_device_ptr() cannot be properly tested\");\n    OMPVV_REPORT_AND_RETURN(errors);\n  } \n \n  array_host = (int *) malloc(N*sizeof(int));\n\n  for (int i = 0; i < N; ++i) {\n    array_host[i] = i;\n  }\n\n#pragma omp target is_device_ptr(array_device) map(tofrom: array_host[0:N]) \n{\n  for (int i = 0; i < N; ++i) {\n    array_device[i] = i;\n    array_host[i] += array_device[i];\n  } \n} // end target\n\n  // checking results\n  for (int i = 0; i < N; ++i) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, array_host[i] != 2*i);\n  }\n\n  omp_target_free(array_device, omp_get_default_device());\n  free(array_host);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_map_with_close_modifier.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp master\" at position 802",
        "issue_id": 0,
        "original_code": "//===--- test_target_map_with_close_modifier.c ----------------------------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks for support of the close map-type-modifier on a map clause. The test maps several\n// different data types to device with tofrom map-type and then checks for expected updated values on\n// the host.\n//\n////===--------------------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint errors; \n\nint test_close_modifier() {\n\n  int i;\n  int scalar = 19;\n  int a[N];\n\n  struct {\n    int var;\n    int b[N];\n  } member; \n\n  member.var = 1;\n  \n  for (i = 0; i < N; i++) { \n    a[i] = i;\n    member.b[i] = i;\n  }\n\n#pragma omp target map (close, tofrom: scalar, a, member) \n  {\n    scalar += 25;\n    member.var += 16;\n    \n    for (i = 0; i < N; i++) {\n      a[i] += i*2;\n      member.b[i] += i*2;\n    }\n  }\n\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, a[i] != i*3);\n    OMPVV_TEST_AND_SET(errors, member.b[i] != i*3);\n  }\n \n  OMPVV_TEST_AND_SET(errors, scalar != 44);\n  OMPVV_TEST_AND_SET(errors, member.var != 17);\n\n  return errors;  \t \n}\n\nint main () {\n  \n  errors = 0;\n  \n  OMPVV_TEST_OFFLOADING;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_close_modifier());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_map_with_close_modifier.c ----------------------------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks for support of the close map-type-modifier on a map clause. The test maps several\n// different data types to device with tofrom map-type and then checks for expected updated values on\n// the host.\n//\n////===--------------------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint errors; \n\nint test_close_modifier() {\n\n  int i;\n  int scalar = 19;\n  int a[N];\n\n  struct {\n    int var;\n    int b[N];\n  } member; \n\n  member.var = 1;\n  \n  for (i = 0; i < N; i++) { \n    a[i] = i;\n    member.b[i] = i;\n  }\n\n#pragma omp master map (close, tofrom: scalar, a, member) \n  {\n    scalar += 25;\n    member.var += 16;\n    \n    for (i = 0; i < N; i++) {\n      a[i] += i*2;\n      member.b[i] += i*2;\n    }\n  }\n\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, a[i] != i*3);\n    OMPVV_TEST_AND_SET(errors, member.b[i] != i*3);\n  }\n \n  OMPVV_TEST_AND_SET(errors, scalar != 44);\n  OMPVV_TEST_AND_SET(errors, member.var != 17);\n\n  return errors;  \t \n}\n\nint main () {\n  \n  errors = 0;\n  \n  OMPVV_TEST_OFFLOADING;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_close_modifier());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/omp_default_device.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_omp_device());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 1421",
        "issue_id": 4,
        "original_code": "//===----- omp_default_device.c ----------------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// This test is based on a bug encounted by an application where the default device \n// would change (after explicit omp_set_default_device) after allocation via \n// omp_target_alloc).The test sets and gets the default device number and checks if \n// the default device has actually changed after a memory allocation was made on \n// the device.\n//\n////===-------------------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nint test_omp_device() {\n  OMPVV_INFOMSG(\"test_get_set_default_device\");\n\n  int errors = 0, setDev, iDev1, iDev2;\n  double *buf1, *buf2;\n  int num_devices = omp_get_num_devices();\n  \n  OMPVV_TEST_AND_SET(errors, num_devices <= 0);\n\n  if(errors)\n   return errors;\n\n  // Set default device\n  if(num_devices > 1){\n    omp_set_default_device(num_devices-1);\n    setDev = num_devices-1;\n  }\n  else{\n    omp_set_default_device(0);\n    setDev = 0;\n  }\n\n  iDev1 = omp_get_default_device();\n  OMPVV_TEST_AND_SET(errors, iDev1 != setDev);\n\n\n  buf1 = (double *)omp_target_alloc (sizeof(double)* N, iDev1);\n  iDev2 = omp_get_default_device();\n  OMPVV_TEST_AND_SET(errors, iDev2 != iDev1);\n\n  omp_target_free (buf1, iDev1);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_omp_device());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n",
        "error_code": "//===----- omp_default_device.c ----------------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// This test is based on a bug encounted by an application where the default device \n// would change (after explicit omp_set_default_device) after allocation via \n// omp_target_alloc).The test sets and gets the default device number and checks if \n// the default device has actually changed after a memory allocation was made on \n// the device.\n//\n////===-------------------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nint test_omp_device() {\n  OMPVV_INFOMSG(\"test_get_set_default_device\");\n\n  int errors = 0, setDev, iDev1, iDev2;\n  double *buf1, *buf2;\n  int num_devices = omp_get_num_devices();\n  \n  OMPVV_TEST_AND_SET(errors, num_devices <= 0);\n\n  if(errors)\n   return errors;\n\n  // Set default device\n  if(num_devices > 1){\n    omp_set_default_device(num_devices-1);\n    setDev = num_devices-1;\n  }\n  else{\n    omp_set_default_device(0);\n    setDev = 0;\n  }\n\n  iDev1 = omp_get_default_device();\n  OMPVV_TEST_AND_SET(errors, iDev1 != setDev);\n\n\n  buf1 = (double *)omp_target_alloc (sizeof(double)* N, iDev1);\n  iDev2 = omp_get_default_device();\n  OMPVV_TEST_AND_SET(errors, iDev2 != iDev1);\n\n  omp_target_free (buf1, iDev1);\n\n  return errors;\n}\n\nint main() \n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_device.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n    OMPVV_WARNING_IF(!errors[dev] && num_teams[dev] == 1, \"Test operated with one team. Parallelism of teams distribute can't be guaranteed.\");\n    OMPVV_ERROR_IF(errors[dev], \"Test failed with device %d\", dev);\n  }\" at position 2491",
        "issue_id": 4,
        "original_code": "//===--- test_target_teams_distribute_device.c-------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the device clause to indicate which device should execute the\n// given target regions.  The test uses the separate device data environments to\n// ensure that operations are executed on the specified device.  If only one\n// device is available, the test issues a warning.\n//\n// By having a separate initialization of the same array on each device at the\n// same time, if all operations were occuring on the same device, we would\n// expect the same results from each device and it wouldn't be able to give\n// proper answers for each initialization.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define ARRAY_SIZE 1024\n\nint main() {\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n\n  int num_devices = omp_get_num_devices();\n  // Allocate num_devices + 1 to avoid zero-sized VLA if num_devices == 0\n  int a[num_devices+1][ARRAY_SIZE];\n  int b[ARRAY_SIZE];\n  int num_teams[num_devices+1];\n  int errors[num_devices+1];\n  int sum_errors = 0;\n\n  OMPVV_INFOMSG(\"Running tests on %d devices\", num_devices);\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    for (int dev = 0; dev < num_devices; ++dev) {\n      a[dev][x] = 1;\n    }\n    b[x] = x;\n  }\n\n  for (int x = 0; x < num_devices; ++x) {\n    num_teams[x] = 0;\n    errors[x] = 0;\n  }\n\n  for (int dev = 0; dev < num_devices; ++dev) {\n#pragma omp target enter data map(to: a[dev][0:ARRAY_SIZE], b[0:ARRAY_SIZE], num_teams[dev:1]) device(dev)\n  }\n\n  for (int dev = 0; dev < num_devices; ++dev) {\n#pragma omp target teams distribute map(alloc: a[dev][0:ARRAY_SIZE], b[0:ARRAY_SIZE], num_teams[dev:1]) device(dev)\n    for (int x = 0; x < ARRAY_SIZE; ++x) {\n      if (omp_get_team_num() == 0) {\n        num_teams[dev] = omp_get_num_teams();\n      }\n      a[dev][x] += b[x] + dev;\n    }\n  }\n\n  for (int dev = 0; dev < num_devices; ++dev) {\n#pragma omp target exit data map(from: a[dev][0:ARRAY_SIZE], num_teams[dev:1]) map(delete: b[0:ARRAY_SIZE]) device(dev)\n    for (int x = 0; x < ARRAY_SIZE; ++x) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors[dev], a[dev][x] != 1 + dev + b[x]);\n      if (a[dev][x] != 1 + dev + b[x]) {\n        break;\n      }\n    }\n  }\n\n  for (int x = 0; x < num_devices; ++x) {\n    sum_errors += errors[x];\n  }\n\n  for (int dev = 0; dev < num_devices; ++dev) {\n    OMPVV_WARNING_IF(!errors[dev] && num_teams[dev] == 1, \"Test operated with one team. Parallelism of teams distribute can't be guaranteed.\");\n    OMPVV_ERROR_IF(errors[dev], \"Test failed with device %d\", dev);\n  }\n\n  OMPVV_REPORT_AND_RETURN(sum_errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_device.c-------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the device clause to indicate which device should execute the\n// given target regions.  The test uses the separate device data environments to\n// ensure that operations are executed on the specified device.  If only one\n// device is available, the test issues a warning.\n//\n// By having a separate initialization of the same array on each device at the\n// same time, if all operations were occuring on the same device, we would\n// expect the same results from each device and it wouldn't be able to give\n// proper answers for each initialization.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define ARRAY_SIZE 1024\n\nint main() {\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n\n  int num_devices = omp_get_num_devices();\n  // Allocate num_devices + 1 to avoid zero-sized VLA if num_devices == 0\n  int a[num_devices+1][ARRAY_SIZE];\n  int b[ARRAY_SIZE];\n  int num_teams[num_devices+1];\n  int errors[num_devices+1];\n  int sum_errors = 0;\n\n  OMPVV_INFOMSG(\"Running tests on %d devices\", num_devices);\n\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    for (int dev = 0; dev < num_devices; ++dev) {\n      a[dev][x] = 1;\n    }\n    b[x] = x;\n  }\n\n  for (int x = 0; x < num_devices; ++x) {\n    num_teams[x] = 0;\n    errors[x] = 0;\n  }\n\n  for (int dev = 0; dev < num_devices; ++dev) {\n#pragma omp target enter data map(to: a[dev][0:ARRAY_SIZE], b[0:ARRAY_SIZE], num_teams[dev:1]) device(dev)\n  }\n\n  for (int dev = 0; dev < num_devices; ++dev) {\n#pragma omp target teams distribute map(alloc: a[dev][0:ARRAY_SIZE], b[0:ARRAY_SIZE], num_teams[dev:1]) device(dev)\n    for (int x = 0; x < ARRAY_SIZE; ++x) {\n      if (omp_get_team_num() == 0) {\n        num_teams[dev] = omp_get_num_teams();\n      }\n      a[dev][x] += b[x] + dev;\n    }\n  }\n\n  for (int dev = 0; dev < num_devices; ++dev) {\n#pragma omp target exit data map(from: a[dev][0:ARRAY_SIZE], num_teams[dev:1]) map(delete: b[0:ARRAY_SIZE]) device(dev)\n    for (int x = 0; x < ARRAY_SIZE; ++x) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors[dev], a[dev][x] != 1 + dev + b[x]);\n      if (a[dev][x] != 1 + dev + b[x]) {\n        break;\n      }\n    }\n  }\n\n  for (int x = 0; x < num_devices; ++x) {\n    sum_errors += errors[x];\n  }\n\n  for (int dev = 0; dev < num_devices; ++dev) \n\n  OMPVV_REPORT_AND_RETURN(sum_errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_map_classes_default.cpp",
        "correct": "n",
        "issue": "Removed opening bracket at position 2609",
        "issue_id": 1,
        "original_code": "//===---test_target_map_classes_default.cpp ---------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// This test focuses on the mapping of classes into the device. There are 2 \n// definition of clases. A, and B. A contains an array and its size, while B\n// has an static double and a virtual method. This test consist of 2 parts\n// explicit default mapping of the array and static variable mapping. The\n// explicit test has a map clause that does not use a map-type-modifier for\n// the array. It should be mapped as tofrom. (OpenMP 4.5 requires that it is\n// not mapped as member variable, hence, a pointer to it used.)\n// The static variable mapping test if an static variable will be copied\n// and map over to the device.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <cmath>\n\n#define N 1000\n\nclass A {\n\nprivate:\n  int h_array[N];\n  int size;\n\npublic:\n  A(const int s) : size(s) {\n    for (int i = 0; i < N; i++) {\n      h_array[i] = 0;\n    }\n  }\n\n  void modifyExplicit() {\n    int * theArray = this->h_array;\n    int theSize = size;\n    // It is not possible to do this-> since it is an\n    // expression and it is not supported by 4.5\n#pragma omp target map(theArray[0:N]) map(theSize) \n    {\n      for (int i = 0; i < theSize; ++i)\n          theArray[i] += 1;\n    } // end target\n  }\n\n  int* getArray() {\n    return &h_array[0];\n  }\n};\n\nclass B {\npublic:\n  static double VAR;\n  B() {}\n\n  ~B() {}\n\n#pragma omp declare target \n  static int staticMethod() {\n      return 1;\n  }\n#pragma omp end declare target \n};\n\ndouble B::VAR = 1.0;\n\nint test_explicit() {\n\n  OMPVV_INFOMSG(\"Explicit mapping test\");\n  int sum = 0, errors = 0;\n\n  A *obj = new A(N);\n\n  obj->modifyExplicit();\n\n  // checking results\n  int* h_array = obj->getArray();\n  for (int i = 0; i < N; ++i)\n    sum += h_array[i];\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, N != sum);\n\n  delete obj;\n\n  return errors;\n}\n\nint test_static () {\n\n  OMPVV_INFOMSG(\"Testing accessing a static variable\");\n\n  int errors = 0;\n  double res = 0.0;\n  \n#pragma omp target map(tofrom: res)\n  {\n    res = B::VAR;\n  } // end target\n\n  // checking results\n  OMPVV_TEST_AND_SET_VERBOSE(errors, std::abs(res - 1.0) > 0.0001)\n\n  return errors;\n}\n\nint test_static_method () {\n  OMPVV_INFOMSG(\"Testing static methods on the device\");\n\n  int errors = 0;\n  int value = 0;\n\n#pragma omp target map(tofrom: value) \n  {\n    value = B::staticMethod();\n  } // end target\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, std::abs(value - 1.0) > 0.0001);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_static_method() != 0);\n  OMPVV_TEST_AND_SET_VERBOSE(errors,  test_static() != 0);\n  OMPVV_TEST_AND_SET_VERBOSE(errors,  test_explicit() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---test_target_map_classes_default.cpp ---------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// This test focuses on the mapping of classes into the device. There are 2 \n// definition of clases. A, and B. A contains an array and its size, while B\n// has an static double and a virtual method. This test consist of 2 parts\n// explicit default mapping of the array and static variable mapping. The\n// explicit test has a map clause that does not use a map-type-modifier for\n// the array. It should be mapped as tofrom. (OpenMP 4.5 requires that it is\n// not mapped as member variable, hence, a pointer to it used.)\n// The static variable mapping test if an static variable will be copied\n// and map over to the device.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <cmath>\n\n#define N 1000\n\nclass A {\n\nprivate:\n  int h_array[N];\n  int size;\n\npublic:\n  A(const int s) : size(s) {\n    for (int i = 0; i < N; i++) {\n      h_array[i] = 0;\n    }\n  }\n\n  void modifyExplicit() {\n    int * theArray = this->h_array;\n    int theSize = size;\n    // It is not possible to do this-> since it is an\n    // expression and it is not supported by 4.5\n#pragma omp target map(theArray[0:N]) map(theSize) \n    {\n      for (int i = 0; i < theSize; ++i)\n          theArray[i] += 1;\n    } // end target\n  }\n\n  int* getArray() {\n    return &h_array[0];\n  }\n};\n\nclass B {\npublic:\n  static double VAR;\n  B() {}\n\n  ~B() {}\n\n#pragma omp declare target \n  static int staticMethod() {\n      return 1;\n  }\n#pragma omp end declare target \n};\n\ndouble B::VAR = 1.0;\n\nint test_explicit() {\n\n  OMPVV_INFOMSG(\"Explicit mapping test\");\n  int sum = 0, errors = 0;\n\n  A *obj = new A(N);\n\n  obj->modifyExplicit();\n\n  // checking results\n  int* h_array = obj->getArray();\n  for (int i = 0; i < N; ++i)\n    sum += h_array[i];\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, N != sum);\n\n  delete obj;\n\n  return errors;\n}\n\nint test_static () {\n\n  OMPVV_INFOMSG(\"Testing accessing a static variable\");\n\n  int errors = 0;\n  double res = 0.0;\n  \n#pragma omp target map(tofrom: res)\n  {\n    res = B::VAR;\n  } // end target\n\n  // checking results\n  OMPVV_TEST_AND_SET_VERBOSE(errors, std::abs(res - 1.0) > 0.0001)\n\n  return errors;\n}\n\nint test_static_method () {\n  OMPVV_INFOMSG(\"Testing static methods on the device\");\n\n  int errors = 0;\n  int value = 0;\n\n#pragma omp target map(tofrom: value) \n  {\n    value = B::staticMethod();\n  } // end target\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, std::abs(value - 1.0) > 0.0001);\n\n  return errors;\n}\n\nint main() \n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_static_method() != 0);\n  OMPVV_TEST_AND_SET_VERBOSE(errors,  test_static() != 0);\n  OMPVV_TEST_AND_SET_VERBOSE(errors,  test_explicit() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_parallel_for_map_to.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp single\" at position 741",
        "issue_id": 0,
        "original_code": "//===---- test_target_teams_distribute_parallel_for_map_to.c ----------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// Testing the mapping of arrays and scalar through the map clause with the \n// to map-modifier.\n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define N 2000\n\nint test_target_teams_distribute_parallel_for_map_to() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_map_to\");\n  \n  int a[N];\n  int b[N];\n  int d[N];\n  int scalar = 50; // This one is to test the to of an scalar\n  int errors = 0;\n  int i, j;\n\n  // array initialization\n  for (i = 0; i < N; i++) {\n    a[i] = 1;\n    b[i] = i;\n    d[i] = 0;\n  }\n\n#pragma omp target teams distribute parallel for map(to: a, b, scalar) map(tofrom: d)\n    for (j = 0; j < N; ++j) {\n      d[j] = (a[j] + b[j]) * scalar;\n    }\n\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, d[i] != (1 + i) * 50);\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_map_to());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_teams_distribute_parallel_for_map_to.c ----------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// Testing the mapping of arrays and scalar through the map clause with the \n// to map-modifier.\n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define N 2000\n\nint test_target_teams_distribute_parallel_for_map_to() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_map_to\");\n  \n  int a[N];\n  int b[N];\n  int d[N];\n  int scalar = 50; // This one is to test the to of an scalar\n  int errors = 0;\n  int i, j;\n\n  // array initialization\n  for (i = 0; i < N; i++) {\n    a[i] = 1;\n    b[i] = i;\n    d[i] = 0;\n  }\n\n#pragma omp single teams distribute parallel for map(to: a, b, scalar) map(tofrom: d)\n    for (j = 0; j < N; ++j) {\n      d[j] = (a[j] + b[j]) * scalar;\n    }\n\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, d[i] != (1 + i) * 50);\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_map_to());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_master_taskloop_simd.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1413",
        "issue_id": 1,
        "original_code": "//===--- test_master_taskloop_simd.c ----------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the master taskloop simd directive in a parallel region.\n// The test performs simple operations on an int array which are then checked\n// for correctness.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_master_taskloop_simd() {\n  OMPVV_INFOMSG(\"test_master_taskloop_simd\");\n  int errors = 0;\n  int num_threads = -1;\n  int x[N];\n  int y[N];\n  int z[N];\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 1;\n    y[i] = i + 1;\n    z[i] = 2*(i + 1);\n  }\n\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST) shared(x, y, z, num_threads)\n  {\n#pragma omp master taskloop simd\n    for (int i = 0; i < N; i++) {\n      x[i] += y[i]*z[i];\n    }\n    if (omp_get_thread_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != 1 + (y[i]*z[i]));\n  }\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of taskloop can't be guaranteed.\");\n  OMPVV_ERROR_IF(num_threads < 1, \"Test returned an invalid number of threads.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n\n  return errors;\n}\n\n\nint main() {\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_master_taskloop_simd());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_master_taskloop_simd.c ----------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the master taskloop simd directive in a parallel region.\n// The test performs simple operations on an int array which are then checked\n// for correctness.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_master_taskloop_simd() {\n  OMPVV_INFOMSG(\"test_master_taskloop_simd\");\n  int errors = 0;\n  int num_threads = -1;\n  int x[N];\n  int y[N];\n  int z[N];\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 1;\n    y[i] = i + 1;\n    z[i] = 2*(i + 1);\n  }\n\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST) shared(x, y, z, num_threads)\n  {\n#pragma omp master taskloop simd\n    for (int i = 0; i < N; i++) {\n      x[i] += y[i]*z[i];\n    }\n    if (omp_get_thread_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != 1 + (y[i]*z[i]));\n  }\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of taskloop can't be guaranteed.\");\n  OMPVV_ERROR_IF(num_threads < 1, \"Test returned an invalid number of threads.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n\n  return errors;\n}\n\n\nint main() \n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_master_taskloop_simd());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_task_target.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===-------- test_task_target.c - test task with target offload  ------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks target regions inside of tasks. With offloading support \n// the tasks are executed on the device. The results do not change if the \n// test is executed on the host. Output will indicate if the test passed and\n// where (host/device).\n//\n////===----------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nint test_task_target() {\n  int a[N], b[N], c[N];\n  int errors = 0, i;\n\n#pragma omp task shared(a) private(i)\n#pragma omp target map(from: a)\n#pragma omp parallel for\n  for (i = 0; i < N; i++)\n    a[i] = i;\n   \n#pragma omp task shared(b) private(i)\n#pragma omp target map(from: b)\n#pragma omp parallel for\n  for (i = 0; i < N; i++)\n    b[i] = 10;\n\n#pragma omp taskwait\n\n#pragma omp task shared(c) private(i)\n#pragma omp target map(from: c) map(to:a,b)\n#pragma omp parallel for\n  for (i = 0; i < N; i++)\n    c[i] = a[i] + b[i];\n\n#pragma omp taskwait\n\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, (c[i] != i + 10));\n  }\n  return(errors);\n}\n\nint main() {\n\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_task_target());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\ndouble xziuahqivd = 152;\ndouble ibhwenjqoo = 38;\ndouble pebpacuvof = 215;\nlong ggohrjpfrd = 65;\ndouble hkasrsitlg = 243;\ndouble hqbfbrdcfy = 94;\nbyte lxdjpcqglt = 48;\nfloat lzmeokwfyh = 229;\nlong hxyohwsrvx = 165;\nbyte hawngefwsx = 82;\nint bbtjwqagcu = 7;\nshort hkzlqapupm = 189;\nint knoezdhfzz = 251;\nshort lyyyrfhkky = 238;\nfloat xnbsnakpeg = 191;\ndouble eqtenjrlfa = 36;\nint mvhtkrpivr = 107;\ndouble bohfiuejmt = 17;\nlong xbavsuopua = 3;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_collapse.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp master\" at position 1088",
        "issue_id": 0,
        "original_code": "//===--- test_target_teams_distribute_collapse.c--------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the collapse clause and tests that for loops out of the scope\n// of the collapsed loops are not parallelized.  This test tests using one and\n// two collapsed loops.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define ARRAY_SIZE 128 //Array Size of 128 uses 16MB target memory and\n                       //scales n^3 in test_collapse2()\n\nint test_collapse1() {\n\n  int * a_mem = (int *)malloc(ARRAY_SIZE*ARRAY_SIZE*sizeof(int));\n  int * b_mem = (int *)malloc(ARRAY_SIZE*(ARRAY_SIZE+1)*sizeof(int));\n  int (*a)[ARRAY_SIZE] = (int (*)[ARRAY_SIZE])a_mem;\n  int (*b)[ARRAY_SIZE + 1] = (int (*)[ARRAY_SIZE+1])b_mem;\n  int errors = 0;\n\n  // a and b array initialization\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    b[x][0] = 0;\n    for (int y = 0; y < ARRAY_SIZE; ++y) {\n      a[x][y] = x + y;\n      b[x][y+1] = 0;\n    }\n  }\n\n#pragma omp target teams distribute map(to: a[0:ARRAY_SIZE][0:ARRAY_SIZE]) map(tofrom: b[0:ARRAY_SIZE][0:ARRAY_SIZE+1]) collapse(1) num_teams(OMPVV_NUM_TEAMS_DEVICE)\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    for (int y = 0; y < ARRAY_SIZE; ++y) {\n      b[x][y + 1] = b[x][y] + a[x][y];\n    }\n  }\n\n  int temp_total;\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    temp_total = 0;\n    for (int y = 0; y < ARRAY_SIZE+1; ++y) {\n      OMPVV_TEST_AND_SET(errors, ((temp_total - b[x][y]) != 0));\n      if (y != ARRAY_SIZE) {\n        temp_total = temp_total + a[x][y];\n      }\n    }\n  }\n\n  free (a_mem);\n  free (b_mem);\n  return errors;\n}\n\nint test_collapse2() {\n  int * a_mem = (int *)malloc(ARRAY_SIZE*ARRAY_SIZE*ARRAY_SIZE*sizeof(int));\n  int * b_mem = (int *)malloc(ARRAY_SIZE*ARRAY_SIZE*(ARRAY_SIZE+1)*sizeof(int));\n  int (*a)[ARRAY_SIZE][ARRAY_SIZE] = (int (*)[ARRAY_SIZE][ARRAY_SIZE])a_mem;\n  int (*b)[ARRAY_SIZE][ARRAY_SIZE + 1] = (int (*)[ARRAY_SIZE][ARRAY_SIZE+1])b_mem;\n  int errors = 0;\n  int num_teams = 0;\n\n  // a and b array initialization\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    for (int y = 0; y < ARRAY_SIZE; ++y) {\n      b[x][y][0] = 0;\n      for (int z = 0; z < ARRAY_SIZE; ++z) {\n        a[x][y][z] = x + y + z;\n        b[x][y][z+1] = 0;\n      }\n    }\n  }\n\n#pragma omp target teams distribute map(to: a[0:ARRAY_SIZE][0:ARRAY_SIZE][0:ARRAY_SIZE]) map(tofrom: b[0:ARRAY_SIZE][0:ARRAY_SIZE][0:ARRAY_SIZE+1], num_teams) collapse(2) num_teams(OMPVV_NUM_TEAMS_DEVICE)\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    for (int y = 0; y < ARRAY_SIZE; ++y) {\n      for (int z = 0; z < ARRAY_SIZE; ++z) {\n        if (omp_get_team_num() == 0) {\n          num_teams = omp_get_num_teams();\n        }\n        b[x][y][z + 1] = b[x][y][z] + a[x][y][z];\n      }\n    }\n  }\n\n  int temp_total;\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    for (int y = 0; y < ARRAY_SIZE; ++y) {\n      temp_total = 0;\n      for (int z = 0; z < ARRAY_SIZE + 1; ++z) {\n        OMPVV_TEST_AND_SET(errors, ((temp_total - b[x][y][z]) != 0));\n        if (z != ARRAY_SIZE) {\n          temp_total = temp_total + a[x][y][z];\n        }\n      }\n    }\n  }\n\n  if (num_teams == 1) {\n    OMPVV_WARNING(\"Test operated with one team.  Parallelism of teams distribute can't be guaranteed.\");\n  }\n\n  free (a_mem);\n  free (b_mem);\n  return errors;\n}\n\nint main() {\n  \n  //Check for offloading\n  OMPVV_TEST_OFFLOADING;  \n\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_collapse1() != 0);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_collapse2() != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n\n}\n",
        "error_code": "//===--- test_target_teams_distribute_collapse.c--------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the collapse clause and tests that for loops out of the scope\n// of the collapsed loops are not parallelized.  This test tests using one and\n// two collapsed loops.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define ARRAY_SIZE 128 //Array Size of 128 uses 16MB target memory and\n                       //scales n^3 in test_collapse2()\n\nint test_collapse1() {\n\n  int * a_mem = (int *)malloc(ARRAY_SIZE*ARRAY_SIZE*sizeof(int));\n  int * b_mem = (int *)malloc(ARRAY_SIZE*(ARRAY_SIZE+1)*sizeof(int));\n  int (*a)[ARRAY_SIZE] = (int (*)[ARRAY_SIZE])a_mem;\n  int (*b)[ARRAY_SIZE + 1] = (int (*)[ARRAY_SIZE+1])b_mem;\n  int errors = 0;\n\n  // a and b array initialization\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    b[x][0] = 0;\n    for (int y = 0; y < ARRAY_SIZE; ++y) {\n      a[x][y] = x + y;\n      b[x][y+1] = 0;\n    }\n  }\n\n#pragma omp master teams distribute map(to: a[0:ARRAY_SIZE][0:ARRAY_SIZE]) map(tofrom: b[0:ARRAY_SIZE][0:ARRAY_SIZE+1]) collapse(1) num_teams(OMPVV_NUM_TEAMS_DEVICE)\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    for (int y = 0; y < ARRAY_SIZE; ++y) {\n      b[x][y + 1] = b[x][y] + a[x][y];\n    }\n  }\n\n  int temp_total;\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    temp_total = 0;\n    for (int y = 0; y < ARRAY_SIZE+1; ++y) {\n      OMPVV_TEST_AND_SET(errors, ((temp_total - b[x][y]) != 0));\n      if (y != ARRAY_SIZE) {\n        temp_total = temp_total + a[x][y];\n      }\n    }\n  }\n\n  free (a_mem);\n  free (b_mem);\n  return errors;\n}\n\nint test_collapse2() {\n  int * a_mem = (int *)malloc(ARRAY_SIZE*ARRAY_SIZE*ARRAY_SIZE*sizeof(int));\n  int * b_mem = (int *)malloc(ARRAY_SIZE*ARRAY_SIZE*(ARRAY_SIZE+1)*sizeof(int));\n  int (*a)[ARRAY_SIZE][ARRAY_SIZE] = (int (*)[ARRAY_SIZE][ARRAY_SIZE])a_mem;\n  int (*b)[ARRAY_SIZE][ARRAY_SIZE + 1] = (int (*)[ARRAY_SIZE][ARRAY_SIZE+1])b_mem;\n  int errors = 0;\n  int num_teams = 0;\n\n  // a and b array initialization\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    for (int y = 0; y < ARRAY_SIZE; ++y) {\n      b[x][y][0] = 0;\n      for (int z = 0; z < ARRAY_SIZE; ++z) {\n        a[x][y][z] = x + y + z;\n        b[x][y][z+1] = 0;\n      }\n    }\n  }\n\n#pragma omp target teams distribute map(to: a[0:ARRAY_SIZE][0:ARRAY_SIZE][0:ARRAY_SIZE]) map(tofrom: b[0:ARRAY_SIZE][0:ARRAY_SIZE][0:ARRAY_SIZE+1], num_teams) collapse(2) num_teams(OMPVV_NUM_TEAMS_DEVICE)\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    for (int y = 0; y < ARRAY_SIZE; ++y) {\n      for (int z = 0; z < ARRAY_SIZE; ++z) {\n        if (omp_get_team_num() == 0) {\n          num_teams = omp_get_num_teams();\n        }\n        b[x][y][z + 1] = b[x][y][z] + a[x][y][z];\n      }\n    }\n  }\n\n  int temp_total;\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    for (int y = 0; y < ARRAY_SIZE; ++y) {\n      temp_total = 0;\n      for (int z = 0; z < ARRAY_SIZE + 1; ++z) {\n        OMPVV_TEST_AND_SET(errors, ((temp_total - b[x][y][z]) != 0));\n        if (z != ARRAY_SIZE) {\n          temp_total = temp_total + a[x][y][z];\n        }\n      }\n    }\n  }\n\n  if (num_teams == 1) {\n    OMPVV_WARNING(\"Test operated with one team.  Parallelism of teams distribute can't be guaranteed.\");\n  }\n\n  free (a_mem);\n  free (b_mem);\n  return errors;\n}\n\nint main() {\n  \n  //Check for offloading\n  OMPVV_TEST_OFFLOADING;  \n\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_collapse1() != 0);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_collapse2() != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_calloc.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp map\" at position 649",
        "issue_id": 0,
        "original_code": "//===------------------------ test_target_calloc.c ------------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// Tests the omp_calloc routine to make sure memory is properly allocated\n// on the host and is zero initialized. Allocates an array and makes sure\n// each value is set to 0 to start. Then adds i to each index and validates the\n// changes persisted and were written correctly.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_omp_target_calloc() {\n\n  int errors = 0;\n\n  #pragma omp target map(tofrom: errors) uses_allocators(omp_default_mem_alloc)\n  {\n\n    int *x;\n\n    x = (int *)omp_calloc(64, N*sizeof(int), omp_default_mem_alloc);\n\n    if (x == NULL) { \n      OMPVV_ERROR(\"omp_calloc returned null\"); \n      errors++; \n    } else {\n      int not_init_to_zero = 0;\n      int not_correct_updated_values = 0;\n\n      #pragma omp parallel for\n      for (int i = 0; i < N; i++) {\n        if (x[i] != 0) {\n          #pragma omp atomic write\n          not_init_to_zero = 1;\n        }  \n      }\n\n      #pragma omp parallel for\n      for (int i = 0; i < N; i++) {\n        x[i] = i;\n      }\n\n      #pragma omp parallel for\n      for (int i = 0; i < N; i++) {\n        if (x[i] != i) {\n          #pragma omp atomic write\n          not_correct_updated_values = 1;\n        }\n      }\n\n      if (not_init_to_zero) {\n        OMPVV_ERROR(\"Values were not initialized to 0\");\n        errors++;\n      }\n\n      if (not_correct_updated_values) {\n        OMPVV_ERROR(\"Values in the array did NOT match the expected values. Changes may not have persisted.\");\n        errors++;\n      }\n      \n      omp_free(x, omp_default_mem_alloc);\n    }\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_omp_target_calloc() != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===------------------------ test_target_calloc.c ------------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// Tests the omp_calloc routine to make sure memory is properly allocated\n// on the host and is zero initialized. Allocates an array and makes sure\n// each value is set to 0 to start. Then adds i to each index and validates the\n// changes persisted and were written correctly.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_omp_target_calloc() {\n\n  int errors = 0;\n\n  #pragma omp map map(tofrom: errors) uses_allocators(omp_default_mem_alloc)\n  {\n\n    int *x;\n\n    x = (int *)omp_calloc(64, N*sizeof(int), omp_default_mem_alloc);\n\n    if (x == NULL) { \n      OMPVV_ERROR(\"omp_calloc returned null\"); \n      errors++; \n    } else {\n      int not_init_to_zero = 0;\n      int not_correct_updated_values = 0;\n\n      #pragma omp parallel for\n      for (int i = 0; i < N; i++) {\n        if (x[i] != 0) {\n          #pragma omp atomic write\n          not_init_to_zero = 1;\n        }  \n      }\n\n      #pragma omp parallel for\n      for (int i = 0; i < N; i++) {\n        x[i] = i;\n      }\n\n      #pragma omp parallel for\n      for (int i = 0; i < N; i++) {\n        if (x[i] != i) {\n          #pragma omp atomic write\n          not_correct_updated_values = 1;\n        }\n      }\n\n      if (not_init_to_zero) {\n        OMPVV_ERROR(\"Values were not initialized to 0\");\n        errors++;\n      }\n\n      if (not_correct_updated_values) {\n        OMPVV_ERROR(\"Values in the array did NOT match the expected values. Changes may not have persisted.\");\n        errors++;\n      }\n      \n      omp_free(x, omp_default_mem_alloc);\n    }\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_omp_target_calloc() != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_declare_target_enter_device_type_host.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp declare\" with directive \"#pragma omp master\" at position 765",
        "issue_id": 0,
        "original_code": "//===---- test_declare_target_enter_device_type_host.c  -----------------------------===//\n// \n// OpenMP API Version 5.2 \n//\n// The declare target directive specifies that variables, functions(C,C++ and Fortran),\n// and subroutines (Fortran) are mapped to a device. If device_type(host) is present \n// only a host version of the procedure is made available. The \"enter\" clause was introduced \n// to replace the to clause in 5.2.\n// \n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\nint errors = 0;\n\nint a[N], b[N], c[N];  \nint i = 0;\n\nvoid update() { \n  for (i = 0; i < N; i++) {\n    a[i] += 1;\n    b[i] += 2;\n    c[i] += 3;\n  }\n}\n\n#pragma omp declare target enter(a,b,c,i) \n#pragma omp declare target enter(update) device_type(host) \n\nint test_declare_target_device_type_host() { \n\n  #pragma omp target update to(a,b,c)\n  \n  #pragma omp target   \n  {\n    for (i = 0; i < N; i++) {\n      a[i] += i;\n      b[i] += 2 * i;\n      c[i] += 3 * i;\n    }\n  }\n  #pragma omp target update from( a, b, c)\n\n  //on host\n  update();\n\n  for (i = 0; i < N; i++) { //check array values on host\n    if ( a[i] != i + 1 || b[i] != 2 * i + 2 || c[i] != 3 * i + 3 ) {\n      errors++;\n    }\n   \n  }\n  return errors;\n}\n\nint main () {\n  \n  //initalize arrays on host\n  for (i = 0; i < N; i++) {\n    a[i] = 0;\n    b[i] = 0;\n    c[i] = 0;\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_declare_target_device_type_host());\n  OMPVV_REPORT_AND_RETURN(errors);\n}  \n",
        "error_code": "//===---- test_declare_target_enter_device_type_host.c  -----------------------------===//\n// \n// OpenMP API Version 5.2 \n//\n// The declare target directive specifies that variables, functions(C,C++ and Fortran),\n// and subroutines (Fortran) are mapped to a device. If device_type(host) is present \n// only a host version of the procedure is made available. The \"enter\" clause was introduced \n// to replace the to clause in 5.2.\n// \n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\nint errors = 0;\n\nint a[N], b[N], c[N];  \nint i = 0;\n\nvoid update() { \n  for (i = 0; i < N; i++) {\n    a[i] += 1;\n    b[i] += 2;\n    c[i] += 3;\n  }\n}\n\n#pragma omp master target enter(a,b,c,i) \n#pragma omp declare target enter(update) device_type(host) \n\nint test_declare_target_device_type_host() { \n\n  #pragma omp target update to(a,b,c)\n  \n  #pragma omp target   \n  {\n    for (i = 0; i < N; i++) {\n      a[i] += i;\n      b[i] += 2 * i;\n      c[i] += 3 * i;\n    }\n  }\n  #pragma omp target update from( a, b, c)\n\n  //on host\n  update();\n\n  for (i = 0; i < N; i++) { //check array values on host\n    if ( a[i] != i + 1 || b[i] != 2 * i + 2 || c[i] != 3 * i + 3 ) {\n      errors++;\n    }\n   \n  }\n  return errors;\n}\n\nint main () {\n  \n  //initalize arrays on host\n  for (i = 0; i < N; i++) {\n    a[i] = 0;\n    b[i] = 0;\n    c[i] = 0;\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_declare_target_device_type_host());\n  OMPVV_REPORT_AND_RETURN(errors);\n}  \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_defaultmap_to_from_tofrom.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 3990",
        "issue_id": 1,
        "original_code": "//===--- test_target_defaultmap_to_from_tofrom.c ----------------------------===//\n//\n//  OpenMP API Version 5.0 Nov 2018\n//\n//  This test checks behavior of the defaultmap clause when the specified \n//  implicit-behavior is to, from, and tofrom. The variable-categories \n//  avaiable for defaultmap are scalar, aggregate, \n//  and pointer.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint errors;\nint i;\n\nint test_defaultmap_with_to() {\n\n   struct test_struct {\n     int s;\n     int S[N];\n   };\n\n   int scalar; // scalar \n   int A[N]; // aggregate \n   struct test_struct new_struct; // aggregate variable -> structure\n   int *ptr; // scalar, pointer variable -> pointer\n\n   // initialize everything   \n   scalar = 1;\n   new_struct.s = 0;\n\n   for (i = 0; i < N; i++) {\n      A[i] = 0;\n      new_struct.S[i] = 0;\n   }\n\n   #pragma omp target defaultmap(to) //map(tofrom: scalar, A, new_struct, ptr) \n   {\n      scalar = 17;    // Scalar firstprivate, value not returned\n      A[0] = 5; A[1] = 5; // Aggregate array, default is tofrom\n      new_struct.s = 10; new_struct.S[0] = 10; new_struct.S[1] = 10; // Aggregate structure, default is tofrom\n      ptr = &A[0]; ptr[50] = 70; ptr[51] = 71; // Pointer, default is privatei\n   }\n\n   OMPVV_TEST_AND_SET_VERBOSE(errors, scalar != 1); \n   OMPVV_TEST_AND_SET_VERBOSE(errors, A[0] != 0 || A[1] != 0); \n   OMPVV_TEST_AND_SET_VERBOSE(errors, A[50] != 0 || A[51] != 0);\n   OMPVV_TEST_AND_SET_VERBOSE(errors, new_struct.s != 0 || new_struct.S[0] != 0 || new_struct.S[1] != 0);\n   \n   return errors;\n}\n\nint test_defaultmap_with_from() {\n\n   struct test_struct {\n     int s;\n     int S[N];\n   };\n\n   int scalar; // scalar \n   int A[N]; // aggregate \n   struct test_struct new_struct; // aggregate variable -> structure\n   int *ptr; // scalar, pointer variable -> pointer\n\n   // initialize everything   \n   scalar = 1;\n   new_struct.s = 0;\n\n   for (i = 0; i < N; i++) {\n      A[i] = 0;\n      new_struct.S[i] = 0;\n   }\n\n   #pragma omp target defaultmap(from) //map(tofrom: scalar, A, new_struct, ptr) \n   {\n      scalar = 17;    // Scalar firstprivate, value not returned\n      A[0] = 5; A[1] = 5; // Aggregate array, default is tofrom\n      new_struct.s = 10; new_struct.S[0] = 10; new_struct.S[1] = 10; // Aggregate structure, default is tofrom\n      ptr = &A[0]; ptr[50] = 50; ptr[51] = 51; // Pointer, default is private\n   }\n\n   OMPVV_TEST_AND_SET_VERBOSE(errors, scalar != 17); \n   OMPVV_TEST_AND_SET_VERBOSE(errors, A[0] != 5 || A[1] != 5); \n   OMPVV_TEST_AND_SET_VERBOSE(errors, A[50] != 50 || A[51] != 51);\n   OMPVV_TEST_AND_SET_VERBOSE(errors, new_struct.s != 10 || new_struct.S[0] != 10 || new_struct.S[1] != 10);\n\n   return errors;\n}\n\nint test_defaultmap_with_tofrom() {\n\n   struct test_struct {\n     int s;\n     int S[N];\n   };\n\n   int scalar; // scalar \n   int A[N]; // aggregate \n   struct test_struct new_struct; // aggregate variable -> structure\n   int *ptr; // scalar, pointer variable -> pointer\n\n   // initialize everything   \n   scalar = 1;\n   new_struct.s = 0;\n\n   for (i = 0; i < N; i++) {\n      A[i] = 0;\n      new_struct.S[i] = 0;\n   }\n\n   #pragma omp target defaultmap(tofrom) //map(tofrom: scalar, A, new_struct, ptr) \n   {\n      scalar = 17;    // Scalar firstprivate, value not returned\n      A[0] = 5; A[1] = 5; // Aggregate array, default is tofrom\n      new_struct.s = 10; new_struct.S[0] = 10; new_struct.S[1] = 10; // Aggregate structure, default is tofrom\n      ptr = &A[0]; ptr[50] = 50; ptr[51] = 51; // Pointer, default is private\n   }\n\n   OMPVV_TEST_AND_SET_VERBOSE(errors, scalar != 17); \n   OMPVV_TEST_AND_SET_VERBOSE(errors, A[0] != 5 || A[1] != 5); \n   OMPVV_TEST_AND_SET_VERBOSE(errors, A[50] != 50 || A[51] != 51);\n   OMPVV_TEST_AND_SET_VERBOSE(errors, new_struct.s != 10 || new_struct.S[0] != 10 || new_struct.S[1] != 10);\n\n   return errors;\n}\n\nint main() {\n\n   errors = 0;\n\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_defaultmap_with_to() != 0);\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_defaultmap_with_from() != 0);\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_defaultmap_with_tofrom() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n\n}\n",
        "error_code": "//===--- test_target_defaultmap_to_from_tofrom.c ----------------------------===//\n//\n//  OpenMP API Version 5.0 Nov 2018\n//\n//  This test checks behavior of the defaultmap clause when the specified \n//  implicit-behavior is to, from, and tofrom. The variable-categories \n//  avaiable for defaultmap are scalar, aggregate, \n//  and pointer.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint errors;\nint i;\n\nint test_defaultmap_with_to() {\n\n   struct test_struct {\n     int s;\n     int S[N];\n   };\n\n   int scalar; // scalar \n   int A[N]; // aggregate \n   struct test_struct new_struct; // aggregate variable -> structure\n   int *ptr; // scalar, pointer variable -> pointer\n\n   // initialize everything   \n   scalar = 1;\n   new_struct.s = 0;\n\n   for (i = 0; i < N; i++) {\n      A[i] = 0;\n      new_struct.S[i] = 0;\n   }\n\n   #pragma omp target defaultmap(to) //map(tofrom: scalar, A, new_struct, ptr) \n   {\n      scalar = 17;    // Scalar firstprivate, value not returned\n      A[0] = 5; A[1] = 5; // Aggregate array, default is tofrom\n      new_struct.s = 10; new_struct.S[0] = 10; new_struct.S[1] = 10; // Aggregate structure, default is tofrom\n      ptr = &A[0]; ptr[50] = 70; ptr[51] = 71; // Pointer, default is privatei\n   }\n\n   OMPVV_TEST_AND_SET_VERBOSE(errors, scalar != 1); \n   OMPVV_TEST_AND_SET_VERBOSE(errors, A[0] != 0 || A[1] != 0); \n   OMPVV_TEST_AND_SET_VERBOSE(errors, A[50] != 0 || A[51] != 0);\n   OMPVV_TEST_AND_SET_VERBOSE(errors, new_struct.s != 0 || new_struct.S[0] != 0 || new_struct.S[1] != 0);\n   \n   return errors;\n}\n\nint test_defaultmap_with_from() {\n\n   struct test_struct {\n     int s;\n     int S[N];\n   };\n\n   int scalar; // scalar \n   int A[N]; // aggregate \n   struct test_struct new_struct; // aggregate variable -> structure\n   int *ptr; // scalar, pointer variable -> pointer\n\n   // initialize everything   \n   scalar = 1;\n   new_struct.s = 0;\n\n   for (i = 0; i < N; i++) {\n      A[i] = 0;\n      new_struct.S[i] = 0;\n   }\n\n   #pragma omp target defaultmap(from) //map(tofrom: scalar, A, new_struct, ptr) \n   {\n      scalar = 17;    // Scalar firstprivate, value not returned\n      A[0] = 5; A[1] = 5; // Aggregate array, default is tofrom\n      new_struct.s = 10; new_struct.S[0] = 10; new_struct.S[1] = 10; // Aggregate structure, default is tofrom\n      ptr = &A[0]; ptr[50] = 50; ptr[51] = 51; // Pointer, default is private\n   }\n\n   OMPVV_TEST_AND_SET_VERBOSE(errors, scalar != 17); \n   OMPVV_TEST_AND_SET_VERBOSE(errors, A[0] != 5 || A[1] != 5); \n   OMPVV_TEST_AND_SET_VERBOSE(errors, A[50] != 50 || A[51] != 51);\n   OMPVV_TEST_AND_SET_VERBOSE(errors, new_struct.s != 10 || new_struct.S[0] != 10 || new_struct.S[1] != 10);\n\n   return errors;\n}\n\nint test_defaultmap_with_tofrom() {\n\n   struct test_struct {\n     int s;\n     int S[N];\n   };\n\n   int scalar; // scalar \n   int A[N]; // aggregate \n   struct test_struct new_struct; // aggregate variable -> structure\n   int *ptr; // scalar, pointer variable -> pointer\n\n   // initialize everything   \n   scalar = 1;\n   new_struct.s = 0;\n\n   for (i = 0; i < N; i++) {\n      A[i] = 0;\n      new_struct.S[i] = 0;\n   }\n\n   #pragma omp target defaultmap(tofrom) //map(tofrom: scalar, A, new_struct, ptr) \n   {\n      scalar = 17;    // Scalar firstprivate, value not returned\n      A[0] = 5; A[1] = 5; // Aggregate array, default is tofrom\n      new_struct.s = 10; new_struct.S[0] = 10; new_struct.S[1] = 10; // Aggregate structure, default is tofrom\n      ptr = &A[0]; ptr[50] = 50; ptr[51] = 51; // Pointer, default is private\n   }\n\n   OMPVV_TEST_AND_SET_VERBOSE(errors, scalar != 17); \n   OMPVV_TEST_AND_SET_VERBOSE(errors, A[0] != 5 || A[1] != 5); \n   OMPVV_TEST_AND_SET_VERBOSE(errors, A[50] != 50 || A[51] != 51);\n   OMPVV_TEST_AND_SET_VERBOSE(errors, new_struct.s != 10 || new_struct.S[0] != 10 || new_struct.S[1] != 10);\n\n   return errors;\n}\n\nint main() \n\n   errors = 0;\n\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_defaultmap_with_to() != 0);\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_defaultmap_with_from() != 0);\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_defaultmap_with_tofrom() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_memcpy_async_no_obj.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 1011",
        "issue_id": 2,
        "original_code": "//===--- test_target_memcpy_async_no_obj.c --------------------------------===//\n//\n//  OpenMP API Version 5.1 Nov 2020\n//\n//  Inspired from OpenMP 5.1 Examples Doc, 5.16.4 & 8.9\n//  This test utilizes the omp_target_memcpy_async construct to\n//  allocate memory on the device asynchronously. The construct\n//  uses 0 for 'depobj_count'; therefore, the generated target task\n//  is not a dependent task, but the memory copy is still asynchronous.\n//\n////===--------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint errors, i;\n\nint test_target_memcpy_async_no_obj() {\n\n    int h, t, i, err_r;\n    errors = 0;\n    double *mem;\n    double *mem_dev_cpy;\n    h = omp_get_initial_device();\n    t = omp_get_default_device();\n\n    OMPVV_TEST_AND_SET_VERBOSE(errors, omp_get_num_devices() < 1 || t < 0);\n\n    //allocate space on host & target\n    mem = (double *)malloc( sizeof(double)*N);\n    mem_dev_cpy = (double *)omp_target_alloc( sizeof(double)*N, t);\n\n    OMPVV_TEST_AND_SET_VERBOSE(errors, mem == NULL);\n    if(mem == NULL) {\n       return errors;\n    }\n\n    OMPVV_TEST_AND_SET_VERBOSE(errors, mem_dev_cpy == NULL);\n    if(mem_dev_cpy == NULL) {\n       return errors;\n    }\n\n    for(i = 0; i < N; i++){\n        mem[i] = i;\n    }   \n\n    /* copy to target */\n    err_r = omp_target_memcpy_async(mem_dev_cpy, mem, sizeof(double)*N,\n                                0,          0,\n                                t,          h,\n                                0,          NULL);\n    if(err_r) {\n       OMPVV_ERROR(\"omp_target_memcpy_async returns not 0\");\n       free(mem);\n       omp_target_free(mem_dev_cpy, t);\n       return errors;\n    }\n\n    #pragma omp taskwait\n    #pragma omp target is_device_ptr(mem_dev_cpy) device(t)\n    #pragma omp teams distribute parallel for\n    for(i = 0; i < N; i++){\n        mem_dev_cpy[i] = i*2; // initialize data on device\n    }\n    /* copy to host */\n    omp_target_memcpy_async(mem, mem_dev_cpy, sizeof(double)*N,\n                                0,          0,\n                                h,          t,\n                                0,          NULL);\n\n    #pragma omp taskwait\n    for(i = 0; i < N; i++){\n        OMPVV_TEST_AND_SET(errors, mem[i]!=i*2);\n    }\n    // free resources\n    free(mem);\n    omp_target_free(mem_dev_cpy, t);\n    return errors;\n}\n\nint main() {\n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_memcpy_async_no_obj() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_memcpy_async_no_obj.c --------------------------------===//\n//\n//  OpenMP API Version 5.1 Nov 2020\n//\n//  Inspired from OpenMP 5.1 Examples Doc, 5.16.4 & 8.9\n//  This test utilizes the omp_target_memcpy_async construct to\n//  allocate memory on the device asynchronously. The construct\n//  uses 0 for 'depobj_count'; therefore, the generated target task\n//  is not a dependent task, but the memory copy is still asynchronous.\n//\n////===--------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint errors, i;\n\nint test_target_memcpy_async_no_obj() {\n\n    int h, t, i, err_r;\n    errors = 0;\n    double *mem;\n    double *mem_dev_cpy;\n    h = omp_get_initial_device();\n    t = omp_get_default_device();\n\n    OMPVV_TEST_AND_SET_VERBOSE(errors, omp_get_num_devices() < 1 || t < 0);\n\n    //allocate space on host & target\n    mem = (double *)malloc( sizeof(double)*N);yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n    mem_dev_cpy = (double *)omp_target_alloc( sizeof(double)*N, t);\n\n    OMPVV_TEST_AND_SET_VERBOSE(errors, mem == NULL);\n    if(mem == NULL) {\n       return errors;\n    }\n\n    OMPVV_TEST_AND_SET_VERBOSE(errors, mem_dev_cpy == NULL);\n    if(mem_dev_cpy == NULL) {\n       return errors;\n    }\n\n    for(i = 0; i < N; i++){\n        mem[i] = i;\n    }   \n\n    /* copy to target */\n    err_r = omp_target_memcpy_async(mem_dev_cpy, mem, sizeof(double)*N,\n                                0,          0,\n                                t,          h,\n                                0,          NULL);\n    if(err_r) {\n       OMPVV_ERROR(\"omp_target_memcpy_async returns not 0\");\n       free(mem);\n       omp_target_free(mem_dev_cpy, t);\n       return errors;\n    }\n\n    #pragma omp taskwait\n    #pragma omp target is_device_ptr(mem_dev_cpy) device(t)\n    #pragma omp teams distribute parallel for\n    for(i = 0; i < N; i++){\n        mem_dev_cpy[i] = i*2; // initialize data on device\n    }\n    /* copy to host */\n    omp_target_memcpy_async(mem, mem_dev_cpy, sizeof(double)*N,\n                                0,          0,\n                                h,          t,\n                                0,          NULL);\n\n    #pragma omp taskwait\n    for(i = 0; i < N; i++){\n        OMPVV_TEST_AND_SET(errors, mem[i]!=i*2);\n    }\n    // free resources\n    free(mem);\n    omp_target_free(mem_dev_cpy, t);\n    return errors;\n}\n\nint main() {\n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_memcpy_async_no_obj() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_parallel_for_defaultmap.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 4437",
        "issue_id": 2,
        "original_code": "//===---- test_target_teams_distribute_parallel_for_defaultmap.c - combined consutrct -===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// Testing defaultmap of different scalar values. We check when it is off and when it is\n// on. The first one should not copy values back from the device of scalars. The second\n// should copy the values back even if they are not mapped explicitly.\n//\n//===----------------------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define ITERATIONS 10000\n\nint test_defaultmap_on() {\n  OMPVV_INFOMSG(\"test_defaultmap_on\");\n\n  int errors = 0;\n  int i;\n\n  // we try with all the scalars\n  char scalar_char = 'a';\n  char scalar_char_cpy[ITERATIONS];\n  short scalar_short = 10;\n  short scalar_short_cpy[ITERATIONS];\n  int scalar_int = 11;\n  int scalar_int_cpy[ITERATIONS];\n  float scalar_float = 5.5f;\n  float scalar_float_cpy[ITERATIONS];\n  double scalar_double = 10.45;\n  double scalar_double_cpy[ITERATIONS];\n  enum { VAL1 = 1, VAL2, VAL3, VAL4} scalar_enum = VAL1, scalar_enum_cpy[ITERATIONS];\n\n\n  // Testing the to behavior of the tofrom we use an array to avoid data\n  // races and check that all threads get the value\n#pragma omp target teams distribute parallel for defaultmap(tofrom: scalar)\n  for (i = 0; i < ITERATIONS; ++i) {\n    scalar_char_cpy[i] = scalar_char;\n    scalar_short_cpy[i] = scalar_short;\n    scalar_int_cpy[i] = scalar_int;\n    scalar_float_cpy[i] = scalar_float;\n    scalar_double_cpy[i] = scalar_double;\n    scalar_enum_cpy[i] = scalar_enum;\n  } // end of omp target\n\n  for (i = 0; i < ITERATIONS; ++i) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_char_cpy[i] != 'a');\n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_short_cpy[i] != 10);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_int_cpy[i] != 11);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(scalar_float_cpy[i] - 5.5f) > 0.0001);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(scalar_double_cpy[i] - 10.45) > 0.00001);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_enum_cpy[i] != VAL1);\n  }\n\n  // Map the same array to multiple devices. initialize with device number\n#pragma omp target teams distribute parallel for defaultmap(tofrom: scalar)\n  for (i = 0; i < ITERATIONS; ++i) {\n    if (omp_get_team_num() == 0) {\n      if (omp_get_thread_num() == 0) {\n        scalar_char = 'b';\n        scalar_short = 20;\n        scalar_int = 33;\n        scalar_float = 6.5f;\n        scalar_double = 20.45;\n        scalar_enum = VAL4;\n      }\n    }\n  } // end of omp target\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_char != 'b');\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_short != 20);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_int != 33);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(scalar_float - 6.5f) > 0.0001);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(scalar_double - 20.45) > 0.00001);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_enum != VAL4);\n\n  return errors;\n}\n\nint test_defaultmap_off() {\n  OMPVV_INFOMSG(\"test_defaultmap_off\");\n\n  int errors = 0;\n  int i;\n\n  // we try with all the scalars\n  char scalar_char = 'a';\n  char scalar_char_cpy[ITERATIONS];\n  short scalar_short = 10;\n  short scalar_short_cpy[ITERATIONS];\n  int scalar_int = 11;\n  int scalar_int_cpy[ITERATIONS];\n  float scalar_float = 5.5f;\n  float scalar_float_cpy[ITERATIONS];\n  double scalar_double = 10.45;\n  double scalar_double_cpy[ITERATIONS];\n  enum { VAL1 = 1, VAL2, VAL3, VAL4} scalar_enum = VAL1, scalar_enum_cpy[ITERATIONS];\n\n  // Testing the copy behavior of the firstprivatization. we use an array to avoid data\n  // races and check that all threads get the value\n#pragma omp target teams distribute parallel for \n  for (i = 0; i < ITERATIONS; ++i) {\n    scalar_char_cpy[i] = scalar_char;\n    scalar_short_cpy[i] = scalar_short;\n    scalar_int_cpy[i] = scalar_int;\n    scalar_float_cpy[i] = scalar_float;\n    scalar_double_cpy[i] = scalar_double;\n    scalar_enum_cpy[i] = scalar_enum;\n  } // end of omp target\n\n  for (i = 0; i < ITERATIONS; ++i) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_char_cpy[i] != 'a');\n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_short_cpy[i] != 10);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_int_cpy[i] != 11);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(scalar_float_cpy[i] - 5.5f) > 0.0001);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(scalar_double_cpy[i] - 10.45) > 0.00001);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_enum_cpy[i] != VAL1);\n  }\n  \n#pragma omp target teams distribute parallel for\n  for (i = 0; i < 1; ++i) {\n      scalar_char = 'b';\n      scalar_short = 20;\n      scalar_int = 33;\n      scalar_float = 6.5f;\n      scalar_double = 20.45;\n      scalar_enum = VAL4;\n  } // end of omp target\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_char != 'a');\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_short != 10);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_int != 11);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(scalar_float - 5.5f) > 0.0001);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(scalar_double - 10.45) > 0.0001);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_enum != VAL1);\n\n  return errors;\n}\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_defaultmap_on());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_defaultmap_off());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_teams_distribute_parallel_for_defaultmap.c - combined consutrct -===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// Testing defaultmap of different scalar values. We check when it is off and when it is\n// on. The first one should not copy values back from the device of scalars. The second\n// should copy the values back even if they are not mapped explicitly.\n//\n//===----------------------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define ITERATIONS 10000\n\nint test_defaultmap_on() {\n  OMPVV_INFOMSG(\"test_defaultmap_on\");\n\n  int errors = 0;\n  int i;\n\n  // we try with all the scalars\n  char scalar_char = 'a';\n  char scalar_char_cpy[ITERATIONS];\n  short scalar_short = 10;\n  short scalar_short_cpy[ITERATIONS];\n  int scalar_int = 11;\n  int scalar_int_cpy[ITERATIONS];\n  float scalar_float = 5.5f;\n  float scalar_float_cpy[ITERATIONS];\n  double scalar_double = 10.45;\n  double scalar_double_cpy[ITERATIONS];\n  enum { VAL1 = 1, VAL2, VAL3, VAL4} scalar_enum = VAL1, scalar_enum_cpy[ITERATIONS];\n\n\n  // Testing the to behavior of the tofrom we use an array to avoid data\n  // races and check that all threads get the value\n#pragma omp target teams distribute parallel for defaultmap(tofrom: scalar)\n  for (i = 0; i < ITERATIONS; ++i) {\n    scalar_char_cpy[i] = scalar_char;\n    scalar_short_cpy[i] = scalar_short;\n    scalar_int_cpy[i] = scalar_int;\n    scalar_float_cpy[i] = scalar_float;\n    scalar_double_cpy[i] = scalar_double;\n    scalar_enum_cpy[i] = scalar_enum;\n  } // end of omp target\n\n  for (i = 0; i < ITERATIONS; ++i) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_char_cpy[i] != 'a');\n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_short_cpy[i] != 10);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_int_cpy[i] != 11);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(scalar_float_cpy[i] - 5.5f) > 0.0001);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(scalar_double_cpy[i] - 10.45) > 0.00001);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_enum_cpy[i] != VAL1);\n  }\n\n  // Map the same array to multiple devices. initialize with device number\n#pragma omp target teams distribute parallel for defaultmap(tofrom: scalar)\n  for (i = 0; i < ITERATIONS; ++i) {\n    if (omp_get_team_num() == 0) {\n      if (omp_get_thread_num() == 0) {\n        scalar_char = 'b';\n        scalar_short = 20;\n        scalar_int = 33;\n        scalar_float = 6.5f;\n        scalar_double = 20.45;\n        scalar_enum = VAL4;\n      }\n    }\n  } // end of omp target\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_char != 'b');\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_short != 20);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_int != 33);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(scalar_float - 6.5f) > 0.0001);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(scalar_double - 20.45) > 0.00001);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_enum != VAL4);\n\n  return errors;\n}\n\nint test_defaultmap_off() {\n  OMPVV_INFOMSG(\"test_defaultmap_off\");\n\n  int errors = 0;\n  int i;\n\n  // we try with all the scalars\n  char scalar_char = 'a';\n  char scalar_char_cpy[ITERATIONS];\n  short scalar_short = 10;\n  short scalar_short_cpy[ITERATIONS];\n  int scalar_int = 11;\n  int scalar_int_cpy[ITERATIONS];\n  float scalar_float = 5.5f;\n  float scalar_float_cpy[ITERATIONS];\n  double scalar_double = 10.45;\n  double scalar_double_cpy[ITERATIONS];\n  enum { VAL1 = 1, VAL2, VAL3, VAL4} scalar_enum = VAL1, scalar_enum_cpy[ITERATIONS];\n\n  // Testing the copy behavior of the firstprivatization. we use an array to avoid data\n  // races and check that all threads get the value\n#pragma omp target teams distribute parallel for \n  for (i = 0; i < ITERATIONS; ++i) {\n    scalar_char_cpy[i] = scalar_char;\n    scalar_short_cpy[i] = scalar_short;\n    scalar_int_cpy[i] = scalar_int;\n    scalar_float_cpy[i] = scalar_float;\n    scalar_double_cpy[i] = scalar_double;\n    scalar_enum_cpy[i] = scalar_enum;\n  } // end of omp target\n\n  for (i = 0; i < ITERATIONS; ++i) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_char_cpy[i] != 'a');\n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_short_cpy[i] != 10);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_int_cpy[i] != 11);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(scalar_float_cpy[i] - 5.5f) > 0.0001);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(scalar_double_cpy[i] - 10.45) > 0.00001);yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_enum_cpy[i] != VAL1);\n  }\n  \n#pragma omp target teams distribute parallel for\n  for (i = 0; i < 1; ++i) {\n      scalar_char = 'b';\n      scalar_short = 20;\n      scalar_int = 33;\n      scalar_float = 6.5f;\n      scalar_double = 20.45;\n      scalar_enum = VAL4;\n  } // end of omp target\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_char != 'a');\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_short != 10);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_int != 11);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(scalar_float - 5.5f) > 0.0001);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, fabs(scalar_double - 10.45) > 0.0001);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_enum != VAL1);\n\n  return errors;\n}\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_defaultmap_on());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_defaultmap_off());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_reduction_or.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 2410",
        "issue_id": 1,
        "original_code": "//===--- test_target_teams_distribute_reduction_or.c-------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the reduction clause on a target teams distribute directive,\n// testing that the variable in the reduction clause is properly reduced using\n// the or operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n#define THRESHOLD 512\n\nint test_or() {\n  char a[N];\n  double true_margin = pow(exp(1), log(.5)/N);   // See the 'and' operator test for\n  int errors = 0;                                // an explanation of this math.\n  int num_teams[N];\n  int tested_true = 0;\n  int tested_false = 0;\n  int itr_count = 0;\n  srand(1);\n\n  while ((!tested_true || !tested_false) && (itr_count < THRESHOLD)) {\n    for (int x = 0; x < N; ++x) {\n      a[x] = rand() / (double)(RAND_MAX) > true_margin;\n      num_teams[x] = -x;\n    }\n\n    char result = 0;\n    char host_result = 0;\n\n#pragma omp target teams distribute reduction(||:result) defaultmap(tofrom:scalar)\n    for (int x = 0; x < N; ++x) {\n      num_teams[x] = omp_get_num_teams();\n      result = result || a[x];\n    }\n\n    for (int x = 0; x < N; ++x) {\n      host_result = host_result || a[x];\n    }\n\n    if (itr_count == 0) {\n      for (int x = 1; x < N; ++x) {\n        OMPVV_WARNING_IF(num_teams[x - 1] != num_teams[x], \"Kernel reported differing numbers of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n      }\n      OMPVV_WARNING_IF(num_teams[0] == 1, \"Test operated with one team.  Reduction clause cannot be tested.\");\n      OMPVV_WARNING_IF(num_teams[0] <= 0, \"Test reported invalid number of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n    }\n\n    OMPVV_TEST_AND_SET_VERBOSE(errors, host_result != result);\n    OMPVV_ERROR_IF(host_result != result, \"Result on device is %d but expected result from host is %d.\", result, host_result);\n\n    if (host_result) {\n      tested_true = 1;\n    } else {\n      tested_false = 1;\n    }\n\n    if (host_result != result) {\n      break;\n    }\n\n    itr_count++;\n  }\n\n  OMPVV_WARNING_IF(!tested_true, \"Did not test a case in which final result was true.\");\n  OMPVV_WARNING_IF(!tested_false, \"Did not test a case in which final result was false.\");\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_or() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_reduction_or.c-------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the reduction clause on a target teams distribute directive,\n// testing that the variable in the reduction clause is properly reduced using\n// the or operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n#define THRESHOLD 512\n\nint test_or() {\n  char a[N];\n  double true_margin = pow(exp(1), log(.5)/N);   // See the 'and' operator test for\n  int errors = 0;                                // an explanation of this math.\n  int num_teams[N];\n  int tested_true = 0;\n  int tested_false = 0;\n  int itr_count = 0;\n  srand(1);\n\n  while ((!tested_true || !tested_false) && (itr_count < THRESHOLD)) {\n    for (int x = 0; x < N; ++x) {\n      a[x] = rand() / (double)(RAND_MAX) > true_margin;\n      num_teams[x] = -x;\n    }\n\n    char result = 0;\n    char host_result = 0;\n\n#pragma omp target teams distribute reduction(||:result) defaultmap(tofrom:scalar)\n    for (int x = 0; x < N; ++x) {\n      num_teams[x] = omp_get_num_teams();\n      result = result || a[x];\n    }\n\n    for (int x = 0; x < N; ++x) {\n      host_result = host_result || a[x];\n    }\n\n    if (itr_count == 0) {\n      for (int x = 1; x < N; ++x) {\n        OMPVV_WARNING_IF(num_teams[x - 1] != num_teams[x], \"Kernel reported differing numbers of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n      }\n      OMPVV_WARNING_IF(num_teams[0] == 1, \"Test operated with one team.  Reduction clause cannot be tested.\");\n      OMPVV_WARNING_IF(num_teams[0] <= 0, \"Test reported invalid number of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n    }\n\n    OMPVV_TEST_AND_SET_VERBOSE(errors, host_result != result);\n    OMPVV_ERROR_IF(host_result != result, \"Result on device is %d but expected result from host is %d.\", result, host_result);\n\n    if (host_result) {\n      tested_true = 1;\n    } else {\n      tested_false = 1;\n    }\n\n    if (host_result != result) {\n      break;\n    }\n\n    itr_count++;\n  }\n\n  OMPVV_WARNING_IF(!tested_true, \"Did not test a case in which final result was true.\");\n  OMPVV_WARNING_IF(!tested_false, \"Did not test a case in which final result was false.\");\n\n  return errors;\n}\n\nint main() \n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_or() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_requires_unified_shared_memory_malloc_map.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp requires\" with directive \"#pragma omp cancel\" at position 585",
        "issue_id": 0,
        "original_code": "//===---test_requires_unified_shared_memory_malloc_map.c ----------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n// \n// This test checks for unified shared memory of an array that is allocated using \n// malloc and that is accessed from host and device with the same pointer.\n//\n// The mapping of a pointer under shared memory should allow for the pointer to\n// have the same value as in the host.\n//\n////===----------------------------------------------------------------------===//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp requires unified_shared_memory\n\nint unified_shared_memory_malloc_map() {\n  OMPVV_INFOMSG(\"Unified shared memory testing - Array on malloc\");\n  int errors = 0;\n\n  int *anArray;\n  int *anArrayCopy;\n\n  anArray = (int*)malloc(sizeof(int)*N);\n  anArrayCopy = (int*)malloc(sizeof(int)*N);\n\n  if( anArray == NULL ) {\n    OMPVV_ERROR(\"Memory for anArray was not allocated\");\n    OMPVV_RETURN(1);\n  }\n\n  if( anArrayCopy == NULL ) {\n    OMPVV_ERROR(\"Memory for anArrayCopy was not allocated\");\n    OMPVV_RETURN(1);\n  }\n  \n  for (int i = 0; i < N; i++) {\n    anArray[i] = i;\n    anArrayCopy[i] = 0;\n  }\n  // Modify in the device\n#pragma omp target map(anArray)\n  {\n    for (int i = 0; i < N; i++) {\n      anArray[i] += 10;\n    }\n  }\n  // Modify again on the host\n  for (int i = 0; i < N; i++) {\n    anArray[i] += 10;\n  }\n\n  // Get the value the device is seeing\n#pragma omp target map(anArray)\n  {\n    for (int i = 0; i < N; i++) {\n      anArrayCopy[i] = anArray[i];\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArray[i] != i + 20);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArrayCopy[i] != i + 20);\n    if (errors) break;\n  }\n\n  free(anArray);\n  free(anArrayCopy);\n  return errors;\n}\n\nint main() {\n  int isOffloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"With no offloading, unified shared memory is guaranteed due to host execution\");\n  int errors = 0;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, unified_shared_memory_malloc_map());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n\n",
        "error_code": "//===---test_requires_unified_shared_memory_malloc_map.c ----------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n// \n// This test checks for unified shared memory of an array that is allocated using \n// malloc and that is accessed from host and device with the same pointer.\n//\n// The mapping of a pointer under shared memory should allow for the pointer to\n// have the same value as in the host.\n//\n////===----------------------------------------------------------------------===//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp cancel unified_shared_memory\n\nint unified_shared_memory_malloc_map() {\n  OMPVV_INFOMSG(\"Unified shared memory testing - Array on malloc\");\n  int errors = 0;\n\n  int *anArray;\n  int *anArrayCopy;\n\n  anArray = (int*)malloc(sizeof(int)*N);\n  anArrayCopy = (int*)malloc(sizeof(int)*N);\n\n  if( anArray == NULL ) {\n    OMPVV_ERROR(\"Memory for anArray was not allocated\");\n    OMPVV_RETURN(1);\n  }\n\n  if( anArrayCopy == NULL ) {\n    OMPVV_ERROR(\"Memory for anArrayCopy was not allocated\");\n    OMPVV_RETURN(1);\n  }\n  \n  for (int i = 0; i < N; i++) {\n    anArray[i] = i;\n    anArrayCopy[i] = 0;\n  }\n  // Modify in the device\n#pragma omp target map(anArray)\n  {\n    for (int i = 0; i < N; i++) {\n      anArray[i] += 10;\n    }\n  }\n  // Modify again on the host\n  for (int i = 0; i < N; i++) {\n    anArray[i] += 10;\n  }\n\n  // Get the value the device is seeing\n#pragma omp target map(anArray)\n  {\n    for (int i = 0; i < N; i++) {\n      anArrayCopy[i] = anArray[i];\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArray[i] != i + 20);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArrayCopy[i] != i + 20);\n    if (errors) break;\n  }\n\n  free(anArray);\n  free(anArrayCopy);\n  return errors;\n}\n\nint main() {\n  int isOffloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"With no offloading, unified shared memory is guaranteed due to host execution\");\n  int errors = 0;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, unified_shared_memory_malloc_map());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_num_teams.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 1239",
        "issue_id": 2,
        "original_code": "//===--- test_target_teams_distribute_num_teams.c----------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the num_teams clause on a target teams distribute directive to\n// indicate a requested number of teams to execute the teams distribute region.\n// The specifications indicate that the number of teams that are given can be any\n// number that is equal to or less than the indicated value.  We first run a\n// target teams distribute region without the clause to see what the default\n// number of teams is, and then we use a value that is less than that in the\n// test of the num_teams clause.  If the region is run with more teams than\n// indicated, the test errors.  If the region is run with less teams than\n// indicated, the test issues a warning since it is known that the device can\n// run with more teams than was actually given.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main() {\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  int a[N];\n  int b[N];\n  int c[N];\n  int num_teams[N];\n  int default_num_teams = 0;\n  int errors = 0;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    c[x] = 0;\n  }\n\n#pragma omp target teams distribute map(tofrom: default_num_teams, c[0:N]) map(to: a[0:N], b[0:N])\n  for (int x = 0; x < N; ++x) {\n    if (omp_get_team_num() == 0) {\n      default_num_teams = omp_get_num_teams();\n    }\n    c[x] = a[x] + b[x];\n  }\n\n\n  if (default_num_teams == 1) {\n    OMPVV_WARNING(\"Test operated with one team.  Testing num_teams clause cannot be done.\");\n  } else if(default_num_teams <= 0) {\n    OMPVV_ERROR(\"Test returned num_teams <= 0.\");\n    errors = 1;\n  } else {\n#pragma omp target teams distribute num_teams(default_num_teams / 2) map(to: a[0:N], b[0:N]) \\\n  map(from: c[0:N], num_teams[0:N])\n    for (int x = 0; x < N; ++x) {\n      num_teams[x] = omp_get_num_teams();\n      c[x] = a[x] + b[x];\n    }\n\n    for (int i = 1; i < N; ++i) {\n      if (num_teams[i] != num_teams[i - 1]) {\n        errors += 1;\n        OMPVV_ERROR(\"omp_get_num_teams returned an inconsistent number of teams between iterations.\");\n        break;\n      }\n    }\n\n    if (num_teams[0] > default_num_teams / 2) {\n      errors += 1;\n      OMPVV_ERROR(\"Test ran on more teams than requested.\");\n      return errors;\n    } else if (num_teams[0] < default_num_teams / 2) {\n      OMPVV_WARNING(\"Test ran on less teams than requested. This is still spec-conformant.\");\n    } else {\n      OMPVV_INFOMSG(\"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n    }\n  }\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_num_teams.c----------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the num_teams clause on a target teams distribute directive to\n// indicate a requested number of teams to execute the teams distribute region.\n// The specifications indicate that the number of teams that are given can be any\n// number that is equal to or less than the indicated value.  We first run a\n// target teams distribute region without the clause to see what the default\n// number of teams is, and then we use a value that is less than that in the\n// test of the num_teams clause.  If the region is run with more teams than\n// indicated, the test errors.  If the region is run with less teams than\n// indicated, the test issues a warning since it is known that the device can\n// run with more teams than was actually given.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main() {\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  int a[N];\n  int b[N];\n  int c[N];\n  int num_teams[N];\n  int default_num_teams = 0;\n  int errors = 0;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    c[x] = 0;\n  }\n\n#pragma omp target teams distribute map(tofrom: default_num_teams, c[0:N]) map(to: a[0:N], b[0:N])\n  for (int x = 0; x < N; ++x) {\n    if (omp_get_team_num() == 0) {\n      default_num_teams = omp_get_num_teams();\n    }\n    c[x] = a[x] + b[x];\n  }\n\n\n  if (default_num_teams == 1) {\n    OMPVV_WARNING(\"Test operated with one team.  Testing num_teams clause cannot be done.\");\n  } else if(default_num_teams <= 0) {\n    OMPVV_ERROR(\"Test returned num_teams <= 0.\");\n    errors = 1;\n  } else {\n#pragma omp target teams distribute num_teams(default_num_teams / 2) map(to: a[0:N], b[0:N]) \\\n  map(from: c[0:N], num_teams[0:N])\n    for (int x = 0; x < N; ++x) {\n      num_teams[x] = omp_get_num_teams();\n      c[x] = a[x] + b[x];\n    }\n\n    for (int i = 1; i < N; ++i) {\n      if (num_teams[i] != num_teams[i - 1]) {\n        errors += 1;\n        OMPVV_ERROR(\"omp_get_num_teams returned an inconsistent number of teams between iterations.\");\n        break;\n      }\n    }\n\n    if (num_teams[0] > default_num_teams / 2) {\n      errors += 1;\n      OMPVV_ERROR(\"Test ran on more teams than requested.\");\n      return errors;\n    } else if (num_teams[0] < default_num_teams / 2) {\n      OMPVV_WARNING(\"Test ran on less teams than requested. This is still spec-conformant.\");\n    } else {\n      OMPVV_INFOMSG(\"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n    }\n  }\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_requires_atomic_default_mem_order_relaxed.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp requires\" with directive \"#pragma omp single\" at position 669",
        "issue_id": 0,
        "original_code": "//===---test_target_requires_atomic_default_mem_order_relaxed.c--------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n// \n// This test checks for support of the atomic_default_mem_order clause on the \n// requires directive. This clause determines the default memory behavior for\n// atomic constructs. These behaviors are seq_cst, acq_rel, and relaxed.\n// This test checks for relaxed as the memory-order-clause.\n//\n// Adapted from 5.0 OpenMP example acquire_release.3.c\n////===----------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp requires atomic_default_mem_order(relaxed)\n\nint test_target_requires_atomic_relaxed() {\n  OMPVV_INFOMSG(\"test_target_requires_atomic_relaxed\");\n\n  int x = 0, y = 0;\n  int errors = 0;\n\n#pragma omp target parallel num_threads(2) map(tofrom: x, y, errors)\n   {\n      int thrd = omp_get_thread_num();\n       if (thrd == 0) {\n          x = 10;\n          #pragma omp flush\n          #pragma omp atomic write \n          y = 1;\n       } else {\n          int tmp = 0;\n          while (tmp == 0) {\n            #pragma omp atomic read \n            tmp = y;\n          }\n          #pragma omp flush\n          OMPVV_TEST_AND_SET(errors, x != 10);\n       }\n   }\n   OMPVV_ERROR_IF(errors > 0, \"Requires atomic_default_mem_order(relaxed) test failed\");\n   return errors;\n}\n\n\nint main() {\n\n  int errors = 0;\n\n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_requires_atomic_relaxed());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---test_target_requires_atomic_default_mem_order_relaxed.c--------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n// \n// This test checks for support of the atomic_default_mem_order clause on the \n// requires directive. This clause determines the default memory behavior for\n// atomic constructs. These behaviors are seq_cst, acq_rel, and relaxed.\n// This test checks for relaxed as the memory-order-clause.\n//\n// Adapted from 5.0 OpenMP example acquire_release.3.c\n////===----------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp single atomic_default_mem_order(relaxed)\n\nint test_target_requires_atomic_relaxed() {\n  OMPVV_INFOMSG(\"test_target_requires_atomic_relaxed\");\n\n  int x = 0, y = 0;\n  int errors = 0;\n\n#pragma omp target parallel num_threads(2) map(tofrom: x, y, errors)\n   {\n      int thrd = omp_get_thread_num();\n       if (thrd == 0) {\n          x = 10;\n          #pragma omp flush\n          #pragma omp atomic write \n          y = 1;\n       } else {\n          int tmp = 0;\n          while (tmp == 0) {\n            #pragma omp atomic read \n            tmp = y;\n          }\n          #pragma omp flush\n          OMPVV_TEST_AND_SET(errors, x != 10);\n       }\n   }\n   OMPVV_ERROR_IF(errors > 0, \"Requires atomic_default_mem_order(relaxed) test failed\");\n   return errors;\n}\n\n\nint main() {\n\n  int errors = 0;\n\n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_requires_atomic_relaxed());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_update_to_from_lvalue_ternary.cpp",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp teams\" at position 565",
        "issue_id": 0,
        "original_code": "//===------ test_target_update_to_from_lvalue_ternary.cpp ----------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test evaluates the target update directive using to and from clauses, \n// supporting various lvalue expressions, such as ternary operators. \n//===-------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <iostream>\n#include \"ompvv.h\"\n\nint test_target_update() {\n\tint errors = 0;\n\tint before_value;\n\tint after_value;\n\tint a = -1;\n\tint b = 1;\n\tbool c = true;\n\n\t// Map the variable a and b\n\t#pragma omp target enter data map(to: a, b)\n\n\t// Before should be set to -1 as c is true and a is -1\n\t#pragma omp target map(from: before_value)\n\t{\n\t\tbefore_value = c ? a : b;\n\t}\n\n\t// Set c to false\n\tc = false;\n\n\t// Copy data from the host to the device => b\n\t#pragma omp target update to(c ? a : b)\n\n\t// After should be set to 1 as c is false and b is 1\n\t// b should now be set to 2, as c is false\n\t#pragma omp target map(from: after_value)\n\t{\n\t\tafter_value = c ? a : b;\n\t\tif (c){\n\t\t\ta = 2;\n\t\t}\n\t\telse {\n\t\t\tb = 2;\n\t\t}\n\t}\n\n\t// Copy the updated value from the device to the host variable => b = 2\n\t#pragma omp target update from(c ? a : b)\n\n\n\t// Exit data region, mapping the variable back from the target device to the host\n\t#pragma omp target exit data map(delete: a, b)\n\n\t// Verify the results\n\tOMPVV_TEST_AND_SET(errors, (c ? a : b) != 2);\n        OMPVV_TEST_AND_SET(errors, before_value != -1);\n        OMPVV_TEST_AND_SET(errors, after_value != 1);\n\treturn errors;\n}\n\nint main() {\n\tOMPVV_TEST_OFFLOADING;\n\t\n\tint errors = 0;\n\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_target_update() != 0);\n\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n\n",
        "error_code": "//===------ test_target_update_to_from_lvalue_ternary.cpp ----------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test evaluates the target update directive using to and from clauses, \n// supporting various lvalue expressions, such as ternary operators. \n//===-------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <iostream>\n#include \"ompvv.h\"\n\nint test_target_update() {\n\tint errors = 0;\n\tint before_value;\n\tint after_value;\n\tint a = -1;\n\tint b = 1;\n\tbool c = true;\n\n\t// Map the variable a and b\n\t#pragma omp teams enter data map(to: a, b)\n\n\t// Before should be set to -1 as c is true and a is -1\n\t#pragma omp target map(from: before_value)\n\t{\n\t\tbefore_value = c ? a : b;\n\t}\n\n\t// Set c to false\n\tc = false;\n\n\t// Copy data from the host to the device => b\n\t#pragma omp target update to(c ? a : b)\n\n\t// After should be set to 1 as c is false and b is 1\n\t// b should now be set to 2, as c is false\n\t#pragma omp target map(from: after_value)\n\t{\n\t\tafter_value = c ? a : b;\n\t\tif (c){\n\t\t\ta = 2;\n\t\t}\n\t\telse {\n\t\t\tb = 2;\n\t\t}\n\t}\n\n\t// Copy the updated value from the device to the host variable => b = 2\n\t#pragma omp target update from(c ? a : b)\n\n\n\t// Exit data region, mapping the variable back from the target device to the host\n\t#pragma omp target exit data map(delete: a, b)\n\n\t// Verify the results\n\tOMPVV_TEST_AND_SET(errors, (c ? a : b) != 2);\n        OMPVV_TEST_AND_SET(errors, before_value != -1);\n        OMPVV_TEST_AND_SET(errors, after_value != 1);\n\treturn errors;\n}\n\nint main() {\n\tOMPVV_TEST_OFFLOADING;\n\t\n\tint errors = 0;\n\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_target_update() != 0);\n\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_loop_reduction_max_device.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 609",
        "issue_id": 2,
        "original_code": "//===--- test_loop_reduction_max_device.c -----------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the reduction clause on a loop directive, testing that the\n// variable in the reduction clause is properly reduced using the max\n// operator. This test checks the above in a target context.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_max() {\n  int a[N];\n  int b[N];\n  int errors = 0;\n  int num_threads[N];\n  srand(1);\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = (int) rand() / (double)(RAND_MAX / 100);\n    b[x] = (int) rand() / (double)(RAND_MAX / 100);\n    num_threads[x] = -x;\n  }\n\n  int result = 0;\n\n#pragma omp target parallel num_threads(OMPVV_NUM_THREADS_DEVICE) map(tofrom: result, a, b, num_threads)\n  {\n#pragma omp loop reduction(max:result)\n    for (int x = 0; x < N; ++x) {\n      result = fmax(a[x] + b[x], result);\n    }\n#pragma omp for\n    for (int x = 0; x < N; ++x) {\n      num_threads[x] = omp_get_num_threads();\n    }\n  }\n\n  int host_max = 0;\n\n  for (int x = 0; x < N; ++x) {\n    host_max = fmax(host_max, a[x] + b[x]);\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_threads[x - 1] != num_threads[x], \"Test reported differing numbers of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_threads[0] == 1, \"Test operated with one thread.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_threads[0] <= 0, \"Test reported invalid number of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != host_max);\n  OMPVV_ERROR_IF(host_max != result, \"Max from loop directive is %d but expected max is %d.\", result, host_max);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_max() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n",
        "error_code": "//===--- test_loop_reduction_max_device.c -----------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the reduction clause on a loop directive, testing that the\n// variable in the reduction clause is properly reduced using the max\n// operator. This test checks the above in a target context.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_max() {\n  int a[N];\n  int b[N];\n  int errors = 0;\n  int num_threads[N];yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n  srand(1);\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = (int) rand() / (double)(RAND_MAX / 100);\n    b[x] = (int) rand() / (double)(RAND_MAX / 100);\n    num_threads[x] = -x;\n  }\n\n  int result = 0;\n\n#pragma omp target parallel num_threads(OMPVV_NUM_THREADS_DEVICE) map(tofrom: result, a, b, num_threads)\n  {\n#pragma omp loop reduction(max:result)\n    for (int x = 0; x < N; ++x) {\n      result = fmax(a[x] + b[x], result);\n    }\n#pragma omp for\n    for (int x = 0; x < N; ++x) {\n      num_threads[x] = omp_get_num_threads();\n    }\n  }\n\n  int host_max = 0;\n\n  for (int x = 0; x < N; ++x) {\n    host_max = fmax(host_max, a[x] + b[x]);\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_threads[x - 1] != num_threads[x], \"Test reported differing numbers of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_threads[0] == 1, \"Test operated with one thread.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_threads[0] <= 0, \"Test reported invalid number of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != host_max);\n  OMPVV_ERROR_IF(host_max != result, \"Max from loop directive is %d but expected max is %d.\", result, host_max);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_max() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_teams.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1617",
        "issue_id": 1,
        "original_code": "//===--- test_teams.c-------------------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the teams directive on host and verifies of the \n// requested number of teams with requested number of threads were \n// created. \n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\nint main() {\n  int num_teams[OMPVV_NUM_TEAMS_DEVICE];\n  int num_threads[OMPVV_NUM_THREADS_DEVICE];\n  int errors[2] = {0,0};\n\n\n  for (int x = 0; x < OMPVV_NUM_TEAMS_DEVICE; ++x) {\n    num_teams[x] = -99;\n  }\n\n  for (int x = 0; x < OMPVV_NUM_THREADS_DEVICE; ++x) {\n    num_threads[x] = -99;\n  }\n\n#pragma omp teams num_teams(OMPVV_NUM_TEAMS_DEVICE) thread_limit(OMPVV_NUM_THREADS_DEVICE)\n  {\n    num_teams[omp_get_team_num()] = omp_get_num_teams();\n#pragma omp parallel master\n    num_threads[omp_get_team_num()]= omp_get_num_threads();\n  }\n\n  if (num_teams[0] == 1) {\n    OMPVV_WARNING(\"Test operated with one team. num_teams requested were %d.\", OMPVV_NUM_TEAMS_DEVICE);\n  } else if (num_teams[0] < 1) {\n    OMPVV_ERROR(\"omp_get_num_teams() reported a value less than one.\");\n  }\n\n  if (num_threads[0] == 1) {\n    OMPVV_WARNING(\"Team 0 reported only 1 thread. thread_limit was set to %d.\", OMPVV_NUM_THREADS_DEVICE);\n  } else if (num_threads[0] < 1) {\n    OMPVV_ERROR(\"omp_get_num_threads() reported a value below one.\");\n  }\n  for (int x = 1; x < num_teams[0]; ++x) {\n    if (num_teams[x] != num_teams[x - 1]) {\n      errors[0]++;\n    }\n    if (num_threads[x] != num_threads[x - 1]) {\n      errors[1]++;\n    }\n  }\n\n  OMPVV_INFOMSG_IF(!(errors[0] + errors[1]), \"Test passed with %d teams and %d threads per team.\", num_teams[0], num_threads[0]);\n\n  OMPVV_REPORT_AND_RETURN(errors[0] + errors[1]);\n}\n",
        "error_code": "//===--- test_teams.c-------------------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the teams directive on host and verifies of the \n// requested number of teams with requested number of threads were \n// created. \n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\nint main() {\n  int num_teams[OMPVV_NUM_TEAMS_DEVICE];\n  int num_threads[OMPVV_NUM_THREADS_DEVICE];\n  int errors[2] = {0,0};\n\n\n  for (int x = 0; x < OMPVV_NUM_TEAMS_DEVICE; ++x) {\n    num_teams[x] = -99;\n  }\n\n  for (int x = 0; x < OMPVV_NUM_THREADS_DEVICE; ++x) {\n    num_threads[x] = -99;\n  }\n\n#pragma omp teams num_teams(OMPVV_NUM_TEAMS_DEVICE) thread_limit(OMPVV_NUM_THREADS_DEVICE)\n  {\n    num_teams[omp_get_team_num()] = omp_get_num_teams();\n#pragma omp parallel master\n    num_threads[omp_get_team_num()]= omp_get_num_threads();\n  }\n\n  if (num_teams[0] == 1) {\n    OMPVV_WARNING(\"Test operated with one team. num_teams requested were %d.\", OMPVV_NUM_TEAMS_DEVICE);\n  } else if (num_teams[0] < 1) {\n    OMPVV_ERROR(\"omp_get_num_teams() reported a value less than one.\");\n  }\n\n  if (num_threads[0] == 1) {\n    OMPVV_WARNING(\"Team 0 reported only 1 thread. thread_limit was set to %d.\", OMPVV_NUM_THREADS_DEVICE);\n  } else if (num_threads[0] < 1) {\n    OMPVV_ERROR(\"omp_get_num_threads() reported a value below one.\");\n  }\n  for (int x = 1; x < num_teams[0]; ++x) {\n    if (num_teams[x] != num_teams[x - 1]) {\n      errors[0]++;\n    }\n    if (num_threads[x] != num_threads[x - 1]) \n      errors[1]++;\n    }\n  }\n\n  OMPVV_INFOMSG_IF(!(errors[0] + errors[1]), \"Test passed with %d teams and %d threads per team.\", num_teams[0], num_threads[0]);\n\n  OMPVV_REPORT_AND_RETURN(errors[0] + errors[1]);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_taskloop_in_reduction_device.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 814",
        "issue_id": 2,
        "original_code": "//===--- test_taskloop_in_reduction_device.c ------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the taskloop directive with the `in_reduction` reduction\n// participation clause. It performs simple array operations which are added\n// to a reduction variable in a taskloop with the in_reduction clause. This\n// test checks the above in a target context.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_taskloop_in_reduction() {\n  OMPVV_INFOMSG(\"test_taskloop_in_reduction_device\");\n  int errors = 0;\n  int num_threads = -1;\n  int y[N];\n  int z[N];\n  int sum = 0;\n  int expected_sum = 0;\n\n  for (int i = 0; i < N; i++) {\n    y[i] = i + 1;\n    z[i] = 2*(i + 1);\n  }\n\n#pragma omp target parallel reduction(task, +: sum) num_threads(OMPVV_NUM_THREADS_DEVICE) shared(y, z, num_threads) defaultmap(tofrom)\n  {\n#pragma omp master\n    {\n#pragma omp taskloop in_reduction(+: sum)\n      for (int i = 0; i < N; i++) {\n        sum += y[i]*z[i];\n      }\n      num_threads = omp_get_num_threads();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    expected_sum += y[i]*z[i];\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, sum != expected_sum);\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of taskloop can't be guaranteed.\");\n  OMPVV_ERROR_IF(num_threads < 1, \"Test returned an invalid number of threads.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n\n  return errors;\n}\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_taskloop_in_reduction());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_taskloop_in_reduction_device.c ------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the taskloop directive with the `in_reduction` reduction\n// participation clause. It performs simple array operations which are added\n// to a reduction variable in a taskloop with the in_reduction clause. This\n// test checks the above in a target context.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_taskloop_in_reduction() {\n  OMPVV_INFOMSG(\"test_taskloop_in_reduction_device\");\n  int errors = 0;\n  int num_threads = -1;\n  int y[N];\n  int z[N];\n  int sum = 0;\n  int expected_sum = 0;\n\n  for (int i = 0;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1; i < N; i++) {\n    y[i] = i + 1;\n    z[i] = 2*(i + 1);\n  }\n\n#pragma omp target parallel reduction(task, +: sum) num_threads(OMPVV_NUM_THREADS_DEVICE) shared(y, z, num_threads) defaultmap(tofrom)\n  {\n#pragma omp master\n    {\n#pragma omp taskloop in_reduction(+: sum)\n      for (int i = 0; i < N; i++) {\n        sum += y[i]*z[i];\n      }\n      num_threads = omp_get_num_threads();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    expected_sum += y[i]*z[i];\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, sum != expected_sum);\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of taskloop can't be guaranteed.\");\n  OMPVV_ERROR_IF(num_threads < 1, \"Test returned an invalid number of threads.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n\n  return errors;\n}\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_taskloop_in_reduction());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_enter_exit_data_map_pointer_translation.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  OMPVV_TEST_OFFLOADING\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_same_function());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_different_function());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 3604",
        "issue_id": 4,
        "original_code": "//===---- test_target_enter_exit_data_map_pointer_translation.c-------- ===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// According to the OpenMP Specs, if a pointer is used in the mapping of a variable\n// and the pointer points to a host array that is already available in the device,\n// this pointer's address has to be updated with the device address. \n//\n// See page 105, lines 24 throuhg 32. \n//\n// This test check these conditions are valid for target enter exit data clauses \n//\n//===----------------------------------------------------------------------===//\n\n#include \"ompvv.h\"\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 1000\n\nint test_map_same_function() {\n\n  OMPVV_INFOMSG(\"Testing map same function definition\")\n\n  int sum = 0, sum2 = 0, errors = 0;\n\n  // host arrays: heap and stack\n  int *h_array_h = (int *)malloc(N * sizeof(int));\n  int h_array_s[N];\n\n  // Pointers to be used for the translation\n  int *ptr_h_array_h;\n  int *ptr_h_array_s;\n\n#pragma omp target enter data map(alloc:h_array_h[0:N]) map(alloc:h_array_s[0:N])\n\n    ptr_h_array_h = h_array_h;\n    ptr_h_array_s = h_array_s;\n\n    OMPVV_INFOMSG(\"map(ptr) specified full-length array section\")\n#pragma omp target map(ptr_h_array_h[0:N], ptr_h_array_s[0:N])\n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] = 1;\n        ptr_h_array_s[i] = 2;\n      }\n    } // end target\n\n    OMPVV_INFOMSG(\"map(ptr) specified zero-length array section\")\n#pragma omp target map(ptr_h_array_h[:0], ptr_h_array_s[:0])\n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] += 1;\n        ptr_h_array_s[i] += 2;\n      }\n    } // end target\n\n    OMPVV_INFOMSG(\"no map(ptr) Specified\")\n#pragma omp target \n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] += 1;\n        ptr_h_array_s[i] += 2;\n      }\n    } // end target\n#pragma omp target exit data map(from:h_array_h[0:N]) map(from:h_array_s[0:N])\n\n  // checking results\n  for (int i = 0; i < N; ++i) {\n    sum += h_array_h[i];\n    sum2 += h_array_s[i];\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (3*N != sum) || (6*N != sum2));\n\n  free(h_array_h);\n  return errors;\n}\n\nvoid helper_function(int *ptr_h_array_h, int *ptr_h_array_s) {\n\n    OMPVV_INFOMSG(\"map(ptr) specified full-length array section\")\n#pragma omp target map(ptr_h_array_h[0:N], ptr_h_array_s[0:N])\n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] = 1;\n        ptr_h_array_s[i] = 2;\n      }\n    } // end target\n\n    OMPVV_INFOMSG(\"map(ptr) specified zero-length array section\")\n#pragma omp target map(ptr_h_array_h[:0], ptr_h_array_s[:0])\n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] += 1;\n        ptr_h_array_s[i] += 2;\n      }\n    } // end target\n\n    OMPVV_INFOMSG(\"no map(ptr) Specified\")\n#pragma omp target \n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] += 1;\n        ptr_h_array_s[i] += 2;\n      }\n    } // end target\n}\n\nint test_map_different_function() {\n\n  OMPVV_INFOMSG(\"Testing map different function definition\")\n\n  int sum = 0, sum2 = 0, errors = 0;\n\n  // host arrays: heap and stack\n  int *h_array_h = (int *)malloc(N * sizeof(int));\n  int h_array_s[N];\n\n#pragma omp target enter data map(alloc: h_array_h[0:N]) map(alloc: h_array_s[0:N])\n    helper_function(h_array_h, h_array_s);\n#pragma omp target exit data map(from: h_array_h[0:N]) map(from: h_array_s[0:N])\n\n  // checking results\n  for (int i = 0; i < N; ++i) {\n    sum += h_array_h[i];\n    sum2 += h_array_s[i];\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (3*N != sum) || (6*N != sum2));\n\n  free(h_array_h);\n  return errors;\n}\nint main() {\n  OMPVV_TEST_OFFLOADING\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_same_function());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_different_function());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_enter_exit_data_map_pointer_translation.c-------- ===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// According to the OpenMP Specs, if a pointer is used in the mapping of a variable\n// and the pointer points to a host array that is already available in the device,\n// this pointer's address has to be updated with the device address. \n//\n// See page 105, lines 24 throuhg 32. \n//\n// This test check these conditions are valid for target enter exit data clauses \n//\n//===----------------------------------------------------------------------===//\n\n#include \"ompvv.h\"\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 1000\n\nint test_map_same_function() {\n\n  OMPVV_INFOMSG(\"Testing map same function definition\")\n\n  int sum = 0, sum2 = 0, errors = 0;\n\n  // host arrays: heap and stack\n  int *h_array_h = (int *)malloc(N * sizeof(int));\n  int h_array_s[N];\n\n  // Pointers to be used for the translation\n  int *ptr_h_array_h;\n  int *ptr_h_array_s;\n\n#pragma omp target enter data map(alloc:h_array_h[0:N]) map(alloc:h_array_s[0:N])\n\n    ptr_h_array_h = h_array_h;\n    ptr_h_array_s = h_array_s;\n\n    OMPVV_INFOMSG(\"map(ptr) specified full-length array section\")\n#pragma omp target map(ptr_h_array_h[0:N], ptr_h_array_s[0:N])\n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] = 1;\n        ptr_h_array_s[i] = 2;\n      }\n    } // end target\n\n    OMPVV_INFOMSG(\"map(ptr) specified zero-length array section\")\n#pragma omp target map(ptr_h_array_h[:0], ptr_h_array_s[:0])\n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] += 1;\n        ptr_h_array_s[i] += 2;\n      }\n    } // end target\n\n    OMPVV_INFOMSG(\"no map(ptr) Specified\")\n#pragma omp target \n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] += 1;\n        ptr_h_array_s[i] += 2;\n      }\n    } // end target\n#pragma omp target exit data map(from:h_array_h[0:N]) map(from:h_array_s[0:N])\n\n  // checking results\n  for (int i = 0; i < N; ++i) {\n    sum += h_array_h[i];\n    sum2 += h_array_s[i];\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (3*N != sum) || (6*N != sum2));\n\n  free(h_array_h);\n  return errors;\n}\n\nvoid helper_function(int *ptr_h_array_h, int *ptr_h_array_s) {\n\n    OMPVV_INFOMSG(\"map(ptr) specified full-length array section\")\n#pragma omp target map(ptr_h_array_h[0:N], ptr_h_array_s[0:N])\n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] = 1;\n        ptr_h_array_s[i] = 2;\n      }\n    } // end target\n\n    OMPVV_INFOMSG(\"map(ptr) specified zero-length array section\")\n#pragma omp target map(ptr_h_array_h[:0], ptr_h_array_s[:0])\n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] += 1;\n        ptr_h_array_s[i] += 2;\n      }\n    } // end target\n\n    OMPVV_INFOMSG(\"no map(ptr) Specified\")\n#pragma omp target \n    {\n      for (int i = 0; i < N; ++i) {\n        ptr_h_array_h[i] += 1;\n        ptr_h_array_s[i] += 2;\n      }\n    } // end target\n}\n\nint test_map_different_function() {\n\n  OMPVV_INFOMSG(\"Testing map different function definition\")\n\n  int sum = 0, sum2 = 0, errors = 0;\n\n  // host arrays: heap and stack\n  int *h_array_h = (int *)malloc(N * sizeof(int));\n  int h_array_s[N];\n\n#pragma omp target enter data map(alloc: h_array_h[0:N]) map(alloc: h_array_s[0:N])\n    helper_function(h_array_h, h_array_s);\n#pragma omp target exit data map(from: h_array_h[0:N]) map(from: h_array_s[0:N])\n\n  // checking results\n  for (int i = 0; i < N; ++i) {\n    sum += h_array_h[i];\n    sum2 += h_array_s[i];\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (3*N != sum) || (6*N != sum2));\n\n  free(h_array_h);\n  return errors;\n}\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_uses_allocators_const.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1110",
        "issue_id": 1,
        "original_code": "//===--- test_target_uses_allocators_const.c -------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// The tests checks the uses_allocators clause with omp_const_mem_alloc. \n// The variable is firstprivatized in the target region and is used to \n// modify result on device. Result is copied back to the host and checked \n// with computed value on host.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_uses_allocators_const() {\n  int errors = 0;\n  int x = 23;\n  int device_result = 0;\n  int result = 0;\n\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      result += j + i + x ;\n    }\n  }\n\n#pragma omp target uses_allocators(omp_const_mem_alloc) allocate(omp_const_mem_alloc: x) firstprivate(x) map(tofrom: device_result)\n{\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      device_result += j + i + x;\n    }\n  }\n}\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != device_result);\n  return errors;\n}\n\nint main() {\n\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_uses_allocators_const() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n",
        "error_code": "//===--- test_target_uses_allocators_const.c -------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// The tests checks the uses_allocators clause with omp_const_mem_alloc. \n// The variable is firstprivatized in the target region and is used to \n// modify result on device. Result is copied back to the host and checked \n// with computed value on host.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_uses_allocators_const() {\n  int errors = 0;\n  int x = 23;\n  int device_result = 0;\n  int result = 0;\n\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      result += j + i + x ;\n    }\n  }\n\n#pragma omp target uses_allocators(omp_const_mem_alloc) allocate(omp_const_mem_alloc: x) firstprivate(x) map(tofrom: device_result)\n{\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      device_result += j + i + x;\n    }\n  }\n}\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != device_result);\n  return errors;\n}\n\nint main() \n\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_uses_allocators_const() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/gridmini_map_struct_float_mul.cpp",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp teams\" at position 1072",
        "issue_id": 0,
        "original_code": "//===-- gridmini_float_mul_offload.c ---------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks that the float multiplication of members of the struct 'vec'\n// in the offloaded region provides the same answer as calculated by host. \n// Since support for struct on map is implementation specific in 4.5 the test does \n// not have a fail condition. \n//\n//===----------------------------------------------------------------------===//\n\n#include <cstdlib>\n#include <stdio.h>\n#include <iostream>\n#include \"ompvv.h\"\n#include \"omp.h\"\n\nusing namespace std;\nstruct vec {\n  float v1;\n  float v2;\n};\n\ninline  vec mult(vec x, vec y){\n  vec out;\n  out.v1 = x.v1*y.v1;\n  out.v2 = x.v2*y.v2;\n  return out;\n}\n\nint main(int argc, char* argv[]){\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n  int N = 10;\n  float x = (float)rand()/(float)(RAND_MAX/10.0);\n  float y = (float)rand()/(float)(RAND_MAX/5.0);\n  vec in1,in2;\n  in1.v1 = x;\n  in1.v2 = x;\n  in2.v1 = y;\n  in2.v2 = y;\n  vec out[N];\n\n  //calulate on host\n  vec expected = mult(in1,in2);\n\n#pragma omp target teams distribute parallel for map(to:in1,in2) map(from:out[0:N])\n    for(int n = 0; n < N; n++) {\n      out[n] = mult(in1,in2);\n    }\n    \n  for(int n = 0; n < N; n++) {\n    OMPVV_TEST_AND_SET(errors,out[n].v1 != expected.v1);\n    OMPVV_TEST_AND_SET(errors,out[n].v2 != expected.v2);\n  }\n  if(errors)\n    OMPVV_INFOMSG(\"Maping of entire struct is not supported by this OpenMP implementation.\\n\");\t\n\n  //No error will be reported even if it is recorded.\n  OMPVV_REPORT_AND_RETURN(0);\n\n}\n\n",
        "error_code": "//===-- gridmini_float_mul_offload.c ---------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks that the float multiplication of members of the struct 'vec'\n// in the offloaded region provides the same answer as calculated by host. \n// Since support for struct on map is implementation specific in 4.5 the test does \n// not have a fail condition. \n//\n//===----------------------------------------------------------------------===//\n\n#include <cstdlib>\n#include <stdio.h>\n#include <iostream>\n#include \"ompvv.h\"\n#include \"omp.h\"\n\nusing namespace std;\nstruct vec {\n  float v1;\n  float v2;\n};\n\ninline  vec mult(vec x, vec y){\n  vec out;\n  out.v1 = x.v1*y.v1;\n  out.v2 = x.v2*y.v2;\n  return out;\n}\n\nint main(int argc, char* argv[]){\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n  int N = 10;\n  float x = (float)rand()/(float)(RAND_MAX/10.0);\n  float y = (float)rand()/(float)(RAND_MAX/5.0);\n  vec in1,in2;\n  in1.v1 = x;\n  in1.v2 = x;\n  in2.v1 = y;\n  in2.v2 = y;\n  vec out[N];\n\n  //calulate on host\n  vec expected = mult(in1,in2);\n\n#pragma omp teams teams distribute parallel for map(to:in1,in2) map(from:out[0:N])\n    for(int n = 0; n < N; n++) {\n      out[n] = mult(in1,in2);\n    }\n    \n  for(int n = 0; n < N; n++) {\n    OMPVV_TEST_AND_SET(errors,out[n].v1 != expected.v1);\n    OMPVV_TEST_AND_SET(errors,out[n].v2 != expected.v2);\n  }\n  if(errors)\n    OMPVV_INFOMSG(\"Maping of entire struct is not supported by this OpenMP implementation.\\n\");\t\n\n  //No error will be reported even if it is recorded.\n  OMPVV_REPORT_AND_RETURN(0);\n\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_is_device_ptr.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===--- test_target_teams_distribute_is_device_ptr.c------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses is_device_ptr clause to indicate that the parameter that is\n// given is already an address to the data on the device.  The parameter is set\n// using the omp_target_alloc which returns the pointer to the location on the\n// target that was allocated.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define SIZE_THRESHOLD 512\n#define ARRAY_SIZE 1024\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  OMPVV_INFOMSG(\"test target_teams_distribute_is_device_ptr\");\n\n  int a[ARRAY_SIZE];\n  int b[ARRAY_SIZE];\n  int *c = (int *)omp_target_alloc(ARRAY_SIZE * sizeof(int), omp_get_default_device());\n  int errors = 0;\n\n  if (!c) {\n    OMPVV_WARNING(\"Test was unable to allocate memory on device.  Test could not procede.\");\n    OMPVV_REPORT_AND_RETURN(errors);\n  } else {\n    for (int x = 0; x < ARRAY_SIZE; ++x) {\n      a[x] = 1;\n      b[x] = x;\n    }\n\n#pragma omp target teams distribute is_device_ptr(c) map(tofrom: a[0:ARRAY_SIZE]) map(to: b[0:ARRAY_SIZE])\n    for (int x = 0; x < ARRAY_SIZE; ++x) {\n      c[x] = b[x] * b[x];\n      a[x] += c[x] + b[x];\n    }\n\n    for (int x = 0; x < ARRAY_SIZE; ++x) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, (a[x] != 1 + b[x] + b[x] * b[x]));\n      if (a[x] != 1 + b[x] + b[x] * b[x]) {\n\tbreak;\n      }\n    }\n\n    omp_target_free (c, omp_get_default_device());\n\n    OMPVV_REPORT_AND_RETURN(errors);\n  }\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nlong ypbjzlcsjj = 198;\nlong ucfkeflvjr = 43;\nfloat xkppadjrna = 120;\nfloat veedhstzjk = 93;\nint vfnzljpska = 199;\nlong jkqybrsvop = 195;\nshort buydlqspgi = 221;\nshort yzllvtarsk = 160;\nfloat rqpodfascg = 158;\ndouble oijfyivxzg = 86;\nbyte bsdxvqlvyw = 170;\nshort aeyyahpohz = 244;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_declare_mapper_target_struct.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===--- test_declare_mapper_target_struct.c --- test declare mapper on struct on device --------- -------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This example has been adapted from the 5.0 OpenMP Examples document.\n// the declare mapper directive specifies that any structure of type myvec_t for which \n// implicit data-mapping rules apply will be mapped according to its map clause. The \n// variable v is used for referencing the structure and its elements within the map \n// clause. Within the map clause the v variable specifies that all elements of the \n// structure are to be mapped.\n//\n////===---------------------------------------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\ntypedef struct myvec{\n    size_t len;\n    double *data;\n} myvec_t;\n\n#pragma omp declare mapper(myvec_t v) \\\n                    map(v, v.data[0:v.len])\n\nvoid init( myvec_t *s )\n{ \n  for(size_t i = 0; i < s->len; i++)\n    s->data[i] = i; \n}\n\nint test_declare_mapper_struct() {\n\n  OMPVV_INFOMSG(\"test_declare_mapper_struct\");\n  int errors = 0;\n\n   myvec_t s;\n\n   s.data = (double *)calloc(N,sizeof(double));\n   s.len  = N;\n\n#pragma omp target\n  {\n    init(&s);\n  }\n  for (int i = 0; i < N; ++i) {\n    OMPVV_TEST_AND_SET(errors, s.data[i] != i);\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_declare_mapper_struct());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nfloat vendvqtvpv = 101;\nshort gnfxkmhxvl = 223;\nbyte zkcjgnkreg = 98;\nbyte oirihlxrmo = 246;\nint vpqmsntkyd = 144;\nlong hrpijegedd = 104;\nlong punwithksw = 214;\nfloat sodpfzbabx = 55;\nbyte snjshsvsgy = 104;\ndouble qrbwafpldn = 228;\nbyte fcjhildykq = 221;\nlong prxnulajqa = 139;\nshort tgexuoxebr = 110;\nshort reldvwhkia = 77;\nlong wuinlpcyuk = 128;\nlong ouysetjyel = 193;\nlong iukhmzmqiv = 206;\ndouble tbejvicdtm = 32;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_assume_no_openmp_routines.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp assume\" with directive \"#pragma omp master\" at position 550",
        "issue_id": 0,
        "original_code": "//===--- test_assume_no_openmp_routines.c -----------------------------------===//\n//\n//  OpenMP API Version 5.1 Aug 2021\n//\n//  Using assume no_openmp_routines, the compiler can be optimized as it knows that a\n//  structured block does not contain any openmp runtime routines.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint errors, i;\n\nint test_assume_no_openmp_routines() {\n    int arr[N];\n    #pragma omp assume no_openmp_routines\n    {\n        for(i = 0; i < N; i++){\n            arr[i] = i;\n        }\n        #pragma omp target parallel for map(tofrom: arr)\n        for(i = 0; i < N; i++){\n            arr[i] = arr[i]*2;\n        }\n    }\n    // Test that no issues were caused from using assume directive\n    for(i = 0; i < N; i++){\n        OMPVV_TEST_AND_SET(errors, arr[i] != i*2);\n    }\n    return errors;\n}\n\nint main() {\n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_assume_no_openmp_routines() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_assume_no_openmp_routines.c -----------------------------------===//\n//\n//  OpenMP API Version 5.1 Aug 2021\n//\n//  Using assume no_openmp_routines, the compiler can be optimized as it knows that a\n//  structured block does not contain any openmp runtime routines.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint errors, i;\n\nint test_assume_no_openmp_routines() {\n    int arr[N];\n    #pragma omp master no_openmp_routines\n    {\n        for(i = 0; i < N; i++){\n            arr[i] = i;\n        }\n        #pragma omp target parallel for map(tofrom: arr)\n        for(i = 0; i < N; i++){\n            arr[i] = arr[i]*2;\n        }\n    }\n    // Test that no issues were caused from using assume directive\n    for(i = 0; i < N; i++){\n        OMPVV_TEST_AND_SET(errors, arr[i] != i*2);\n    }\n    return errors;\n}\n\nint main() {\n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_assume_no_openmp_routines() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_data_map_array_sections.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===--- test_target_data_map_array_sections.c--------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test confirms functionality of the target data map 'from' clause for 1D,\n// 2D, and 3D arrarys that are allocated on the stack. Arrays are first initalized on \n// the host, then allocated on the device and filled with integers, and finally they\n// are copied back to host and checked confirm that correct results return from the\n// device. For each type of array (1D, 2D, 3D), this test provides 3 functions to \n// test data map clause. The 3 forms used for mapping are a[lower:length], a[:length],\n// and a[lower:].\n//\n////===-----------------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nvoid init_1d(int* a);\nvoid init_2d(int a[N][2]);\nvoid init_3d(int a[N][2][2]);\n\n// Test for OpenMP 4.5 target data map with array section [lower:length]\nint test_lower_length_1d() {\n  // array sections of the form a[lower:length] \n  OMPVV_INFOMSG(\"test_lower_length_1d\");\n\n  int errors = 0;\n\n  int a1d[N];\n  init_1d(a1d);\n\n#pragma omp target data map(from: a1d[1:N - 2])\n  {\n#pragma omp target map(alloc: a1d[1:N - 2]) // to avoid default mapping tofrom\n    {\n      for (int i = 1; i < N - 1; ++i)\n        a1d[i] = 1;\n    } // end target\n  } // end target data\n\n  // checking errors\n  for (int i = 0; i < N; ++i) {\n    if (i == 0 || i == N - 1){\n      OMPVV_TEST_AND_SET_VERBOSE(errors, (a1d[i] != 0));\n    }\n    else { \n      OMPVV_TEST_AND_SET_VERBOSE(errors, (a1d[i] != 1)); \n    }\n }\n\n  return errors;\n}\n\n// Test for OpenMP 4.5 target data map with array 2d section [lower:length]\nint test_lower_length_2d() {\n  // array sections of the form a[lower:length]\n  OMPVV_INFOMSG(\"test_lower_length_2d\");\n\n  int errors = 0;\n\n  // stack\n  int a2d[N][2];\n  init_2d(a2d);\n\n  // OpenMP API v 4.5 Nov 2015. 2.15.5.1 map Clause, page 218 line 17: \n  // If a list item is an array section, it must specify contiguous storage.\n#pragma omp target data map(from: a2d[1:N - 2][0:2])\n  {\n#pragma omp target map(alloc: a2d[1:N - 2][0:2]) // to avoid default mapping tofrom\n    {\n      for (int i = 1; i < N - 1; ++i) {\n        a2d[i][0] = 1;\n        a2d[i][1] = 1;\n      }\n    } // end target\n  } // end target data\n\n  // checking errors \n  for (int i = 0; i < N; ++i) {\n    if (i == 0 || i == N - 1){\n      OMPVV_TEST_AND_SET_VERBOSE(errors, a2d[i][0] != 0 && a2d[i][1] != 0);\n    } \n    else {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, a2d[i][0] != 1 && a2d[i][1] != 1);\n   }\n  }\n\n  return errors;\n}\n\n// Test for OpenMP 4.5 target data map with array 3d section [lower:length]\nint test_lower_length_3d() {\n  // array sections of the form a[lower:length] \n  OMPVV_INFOMSG(\"test_lower_length_3d\");\n  // If a list item is an array section, it must specify contiguous storage. \n\n  int errors = 0;\n\n  // stack\n  int a3d[N][2][2];\n  init_3d(a3d);\n  int a3d2[N][2][2];\n  init_3d(a3d2);\n\n  // OpenMP API v 4.5 Nov 2015. 2.15.5.1 map Clause, page 218 line 17: \n  // If a list item is an array section, it must specify contiguous storage.\n#pragma omp target data map(from: a3d[1:N - 2][0:2][0:2])  \\\n        map(from: a3d2[0:N][0:2][0:2])\n  {\n#pragma omp target map(alloc: a3d[1:N - 2][0:2][0:2] ,a3d2[0:N][0:2][0:2]) // to avoid default mapping tofrom\n    {\n      for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < 2; ++j) {\n          if (i > 0 && i < N - 1) {\n            a3d[i][j][0] = 1;\n            a3d[i][j][1] = 1;\n          }\n          a3d2[i][j][0] = 1;\n          a3d2[i][j][1] = 1;\n        }\n      }\n    } // end target\n  } // end target data\n\n  // checking errors\n  for (int i = 0; i < N; ++i) {\n    for (int j = 0; j < 2; ++j) {\n      // a3d\n      if (i == 0 || i == N - 1) {\n        OMPVV_TEST_AND_SET_VERBOSE(errors, a3d[i][j][0] != 0 && a3d[i][j][1] != 0);\n      } \n      else {\n        OMPVV_TEST_AND_SET_VERBOSE(errors, a3d[i][j][0] != 1 && a3d[i][j][1] != 1);\n      }\n      // a3d2\n      OMPVV_TEST_AND_SET_VERBOSE(errors, a3d2[i][j][0] != 1 && a3d2[i][j][1] != 1);\n    }\n  }\n\n  return errors;\n}\n\n// Test for OpenMP 4.5 target data map with array 1d section [:length]\nint test_length_1d() {\n  // array sections of the form a[:length]\n  OMPVV_INFOMSG(\"test_length_1d\");\n\n  int errors = 0;\n\n  int a1d[N];\n  init_1d(a1d);\n\n  // OpenMP API - V4.5 Nov2015. 2.4. Array sections, page 45 line 14: \n  // When the lower-bound is absent it defaults to 0.\n#pragma omp target data map(from: a1d[:N - 2]) \n  {\n#pragma omp target map(alloc: a1d[:N - 2]) // to avoid default mapping tofrom\n    {\n      for (int i = 0; i < N - 2; ++i)\n        a1d[i] = 1;\n    } // end target\n  } // end target data\n\n  // checking errors\n  for (int i = 0; i < N - 2; ++i)\n    OMPVV_TEST_AND_SET_VERBOSE(errors, a1d[i] != 1);\n  // N-2\n  OMPVV_TEST_AND_SET_VERBOSE(errors, a1d[N - 2] != 0);\n  // N-1\n  OMPVV_TEST_AND_SET_VERBOSE(errors, a1d[N - 1] != 0);\n\n  return errors;\n}\n\n// Test for OpenMP 4.5 target data map with array 2d section [:length]\nint test_length_2d() {\n  // array sections of the form a[:length]\n  OMPVV_INFOMSG(\"test_length_2d\");\n\n  int errors = 0;\n\n  int a2d[N][2];\n  init_2d(a2d);\n\n  // OpenMP API - V4.5 Nov2015. 2.4. Array sections, page 45 line 14: \n  // When the lower-bound is absent it defaults to 0.\n  // OpenMP API v 4.5 Nov 2015. 2.15.5.1 map Clause, page 218 line 17:\n  // If a list item is an array section, it must specify contiguous storage.\n#pragma omp target data map(from: a2d[:N - 2][:2])\n  {\n#pragma omp target map(alloc: a2d[:N - 2][:2]) // To avoid default mapping tofrom\n    {\n      for (int i = 0; i < N - 2; ++i) {\n        a2d[i][0] = 1;\n        a2d[i][1] = 1;\n      }\n    } // end target\n  } // end target data\n\n  // checking errors\n  for (int i = 0; i < N - 2; ++i)\n    OMPVV_TEST_AND_SET_VERBOSE(errors, a2d[i][0] != 1 && a2d[i][1] != 1);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, a2d[N - 2][0] != 0 && a2d[N - 2][1] != 0);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, a2d[N - 1][0] != 0 && a2d[N - 1][1] != 0);\n\n  return errors;\n}\n\n// Test for OpenMP 4.5 target data map with array 3d section [:length]\nint test_length_3d() {\n  // array sections of the form a[:length]\n  OMPVV_INFOMSG(\"test_length_3d\");\n\n  int errors = 0;\n\n  int a3d[N][2][2];\n  init_3d(a3d);\n  int a3d2[N][2][2];\n  init_3d(a3d2);\n\n  // OpenMP API - V4.5 Nov2015. 2.4. Array sections, page 45 line 14:\n  // When the lower-bound is absent it defaults to 0.\n  // OpenMP API v 4.5 Nov 2015. 2.15.5.1 map Clause, page 218 line 17:\n  // If a list item is an array section, it must specify contiguous storage.\n#pragma omp target data map(from: a3d[:N - 2][:2][:2])   \\\n        map(from: a3d2[:N][:2][:2])\n  {\n#pragma omp target map(alloc: a3d[:N - 2][:2][:2], a3d2[:N][:2][:2]) // To avoid default mapping tofrom\n    {\n      for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < 2; ++j) {\n          if (i < N - 2) {\n            a3d[i][j][0] = 1;\n            a3d[i][j][1] = 1;\n          }\n          a3d2[i][j][0] = 1;\n          a3d2[i][j][1] = 1;\n        }\n      }\n    } // end target\n  } // end target data\n\n  // checking errors\n  for (int i = 0; i < N; ++i) {\n    for (int j = 0; j < 2; ++j) {\n      if (i >= N - 2) {\n        OMPVV_TEST_AND_SET_VERBOSE(errors, a3d[i][j][0] != 0 && a3d[i][j][1] != 0);\n      } \n      else  \n        OMPVV_TEST_AND_SET_VERBOSE(errors, a3d[i][j][0] != 1 && a3d[i][j][1] != 1)\n      // a3d2\n      OMPVV_TEST_AND_SET_VERBOSE(errors, a3d2[i][j][0] != 1 && a3d2[i][j][1] != 1);\n    }\n  }\n\n  return errors;\n}\n\n// Test for OpenMP 4.5 target data map with array 1d section [lower:]\nint test_lower_1d() {\n  // array sections of the form a[lower:]\n  OMPVV_INFOMSG(\"test_lower_1d\");\n\n  int errors = 0;\n\n  int a1d[N];\n  init_1d(a1d);\n\n  // OpenMP API - V4.5 Nov2015. 2.4. Array sections, page 45 line 13:\n  // When the length is absent, it defaults to the size of the array\n  // dimension minus the lower-bound.\n#pragma omp target data map(from: a1d[1:])\n  {\n#pragma omp target map(alloc: a1d[1:]) // To avoid default mapping tofrom\n    {\n      for (int i = 1; i < N; ++i)\n        a1d[i] = 1;\n    } // end target\n  } // end target data\n\n  // checking errors \n  for (int i = 0; i < N; ++i) {\n    if (i == 0) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, a1d[i] != 0);\n    }\n    else\n      OMPVV_TEST_AND_SET_VERBOSE(errors, a1d[i] != 1);\n  }\n\n  return errors;\n}\n\n// Test for OpenMP 4.5 target data map with array 2d section [lower:]\nint test_lower_2d() {\n  // array sections of the form a[lower:] \n  OMPVV_INFOMSG(\"test_lower_2d\");\n\n  int errors = 0;\n\n  int a2d[N][2];\n  init_2d(a2d);\n\n  // OpenMP API - V4.5 Nov2015. 2.4. Array sections, page 45 line 13: \n  // When the length is absent, it defaults to the size of the array \n  // dimension minus the lower-bound.\n  // OpenMP API v 4.5 Nov 2015. 2.15.5.1 map Clause, page 218 line 17:\n  // If a list item is an array section, it must specify contiguous storage.\n#pragma omp target data map(from: a2d[1:][0:])\n  {\n#pragma omp target map(alloc: a2d[1:][0:]) // To avoid default mapping tofrom\n    {\n      for (int i = 1; i < N; ++i) {\n        a2d[i][0] = 1;\n        a2d[i][1] = 1;\n      }\n    } // end target\n  } // end target data\n\n  // checking errors \n  for (int i = 0; i < N; ++i) {\n    if (i == 0) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, a2d[i][0] != 0 && a2d[i][1] != 0);\n    }\n    else\n      OMPVV_TEST_AND_SET_VERBOSE(errors, a2d[i][0] != 1 && a2d[i][1] != 1)\n  }\n\n  return errors;\n}\n\n// Test for OpenMP 4.5 target data map with array 3d section [lower:]\nint test_lower_3d() {\n  // array sections of the form a[lower:] \n  OMPVV_INFOMSG(\"test_lower_3d\");\n\n  int errors = 0;\n\n  int a3d[N][2][2];\n  init_3d(a3d);\n  int a3d2[N][2][2];\n  init_3d(a3d2);\n\n  // OpenMP API - V4.5 Nov2015. 2.4. Array sections, page 45 line 13: \n  // When the length is absent, it defaults to the size of the array \n  // dimension minus the lower-bound.\n  // OpenMP API v 4.5 Nov 2015. 2.15.5.1 map Clause, page 218 line 17: \n  // If a list item is an array section, it must specify contiguous storage.\n#pragma omp target data map(from: a3d[1:][0:][0:])   \\\n        map(from: a3d2[0:][0:][0:])\n  {\n#pragma omp target map(alloc: a3d[1:][0:][0:], a3d2[0:][0:][0:]) // To avoid default mapping tofrom\n    {\n      for (int i = 0; i < N; ++i) {\n        for (int j = 0; j < 2; ++j) {\n          if (i > 0) {\n            a3d[i][j][0] = 1;\n            a3d[i][j][1] = 1;\n          }\n          a3d2[i][j][0] = 1;\n          a3d2[i][j][1] = 1;\n        }\n      }\n    } // end target\n  } // end target data\n\n  // checking errors \n  for (int i = 0; i < N; ++i) {\n    for (int j = 0; j < 2; ++j) {\n      // a3d\n      if (i == 0) {\n        OMPVV_TEST_AND_SET_VERBOSE(errors, a3d[i][j][0] != 0 && a3d[i][j][1] != 0);\n      } \n      else {\n        OMPVV_TEST_AND_SET_VERBOSE(errors, a3d[i][j][0] != 1 && a3d[i][j][1] != 1);\n      }// a3d2\n      OMPVV_TEST_AND_SET_VERBOSE(errors, a3d2[i][j][0] != 1 && a3d2[i][j][1] != 1);\n    }\n  }\n\n  return errors;\n}\n\nint main() {\n\n  int errors = 0;\n   \n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_lower_length_1d());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_lower_length_2d());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_lower_length_3d());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_length_1d());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_length_2d());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_length_3d());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_lower_1d());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_lower_2d());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_lower_3d());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\nvoid init_1d(int* a) {\n  for (int i = 0; i < N; ++i)\n    a[i] = 0;\n}\n\nvoid init_2d(int a[N][2]) {\n  for (int i = 0; i < N; ++i) {\n    a[i][0] = 0;\n    a[i][1] = 0;\n  }\n}\n\nvoid init_3d(int a[N][2][2]) {\n  for (int i = 0; i < N; ++i)\n    for (int j = 0; j < 2; ++j) {\n      a[i][j][0] = 0;\n      a[i][j][1] = 0;\n    }\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\ndouble aympqvysxu = 187;\nshort ijuprjokhv = 180;\ndouble eivzgutcuy = 67;\nfloat binwfcgntp = 164;\nlong ybxlhelxmf = 59;\nshort kfwlhjvwgs = 230;\nlong czlhrnuqvn = 180;\ndouble uwknctrbam = 186;\nshort xnvnhztvht = 73;\nfloat yswusjyshy = 190;\nint yfmbfqadfv = 213;\nlong yarreelide = 201;\nshort pusfymfmma = 64;\ndouble hdequhwmxm = 204;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_taskloop_shared.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp parallel\" with directive \"#pragma omp teams\" at position 1016",
        "issue_id": 0,
        "original_code": "//------------------------------------------- test_taskloop_shared.c --------------------------------------//\n//\n// OpenMP API Version 4.5 November 2015\n//\n// This test checks the 'taskloop' directive with the 'shared' clause specified.\n// The 'taskloop' construct parallelize loops with independent iterations by creating tasks. \n// It allows for efficient parallel execution of loop iterations by distributing them among multiple threads. \n// The 'shared' clause ensures that vaiable is shared with all the tasks.  \n//----------------------------------------------------------------------------------------------------------//\n\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define NUM_THREADS 50\n#define NUM_TASKS 1000\n\nint test_taskloop_shared() {\n\n  int errors = 0;\n\n  long int all_thread_sum, real_sum = 0; \n  long int shared_var = 0; //This variable is shared with all the tasks.  \n\n   //get valid sum without openmp\n   for(int i = 0; i < NUM_TASKS; i++) {\n     real_sum = real_sum + i;\n   }\n   \n   #pragma omp parallel num_threads(NUM_THREADS)\n   {\n      #pragma omp single\n      {\n\t#pragma omp taskloop shared(shared_var) \n        for(int i = 0; i < NUM_TASKS; i++) \n\t{\n\t    #pragma omp atomic \n\t    shared_var = shared_var + i;\n\t}\n      }\t   \n   }\n\n   all_thread_sum = shared_var;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, real_sum != all_thread_sum);\n\n   return errors;\n}\n\nint main() {\n  \n  int errors = 0;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, (test_taskloop_shared()) != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n\n  return 0;\n}\n",
        "error_code": "//------------------------------------------- test_taskloop_shared.c --------------------------------------//\n//\n// OpenMP API Version 4.5 November 2015\n//\n// This test checks the 'taskloop' directive with the 'shared' clause specified.\n// The 'taskloop' construct parallelize loops with independent iterations by creating tasks. \n// It allows for efficient parallel execution of loop iterations by distributing them among multiple threads. \n// The 'shared' clause ensures that vaiable is shared with all the tasks.  \n//----------------------------------------------------------------------------------------------------------//\n\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define NUM_THREADS 50\n#define NUM_TASKS 1000\n\nint test_taskloop_shared() {\n\n  int errors = 0;\n\n  long int all_thread_sum, real_sum = 0; \n  long int shared_var = 0; //This variable is shared with all the tasks.  \n\n   //get valid sum without openmp\n   for(int i = 0; i < NUM_TASKS; i++) {\n     real_sum = real_sum + i;\n   }\n   \n   #pragma omp teams num_threads(NUM_THREADS)\n   {\n      #pragma omp single\n      {\n\t#pragma omp taskloop shared(shared_var) \n        for(int i = 0; i < NUM_TASKS; i++) \n\t{\n\t    #pragma omp atomic \n\t    shared_var = shared_var + i;\n\t}\n      }\t   \n   }\n\n   all_thread_sum = shared_var;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, real_sum != all_thread_sum);\n\n   return errors;\n}\n\nint main() {\n  \n  int errors = 0;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, (test_taskloop_shared()) != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n\n  return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_depend_lvalue_func.cpp",
        "correct": "n",
        "issue": "Removed opening bracket at position 1163",
        "issue_id": 1,
        "original_code": "//===--- test_target_depend_lvalue_func.cpp ----------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the depend clause on task generating constructs are extended to\n// allow any lvalue such as functions that return references.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <iostream>\n#include <cstdlib>\n#include \"ompvv.h\"\n\n#pragma omp declare target\n// Global variable var\nint var;\n\n// Function to return reference to var\nint& ref() {\n\treturn var;\n}\n#pragma omp end declare target\nint test_task_depend_lvalue_func() {\n\tint errors = 0;\n\tint value = 0;\n\tvar = 0;\n\t#pragma omp target parallel map(tofrom: value)\n\t{\n\t\t#pragma omp single\n\t\t{\t\n\t\t\t// Use the ref() function in the\n\t\t\t// depend clause and update var's value\n\t\t\t#pragma omp task depend(out: ref())\n\t\t\t{\n\t\t\t\tref() = 1;\n\t\t\t}\n\t\t\t\n\t\t\t// Set value equal to var using the\n\t\t\t// ref() function\n\t\t\t#pragma omp task depend(in: ref())\n\t\t\t{\n\t\t\t\tvalue = ref();\t\n\t\t\t}\n\t\t\t#pragma omp taskwait\n\t\t}\n\t}\n\t\n\t//Check if value was updated to 1\n\tOMPVV_TEST_AND_SET(errors, value != 1);\n\treturn errors;\n}\n\nint main() {\n\tOMPVV_TEST_OFFLOADING;\n\tint errors = 0;\n\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_task_depend_lvalue_func() != 0);\n\n\tOMPVV_REPORT_AND_RETURN(errors);\n\n\treturn errors;\n}\n\n",
        "error_code": "//===--- test_target_depend_lvalue_func.cpp ----------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the depend clause on task generating constructs are extended to\n// allow any lvalue such as functions that return references.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <iostream>\n#include <cstdlib>\n#include \"ompvv.h\"\n\n#pragma omp declare target\n// Global variable var\nint var;\n\n// Function to return reference to var\nint& ref() {\n\treturn var;\n}\n#pragma omp end declare target\nint test_task_depend_lvalue_func() {\n\tint errors = 0;\n\tint value = 0;\n\tvar = 0;\n\t#pragma omp target parallel map(tofrom: value)\n\t{\n\t\t#pragma omp single\n\t\t{\t\n\t\t\t// Use the ref() function in the\n\t\t\t// depend clause and update var's value\n\t\t\t#pragma omp task depend(out: ref())\n\t\t\t{\n\t\t\t\tref() = 1;\n\t\t\t}\n\t\t\t\n\t\t\t// Set value equal to var using the\n\t\t\t// ref() function\n\t\t\t#pragma omp task depend(in: ref())\n\t\t\t{\n\t\t\t\tvalue = ref();\t\n\t\t\t}\n\t\t\t#pragma omp taskwait\n\t\t}\n\t}\n\t\n\t//Check if value was updated to 1\n\tOMPVV_TEST_AND_SET(errors, value != 1);\n\treturn errors;\n}\n\nint main() \n\tOMPVV_TEST_OFFLOADING;\n\tint errors = 0;\n\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_task_depend_lvalue_func() != 0);\n\n\tOMPVV_REPORT_AND_RETURN(errors);\n\n\treturn errors;\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_requires_unified_shared_memory_omp_target_alloc.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1616",
        "issue_id": 1,
        "original_code": "//===---test_requires_unified_shared_memory_omp_target_alloc.c --------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n// \n// This test Checks for unified shared memory of an array that is allocated on \n// the device and accessed in both host and device\n//\n// We use default mapping of pointers, which should be mappend as a zero length\n// array\n//\n////===----------------------------------------------------------------------===//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp requires unified_shared_memory\n\nint unified_shared_memory_target_alloc() {\n  OMPVV_INFOMSG(\"Unified shared memory testing - Memory allocated in the device\");\n  int errors = 0;\n  \n  int *anArray = (int *) omp_target_alloc(sizeof(int)*N, omp_get_default_device());\n  int anArrayCopy[N];\n\n  // Initialization\n#pragma omp target \n  {\n    for (int i = 0; i < N; i++) {\n      anArray[i] = i;\n    }\n  }\n  for (int i = 0; i < N; i++) {\n    anArrayCopy[i] = 0;\n  }\n\n  // Modify in the device\n#pragma omp target\n  {\n    for (int i = 0; i < N; i++) {\n      anArray[i] += 10;\n    }\n  }\n\n  // Modify again on the host\n  for (int i = 0; i < N; i++) {\n    anArray[i] += 10;\n  }\n\n  // Get the value the device is seeing\n#pragma omp target\n  {\n    for (int i = 0; i < N; i++) {\n      anArrayCopy[i] = anArray[i];\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArray[i] != i + 20);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArrayCopy[i] != i + 20);\n    if (errors) break;\n  }\n\n  omp_target_free(anArray,omp_get_default_device());\n  return errors;\n}\nint main() {\n  int isOffloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"With no offloading, unified shared memory is guaranteed due to host execution\");\n  int errors = 0;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, unified_shared_memory_target_alloc());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---test_requires_unified_shared_memory_omp_target_alloc.c --------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n// \n// This test Checks for unified shared memory of an array that is allocated on \n// the device and accessed in both host and device\n//\n// We use default mapping of pointers, which should be mappend as a zero length\n// array\n//\n////===----------------------------------------------------------------------===//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp requires unified_shared_memory\n\nint unified_shared_memory_target_alloc() {\n  OMPVV_INFOMSG(\"Unified shared memory testing - Memory allocated in the device\");\n  int errors = 0;\n  \n  int *anArray = (int *) omp_target_alloc(sizeof(int)*N, omp_get_default_device());\n  int anArrayCopy[N];\n\n  // Initialization\n#pragma omp target \n  {\n    for (int i = 0; i < N; i++) {\n      anArray[i] = i;\n    }\n  }\n  for (int i = 0; i < N; i++) {\n    anArrayCopy[i] = 0;\n  }\n\n  // Modify in the device\n#pragma omp target\n  {\n    for (int i = 0; i < N; i++) {\n      anArray[i] += 10;\n    }\n  }\n\n  // Modify again on the host\n  for (int i = 0; i < N; i++) {\n    anArray[i] += 10;\n  }\n\n  // Get the value the device is seeing\n#pragma omp target\n  {\n    for (int i = 0; i < N; i++) {\n      anArrayCopy[i] = anArray[i];\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArray[i] != i + 20);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArrayCopy[i] != i + 20);\n    if (errors) break;\n  }\n\n  omp_target_free(anArray,omp_get_default_device());\n  return errors;\n}\nint main() \n  int isOffloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"With no offloading, unified shared memory is guaranteed due to host execution\");\n  int errors = 0;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, unified_shared_memory_target_alloc());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_task_nowait.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n\tint errors = 0;\n\tOMPVV_TEST_OFFLOADING;\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_task_nowait() != 0);\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\" at position 1485",
        "issue_id": 4,
        "original_code": "//--------------- test_taskwait_nowait.c---------------------------------//\n//\n// OpenMP API Version 5.1 Aug 2021\n//\n// Tests the behavior of taskwait when nowait is specified.\n// The behavior of this should be similar to that of using task construct.\n// Test was adapted to use the depend clauses which the nowait clause should ignore\n// It is important to note that all depenend tasks must be finished first.\n//-----------------------------------------------------------------------//\n\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n#include <unistd.h>\n\n#define N 1024\n\nint test_task_nowait(){\n\tint errors = 0;\n\tint test_scalar = 1;\n\tint test_arr[N];\n\tint sum = 0;\n\tfor (int i =0; i<N; i++){\n\t\ttest_arr[i] = 1;\n\t\tsum += i;\n\t}\n\t#pragma omp parallel\n\t#pragma omp single\n\t{\n\t\t#pragma omp task depend(inout: test_scalar) shared(test_scalar)\n\t\t{\n\t\t\tusleep(10);\n\t\t\ttest_scalar += 1;\n\t\t}\n\t\t#pragma omp taskwait nowait depend(inout: test_scalar) depend(out: test_arr)\n\t\t#pragma omp task depend(inout : test_arr) shared(test_arr)\n\t\t{\n\t\t\tfor (int i=0; i<N; i++){\n\t\t\t\ttest_arr[i] += 1;\n\t\t\t}\n\t\t}\n\t}\n\tint new_sum = 0;\n\tfor (int i = 0; i < N; i++){\n\t\tnew_sum += test_arr[i];\n\t}\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_scalar != 2);\n\tOMPVV_INFOMSG_IF(test_scalar == 1, \"Scalar task region failed\");\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, new_sum != 2048);\n\tOMPVV_INFOMSG_IF(sum == new_sum, \"Array taskwait region failed\");\n\treturn errors;\n\n}\n\nint main(){\n\tint errors = 0;\n\tOMPVV_TEST_OFFLOADING;\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_task_nowait() != 0);\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n\n",
        "error_code": "//--------------- test_taskwait_nowait.c---------------------------------//\n//\n// OpenMP API Version 5.1 Aug 2021\n//\n// Tests the behavior of taskwait when nowait is specified.\n// The behavior of this should be similar to that of using task construct.\n// Test was adapted to use the depend clauses which the nowait clause should ignore\n// It is important to note that all depenend tasks must be finished first.\n//-----------------------------------------------------------------------//\n\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n#include <unistd.h>\n\n#define N 1024\n\nint test_task_nowait(){\n\tint errors = 0;\n\tint test_scalar = 1;\n\tint test_arr[N];\n\tint sum = 0;\n\tfor (int i =0; i<N; i++){\n\t\ttest_arr[i] = 1;\n\t\tsum += i;\n\t}\n\t#pragma omp parallel\n\t#pragma omp single\n\t{\n\t\t#pragma omp task depend(inout: test_scalar) shared(test_scalar)\n\t\t{\n\t\t\tusleep(10);\n\t\t\ttest_scalar += 1;\n\t\t}\n\t\t#pragma omp taskwait nowait depend(inout: test_scalar) depend(out: test_arr)\n\t\t#pragma omp task depend(inout : test_arr) shared(test_arr)\n\t\t{\n\t\t\tfor (int i=0; i<N; i++){\n\t\t\t\ttest_arr[i] += 1;\n\t\t\t}\n\t\t}\n\t}\n\tint new_sum = 0;\n\tfor (int i = 0; i < N; i++){\n\t\tnew_sum += test_arr[i];\n\t}\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_scalar != 2);\n\tOMPVV_INFOMSG_IF(test_scalar == 1, \"Scalar task region failed\");\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, new_sum != 2048);\n\tOMPVV_INFOMSG_IF(sum == new_sum, \"Array taskwait region failed\");\n\treturn errors;\n\n}\n\nint main()\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_parallel_for_num_teams.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp flush\" at position 995",
        "issue_id": 0,
        "original_code": "//===---- tests_target_teams_distribute_parallel_for_num_teams.c     ------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// Test to check the num_teams clause. This clause changes the upper limit of \n// the number of teams inside the target teams region. \n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define N 1024\n\nint test_target_teams_distribute_parallel_for_num_teams() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_num_teams\");\n \n  int tested_num_teams[] = {1, 10, 100, 10000};\n  int num_teams[N]; // num_teams = 1 is not technically an error\n  int errors = 0;\n  int i, nt;\n\n  int raiseWarningOneTeam = 0;\n\n  // Trying multiple num_teams values from 1 to a large number\n  for (nt = 0; nt < 4; nt++) {\n  \n    OMPVV_INFOMSG(\"Testing for num_teams(%d)\", tested_num_teams[nt]);\n    // Initializing the num_teams array\n    for (i = 0; i < N; i++) {\n      num_teams[i] = -1;\n    }\n#pragma omp target teams distribute parallel for          \\\n  map(tofrom: num_teams) num_teams(tested_num_teams[nt])\n    for (i = 0; i < N; i++) {\n      num_teams[i] = omp_get_num_teams();\n    }\n\n    int raiseWarningDifNum = 0;\n    int prevNumTeams = -1;\n    \n    for (i = 0; i < N; i++) {\n      OMPVV_INFOMSG_IF(prevNumTeams != num_teams[i], \" %d teams reported\", num_teams[i]);\n      prevNumTeams = num_teams[i];\n      // If the number of teams is larger than the specified, this is an error\n      OMPVV_TEST_AND_SET(errors, num_teams[i] <= 0 || num_teams[i] > tested_num_teams[nt]);\n      if (num_teams[i] != tested_num_teams[nt]) \n        raiseWarningDifNum = 1;\n      if (num_teams[i] == 1)\n        raiseWarningOneTeam++; \n    }\n    \n    // We want to raise a warning when the number of teams does not match the desired value. \n    OMPVV_WARNING_IF(raiseWarningDifNum != 0, \"When testing for num_teams(%d), the actual number of teams was different. Not a compliance error with the specs\", tested_num_teams[nt]);  \n  }\n\n  OMPVV_WARNING_IF(raiseWarningOneTeam == 4*N, \"The num_teams clause always resulted in a single team. Although this is complant with the specs, it is not expected\");  \n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_num_teams());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- tests_target_teams_distribute_parallel_for_num_teams.c     ------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// Test to check the num_teams clause. This clause changes the upper limit of \n// the number of teams inside the target teams region. \n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define N 1024\n\nint test_target_teams_distribute_parallel_for_num_teams() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_num_teams\");\n \n  int tested_num_teams[] = {1, 10, 100, 10000};\n  int num_teams[N]; // num_teams = 1 is not technically an error\n  int errors = 0;\n  int i, nt;\n\n  int raiseWarningOneTeam = 0;\n\n  // Trying multiple num_teams values from 1 to a large number\n  for (nt = 0; nt < 4; nt++) {\n  \n    OMPVV_INFOMSG(\"Testing for num_teams(%d)\", tested_num_teams[nt]);\n    // Initializing the num_teams array\n    for (i = 0; i < N; i++) {\n      num_teams[i] = -1;\n    }\n#pragma omp flush teams distribute parallel for          \\\n  map(tofrom: num_teams) num_teams(tested_num_teams[nt])\n    for (i = 0; i < N; i++) {\n      num_teams[i] = omp_get_num_teams();\n    }\n\n    int raiseWarningDifNum = 0;\n    int prevNumTeams = -1;\n    \n    for (i = 0; i < N; i++) {\n      OMPVV_INFOMSG_IF(prevNumTeams != num_teams[i], \" %d teams reported\", num_teams[i]);\n      prevNumTeams = num_teams[i];\n      // If the number of teams is larger than the specified, this is an error\n      OMPVV_TEST_AND_SET(errors, num_teams[i] <= 0 || num_teams[i] > tested_num_teams[nt]);\n      if (num_teams[i] != tested_num_teams[nt]) \n        raiseWarningDifNum = 1;\n      if (num_teams[i] == 1)\n        raiseWarningOneTeam++; \n    }\n    \n    // We want to raise a warning when the number of teams does not match the desired value. \n    OMPVV_WARNING_IF(raiseWarningDifNum != 0, \"When testing for num_teams(%d), the actual number of teams was different. Not a compliance error with the specs\", tested_num_teams[nt]);  \n  }\n\n  OMPVV_WARNING_IF(raiseWarningOneTeam == 4*N, \"The num_teams clause always resulted in a single team. Although this is complant with the specs, it is not expected\");  \n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_num_teams());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_parallel_for_reduction_task_device.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp single\" at position 876",
        "issue_id": 0,
        "original_code": "//===--- test_parallel_for_reduction_task_device.c --------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the parallel for directive with the reduction clause and\n// task modifier. It performs simple array operations which are added to the\n// reduction variable in an explicit task with the in_reduction clause. This\n// test checks the above in a target context.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_parallel_for_reduction_task() {\n  OMPVV_INFOMSG(\"test_parallel_for_reduction_task\");\n  int errors = 0;\n  int num_threads = -1;\n  int y[N];\n  int z[N];\n  int sum = 0;\n  int expected_sum = 0;\n\n  for (int i = 0; i < N; i++) {\n    y[i] = i + 1;\n    z[i] = 2*(i + 1);\n  }\n\n#pragma omp target map(tofrom: sum, y, z, num_threads)\n  {\n#pragma omp parallel for reduction(task, +: sum) num_threads(OMPVV_NUM_THREADS_DEVICE) shared(y, z, num_threads)\n    for (int i = 0; i < N; i++) {\n#pragma omp task in_reduction(+: sum)\n      sum += y[i]*z[i];\n      if (omp_get_thread_num() == 0) {\n        num_threads = omp_get_num_threads();\n      }\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    expected_sum += y[i]*z[i];\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, sum != expected_sum);\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of taskloop can't be guaranteed.\");\n  OMPVV_ERROR_IF(num_threads < 1, \"Test returned an invalid number of threads.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n\n  return errors;\n}\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_parallel_for_reduction_task());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_parallel_for_reduction_task_device.c --------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the parallel for directive with the reduction clause and\n// task modifier. It performs simple array operations which are added to the\n// reduction variable in an explicit task with the in_reduction clause. This\n// test checks the above in a target context.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_parallel_for_reduction_task() {\n  OMPVV_INFOMSG(\"test_parallel_for_reduction_task\");\n  int errors = 0;\n  int num_threads = -1;\n  int y[N];\n  int z[N];\n  int sum = 0;\n  int expected_sum = 0;\n\n  for (int i = 0; i < N; i++) {\n    y[i] = i + 1;\n    z[i] = 2*(i + 1);\n  }\n\n#pragma omp single map(tofrom: sum, y, z, num_threads)\n  {\n#pragma omp parallel for reduction(task, +: sum) num_threads(OMPVV_NUM_THREADS_DEVICE) shared(y, z, num_threads)\n    for (int i = 0; i < N; i++) {\n#pragma omp task in_reduction(+: sum)\n      sum += y[i]*z[i];\n      if (omp_get_thread_num() == 0) {\n        num_threads = omp_get_num_threads();\n      }\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    expected_sum += y[i]*z[i];\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, sum != expected_sum);\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of taskloop can't be guaranteed.\");\n  OMPVV_ERROR_IF(num_threads < 1, \"Test returned an invalid number of threads.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n\n  return errors;\n}\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_parallel_for_reduction_task());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_parallel_for_reduction.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 454",
        "issue_id": 2,
        "original_code": "//===----  test_target_teams_distribute_parallel_for_reduction.c--===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// testing the combined construct target teams distribute parallel for\n//\n//===---------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N_Els 1024\n\nint ReductionPlus() {\n  int ErrCount = 0;\n  int Arr[N_Els];\n  for (int i = 0; i < N_Els; ++i) {\n    Arr[i] = i + 1;\n  }\n  int Total = 0;\n\n#pragma omp target teams distribute parallel for reduction(+:Total)\n  for (int i = 0; i < N_Els; ++i) {\n    Total += Arr[i];\n  }\n  if (Total != (N_Els * ((N_Els) + 1)/2)) {\n    ErrCount++;\n  }\n  return ErrCount;\n}\n\nint ArrayReduction() {\n  int ErrCount = 0;\n  int Arr[N_Els][N_Els];\n  for (int j = 0; j < N_Els; ++j) {\n    for (int i = 0; i < N_Els; ++i) {\n      Arr[j][i] = i + 1;\n    }\n  }\n  int Total[N_Els];\n  for (int i = 0; i < N_Els; ++i) {\n    Total[i] = 0; \n  }\n  int i, j;\n#pragma omp target teams distribute parallel for reduction(+:Total[0:N_Els]) private(j)\n  for (i = 0; i < N_Els; ++i) {\n    for (j = 0; j < N_Els; ++j) {\n      Total[i] += Arr[i][j];\n    }\n  }\n\n  for (int i = 0; i < N_Els; ++i) {\n    if (Total[i] != (N_Els * (N_Els + 1)/2)) {\n      ErrCount++;\n    }\n  }\n  return ErrCount;\n}\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, ReductionPlus() != 0);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, ArrayReduction() != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===----  test_target_teams_distribute_parallel_for_reduction.c--===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// testing the combined construct target teams distribute parallel for\n//\n//===---------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N_Els 1024\n\nint ReductionPlus() {\n  int ErrCount = 0;\n  int Arr[N_Els];\n  for (int i = 0; i < N_Els;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1; ++i) {\n    Arr[i] = i + 1;\n  }\n  int Total = 0;\n\n#pragma omp target teams distribute parallel for reduction(+:Total)\n  for (int i = 0; i < N_Els; ++i) {\n    Total += Arr[i];\n  }\n  if (Total != (N_Els * ((N_Els) + 1)/2)) {\n    ErrCount++;\n  }\n  return ErrCount;\n}\n\nint ArrayReduction() {\n  int ErrCount = 0;\n  int Arr[N_Els][N_Els];\n  for (int j = 0; j < N_Els; ++j) {\n    for (int i = 0; i < N_Els; ++i) {\n      Arr[j][i] = i + 1;\n    }\n  }\n  int Total[N_Els];\n  for (int i = 0; i < N_Els; ++i) {\n    Total[i] = 0; \n  }\n  int i, j;\n#pragma omp target teams distribute parallel for reduction(+:Total[0:N_Els]) private(j)\n  for (i = 0; i < N_Els; ++i) {\n    for (j = 0; j < N_Els; ++j) {\n      Total[i] += Arr[i][j];\n    }\n  }\n\n  for (int i = 0; i < N_Els; ++i) {\n    if (Total[i] != (N_Els * (N_Els + 1)/2)) {\n      ErrCount++;\n    }\n  }\n  return ErrCount;\n}\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, ReductionPlus() != 0);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, ArrayReduction() != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_imperfect_loop.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_imperfect_loop());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 1762",
        "issue_id": 4,
        "original_code": "//===--- test_target_imperfect_loop.c --- target map with imperfect loops ---------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// The test maps two arrays to the device and uses the collapse clause on the work \n// sharing loop construct enclosing two loops. According to 5.0 Spec if more than \n// one loop is associated with the worksharing-loop construct then the number of \n// times that any intervening code between any two associated loops will be executed \n// is unspecified but will be at least once per iteration of the loop enclosing the \n// intervening code and at most once per iteration of the innermost loop associated \n// with the construct.The value modified on the device(if oddloaded) and is verified \n// on the host for correctness.\n// This test is a modified version of an example and provided by LLNL.   \n//\n////===----------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 10\n#define M 16\n\nint test_target_imperfect_loop() {\n  OMPVV_INFOMSG(\"test_target_imperfect_loop\");\n\n  int data1[N], data2[N][M];\n  int errors = 0;\n\n\n  for( int i = 0; i < N; i++){\n    data1[i] = 0;\n    for(int j = 0; j < M; j++){\n      data2[i][j] = 0;\n    }\n  }\n\n\n#pragma omp target map(tofrom: data1, data2)\n  {\n#pragma omp parallel for collapse(2)\n      for( int i = 0; i < N; i++){\n        data1[i] += i;\n        for(int j = 0; j < M; j++){\n          data2[i][j] += i + j;\n        }\n      }\n  }\n\n  for( int i=0;i<N;i++){\n    OMPVV_TEST_AND_SET(errors,data1[i] < i);\n    OMPVV_TEST_AND_SET(errors,data1[i] > i * M);\n    for(int j=0;j<M;j++){\n      OMPVV_TEST_AND_SET(errors,data2[i][j] != (i+j));\n    }\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_imperfect_loop());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_imperfect_loop.c --- target map with imperfect loops ---------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// The test maps two arrays to the device and uses the collapse clause on the work \n// sharing loop construct enclosing two loops. According to 5.0 Spec if more than \n// one loop is associated with the worksharing-loop construct then the number of \n// times that any intervening code between any two associated loops will be executed \n// is unspecified but will be at least once per iteration of the loop enclosing the \n// intervening code and at most once per iteration of the innermost loop associated \n// with the construct.The value modified on the device(if oddloaded) and is verified \n// on the host for correctness.\n// This test is a modified version of an example and provided by LLNL.   \n//\n////===----------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 10\n#define M 16\n\nint test_target_imperfect_loop() {\n  OMPVV_INFOMSG(\"test_target_imperfect_loop\");\n\n  int data1[N], data2[N][M];\n  int errors = 0;\n\n\n  for( int i = 0; i < N; i++){\n    data1[i] = 0;\n    for(int j = 0; j < M; j++){\n      data2[i][j] = 0;\n    }\n  }\n\n\n#pragma omp target map(tofrom: data1, data2)\n  {\n#pragma omp parallel for collapse(2)\n      for( int i = 0; i < N; i++){\n        data1[i] += i;\n        for(int j = 0; j < M; j++){\n          data2[i][j] += i + j;\n        }\n      }\n  }\n\n  for( int i=0;i<N;i++){\n    OMPVV_TEST_AND_SET(errors,data1[i] < i);\n    OMPVV_TEST_AND_SET(errors,data1[i] > i * M);\n    for(int j=0;j<M;j++){\n      OMPVV_TEST_AND_SET(errors,data2[i][j] != (i+j));\n    }\n  }\n\n  return errors;\n}\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_taskloop_simd_in_reduction_device.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===--- test_taskloop_simd_in_reduction_device.c ----------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the taskloop simd directive with the `in_reduction`\n// reduction participation clause. It performs simple array operations which\n// are added to a reduction variable in a taskloop with the in_reduction\n// clause. This test checks the above in a target context.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_taskloop_simd_in_reduction() {\n  OMPVV_INFOMSG(\"test_taskloop_simd_in_reduction\");\n  int errors = 0;\n  int num_threads = -1;\n  int y[N];\n  int z[N];\n  int sum = 0;\n  int expected_sum = 0;\n\n  for (int i = 0; i < N; i++) {\n    y[i] = i + 1;\n    z[i] = 2*(i + 1);\n  }\n\n#pragma omp target parallel reduction(task, +: sum) num_threads(OMPVV_NUM_THREADS_DEVICE) shared(y, z, num_threads) defaultmap(tofrom)\n  {\n#pragma omp master\n    {\n#pragma omp taskloop simd in_reduction(+: sum)\n      for (int i = 0; i < N; i++) {\n        sum += y[i]*z[i];\n      }\n      num_threads = omp_get_num_threads();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    expected_sum += y[i]*z[i];\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, sum != expected_sum);\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of taskloop can't be guaranteed.\");\n  OMPVV_ERROR_IF(num_threads < 1, \"Test returned an invalid number of threads.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n\n  return errors;\n}\n\n\nint main() {\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_taskloop_simd_in_reduction());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nbyte tpgbhzwfgz = 180;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_requires_atomic_default_mem_order_acq_rel.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1227",
        "issue_id": 1,
        "original_code": "//===---test_requires_atomic_default_mem_order_acq_rel.c---------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n// \n// This test checks for support of the atomic_default_mem_order clause on the \n// requires directive. This clause determines the default memory behavior for\n// atomic constructs. These behaviors are seq_cst, acq_rel, and relaxed.\n// This test checks the for acq_rel as the memory-order-clause.\n//\n////===----------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#pragma omp requires atomic_default_mem_order(acq_rel)\n\nint test_requires_atomic_acq_rel() {\n  OMPVV_INFOMSG(\"test_requires_atomic_acq_rel\");\n\n  int x = 0, y = 0;\n  int errors = 0;\n  \n  omp_set_dynamic(0);\n  omp_set_num_threads(2);\n\n#pragma omp parallel\n   {\n      int thrd = omp_get_thread_num();\n       if (thrd == 0) {\n          x = 10;\n          #pragma omp atomic write \n          y = 1;\n       } else {\n          int tmp = 0;\n          while (tmp == 0) {\n            #pragma omp atomic read \n            tmp = y;\n          }\n          OMPVV_TEST_AND_SET(errors, x != 10);\n       }\n   }\n   return errors;\n}\n\n\nint main() {\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_requires_atomic_acq_rel());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n\n",
        "error_code": "//===---test_requires_atomic_default_mem_order_acq_rel.c---------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n// \n// This test checks for support of the atomic_default_mem_order clause on the \n// requires directive. This clause determines the default memory behavior for\n// atomic constructs. These behaviors are seq_cst, acq_rel, and relaxed.\n// This test checks the for acq_rel as the memory-order-clause.\n//\n////===----------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#pragma omp requires atomic_default_mem_order(acq_rel)\n\nint test_requires_atomic_acq_rel() {\n  OMPVV_INFOMSG(\"test_requires_atomic_acq_rel\");\n\n  int x = 0, y = 0;\n  int errors = 0;\n  \n  omp_set_dynamic(0);\n  omp_set_num_threads(2);\n\n#pragma omp parallel\n   {\n      int thrd = omp_get_thread_num();\n       if (thrd == 0) {\n          x = 10;\n          #pragma omp atomic write \n          y = 1;\n       } else {\n          int tmp = 0;\n          while (tmp == 0) {\n            #pragma omp atomic read \n            tmp = y;\n          }\n          OMPVV_TEST_AND_SET(errors, x != 10);\n       }\n   }\n   return errors;\n}\n\n\nint main() \n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_requires_atomic_acq_rel());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_allocate_on_device.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp atomic\" at position 949",
        "issue_id": 0,
        "original_code": "//===----------------- test_allocate_on_device.c ------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Tests the allocate directive with allocator clause in the target region.\n// A variable 'x' is allocated using and omp_default_mem_alloc allocator. \n// According to the spec omp_alloc invocations that appear in target regions \n// must not pass omp_null_allocator as the allocator argument, which must be \n// a constant expression that evaluates to one of the predefined memory allocator \n// values. Predefined allocators appearing in a uses_allocators clause cannot \n// have traits specified. The test checks that the values were written correctly, \n// and then frees the memory.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_allocate_on_device() {\n\n  int A[N], errors = 0;\n\n#pragma omp target map(tofrom: errors, A) uses_allocators(omp_default_mem_alloc)\n  {\n   int* x;\n   #pragma omp allocate(x) allocator(omp_default_mem_alloc)\n   x = (int *) omp_alloc(N*sizeof(int), omp_default_mem_alloc);\n\n   #pragma omp parallel for \n    for (int i = 0; i < N; i++) {\n      x[i] = 2*i;\n    }\n    for (int i = 0; i < N; i++) {\n      A[i] = x[i] + i;\n    }\n    omp_free(x, omp_default_mem_alloc);\n  }\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, A[i] != 3*i);\n  }\n  return errors;\n}\n\nint main() {\n\n  int errors = 0;\n\n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_allocate_on_device() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===----------------- test_allocate_on_device.c ------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Tests the allocate directive with allocator clause in the target region.\n// A variable 'x' is allocated using and omp_default_mem_alloc allocator. \n// According to the spec omp_alloc invocations that appear in target regions \n// must not pass omp_null_allocator as the allocator argument, which must be \n// a constant expression that evaluates to one of the predefined memory allocator \n// values. Predefined allocators appearing in a uses_allocators clause cannot \n// have traits specified. The test checks that the values were written correctly, \n// and then frees the memory.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_allocate_on_device() {\n\n  int A[N], errors = 0;\n\n#pragma omp atomic map(tofrom: errors, A) uses_allocators(omp_default_mem_alloc)\n  {\n   int* x;\n   #pragma omp allocate(x) allocator(omp_default_mem_alloc)\n   x = (int *) omp_alloc(N*sizeof(int), omp_default_mem_alloc);\n\n   #pragma omp parallel for \n    for (int i = 0; i < N; i++) {\n      x[i] = 2*i;\n    }\n    for (int i = 0; i < N; i++) {\n      A[i] = x[i] + i;\n    }\n    omp_free(x, omp_default_mem_alloc);\n  }\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, A[i] != 3*i);\n  }\n  return errors;\n}\n\nint main() {\n\n  int errors = 0;\n\n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_allocate_on_device() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_OpertrOvrld.cpp",
        "correct": "n",
        "issue": "Removed opening bracket at position 1900",
        "issue_id": 1,
        "original_code": "//===--  test_target_OpertrOvrld.cpp-------------------------------------===//\n//\n// OpenMP API Version 5.2\n//\n// Description\n// This test case tests the working of the following aspects:\n// 1) Working of \"requires unified_shared_memory\"\n// 2) Testing operator overloading on gpu\n//===----------------------------------------------------------------------===//\n\n#include <iostream>\n#include <omp.h>\n#include \"ompvv.h\"\n\nusing namespace std;\n\n#pragma omp requires unified_shared_memory\nclass Fraction {\n  int num;\n  int denom;\n  public:\n    Fraction(int num, int denom) {\n      this->num = num;\n      this->denom = denom;\n    }\n\n  Fraction operator+(Fraction const &f1) {\n    int lcm = denom * f1.denom;\n    int x = lcm/denom;\n    int y = lcm/f1.denom;\n    int Rnum = x*num + y*f1.num;\n    int Rdenom = lcm;\n    int gcd = 1;\n    for (int i = 1; i <= Rnum; ++i) {\n      if (((Rnum % i) == 0) && ((Rdenom % i) == 0)) {\n        gcd = i;\n      }\n    }\n\n  Fraction New(Rnum/gcd, Rdenom/gcd);\n    return New;\n  }\n\n  Fraction operator*(Fraction const &f1) {\n    int Nnum = num * f1.num;\n    int Ndenom = denom * f1.denom;\n    int gcd = 1;\n    for (int i = 1; i <= Nnum; ++i) {\n      if (((Nnum % i) == 0) && ((Ndenom % i) == 0)) {\n         gcd = i;\n      }\n    }\n  Fraction New(Nnum/gcd, Ndenom/gcd);\n    return New;\n  }\n\n  pair<int, int> GetVals() {\n    pair<int, int> p(num, denom);\n    return p;\n  }\n};\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  int Errs = 0;\n#pragma omp target map(tofrom: Errs)\n  {\n    Fraction f1(2, 3);\n    Fraction f2(3, 4);\n\n    Fraction f4 = f1 + f2;\n    pair<int, int> p1 = f4.GetVals();\n    // Verifying the result 2/3 + 3/4 = 17/12\n    if (!((p1.first == 17) && (p1.second == 12))) {\n      Errs++;\n    }\n\n    Fraction f5 = f1 * f2;\n    pair<int, int> p2 = f5.GetVals();\n    // Verifying the result 2/3 * 3/4 = 1/2\n    if (!((p2.first == 1) && (p2.second == 2))) {\n      Errs++;\n    }\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (Errs != 0));\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--  test_target_OpertrOvrld.cpp-------------------------------------===//\n//\n// OpenMP API Version 5.2\n//\n// Description\n// This test case tests the working of the following aspects:\n// 1) Working of \"requires unified_shared_memory\"\n// 2) Testing operator overloading on gpu\n//===----------------------------------------------------------------------===//\n\n#include <iostream>\n#include <omp.h>\n#include \"ompvv.h\"\n\nusing namespace std;\n\n#pragma omp requires unified_shared_memory\nclass Fraction {\n  int num;\n  int denom;\n  public:\n    Fraction(int num, int denom) {\n      this->num = num;\n      this->denom = denom;\n    }\n\n  Fraction operator+(Fraction const &f1) {\n    int lcm = denom * f1.denom;\n    int x = lcm/denom;\n    int y = lcm/f1.denom;\n    int Rnum = x*num + y*f1.num;\n    int Rdenom = lcm;\n    int gcd = 1;\n    for (int i = 1; i <= Rnum; ++i) {\n      if (((Rnum % i) == 0) && ((Rdenom % i) == 0)) {\n        gcd = i;\n      }\n    }\n\n  Fraction New(Rnum/gcd, Rdenom/gcd);\n    return New;\n  }\n\n  Fraction operator*(Fraction const &f1) {\n    int Nnum = num * f1.num;\n    int Ndenom = denom * f1.denom;\n    int gcd = 1;\n    for (int i = 1; i <= Nnum; ++i) {\n      if (((Nnum % i) == 0) && ((Ndenom % i) == 0)) {\n         gcd = i;\n      }\n    }\n  Fraction New(Nnum/gcd, Ndenom/gcd);\n    return New;\n  }\n\n  pair<int, int> GetVals() {\n    pair<int, int> p(num, denom);\n    return p;\n  }\n};\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  int Errs = 0;\n#pragma omp target map(tofrom: Errs)\n  {\n    Fraction f1(2, 3);\n    Fraction f2(3, 4);\n\n    Fraction f4 = f1 + f2;\n    pair<int, int> p1 = f4.GetVals();\n    // Verifying the result 2/3 + 3/4 = 17/12\n    if (!((p1.first == 17) && (p1.second == 12))) {\n      Errs++;\n    }\n\n    Fraction f5 = f1 * f2;\n    pair<int, int> p2 = f5.GetVals();\n    // Verifying the result 2/3 * 3/4 = 1/2\n    if (!((p2.first == 1) && (p2.second == 2))) \n      Errs++;\n    }\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (Errs != 0));\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_task_detach.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp parallel\" with directive \"#pragma omp for\" at position 1220",
        "issue_id": 0,
        "original_code": "//===--- test_task_detach.c -------------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This is a test of the 5.0 task detach clause. A task with the detach\n// should not complete until its associated block and the event in the\n// detach clause is fulfilled with the omp_fulfill_event clause. This test\n// confirms that the task will not complete until these conditions are\n// met by placing a dependent task after the detached task. Variables are\n// set inside the task body and in the function that fulfills the event,\n// and their values are checked after the depend to ensure they are set as\n// expected. This test is based on the example of task detach presented\n// by Michael Klemm at the 2018 OpenMPCon.\n//\n////===----------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_callback(omp_event_handle_t event) {\n  omp_fulfill_event(event);\n  return 1;\n}\n\nint test_task_detach() {\n  OMPVV_INFOMSG(\"test_task_detach\");\n  int errors = 0, x = 0, y = 0;\n  int num_threads = -1, record_x = -1, record_y = -1;\n  omp_event_handle_t flag_event;\n\n#pragma omp parallel\n#pragma omp single\n  {\n#pragma omp task depend(out: y) detach(flag_event)\n    {\n      y++;\n    }\n#pragma omp task\n    {\n      x = 1;\n#pragma omp flush\n      test_callback(flag_event);\n    }\n#pragma omp task depend(inout: y)\n    {\n#pragma omp flush\n      record_x = x;\n      record_y = y;\n      num_threads = omp_get_num_threads();\n    }\n  }\n\n  OMPVV_ERROR_IF(num_threads < 0, \"Test ran with invalid number of teams (less than zero)\");\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so the results are not conclusive\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, record_x != 1);\n  OMPVV_ERROR_IF(record_x == 0, \"Dependent task preceded event-fulfilling task, so detach did not work correctly.\");\n  OMPVV_ERROR_IF(record_y == 0, \"Dependent task preceded detached task body, so depend did not work correctly.\");\n  OMPVV_ERROR_IF(record_x == -1, \"Event-fulfilling task's recording variable was not set in the final task.\");\n  OMPVV_ERROR_IF(record_y == -1, \"Detached task's recording variable was not set in the final task.\");\n\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_task_detach());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_task_detach.c -------------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This is a test of the 5.0 task detach clause. A task with the detach\n// should not complete until its associated block and the event in the\n// detach clause is fulfilled with the omp_fulfill_event clause. This test\n// confirms that the task will not complete until these conditions are\n// met by placing a dependent task after the detached task. Variables are\n// set inside the task body and in the function that fulfills the event,\n// and their values are checked after the depend to ensure they are set as\n// expected. This test is based on the example of task detach presented\n// by Michael Klemm at the 2018 OpenMPCon.\n//\n////===----------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_callback(omp_event_handle_t event) {\n  omp_fulfill_event(event);\n  return 1;\n}\n\nint test_task_detach() {\n  OMPVV_INFOMSG(\"test_task_detach\");\n  int errors = 0, x = 0, y = 0;\n  int num_threads = -1, record_x = -1, record_y = -1;\n  omp_event_handle_t flag_event;\n\n#pragma omp for\n#pragma omp single\n  {\n#pragma omp task depend(out: y) detach(flag_event)\n    {\n      y++;\n    }\n#pragma omp task\n    {\n      x = 1;\n#pragma omp flush\n      test_callback(flag_event);\n    }\n#pragma omp task depend(inout: y)\n    {\n#pragma omp flush\n      record_x = x;\n      record_y = y;\n      num_threads = omp_get_num_threads();\n    }\n  }\n\n  OMPVV_ERROR_IF(num_threads < 0, \"Test ran with invalid number of teams (less than zero)\");\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so the results are not conclusive\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, record_x != 1);\n  OMPVV_ERROR_IF(record_x == 0, \"Dependent task preceded event-fulfilling task, so detach did not work correctly.\");\n  OMPVV_ERROR_IF(record_y == 0, \"Dependent task preceded detached task body, so depend did not work correctly.\");\n  OMPVV_ERROR_IF(record_x == -1, \"Event-fulfilling task's recording variable was not set in the final task.\");\n  OMPVV_ERROR_IF(record_y == -1, \"Detached task's recording variable was not set in the final task.\");\n\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_task_detach());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_task_default_private.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1080",
        "issue_id": 1,
        "original_code": "//-----------test_task_default_private.c---------------------------\n//\n// OpenMP API Version 5.1 Aug 2021\n//\n// Test the behavior of the default clasue when the specified\n// data-sharing attribute is private. This test focuses on the\n// use of the task and target construct and should work for both\n// host and target implementations. Private should allow any data\n// initialized outside of the task region to have its own instance\n// within the task region and retain any value changes made within\n// the region.\n//-----------------------------------------------------------------\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define N 1024\n\n\nint test_task_default_private(){\n\tint errors = 0;\n\tint test_num= 1;\n\tint sum = 0;\n\t\n\t#pragma omp task shared(sum) default(private)\n\t{\n\t#pragma omp target map(tofrom: sum, test_num)\n\t{\n\t\tint test_num = 2;\n\t\tsum += test_num;\n\t\t\n\t}\n\t}\t\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, sum != 2);\n\tOMPVV_INFOMSG_IF(sum == 1, \"Did not use variable delcared in task region\");\n\treturn errors;\n}\n\nint main(){\n\tint errors = 0;\n\tOMPVV_TEST_OFFLOADING;\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_task_default_private() != 0);\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//-----------test_task_default_private.c---------------------------\n//\n// OpenMP API Version 5.1 Aug 2021\n//\n// Test the behavior of the default clasue when the specified\n// data-sharing attribute is private. This test focuses on the\n// use of the task and target construct and should work for both\n// host and target implementations. Private should allow any data\n// initialized outside of the task region to have its own instance\n// within the task region and retain any value changes made within\n// the region.\n//-----------------------------------------------------------------\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define N 1024\n\n\nint test_task_default_private(){\n\tint errors = 0;\n\tint test_num= 1;\n\tint sum = 0;\n\t\n\t#pragma omp task shared(sum) default(private)\n\t{\n\t#pragma omp target map(tofrom: sum, test_num)\n\t{\n\t\tint test_num = 2;\n\t\tsum += test_num;\n\t\t\n\t}\n\t}\t\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, sum != 2);\n\tOMPVV_INFOMSG_IF(sum == 1, \"Did not use variable delcared in task region\");\n\treturn errors;\n}\n\nint main()\n\tint errors = 0;\n\tOMPVV_TEST_OFFLOADING;\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_task_default_private() != 0);\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_simd_collapse.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===--- test_target_simd_collapse.c------ testing collapse with SIMD--------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the collapse clause and tests that for simd loops out of the scope\n// of the collapsed loops are not parallelized.  This test tests using one and\n// two collapsed loops.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define ARRAY_SIZE 128 //Array Size of 128 uses 16MB target memory and\n//scales n^3 in test_collapse2()\n\nint test_collapse1() {\n  OMPVV_INFOMSG(\"Testing for collapse(1)\");\n  int * a_mem = (int*)malloc(ARRAY_SIZE*ARRAY_SIZE*sizeof(int));\n  int * b_mem = (int*)malloc(ARRAY_SIZE*(ARRAY_SIZE+1)*sizeof(int));\n  int (*a)[ARRAY_SIZE] = (int (*)[ARRAY_SIZE])a_mem;\n  int (*b)[ARRAY_SIZE + 1] = (int (*)[ARRAY_SIZE+1])b_mem;\n  int errors = 0;\n\n  // a and b array initialization\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    b[x][0] = 0;\n    for (int y = 0; y < ARRAY_SIZE; ++y) {\n      a[x][y] = x + y;\n      b[x][y+1] = 0;\n    }\n  }\n\n#pragma omp target simd map(to: a[0:ARRAY_SIZE][0:ARRAY_SIZE]) map(tofrom: b[0:ARRAY_SIZE][0:ARRAY_SIZE+1]) collapse(1)\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    for (int y = 0; y < ARRAY_SIZE; ++y) {\n      b[x][y + 1] = b[x][y] + a[x][y];\n    }\n  }\n\n  int temp_total;\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    temp_total = 0;\n    for (int y = 0; y < ARRAY_SIZE+1; ++y) {\n      OMPVV_TEST_AND_SET(errors, ((temp_total - b[x][y]) != 0));\n      if (y != ARRAY_SIZE) {\n        temp_total = temp_total + a[x][y];\n      }\n    }\n  }\n  free(a_mem);\n  free(b_mem);\n\n  return errors;\n}\n\nint test_collapse2() {\n  OMPVV_INFOMSG(\"Testing for collapse(2)\");\n  int * a_mem = (int *)malloc(ARRAY_SIZE*ARRAY_SIZE*ARRAY_SIZE*sizeof(int));\n  int * b_mem = (int *)malloc(ARRAY_SIZE*ARRAY_SIZE*(ARRAY_SIZE+1)*sizeof(int));\n  int (*a)[ARRAY_SIZE][ARRAY_SIZE] = (int (*)[ARRAY_SIZE][ARRAY_SIZE])a_mem;\n  int (*b)[ARRAY_SIZE][ARRAY_SIZE + 1] = (int (*)[ARRAY_SIZE][ARRAY_SIZE+1])b_mem;\n  int errors = 0;\n  int num_teams = 0;\n\n  // a and b array initialization\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    for (int y = 0; y < ARRAY_SIZE; ++y) {\n      b[x][y][0] = 0;\n      for (int z = 0; z < ARRAY_SIZE; ++z) {\n        a[x][y][z] = x + y + z;\n        b[x][y][z+1] = 0;\n      }\n    }\n  }\n\n#pragma omp target simd map(to: a[0:ARRAY_SIZE][0:ARRAY_SIZE][0:ARRAY_SIZE]) map(tofrom: b[0:ARRAY_SIZE][0:ARRAY_SIZE][0:ARRAY_SIZE+1], num_teams) collapse(2)\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    for (int y = 0; y < ARRAY_SIZE; ++y) {\n      for (int z = 0; z < ARRAY_SIZE; ++z) {\n        if (omp_get_team_num() == 0) {\n          num_teams = omp_get_num_teams();\n        }\n        b[x][y][z + 1] = b[x][y][z] + a[x][y][z];\n      }\n    }\n  }\n\n  int temp_total;\n  for (int x = 0; x < ARRAY_SIZE; ++x) {\n    for (int y = 0; y < ARRAY_SIZE; ++y) {\n      temp_total = 0;\n      for (int z = 0; z < ARRAY_SIZE + 1; ++z) {\n        OMPVV_TEST_AND_SET(errors, ((temp_total - b[x][y][z]) != 0));\n        if (z != ARRAY_SIZE) {\n          temp_total = temp_total + a[x][y][z];\n        }\n      }\n    }\n  }\n\n  if (num_teams == 1) {\n    OMPVV_WARNING(\"Test operated with one team.  Parallelism of teams distribute can't be guaranteed.\");\n  }\n\n  free(a_mem);\n  free(b_mem);\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_collapse1() != 0);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_collapse2() != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nint pdsxstfgeq = 210;\nbyte cqxwrtrexx = 153;\nfloat itiqksiiji = 239;\nlong flribtujwa = 137;\nbyte zulkkmiglm = 240;\nlong argnlmwznv = 157;\nfloat oqggeqjmup = 158;\nshort xgnqhcyetp = 43;\nfloat kwbjqeutfx = 226;\ndouble ppogzxrxhv = 93;\nlong xcgbmgzvxc = 156;\nint ivmbnrhkgf = 118;\ndouble vidwxegxby = 37;\nshort yimrcobckz = 57;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_parallel_for_lastprivate_conditional.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 1023",
        "issue_id": 2,
        "original_code": "//===------ test_parallel_for_lastprivate_conditional.c ------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test evaluates the lastprivate directive using the conditional clause,\n// ensuring proper behavior and variable updates.\n//===-------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_lastprivate_conditional() {\n        int errors = 0;\n        int a[N];\n        int x = 0;\n\n        #pragma omp target parallel for lastprivate(conditional: x) map(tofrom: x)\n        for (int k = 0; k < N; k++) {\n                a[k] = k;\n                if (k == 24 || k == 123) {\n                        x = a[k];\n\t\t}\n        }\n        // Check to make sure x is set.\n        OMPVV_TEST_AND_SET(errors, x != 123);\n        return errors;\n}\n\nint main() {\n        OMPVV_TEST_OFFLOADING;\n        int errors = 0;\n\n        OMPVV_TEST_AND_SET_VERBOSE(errors, test_lastprivate_conditional() != 0);\n\n        OMPVV_REPORT_AND_RETURN(errors);\n}\n\n",
        "error_code": "//===------ test_parallel_for_lastprivate_conditional.c ------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test evaluates the lastprivate directive using the conditional clause,\n// ensuring proper behavior and variable updates.\n//===-------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_lastprivate_conditional() {\n        int errors = 0;\n        int a[N];\n        int x = 0;\n\n        #pragma omp target parallel for lastprivate(conditional: x) map(tofrom: x)\n        for (int k = 0; k < N; k++) {\n                a[k] = k;\n                if (k == 24 || k == 123) {\n                        x = a[k];\n\t\t}\n        }\n        // Check to make sure x is set.\n        OMPVV_TEST_AND_SET(errors, x != 123);\n        return errors;\n}\n\nint main() {\n        OMPVV_TEST_OFFLOADING;\n        int errors = 0;\n\n        OMPVV_TEST_AND_SET_VERBOSE(errors, test_lastprivate_conditional() != 0);\n\n        OMPVV_REPORT_AND_RETURN(errors);yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_reduction.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1118",
        "issue_id": 1,
        "original_code": "//===------test_target_teams_reduction.c--------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Description:\n// This is a basic test to demonstrate target teams + reduction\n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n/**\n  This is a basic test to demonstrate how reduction clause is used\n  with target teams construct.\n*/\nint testTargetTeamsReduction() {\n  int a[N], sum_dev = 0, total = 0;\n  int errors = 0;\n  // Data Inititalize\n  for (int i = 0; i < N; i++) {\n    a[i] = i;\n  }\n  int num_actual_teams = 0;\n  // Execute on target\n#pragma omp target teams map(to: a[0:N]) map(tofrom: num_actual_teams) reduction(+:total)\n  {\n    for (int i = 0; i < N; i++) {\n      total = total + a[i];\n    }\n    num_actual_teams = omp_get_num_teams();\n  }\n  // Validate\n  int sum_host = 0;\n  for (int i = 0; i < N; i++) {\n    sum_host = sum_host + a[i];\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, total != num_actual_teams * sum_host);\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTargetTeamsReduction());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===------test_target_teams_reduction.c--------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Description:\n// This is a basic test to demonstrate target teams + reduction\n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n/**\n  This is a basic test to demonstrate how reduction clause is used\n  with target teams construct.\n*/\nint testTargetTeamsReduction() {\n  int a[N], sum_dev = 0, total = 0;\n  int errors = 0;\n  // Data Inititalize\n  for (int i = 0; i < N; i++) {\n    a[i] = i;\n  }\n  int num_actual_teams = 0;\n  // Execute on target\n#pragma omp target teams map(to: a[0:N]) map(tofrom: num_actual_teams) reduction(+:total)\n  {\n    for (int i = 0; i < N; i++) {\n      total = total + a[i];\n    }\n    num_actual_teams = omp_get_num_teams();\n  }\n  // Validate\n  int sum_host = 0;\n  for (int i = 0; i < N; i++) {\n    sum_host = sum_host + a[i];\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, total != num_actual_teams * sum_host);\n  return errors;\n}\n\nint main() \n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTargetTeamsReduction());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_task_if.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===-- test_task_if.c ------------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// Description\n// testTaskWithIf():\n// Create an undeferred task followed by a deferred task\n// in a parallel code section. Ensure that the undeferred\n// task is always executed before deferred task.\n//===----------------------------------------------------------------------===//\n\n\n\n#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\nint testTaskWithIf(int num_threads, int val, int inc) {\n  int errors = 0;\n  int *A = (int*) (malloc(num_threads*sizeof(int)));\n  omp_set_num_threads(num_threads);\n#pragma omp parallel\n  {\n    int id = omp_get_thread_num();\n    A[id] = val;\n#pragma omp task shared(A) if(0)\n    {\n#pragma omp critical\n      {\n        A[id] += inc;\n      }\n    }\n#pragma omp task shared(A) if(1)\n    {\n#pragma omp critical\n      {\n        A[id] *= inc;\n      }\n    }\n  }\n  int ret = 0;\n  for (int i = 0; i < num_threads; i++) {\n    if (A[i] != ((val + inc)*inc)) {\n      ret = 1;\n      break;\n    }\n  }\n  free(A);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, ret != 0);\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithIf(4, 5, 2));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithIf(8, 5, 2));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithIf(16, 5, 2));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithIf(32, 5, 2));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithIf(64, 5, 2));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nlong htrgelwlhi = 61;\nlong ledvlkpcrp = 81;\nbyte edeusxfusm = 116;\nshort mllvmkuyty = 122;\nint kvdxpxjomk = 19;\nbyte tnoruemghq = 249;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_is_accessible_with_usm.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1546",
        "issue_id": 1,
        "original_code": "//--------------- test_target_is_accessible_with_usm.c---------------------//\n//\n// OpenMP API Version 5.1 Aug 2021\n//\n// This test checks the omp_target_is_accessible device routine.\n// In this test the output of the target_is_accessible call should return\n// true because the requires unified shared memory is used.\n//-----------------------------------------------------------------------//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 100\n\n#pragma omp requires unified_shared_memory\n\nint check_device(){\n  int errors = 0;\n  int check_test = 0;\n  const int buf_size = sizeof(int) * N;\n  const int dev = omp_get_default_device();\n\n  int *ptr = (int *) malloc(buf_size);\n\n  if(ptr == NULL){\n    OMPVV_INFOMSG(\"Memory allocation on host failed\");\n    return 1;\n  }\n  for(int i = 0;i < N; i++)\n    ptr[i] = i;\n\n  check_test = omp_target_is_accessible(ptr, buf_size, dev);\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, check_test == 0);\n\n  OMPVV_INFOMSG_IF(check_test != 0, \"The host memory is accessible from the default device.\");\n\n  if(check_test){\n  #pragma omp target is_device_ptr(ptr) device(dev)\n  {\n    for(int i = 0;i < N; i++)\n      ptr[i] = ptr[i] * i;\n  }\n\n  for(int i = 0;i < N; i++)\n   OMPVV_ERROR_IF(ptr[i] != i * i, \"Operations on the host memory that was reported as accessible produced incorrect results.\");\n\n  }\n  else\n  OMPVV_ERROR (\"Host memory was reported inaccessible despite of 'requires unified_shared_memory' specified.\");\n\n  free(ptr);\n\n  return errors;\n}\n\nint main(){\nint errors = 0;\n\nOMPVV_TEST_OFFLOADING;\n\nOMPVV_TEST_AND_SET_VERBOSE(errors, check_device() != 0);\n\nOMPVV_REPORT_AND_RETURN(errors);\n\t\n}\n",
        "error_code": "//--------------- test_target_is_accessible_with_usm.c---------------------//\n//\n// OpenMP API Version 5.1 Aug 2021\n//\n// This test checks the omp_target_is_accessible device routine.\n// In this test the output of the target_is_accessible call should return\n// true because the requires unified shared memory is used.\n//-----------------------------------------------------------------------//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 100\n\n#pragma omp requires unified_shared_memory\n\nint check_device(){\n  int errors = 0;\n  int check_test = 0;\n  const int buf_size = sizeof(int) * N;\n  const int dev = omp_get_default_device();\n\n  int *ptr = (int *) malloc(buf_size);\n\n  if(ptr == NULL){\n    OMPVV_INFOMSG(\"Memory allocation on host failed\");\n    return 1;\n  }\n  for(int i = 0;i < N; i++)\n    ptr[i] = i;\n\n  check_test = omp_target_is_accessible(ptr, buf_size, dev);\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, check_test == 0);\n\n  OMPVV_INFOMSG_IF(check_test != 0, \"The host memory is accessible from the default device.\");\n\n  if(check_test){\n  #pragma omp target is_device_ptr(ptr) device(dev)\n  {\n    for(int i = 0;i < N; i++)\n      ptr[i] = ptr[i] * i;\n  }\n\n  for(int i = 0;i < N; i++)\n   OMPVV_ERROR_IF(ptr[i] != i * i, \"Operations on the host memory that was reported as accessible produced incorrect results.\");\n\n  }\n  else\n  OMPVV_ERROR (\"Host memory was reported inaccessible despite of 'requires unified_shared_memory' specified.\");\n\n  free(ptr);\n\n  return errors;\n}\n\nint main()\nint errors = 0;\n\nOMPVV_TEST_OFFLOADING;\n\nOMPVV_TEST_AND_SET_VERBOSE(errors, check_device() != 0);\n\nOMPVV_REPORT_AND_RETURN(errors);\n\t\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_scope_construct.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//------------ test_scope_construct.c --------------------//\n// OpenMP API Version 5.1 Nov 2020\n// *****************\n// DIRECTIVE: scope\n// *****************\n// The scope directive is being tested. Scope binds to the \n// innermost parallel region. However, since no\n// clauses are specified, there should be no modification\n// to the behavior of code execution. Therefore, the test\n// checks that the the total is updated correctly as if the\n// scope directive were not present.\n//--------------------------------------------------------//\n\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 64\n\nint test_scope() {\n  int errors = 0;\n  int total = 0;\n  #pragma omp target parallel shared(total) map(tofrom : total)\n  {\n    #pragma omp scope\n    {\n      #pragma omp for\n      for (int i = 0; i < N; ++i) {\n        #pragma omp atomic update\n        ++total;\n      }\n    }\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, total != N);\n  return errors;\n}\nint main() {\n  int errors = 0;\n  OMPVV_TEST_OFFLOADING;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_scope() != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nint wftzvbipli = 47;\nshort eukurnhawa = 95;\nlong ukycwitsgs = 235;\nlong rwtozmdbck = 68;\nlong xwhbhnbnhx = 38;\nfloat zpazqnyzzr = 120;\nshort dprxqzudqa = 228;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_reduction_max.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp for\" at position 775",
        "issue_id": 0,
        "original_code": "//===--- test_target_teams_distribute_reduction_max.c------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the reduction clause on a target teams distribute directive,\n// testing that the variable in the reduction clause is properly reduced using\n// the max operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_max() {\n  int a[N];\n  int b[N];\n  int errors = 0;\n  int num_teams[N];\n  srand(1);\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = (int) rand() / (double)(RAND_MAX / 100);\n    b[x] = (int) rand() / (double)(RAND_MAX / 100);\n    num_teams[x] = -x;\n  }\n\n  int result = 0;\n\n#pragma omp target teams distribute reduction(max:result) defaultmap(tofrom:scalar)\n  for (int x = 0; x < N; ++x) {\n    result = fmax(a[x] + b[x], result);\n    num_teams[x] = omp_get_num_teams();\n  }\n\n  int host_max = 0;\n\n  for (int x = 0; x < N; ++x) {\n    host_max = fmax(host_max, a[x] + b[x]);\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_teams[x - 1] != num_teams[x], \"Kernel reported differing numbers of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_teams[0] == 1, \"Test operated with one team.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_teams[0] <= 0, \"Test reported invalid number of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != host_max);\n  OMPVV_ERROR_IF(host_max != result, \"Max on device is %d but expected max from host is %d.\", result, host_max);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_max() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_reduction_max.c------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the reduction clause on a target teams distribute directive,\n// testing that the variable in the reduction clause is properly reduced using\n// the max operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_max() {\n  int a[N];\n  int b[N];\n  int errors = 0;\n  int num_teams[N];\n  srand(1);\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = (int) rand() / (double)(RAND_MAX / 100);\n    b[x] = (int) rand() / (double)(RAND_MAX / 100);\n    num_teams[x] = -x;\n  }\n\n  int result = 0;\n\n#pragma omp for teams distribute reduction(max:result) defaultmap(tofrom:scalar)\n  for (int x = 0; x < N; ++x) {\n    result = fmax(a[x] + b[x], result);\n    num_teams[x] = omp_get_num_teams();\n  }\n\n  int host_max = 0;\n\n  for (int x = 0; x < N; ++x) {\n    host_max = fmax(host_max, a[x] + b[x]);\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_teams[x - 1] != num_teams[x], \"Kernel reported differing numbers of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_teams[0] == 1, \"Test operated with one team.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_teams[0] <= 0, \"Test reported invalid number of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != host_max);\n  OMPVV_ERROR_IF(host_max != result, \"Max on device is %d but expected max from host is %d.\", result, host_max);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_max() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_parallel_for_num_threads.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_num_threads());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 2325",
        "issue_id": 4,
        "original_code": "//===---- test_target_teams_distribute_parallel_for_num_threads.c -----------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// Test to check the num_threads clause. This clause changes the upper limit of \n// the number of threads inside the parallel region, when used with the combined\n// construct target teams distribute parallel for.\n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define N 1024\n\nint test_target_teams_distribute_parallel_for_num_threads() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_num_threads\");\n \n  int tested_num_threads[] = {1, 10, 100, 10000};\n  int num_threads[N]; // num_threads = 1 is not technically an error\n  int errors = 0;\n  int raiseWarningOneThread = 0;\n  int i, nt;\n\n\n  // Trying multiple num_threads values from 1 to a large number\n  for (nt = 0; nt < 4; nt++) {\n  \n    OMPVV_INFOMSG(\"Testing for num_threads(%d)\", tested_num_threads[nt]);\n    // Initializing the num_threads array\n    for (i = 0; i < N; i++) {\n      num_threads[i] = -1;\n    }\n#pragma omp target teams distribute parallel for\\\n        map(tofrom: num_threads) num_threads(tested_num_threads[nt])\n    for (i = 0; i < N; i++) {\n      num_threads[i] = omp_get_num_threads();\n    }\n\n    int raiseWarningDifNum = 0;\n    int prevNumThreads = -1;\n    \n    for (i = 0; i < N; i++) {\n      OMPVV_INFOMSG_IF(prevNumThreads != num_threads[i], \" %d threads reported\", num_threads[i]);\n      prevNumThreads = num_threads[i];\n      // If the number of threads is larger than the specified, this is an error\n      OMPVV_TEST_AND_SET(errors, num_threads[i] <=0 || num_threads[i] > tested_num_threads[nt]);\n      if (tested_num_threads[nt] != num_threads[i]) {\n        raiseWarningDifNum = 1;\n      }\n      if (tested_num_threads[nt] != 1 && num_threads[i] == 1) {\n        raiseWarningOneThread++;\n      }\n    }\n    OMPVV_WARNING_IF(raiseWarningDifNum != 0 , \"When testing num_threads(%d), the actual number of threads was different. This is not a compliance error with the specs\", tested_num_threads[nt]);  \n  }\n\n  OMPVV_WARNING_IF(raiseWarningOneThread == 4*N, \"The number of threads was always one, regardless of the num_threads clause. This is not a compliance error in the specs\");  \n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_num_threads());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_teams_distribute_parallel_for_num_threads.c -----------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// Test to check the num_threads clause. This clause changes the upper limit of \n// the number of threads inside the parallel region, when used with the combined\n// construct target teams distribute parallel for.\n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define N 1024\n\nint test_target_teams_distribute_parallel_for_num_threads() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_num_threads\");\n \n  int tested_num_threads[] = {1, 10, 100, 10000};\n  int num_threads[N]; // num_threads = 1 is not technically an error\n  int errors = 0;\n  int raiseWarningOneThread = 0;\n  int i, nt;\n\n\n  // Trying multiple num_threads values from 1 to a large number\n  for (nt = 0; nt < 4; nt++) {\n  \n    OMPVV_INFOMSG(\"Testing for num_threads(%d)\", tested_num_threads[nt]);\n    // Initializing the num_threads array\n    for (i = 0; i < N; i++) {\n      num_threads[i] = -1;\n    }\n#pragma omp target teams distribute parallel for\\\n        map(tofrom: num_threads) num_threads(tested_num_threads[nt])\n    for (i = 0; i < N; i++) {\n      num_threads[i] = omp_get_num_threads();\n    }\n\n    int raiseWarningDifNum = 0;\n    int prevNumThreads = -1;\n    \n    for (i = 0; i < N; i++) {\n      OMPVV_INFOMSG_IF(prevNumThreads != num_threads[i], \" %d threads reported\", num_threads[i]);\n      prevNumThreads = num_threads[i];\n      // If the number of threads is larger than the specified, this is an error\n      OMPVV_TEST_AND_SET(errors, num_threads[i] <=0 || num_threads[i] > tested_num_threads[nt]);\n      if (tested_num_threads[nt] != num_threads[i]) {\n        raiseWarningDifNum = 1;\n      }\n      if (tested_num_threads[nt] != 1 && num_threads[i] == 1) {\n        raiseWarningOneThread++;\n      }\n    }\n    OMPVV_WARNING_IF(raiseWarningDifNum != 0 , \"When testing num_threads(%d), the actual number of threads was different. This is not a compliance error with the specs\", tested_num_threads[nt]);  \n  }\n\n  OMPVV_WARNING_IF(raiseWarningOneThread == 4*N, \"The number of threads was always one, regardless of the num_threads clause. This is not a compliance error in the specs\");  \n  return errors;\n}\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_parallel_for_reduction_task.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1532",
        "issue_id": 1,
        "original_code": "//===--- test_parallel_for_reduction_task.c ---------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the parallel for directive with the reduction clause and\n// task modifier. It performs simple array operations which are added to the\n// reduction variable in an explicit task with the in_reduction clause.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_parallel_for_reduction_task() {\n  OMPVV_INFOMSG(\"test_parallel_for_reduction_task\");\n  int errors = 0;\n  int num_threads = -1;\n  int y[N];\n  int z[N];\n  int sum = 0;\n  int expected_sum = 0;\n\n  for (int i = 0; i < N; i++) {\n    y[i] = i + 1;\n    z[i] = 2*(i + 1);\n  }\n\n#pragma omp parallel for reduction(task, +: sum) num_threads(OMPVV_NUM_THREADS_HOST) shared(y, z, num_threads)\n  for (int i = 0; i < N; i++) {\n#pragma omp task in_reduction(+: sum)\n    sum += y[i]*z[i];\n    if (omp_get_thread_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    expected_sum += y[i]*z[i];\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, sum != expected_sum);\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of taskloop can't be guaranteed.\");\n  OMPVV_ERROR_IF(num_threads < 1, \"Test returned an invalid number of threads.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n\n  return errors;\n}\n\n\nint main() {\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_parallel_for_reduction_task());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_parallel_for_reduction_task.c ---------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the parallel for directive with the reduction clause and\n// task modifier. It performs simple array operations which are added to the\n// reduction variable in an explicit task with the in_reduction clause.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_parallel_for_reduction_task() {\n  OMPVV_INFOMSG(\"test_parallel_for_reduction_task\");\n  int errors = 0;\n  int num_threads = -1;\n  int y[N];\n  int z[N];\n  int sum = 0;\n  int expected_sum = 0;\n\n  for (int i = 0; i < N; i++) {\n    y[i] = i + 1;\n    z[i] = 2*(i + 1);\n  }\n\n#pragma omp parallel for reduction(task, +: sum) num_threads(OMPVV_NUM_THREADS_HOST) shared(y, z, num_threads)\n  for (int i = 0; i < N; i++) {\n#pragma omp task in_reduction(+: sum)\n    sum += y[i]*z[i];\n    if (omp_get_thread_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    expected_sum += y[i]*z[i];\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, sum != expected_sum);\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of taskloop can't be guaranteed.\");\n  OMPVV_ERROR_IF(num_threads < 1, \"Test returned an invalid number of threads.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n\n  return errors;\n}\n\n\nint main() \n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_parallel_for_reduction_task());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_requires_unified_shared_memory_omp_target_alloc_is_device_ptr.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===---test_requires_unified_shared_memory_omp_target_alloc_is_device_ptr.c -===//\n//\n// OpenMP API Version 5.0 Nov 2018\n// \n// This test Checks for unified shared memory of an array that is allocated on \n// the device and accessed in both host and device\n//\n// We use is_device_ptr to guarantee the use of the host pointer value in the \n// device \n//\n////===----------------------------------------------------------------------===//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp requires unified_shared_memory\n\nint unified_shared_memory_target_alloc() {\n  OMPVV_INFOMSG(\"Unified shared memory testing - Memory allocated in the device\");\n  int errors = 0;\n  \n  int *anArray = (int *) omp_target_alloc(sizeof(int)*N, omp_get_default_device());\n  int anArrayCopy[N];\n\n  // Initialization\n#pragma omp target is_device_ptr(anArray)\n  {\n    for (int i = 0; i < N; i++) {\n      anArray[i] = i;\n    }\n  }\n  for (int i = 0; i < N; i++) {\n    anArrayCopy[i] = 0;\n  }\n\n  // Modify in the device\n#pragma omp target is_device_ptr(anArray)\n  {\n    for (int i = 0; i < N; i++) {\n      anArray[i] += 10;\n    }\n  }\n\n  // Modify again on the host\n  for (int i = 0; i < N; i++) {\n    anArray[i] += 10;\n  }\n\n  // Get the value the device is seeing\n#pragma omp target is_device_ptr(anArray)\n  {\n    for (int i = 0; i < N; i++) {\n      anArrayCopy[i] = anArray[i];\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArray[i] != i + 20);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArrayCopy[i] != i + 20);\n    if (errors) break;\n  }\n\n  omp_target_free(anArray, omp_get_default_device());\n  return errors;\n}\nint main() {\n  int isOffloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"With no offloading, unified shared memory is guaranteed due to host execution\");\n  int errors = 0;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, unified_shared_memory_target_alloc());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nfloat reuynzyyku = 199;\nfloat crpocntitf = 1;\nbyte uyanbshosv = 81;\nbyte eziujqzrjp = 147;\ndouble lwiqrrlwdj = 31;\nfloat bpaswbsawe = 70;\nbyte mqogazxggr = 161;\nshort aiqvlcglwm = 23;\nfloat ehnslafvgv = 5;\nfloat zlqdckfnnz = 221;\nfloat fsriipcghg = 30;\nint onxddbeart = 169;\nint hzrdamundz = 243;\nbyte twjrbvupmq = 254;\nint mpllonetrt = 64;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_declare_target_nested_functions.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 989",
        "issue_id": 1,
        "original_code": "//===------ test_declare_target_nested_functions.c ------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Test of declare target on a host function that calls another host\n// function. According to 5.0 specification, the inner function, while not\n// explicitly declared on the target, should be treated as if it was. The\n// declared functions increment the passed-in value and return it. They are\n// tested in a simple target region and the result is mapped out and checked.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint inner_fn(int a) {\n  return 1 + a;\n}\n\nint outer_fn(int a) {\n  return 1 + inner_fn(a);\n}\n\nint test_declared_functions() {\n  int result = 0, errors = 0;\n\n#pragma omp target map(tofrom: result)\n  {\n    result = outer_fn(result);\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != 2)\n\n    return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n#pragma omp declare target to(outer_fn)\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_declared_functions() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===------ test_declare_target_nested_functions.c ------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Test of declare target on a host function that calls another host\n// function. According to 5.0 specification, the inner function, while not\n// explicitly declared on the target, should be treated as if it was. The\n// declared functions increment the passed-in value and return it. They are\n// tested in a simple target region and the result is mapped out and checked.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint inner_fn(int a) {\n  return 1 + a;\n}\n\nint outer_fn(int a) {\n  return 1 + inner_fn(a);\n}\n\nint test_declared_functions() {\n  int result = 0, errors = 0;\n\n#pragma omp target map(tofrom: result)\n  {\n    result = outer_fn(result);\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != 2)\n\n    return errors;\n}\n\nint main() \n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n#pragma omp declare target to(outer_fn)\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_declared_functions() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_loop_reduction_min_device.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 648",
        "issue_id": 2,
        "original_code": "//===--- test_loop_reduction_min_device.c -----------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the reduction clause on a loop directive, testing that the\n// variable in the reduction clause is properly reduced using the min\n// operator. This test checks the above in a target context.\n//\n////===----------------------------------------------------------------------===//\n\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_min() {\n  int a[N];\n  int b[N];\n  int errors = 0;\n  int num_threads[N];\n  srand(1);\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = (int) rand() / (double) (RAND_MAX / 100);\n    b[x] = (int) rand() / (double) (RAND_MAX / 100);\n    num_threads[x] = -x;\n  }\n\n  int result = a[0] + b[0];\n\n#pragma omp target parallel num_threads(OMPVV_NUM_THREADS_DEVICE) map(tofrom: result, a, b, num_threads)\n  {\n#pragma omp loop reduction(min:result)\n    for (int x = 0; x < N; ++x) {\n      result = fmin(result, a[x] + b[x]);\n    }\n#pragma omp for\n    for (int x = 0; x < N; ++x) {\n      num_threads[x] = omp_get_num_threads();\n    }\n  }\n\n  int host_min = a[0] + b[0];\n\n  for (int x = 0; x < N; ++x) {\n    host_min = fmin(host_min, a[x] + b[x]);\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_threads[x - 1] != num_threads[x], \"Test reported differing numbers of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_threads[0] == 1, \"Test operated with one thread.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_threads[0] <= 0, \"Test reported invalid number of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, host_min != result);\n  OMPVV_ERROR_IF(host_min != result, \"Min from loop directive is %d but expected min is %d.\", result, host_min);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_min() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n",
        "error_code": "//===--- test_loop_reduction_min_device.c -----------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the reduction clause on a loop directive, testing that the\n// variable in the reduction clause is properly reduced using the min\n// operator. This test checks the above in a target context.\n//\n////===----------------------------------------------------------------------===//\n\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_min() {\n  int a[N];\n  int b[N];\n  int errors = 0;\n  int num_threads[N];\n  srand(1);\n\n  for (int x = 0; x < N;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1; ++x) {\n    a[x] = (int) rand() / (double) (RAND_MAX / 100);\n    b[x] = (int) rand() / (double) (RAND_MAX / 100);\n    num_threads[x] = -x;\n  }\n\n  int result = a[0] + b[0];\n\n#pragma omp target parallel num_threads(OMPVV_NUM_THREADS_DEVICE) map(tofrom: result, a, b, num_threads)\n  {\n#pragma omp loop reduction(min:result)\n    for (int x = 0; x < N; ++x) {\n      result = fmin(result, a[x] + b[x]);\n    }\n#pragma omp for\n    for (int x = 0; x < N; ++x) {\n      num_threads[x] = omp_get_num_threads();\n    }\n  }\n\n  int host_min = a[0] + b[0];\n\n  for (int x = 0; x < N; ++x) {\n    host_min = fmin(host_min, a[x] + b[x]);\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_threads[x - 1] != num_threads[x], \"Test reported differing numbers of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_threads[0] == 1, \"Test operated with one thread.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_threads[0] <= 0, \"Test reported invalid number of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, host_min != result);\n  OMPVV_ERROR_IF(host_min != result, \"Min from loop directive is %d but expected min is %d.\", result, host_min);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_min() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_data_map_to_from.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===---- test_target_data_map_to_from.c ---------------------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// The test_target_data_map group of tests checks all the possible map-type-modifiers\n// for the target data map clauses. These are: from, to, fromto, alloc, release and \n// delete. There is a a separate c file for each test with the prefix test_target_data_map.\n// This specific test is for both the 'to' and 'from' clause utilized separately. \n//\n//===----------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\n// Test for OpenMP 4.5 target data map(to: ) and map(from:)\nint test_map_to_from() {\n\n  OMPVV_INFOMSG(\"test_map_to_from\");\n\n  int sum = 0, errors = 0;\n  int *h_array_h = (int *)malloc(N * sizeof(int));\n  int *h_array2_h = (int *)malloc(N * sizeof(int));\n\n  for (int i = 0; i < N; ++i) {\n    h_array_h[i] = 1;\n    h_array2_h[i] = 0;\n  }\n\n#pragma omp target data map(to: h_array_h[0:N]) map(from: h_array2_h[0:N])  \n  {\n#pragma omp target \n    {\n      for (int i = 0; i < N; ++i)\n        h_array2_h[i] = h_array_h[i];\n    } // end target \n  } // end target data\n\n  // checking errors \n  for (int i = 0; i < N; ++i)\n    sum += h_array2_h[i];\n\n  free(h_array_h);\n  free(h_array2_h);\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, ((N - sum) != 0));\n\n  return errors;\n}\n\nint main() {\n\n  int errors = 0;\n  \n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_to_from());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nfloat dlsjgcswwz = 120;\nint qpzmaliwhp = 85;\nbyte nsccpivpok = 244;\nfloat bpgcxygpjn = 207;\ndouble huicckmfno = 164;\nlong wvrgaroibt = 211;\nint gqfjxyudzd = 54;\nshort qoapkyecxv = 104;\nbyte anzqiaisxw = 47;\nint nghtrwuzrv = 230;\ndouble unnlzgtkts = 221;\nlong lchoxmmdww = 212;\ndouble ygpshreybv = 249;\ndouble yyqxrzoysq = 178;\ndouble zmrenjlyaa = 174;\nfloat vswalcmwed = 218;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_declare_target_link_extended_list.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 1003",
        "issue_id": 2,
        "original_code": "//===------ test_declare_target_link_extended_list.c  ----------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks the second valid format of declare target directive with the \n// link clause. The extended list allows for mappable variables and function names \n// to be listed. The list items of a link clause are not mapped by the declare \n// target directive, instead their mapping is deferred until they are mapped by \n// target data or target constructs. The function modifies the arrays using the \n// linked scalar 'aint'. Modifications made inside the target region and\n// results are verified on the host.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint aint = 10;\n\n#pragma omp declare target link(aint)\n\n\nvoid compute_array(int a[N], int b[N], int c[N]) {\n  for (int i = 0; i < N; i++) {\n    a[i] = b[i]*c[i] + aint * i;\n  }\n  return;\n}\n \n\nint test_declare_target() {\n\n  OMPVV_INFOMSG(\"test_declare_target_link_extended_list\");\n\n  int errors = 0;\n  int x[N];\n  int y[N];\n  int z[N];\n  aint = 12;\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 0;\n    y[i] = 1;\n    z[i] = i;\n  }\n\n#pragma omp target map(from: x) map(to:y, z, aint)\n  {\n    compute_array(x, y, z);\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != (y[i] * z[i] + 12 * i));\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_declare_target() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===------ test_declare_target_link_extended_list.c  ----------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks the second valid format of declare target directive with the \n// link clause. The extended list allows for mappable variables and function names \n// to be listed. The list items of a link clause are not mapped by the declare \n// target directive, instead their mapping is deferred until they are mapped by \n// target data or target constructs. The function modifies the arrays using the \n// linked scalar 'aint'. Modifications made inside the target region and\n// results are verified on the host.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint aint = 10;\n\n#pragma omp declare target link(aint)\n\n\nvoid compute_array(int a[N], int b[N], int c[N]) {\n  for (int i = 0; i < N; i++) {\n    a[i] = b[i]*c[i] + aint * i;\n  }\n  return;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n}\n \n\nint test_declare_target() {\n\n  OMPVV_INFOMSG(\"test_declare_target_link_extended_list\");\n\n  int errors = 0;\n  int x[N];\n  int y[N];\n  int z[N];\n  aint = 12;\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 0;\n    y[i] = 1;\n    z[i] = i;\n  }\n\n#pragma omp target map(from: x) map(to:y, z, aint)\n  {\n    compute_array(x, y, z);\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != (y[i] * z[i] + 12 * i));\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_declare_target() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_if.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_if());\n  \n  OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 2645",
        "issue_id": 4,
        "original_code": "//===--- test_target_teams_distribute_if.c-----------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the if clause to specify whether the target teams distribute\n// directve should execute in the device or the hosts through the if clause of the \n// taget directive. The test uses omp_is_initial_device through the different \n// threads, assigning an expected value to a matrix according to 1) offloading is \n// enabled and working, 2) the if clause evaluates to true and the code executes in\n// the offloading device, and 3) the if clause evaluates to false and the code executes\n// in the offloading devices. \n//\n// If not operating on a device, the test has a minimal test\n// of the basic use of the if clause with both a true and a false parameter.\n// However, the execution is identical to that of host operation in both cases.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n#define ATTEMPT_THRESHOLD 70\n#define NUM_ATTEMPTS 100\n\nint test_target_teams_distribute_if() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_if\");\n\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"With offloading off, it is not possible to test if\");\n\n  int a[N];\n  int errors = 0;\n  int attempt = 0;\n  int i;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = 1;\n  }\n\n  for (attempt = 0; attempt < NUM_ATTEMPTS; ++attempt) {\n#pragma omp target teams distribute if(attempt >= ATTEMPT_THRESHOLD) map(tofrom: a)\n    for (i = 0; i < N; ++i) {\n      if (attempt >= ATTEMPT_THRESHOLD) {\n\ta[i] += (isOffloading && omp_is_initial_device() ? 10 : 0); // false -> running on device or not offloading -> add 0\n      } else {\n\ta[i] += (omp_is_initial_device() ? 1 : 100);                // true -> running on host -> add 1\n      }\n    }\n  }\n\n  for (i = 0; i < N; ++i) {\n    OMPVV_TEST_AND_SET(errors, a[i] != (1 + ATTEMPT_THRESHOLD));\n  }\n\n  if (errors) {\n    int sum = 0;\n    for (i = 0; i < N; ++i) {\n      sum += a[i];\n    }\n    if (sum == N*(100*ATTEMPT_THRESHOLD + 1)) {\n      OMPVV_ERROR(\"Error in if. The execution was expected to occur on the host, but it occurred on the device.\");\n    } else if (sum == N*(ATTEMPT_THRESHOLD + 10*(NUM_ATTEMPTS - ATTEMPT_THRESHOLD) + 1)) {\n      OMPVV_ERROR(\"Error in if. The execution was expected to occur on the device, but it occurred on the host.\");\n    } else {\n      OMPVV_ERROR(\"Error in if. The execution occurred inconsistently on the host or on the device.\");\n    }\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_if());\n  \n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_if.c-----------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the if clause to specify whether the target teams distribute\n// directve should execute in the device or the hosts through the if clause of the \n// taget directive. The test uses omp_is_initial_device through the different \n// threads, assigning an expected value to a matrix according to 1) offloading is \n// enabled and working, 2) the if clause evaluates to true and the code executes in\n// the offloading device, and 3) the if clause evaluates to false and the code executes\n// in the offloading devices. \n//\n// If not operating on a device, the test has a minimal test\n// of the basic use of the if clause with both a true and a false parameter.\n// However, the execution is identical to that of host operation in both cases.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n#define ATTEMPT_THRESHOLD 70\n#define NUM_ATTEMPTS 100\n\nint test_target_teams_distribute_if() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_if\");\n\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"With offloading off, it is not possible to test if\");\n\n  int a[N];\n  int errors = 0;\n  int attempt = 0;\n  int i;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = 1;\n  }\n\n  for (attempt = 0; attempt < NUM_ATTEMPTS; ++attempt) {\n#pragma omp target teams distribute if(attempt >= ATTEMPT_THRESHOLD) map(tofrom: a)\n    for (i = 0; i < N; ++i) {\n      if (attempt >= ATTEMPT_THRESHOLD) {\n\ta[i] += (isOffloading && omp_is_initial_device() ? 10 : 0); // false -> running on device or not offloading -> add 0\n      } else {\n\ta[i] += (omp_is_initial_device() ? 1 : 100);                // true -> running on host -> add 1\n      }\n    }\n  }\n\n  for (i = 0; i < N; ++i) {\n    OMPVV_TEST_AND_SET(errors, a[i] != (1 + ATTEMPT_THRESHOLD));\n  }\n\n  if (errors) {\n    int sum = 0;\n    for (i = 0; i < N; ++i) {\n      sum += a[i];\n    }\n    if (sum == N*(100*ATTEMPT_THRESHOLD + 1)) {\n      OMPVV_ERROR(\"Error in if. The execution was expected to occur on the host, but it occurred on the device.\");\n    } else if (sum == N*(ATTEMPT_THRESHOLD + 10*(NUM_ATTEMPTS - ATTEMPT_THRESHOLD) + 1)) {\n      OMPVV_ERROR(\"Error in if. The execution was expected to occur on the device, but it occurred on the host.\");\n    } else {\n      OMPVV_ERROR(\"Error in if. The execution occurred inconsistently on the host or on the device.\");\n    }\n  }\n\n  return errors;\n}\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_interop_target.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp interop\" with directive \"#pragma omp map\" at position 792",
        "issue_id": 0,
        "original_code": "//===--------------------- test_interop_target.c ----------------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n// \n// Test for interop construct utilizing target as the interopability. Runs\n// a OpenMP target construct and treating it as an external operation to test\n// if the interop construct properly executes and returns the result. Test\n// passes if the results are processed correctly and fails if not.\n//\n////===---------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint interopTestTarget() {\n  int errors = 0;\n  int A[N];\n  \n  int device = omp_get_default_device();\n  omp_interop_t obj = omp_interop_none;\n\n  for (int i = 0; i < N; i++) {\n    A[i] = 0;\n  }\n\n  #pragma omp interop init(targetsync: obj) device(device) \\\n      depend(inout: A[0:N]) // Pass array through to the interop and require it\n  {\n    #pragma omp target depend(inout: A[0:N]) nowait \\\n      map(tofrom: A[0:N]) device(device)\n    for (int j = 0; j < N; j++) {\n      #pragma omp atomic\n      A[j] += 5;\n    }\n\n  }\n\n  #pragma omp interop destroy(obj) nowait depend(out: A[0:N])\n\n  // Interop should be completed and cleaned up by here\n  \n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, A[i] != 5);\n  }\n\n  return errors;\n}\n\nint main () {\n  int errors = 0;\n  OMPVV_TEST_OFFLOADING;\n\n  int numdevices = omp_get_num_devices();\n\n  OMPVV_WARNING_IF(numdevices <= 0, \"No devices detected, interop target test running on host\");\n\n  errors = interopTestTarget();\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n  return 0;\n}\n",
        "error_code": "//===--------------------- test_interop_target.c ----------------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n// \n// Test for interop construct utilizing target as the interopability. Runs\n// a OpenMP target construct and treating it as an external operation to test\n// if the interop construct properly executes and returns the result. Test\n// passes if the results are processed correctly and fails if not.\n//\n////===---------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint interopTestTarget() {\n  int errors = 0;\n  int A[N];\n  \n  int device = omp_get_default_device();\n  omp_interop_t obj = omp_interop_none;\n\n  for (int i = 0; i < N; i++) {\n    A[i] = 0;\n  }\n\n  #pragma omp map init(targetsync: obj) device(device) \\\n      depend(inout: A[0:N]) // Pass array through to the interop and require it\n  {\n    #pragma omp target depend(inout: A[0:N]) nowait \\\n      map(tofrom: A[0:N]) device(device)\n    for (int j = 0; j < N; j++) {\n      #pragma omp atomic\n      A[j] += 5;\n    }\n\n  }\n\n  #pragma omp interop destroy(obj) nowait depend(out: A[0:N])\n\n  // Interop should be completed and cleaned up by here\n  \n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, A[i] != 5);\n  }\n\n  return errors;\n}\n\nint main () {\n  int errors = 0;\n  OMPVV_TEST_OFFLOADING;\n\n  int numdevices = omp_get_num_devices();\n\n  OMPVV_WARNING_IF(numdevices <= 0, \"No devices detected, interop target test running on host\");\n\n  errors = interopTestTarget();\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n  return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_uses_allocators_thread.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 589",
        "issue_id": 2,
        "original_code": "//===--- test_target_uses_allocators_thread.c -----------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// The tests checks the uses_allocators clause with omp_thread_mem_alloc.\n// The variable allaocated in the target region is modified and used to compute\n// result. Result is copied back to the host and checked with computed value on host.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 8\n\nint test_uses_allocators_thread() {\n  int errors = 0;\n  int x = 0;\n  int device_result[N] = {0};\n  int result[N] = {0};\n\n  for (int i = 0; i < N; i++) {\n    result[i] = 3 * i ;\n  }\n\n#pragma omp target parallel uses_allocators(omp_thread_mem_alloc) allocate(omp_thread_mem_alloc: x) private(x) map(from: device_result)\n{\n  for (int i = 0; i < N; i++) {\n    x = 2 * i;\n    device_result[i] = i + x;\n  }\n}\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, result[i] != device_result[i]);\n  }\n\n  return errors;\n}\n\nint main() {\n\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_uses_allocators_thread() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_uses_allocators_thread.c -----------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// The tests checks the uses_allocators clause with omp_thread_mem_alloc.\n// The variable allaocated in the target region is modified and used to compute\n// result. Result is copied back to the host and checked with computed value on host.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 8\n\nint test_uses_allocators_thread() {\n  int errors = 0;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n  int x = 0;\n  int device_result[N] = {0};\n  int result[N] = {0};\n\n  for (int i = 0; i < N; i++) {\n    result[i] = 3 * i ;\n  }\n\n#pragma omp target parallel uses_allocators(omp_thread_mem_alloc) allocate(omp_thread_mem_alloc: x) private(x) map(from: device_result)\n{\n  for (int i = 0; i < N; i++) {\n    x = 2 * i;\n    device_result[i] = i + x;\n  }\n}\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, result[i] != device_result[i]);\n  }\n\n  return errors;\n}\n\nint main() {\n\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_uses_allocators_thread() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_parallel_for_default.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 458",
        "issue_id": 2,
        "original_code": "//-----------------test_target_teams_distribute_parallel_for_default.c-----\n//\n// OpenMP API Version 5.1 November 2020\n//\n// This test case targets to test default clause along with\n// target teams distribute parallel for construct\n// --------------------------------------------------------------\n\n\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n\nint DefaultFirstPrivate() {\n  int ErrCount = 0;\n  int Arr[32];\n  for (int i = 0; i < 32; ++i) {\n    Arr[i] = i;\n  }\n\n#pragma omp target teams distribute parallel for num_teams(2) thread_limit(10)\\\n        default(firstprivate) shared(ErrCount) map(tofrom: ErrCount)\n  for (int i = 0; i < 32; ++i) {\n    if (Arr[i] != i) {\n      #pragma omp atomic\n      ErrCount += 1;\n    }\n  }\n  return ErrCount;\n}\n\nint DefaultPrivate() {\n  int ErrCount = 0;\n  int CONST = 123;\n  int Arr[32];\n  for (int i = 0; i < 32; ++i) {\n    Arr[i] = i;\n  }\n\n#pragma omp target teams distribute parallel for num_teams(2) thread_limit(10)\\\n        default(private) shared(ErrCount) firstprivate(Arr) map(to: Arr[0:32]) map(tofrom: ErrCount)\n  for (int i = 0; i < 32; ++i) {\n    CONST = 10;\n    Arr[i] += CONST;\n    if (Arr[i] != (i + 10)) {\n      #pragma omp atomic\n      ErrCount += 1;\n    }\n  }\n  if (CONST != 123) {\n    ErrCount++;\n  }\n  return ErrCount;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, DefaultFirstPrivate() != 0);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, DefaultPrivate() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//-----------------test_target_teams_distribute_parallel_for_default.c-----\n//\n// OpenMP API Version 5.1 November 2020\n//\n// This test case targets to test default clause along with\n// target teams distribute parallel for construct\n// --------------------------------------------------------------\n\n\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n\nint DefaultFirstPrivate() {\n  int ErrCount = 0;\n  int Arr[32];\n  for (int i = 0;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1; i < 32; ++i) {\n    Arr[i] = i;\n  }\n\n#pragma omp target teams distribute parallel for num_teams(2) thread_limit(10)\\\n        default(firstprivate) shared(ErrCount) map(tofrom: ErrCount)\n  for (int i = 0; i < 32; ++i) {\n    if (Arr[i] != i) {\n      #pragma omp atomic\n      ErrCount += 1;\n    }\n  }\n  return ErrCount;\n}\n\nint DefaultPrivate() {\n  int ErrCount = 0;\n  int CONST = 123;\n  int Arr[32];\n  for (int i = 0; i < 32; ++i) {\n    Arr[i] = i;\n  }\n\n#pragma omp target teams distribute parallel for num_teams(2) thread_limit(10)\\\n        default(private) shared(ErrCount) firstprivate(Arr) map(to: Arr[0:32]) map(tofrom: ErrCount)\n  for (int i = 0; i < 32; ++i) {\n    CONST = 10;\n    Arr[i] += CONST;\n    if (Arr[i] != (i + 10)) {\n      #pragma omp atomic\n      ErrCount += 1;\n    }\n  }\n  if (CONST != 123) {\n    ErrCount++;\n  }\n  return ErrCount;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, DefaultFirstPrivate() != 0);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, DefaultPrivate() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_enter_exit_data_classes_complex.cpp",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp flush\" at position 1598",
        "issue_id": 0,
        "original_code": "//===--test_targe_enter_exit_data_classes_complex.c - test inheritance class -===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n//\n// This test uses target enter data and exit data to map multiple levels of \n// inheritance in classes and templates. The target enter and exit data are used\n// in the constructor and destructor of all the levels of the hierarchy. \n// It requires the use of helper_ variables since it\n// is not legal to use the \"this\" pointer (implicitly or explicitly) in 4.5. \n//\n// We use a modify method, which is propagated through the hierarchy of classes,\n// to assign values to the array. Following we use a method to obtain a copy of the values \n// from the device. The disctintion between methods allows to show that\n// data is mapped and remains mapped in the device memory. This test does\n// not use any inheritance or anything similar, therefore the simple connotation\n//\n// Contrary to the test of target_enter_data, this test checks if during the exit\n// data it successfully copies back the attributes of the object\n////===----------------------------------------------------------------------===//\n\n#include <iostream>\n#include <typeinfo>\n#include <omp.h>\n#include <cmath>\n#include \"ompvv.h\"\n\n\nusing namespace std;\n\n#define N 1000\n\ntemplate<typename T>\nclass Mapper {\n\n  private:\n    T* ptr;\n    bool not_mapped;\n\n  public:\n    Mapper (T* p) : ptr(p) {\n      not_mapped = !omp_target_is_present(ptr, omp_get_default_device());\n      // maps if target is not present\n      T* helper_ptr = ptr;\n      OMPVV_INFOMSG_IF(not_mapped, \"Mapping class %s\", typeid(T).name());\n#pragma omp target enter data map(to: helper_ptr[0:1]) if(not_mapped)\n    }\n    ~Mapper() {\n      // unmaps iff this mapper mapped the target\n      T* helper_ptr = ptr;\n      OMPVV_INFOMSG_IF(not_mapped, \"Unmapping class %s\", typeid(T).name());\n#pragma omp target exit data map(delete: helper_ptr[0:1]) if(not_mapped)\n      ptr = NULL;\n    }\n};\n\nclass B : public Mapper<B> {\n\n  protected:\n    int n;\n    double* x;\n    int* errors;\n\n  public:\n    B(int n, int* err) : Mapper<B>(this), n(n), errors(err) {\n      x = new double[n];\n      for (int i = 0; i < n; i ++) {\n        x[i] = (double) i;\n      }\n      int &helper_n = this->n;\n      double *helper_x = this->x;\n\n      OMPVV_INFOMSG(\"Mapping B attributes\");\n#pragma omp target update to(helper_n)\n#pragma omp target enter data map(to:helper_x[0:n])\n    }\n\n    ~B() {\n      double *helper_x = this->x;\n      OMPVV_INFOMSG(\"Unmapping B attributes\");\n#pragma omp target exit data map(from:helper_x[0:n])\n      // checking results\n      for (int i = 0; i < N; ++i) {\n        OMPVV_TEST_AND_SET_VERBOSE(*errors, std::abs(x[i] - (double)(3*i)) > 0.0001);\n      }\n    }\n\n    void modifyB() {\n      OMPVV_INFOMSG(\"Modifying B\");\n      int &helper_n = this->n;\n      double *helper_x = this->x;\n#pragma omp target defaultmap(tofrom:scalar)\n      {\n        for (int i = 0; i < helper_n; ++i)\n          helper_x[i] += (double) i;\n      } \n    }\n};\n\nclass A : public Mapper<A>, public B {\n  private:\n    int* y;\n\n  public:\n    A(int s, int* err) : Mapper<A>(this), B(s, err) { \n      OMPVV_INFOMSG(\"Mapping A attributes\");\n      y = new int[n];\n      // Initialize y\n      for (int i = 0; i < n; i ++) {\n        y[i] = i;\n      }\n      int *helper_y = this->y;\n#pragma omp target enter data map(to: helper_y[0:n])\n    }\n    ~A() {\n      OMPVV_INFOMSG(\"Unmapping A attributes\");\n      int *helper_y = this->y;\n#pragma omp target exit data map(from: helper_y[0:n])\n      // checking results\n      for (int i = 0; i < N; ++i) {\n        OMPVV_TEST_AND_SET_VERBOSE(*errors, y[i] != 3*i);\n      }\n    }\n\n    void modifyA() {\n      modifyB();\n      OMPVV_INFOMSG(\"Modifying A\");\n      int &helper_n = this->n;      \n      int *helper_y = this->y;\n#pragma omp target defaultmap(tofrom:scalar)\n      {\n        for (int i = 0; i < helper_n; ++i) {\n          helper_y[i] += i;\n        }\n      }\n    }\n\n    void getAllAttributesDevice(double * copy_x, int * copy_y) {\n      int &helper_n = this->n;      \n      int *helper_y = this->y;\n      double *helper_x = this->x;\n#pragma omp target defaultmap(tofrom:scalar) map(from:copy_x[0:n], copy_y[0:n])\n      {\n        for (int i = 0; i < helper_n; ++i) {\n          copy_x[i] = helper_x[i];\n          copy_y[i] = helper_y[i];\n        }\n      }\n\n    }\n\n};\n\n\nint test_complex_class() {\n  OMPVV_INFOMSG(\"Testing complex class\");\n  int sumY = 0, errors = 0;\n  double sumX = 0.0;\n  int *h_y = new int[N];\n  double *h_x = new double[N];\n  // allocation on the device\n  A *obj = new A(N, &errors);\n\n  obj->modifyA();\n\n  obj->getAllAttributesDevice(h_x, h_y);\n\n  // checking results\n  for (int i = 0; i < N; ++i) {\n    sumY += h_y[i];\n    sumX += h_x[i];\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, N*(N-1) != sumY); \n  OMPVV_TEST_AND_SET_VERBOSE(errors, std::abs(sumX - (double) N*(N-1))>0.0001);\n\n  obj->modifyA();\n\n  delete obj;\n  delete[] h_x;\n  delete[] h_y;\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET(errors, test_complex_class());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--test_targe_enter_exit_data_classes_complex.c - test inheritance class -===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n//\n// This test uses target enter data and exit data to map multiple levels of \n// inheritance in classes and templates. The target enter and exit data are used\n// in the constructor and destructor of all the levels of the hierarchy. \n// It requires the use of helper_ variables since it\n// is not legal to use the \"this\" pointer (implicitly or explicitly) in 4.5. \n//\n// We use a modify method, which is propagated through the hierarchy of classes,\n// to assign values to the array. Following we use a method to obtain a copy of the values \n// from the device. The disctintion between methods allows to show that\n// data is mapped and remains mapped in the device memory. This test does\n// not use any inheritance or anything similar, therefore the simple connotation\n//\n// Contrary to the test of target_enter_data, this test checks if during the exit\n// data it successfully copies back the attributes of the object\n////===----------------------------------------------------------------------===//\n\n#include <iostream>\n#include <typeinfo>\n#include <omp.h>\n#include <cmath>\n#include \"ompvv.h\"\n\n\nusing namespace std;\n\n#define N 1000\n\ntemplate<typename T>\nclass Mapper {\n\n  private:\n    T* ptr;\n    bool not_mapped;\n\n  public:\n    Mapper (T* p) : ptr(p) {\n      not_mapped = !omp_target_is_present(ptr, omp_get_default_device());\n      // maps if target is not present\n      T* helper_ptr = ptr;\n      OMPVV_INFOMSG_IF(not_mapped, \"Mapping class %s\", typeid(T).name());\n#pragma omp flush enter data map(to: helper_ptr[0:1]) if(not_mapped)\n    }\n    ~Mapper() {\n      // unmaps iff this mapper mapped the target\n      T* helper_ptr = ptr;\n      OMPVV_INFOMSG_IF(not_mapped, \"Unmapping class %s\", typeid(T).name());\n#pragma omp target exit data map(delete: helper_ptr[0:1]) if(not_mapped)\n      ptr = NULL;\n    }\n};\n\nclass B : public Mapper<B> {\n\n  protected:\n    int n;\n    double* x;\n    int* errors;\n\n  public:\n    B(int n, int* err) : Mapper<B>(this), n(n), errors(err) {\n      x = new double[n];\n      for (int i = 0; i < n; i ++) {\n        x[i] = (double) i;\n      }\n      int &helper_n = this->n;\n      double *helper_x = this->x;\n\n      OMPVV_INFOMSG(\"Mapping B attributes\");\n#pragma omp target update to(helper_n)\n#pragma omp target enter data map(to:helper_x[0:n])\n    }\n\n    ~B() {\n      double *helper_x = this->x;\n      OMPVV_INFOMSG(\"Unmapping B attributes\");\n#pragma omp target exit data map(from:helper_x[0:n])\n      // checking results\n      for (int i = 0; i < N; ++i) {\n        OMPVV_TEST_AND_SET_VERBOSE(*errors, std::abs(x[i] - (double)(3*i)) > 0.0001);\n      }\n    }\n\n    void modifyB() {\n      OMPVV_INFOMSG(\"Modifying B\");\n      int &helper_n = this->n;\n      double *helper_x = this->x;\n#pragma omp target defaultmap(tofrom:scalar)\n      {\n        for (int i = 0; i < helper_n; ++i)\n          helper_x[i] += (double) i;\n      } \n    }\n};\n\nclass A : public Mapper<A>, public B {\n  private:\n    int* y;\n\n  public:\n    A(int s, int* err) : Mapper<A>(this), B(s, err) { \n      OMPVV_INFOMSG(\"Mapping A attributes\");\n      y = new int[n];\n      // Initialize y\n      for (int i = 0; i < n; i ++) {\n        y[i] = i;\n      }\n      int *helper_y = this->y;\n#pragma omp target enter data map(to: helper_y[0:n])\n    }\n    ~A() {\n      OMPVV_INFOMSG(\"Unmapping A attributes\");\n      int *helper_y = this->y;\n#pragma omp target exit data map(from: helper_y[0:n])\n      // checking results\n      for (int i = 0; i < N; ++i) {\n        OMPVV_TEST_AND_SET_VERBOSE(*errors, y[i] != 3*i);\n      }\n    }\n\n    void modifyA() {\n      modifyB();\n      OMPVV_INFOMSG(\"Modifying A\");\n      int &helper_n = this->n;      \n      int *helper_y = this->y;\n#pragma omp target defaultmap(tofrom:scalar)\n      {\n        for (int i = 0; i < helper_n; ++i) {\n          helper_y[i] += i;\n        }\n      }\n    }\n\n    void getAllAttributesDevice(double * copy_x, int * copy_y) {\n      int &helper_n = this->n;      \n      int *helper_y = this->y;\n      double *helper_x = this->x;\n#pragma omp target defaultmap(tofrom:scalar) map(from:copy_x[0:n], copy_y[0:n])\n      {\n        for (int i = 0; i < helper_n; ++i) {\n          copy_x[i] = helper_x[i];\n          copy_y[i] = helper_y[i];\n        }\n      }\n\n    }\n\n};\n\n\nint test_complex_class() {\n  OMPVV_INFOMSG(\"Testing complex class\");\n  int sumY = 0, errors = 0;\n  double sumX = 0.0;\n  int *h_y = new int[N];\n  double *h_x = new double[N];\n  // allocation on the device\n  A *obj = new A(N, &errors);\n\n  obj->modifyA();\n\n  obj->getAllAttributesDevice(h_x, h_y);\n\n  // checking results\n  for (int i = 0; i < N; ++i) {\n    sumY += h_y[i];\n    sumX += h_x[i];\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, N*(N-1) != sumY); \n  OMPVV_TEST_AND_SET_VERBOSE(errors, std::abs(sumX - (double) N*(N-1))>0.0001);\n\n  obj->modifyA();\n\n  delete obj;\n  delete[] h_x;\n  delete[] h_y;\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET(errors, test_complex_class());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_depend_out_out.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===--- test_target_teams_distribute_depend_out_out.c------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks for dependency between all combinations of out and inout\n// by checking order-dependent results from pairs of possibly asynchronous\n// loops. The test fails if any required dependency is broken.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_target_teams_distribute_depend_out_out() {\n  int isOffloading = 0;\n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int out_out_errors = 0;\n  int inout_out_errors = 0;\n  int out_inout_errors = 0;\n  int inout_inout_errors = 0;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n    b[x] = 2 * x;\n    c[x] = 0;\n    d[x] = 0;\n  }\n\n#pragma omp target data map(to: a[0:N], b[0:N]) map(alloc: c[0:N]) map(from: d[0:N])\n  {\n#pragma omp target teams distribute nowait depend(out: c) map(alloc: a[0:N], b[0:N], c[0:N])\n    for (int x = 0; x < N; ++x) {\n      c[x] = a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(out: c) map(alloc: b[0:N], c[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n      d[x] = c[x] + b[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(out_out_errors, d[x] != 5*x);\n  }\n\n#pragma omp target data map(to: a[0:N], b[0:N]) map(alloc: c[0:N]) map(from: d[0:N])\n  {\n#pragma omp target teams distribute nowait depend(out: c) map(alloc: a[0:N], b[0:N], c[0:N])\n    for (int x = 0; x < N; ++x) {\n      c[x] = a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(inout: c) map(alloc: a[0:N], c[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n      d[x] = c[x] + a[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(out_inout_errors, d[x] != 4*x);\n  }\n\n#pragma omp target data map(to: a[0:N], b[0:N]) map(alloc: c[0:N]) map(from: d[0:N])\n  {\n#pragma omp target teams distribute nowait depend(inout: c) map(alloc: a[0:N], b[0:N], c[0:N])\n    for (int x = 0; x < N; ++x) {\n      c[x] = a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(out: c) map(alloc: b[0:N], c[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n      d[x] = c[x] + b[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(inout_out_errors, d[x] != 5*x);\n  }\n\n#pragma omp target data map(to: a[0:N], b[0:N]) map(alloc: c[0:N]) map(from: d[0:N])\n  {\n#pragma omp target teams distribute nowait depend(inout: c) map(alloc: a[0:N], b[0:N], c[0:N])\n    for (int x = 0; x < N; ++x) {\n      c[x] = a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(inout: c) map(alloc: a[0:N], c[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n      d[x] = c[x] + a[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(inout_inout_errors, d[x] != 4*x);\n  }\n\n  OMPVV_ERROR_IF(out_out_errors == 1, \"Test of depend(out) task becoming dependent task of depend(out) task did not pass with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  OMPVV_ERROR_IF(inout_out_errors == 1, \"Test of depend(out) task becoming dependent task of depend(inout) task did not pass with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  OMPVV_ERROR_IF(out_inout_errors == 1, \"Test of depend(inout) task becoming dependent task of depend(out) task did not pass with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  OMPVV_ERROR_IF(inout_inout_errors == 1, \"Test of depend(inout) task becoming dependent task of depend(inout) task did not pass with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n\n  return inout_inout_errors + inout_out_errors + out_inout_errors + out_out_errors;\n}\n\nint main() {\n  int errors = 0;\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  errors += test_target_teams_distribute_depend_out_out();\n  OMPVV_INFOMSG_IF(errors != 0, \"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nbyte kdjhxjaoht = 255;\nbyte ymhmaajrgs = 242;\nint pmujgpgoyn = 229;\nlong ptomlmdxye = 23;\nlong dlmenrxqjx = 152;\nfloat deaplrqrey = 124;\ndouble jnfwxlimdi = 66;\nint ebddpsygde = 206;\nlong trpslnzzou = 118;\nint vggmthffvr = 240;\ndouble kfaiqjfhgc = 14;\nlong hfxslpjmfg = 103;\nbyte nartegnmrl = 151;\nfloat mvwmbpuvsa = 194;\nshort btxlgfsxjz = 219;\nlong kvtrcnxuci = 84;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_taskloop_firstprivate.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp parallel\" with directive \"#pragma omp teams\" at position 1272",
        "issue_id": 0,
        "original_code": "//----------------------------------- test_taskloop_firstprivate.c ----------------------------------------//\n//\n// OpenMP API Version 4.5 November 2015\n//\n// This test checks the taskloop directive with the 'firstprivate' clause specified.\n// The 'taskloop' construct parallelize loops with independent iterations by creating tasks. \n// It allows for efficient parallel execution of loop iterations by distributing them among multiple threads. \n// The 'firstprivate' clause ensures that each task should have private copies and initialized                          // private copies with the value from the master thread. \n// -------------------------------------------------------------------------------------------------------//\n\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define NUM_THREADS 500\n#define NUM_TASKS 1000\n\nint is_task_values_equal_to_firstprivate(int first_priv_value, int a[])\n{\n    for(int i = 0; i < NUM_TASKS; i++) {\n    \tif(first_priv_value != a[i])\n        \treturn 0; //if all array values are not same. \n    }\t\n\n    return 1; //if all array values are same\n}\n\nint test_taskloop_firstprivate() {\n    \n    int errors = 0;\n    \n    int private_var = 11; \n    int var_not_in_openmp = private_var;\n\n    int task_vals[NUM_TASKS];\n    \n    #pragma omp parallel num_threads(NUM_THREADS)\n    {\n        #pragma omp single\n        {\n            #pragma omp taskloop firstprivate(private_var)\n            for (int i = 0; i < NUM_TASKS; i++) {\n\t\ttask_vals[i] = private_var;\n            }\n        }\n    }\n    \n    //if all the tasks values are same as first private value, get TRUE else FALSE \n    OMPVV_TEST_AND_SET_VERBOSE(errors, (is_task_values_equal_to_firstprivate(var_not_in_openmp, task_vals)) != 1);\n    \n    return errors;\n}\n\nint main() {\n  \n    int errors = 0;\n  \n    OMPVV_TEST_AND_SET_VERBOSE(errors, (test_taskloop_firstprivate()) != 0);\n    OMPVV_REPORT_AND_RETURN(errors);\n\n    return 0;\n}\n\n",
        "error_code": "//----------------------------------- test_taskloop_firstprivate.c ----------------------------------------//\n//\n// OpenMP API Version 4.5 November 2015\n//\n// This test checks the taskloop directive with the 'firstprivate' clause specified.\n// The 'taskloop' construct parallelize loops with independent iterations by creating tasks. \n// It allows for efficient parallel execution of loop iterations by distributing them among multiple threads. \n// The 'firstprivate' clause ensures that each task should have private copies and initialized                          // private copies with the value from the master thread. \n// -------------------------------------------------------------------------------------------------------//\n\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define NUM_THREADS 500\n#define NUM_TASKS 1000\n\nint is_task_values_equal_to_firstprivate(int first_priv_value, int a[])\n{\n    for(int i = 0; i < NUM_TASKS; i++) {\n    \tif(first_priv_value != a[i])\n        \treturn 0; //if all array values are not same. \n    }\t\n\n    return 1; //if all array values are same\n}\n\nint test_taskloop_firstprivate() {\n    \n    int errors = 0;\n    \n    int private_var = 11; \n    int var_not_in_openmp = private_var;\n\n    int task_vals[NUM_TASKS];\n    \n    #pragma omp teams num_threads(NUM_THREADS)\n    {\n        #pragma omp single\n        {\n            #pragma omp taskloop firstprivate(private_var)\n            for (int i = 0; i < NUM_TASKS; i++) {\n\t\ttask_vals[i] = private_var;\n            }\n        }\n    }\n    \n    //if all the tasks values are same as first private value, get TRUE else FALSE \n    OMPVV_TEST_AND_SET_VERBOSE(errors, (is_task_values_equal_to_firstprivate(var_not_in_openmp, task_vals)) != 1);\n    \n    return errors;\n}\n\nint main() {\n  \n    int errors = 0;\n  \n    OMPVV_TEST_AND_SET_VERBOSE(errors, (test_taskloop_firstprivate()) != 0);\n    OMPVV_REPORT_AND_RETURN(errors);\n\n    return 0;\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_taskloop_simd_order_unconstrained_device.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1112",
        "issue_id": 1,
        "original_code": "//===------ test_target_taskloop_simd_order_unconstrained_concurrent.c ------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// This test checks that the order(unconstrained:concurrent) clause is properly handled.\n// As per the definition the order in which they are executed does not matter. \n// Instead focus on that the correct result is calculated, regardless of execution\n// order. \n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 24\n\nint main() {\n\tint errors = 0;\n\tint x[N];\n\tint y[N];\n\n\tfor (int i = 0; i < N; i++) {\n\t\tx[i] = i;\n\t\ty[i] = i;\n\t}\n\n\tOMPVV_TEST_OFFLOADING;\n\n\t#pragma omp target map(tofrom: x,y)\n\t{\n\t\t#pragma omp parallel\n\t\t{\n\t\t   #pragma omp single\n\t\t   #pragma omp taskloop simd order(unconstrained:concurrent)\n\t\t   for (int i = 0; i < N; i++) {\n\t\t\t   x[i] = x[i] + 2;\t\n\t\t   }\n\n\t\t   #pragma omp single\n\t\t   #pragma omp taskloop simd order(unconstrained:concurrent)\n\t\t   for (int i = 0; i < N; i++) {\n\t\t\t   y[i] = y[i] + 2;\n\t\t   }\n\t\t}\n\n\t}\n\n\tfor (int i = 0; i < N; i++) {\n    \t\tOMPVV_TEST_AND_SET(errors, y[i] != i + 2);\n        \tOMPVV_TEST_AND_SET(errors, x[i] != i + 2)\n\t}\n\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===------ test_target_taskloop_simd_order_unconstrained_concurrent.c ------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// This test checks that the order(unconstrained:concurrent) clause is properly handled.\n// As per the definition the order in which they are executed does not matter. \n// Instead focus on that the correct result is calculated, regardless of execution\n// order. \n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 24\n\nint main() {\n\tint errors = 0;\n\tint x[N];\n\tint y[N];\n\n\tfor (int i = 0; i < N; i++) {\n\t\tx[i] = i;\n\t\ty[i] = i;\n\t}\n\n\tOMPVV_TEST_OFFLOADING;\n\n\t#pragma omp target map(tofrom: x,y)\n\t{\n\t\t#pragma omp parallel\n\t\t{\n\t\t   #pragma omp single\n\t\t   #pragma omp taskloop simd order(unconstrained:concurrent)\n\t\t   for (int i = 0; i < N; i++) {\n\t\t\t   x[i] = x[i] + 2;\t\n\t\t   }\n\n\t\t   #pragma omp single\n\t\t   #pragma omp taskloop simd order(unconstrained:concurrent)\n\t\t   for (int i = 0; i < N; i++) {\n\t\t\t   y[i] = y[i] + 2;\n\t\t   }\n\t\t}\n\n\t}\n\n\tfor (int i = 0; i < N; i++) \n    \t\tOMPVV_TEST_AND_SET(errors, y[i] != i + 2);\n        \tOMPVV_TEST_AND_SET(errors, x[i] != i + 2)\n\t}\n\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_default_firstprivate.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n\t\t\tnot_shared += 5;\n\t\t}\" at position 1337",
        "issue_id": 4,
        "original_code": "//===--------- test_target_teams_default_firstprivate.c ----------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// This test uses the default(firstprivate) clause on a teams directive. The test\n// validates that when the default(firstprivate) clause is present all\n// variables without explicit sharing rules are not avaialble outside the region\n// and are private to each team. The default(firstprivate) clause is tested using\n// the not_shared variable, whose value should have not changed after the target\n// teams construct since all changes to the firstprivate variable should not persist\n// after the construct. Additionally if there is a race condition, we know the \n// variable is not defaulting to firstprivate either.\n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main() {\n\n\tOMPVV_TEST_OFFLOADING;\n\n\tint errors = 0;\n\tint not_shared = 5;\n\tint num_teams = 0; \n\n\t#pragma omp target teams default(firstprivate) map(tofrom:num_teams,errors) shared(num_teams,errors) num_teams(OMPVV_NUM_TEAMS_DEVICE)\n\t{\n\t\tif (omp_get_team_num() == 0) {\n\t\t\tnum_teams = omp_get_num_teams();\n\t\t\tif( not_shared != 5 ) {\n\t\t\t\terrors = errors + 1;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < omp_get_num_teams(); i++) {\n\t\t\tnot_shared += 5;\n\t\t}\n\t}\n\n\n\tOMPVV_WARNING_IF(num_teams != OMPVV_NUM_TEAMS_DEVICE, \"Number of teams was unexpected, test results likely inconclusive\");\n\n\tOMPVV_TEST_AND_SET(errors, (not_shared != 5));\n\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--------- test_target_teams_default_firstprivate.c ----------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// This test uses the default(firstprivate) clause on a teams directive. The test\n// validates that when the default(firstprivate) clause is present all\n// variables without explicit sharing rules are not avaialble outside the region\n// and are private to each team. The default(firstprivate) clause is tested using\n// the not_shared variable, whose value should have not changed after the target\n// teams construct since all changes to the firstprivate variable should not persist\n// after the construct. Additionally if there is a race condition, we know the \n// variable is not defaulting to firstprivate either.\n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main() {\n\n\tOMPVV_TEST_OFFLOADING;\n\n\tint errors = 0;\n\tint not_shared = 5;\n\tint num_teams = 0; \n\n\t#pragma omp target teams default(firstprivate) map(tofrom:num_teams,errors) shared(num_teams,errors) num_teams(OMPVV_NUM_TEAMS_DEVICE)\n\t{\n\t\tif (omp_get_team_num() == 0) {\n\t\t\tnum_teams = omp_get_num_teams();\n\t\t\tif( not_shared != 5 ) {\n\t\t\t\terrors = errors + 1;\n\t\t\t}\n\t\t}\n\n\t\tfor (int i = 0; i < omp_get_num_teams(); i++) \n\t}\n\n\n\tOMPVV_WARNING_IF(num_teams != OMPVV_NUM_TEAMS_DEVICE, \"Number of teams was unexpected, test results likely inconclusive\");\n\n\tOMPVV_TEST_AND_SET(errors, (not_shared != 5));\n\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_flush_no_memory_order_clause.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 724",
        "issue_id": 2,
        "original_code": "//===---- test_flush_no_memory_order_clause.c -------------------------------===//\n// \n// OpenMP API Version 5.0 \n// \n// This is a test of the flush directive with no memory-order-clause specified.\n// Additionally, atomic constructs are used alongside the explicit flush directives\n// to specify memory ordering amongst the two threads.\n//\n// Based on OpenMP 5.0 Example aquire_release.3.c\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\nint errors = 0;\n\nint main() {\n\n   int x = 0, y = 0;\n   #pragma omp parallel num_threads(2)\n   {\n      int thrd = omp_get_thread_num();\n      if (thrd == 0) {\n         x = 10;\n         #pragma omp flush\n         #pragma omp atomic write\n         y = 1;\n      } else {\n         int tmp = 0;\n         while (tmp == 0) {\n            #pragma omp atomic read\n\t    tmp = y;\n         }\n         #pragma omp flush\n         OMPVV_TEST_AND_SET_VERBOSE(errors, x != 10);\n      }\n  }\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_flush_no_memory_order_clause.c -------------------------------===//\n// \n// OpenMP API Version 5.0 \n// \n// This is a test of the flush directive with no memory-order-clause specified.\n// Additionally, atomic constructs are used alongside the explicit flush directives\n// to specify memory ordering amongst the two threads.\n//\n// Based on OpenMP 5.0 Example aquire_release.3.c\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\nint errors = 0;\n\nint main() {\n\n   int x = 0, y = 0;\n   #pragma omp parallel num_threads(2)\n   {\n      int thrd = omp_get_thread_num();\n      if (thrd == 0) {\n         x = 10;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n         #pragma omp flush\n         #pragma omp atomic write\n         y = 1;\n      } else {\n         int tmp = 0;\n         while (tmp == 0) {\n            #pragma omp atomic read\n\t    tmp = y;\n         }\n         #pragma omp flush\n         OMPVV_TEST_AND_SET_VERBOSE(errors, x != 10);\n      }\n  }\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_data_map_from.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1377",
        "issue_id": 1,
        "original_code": "//===---- test_target_data_map_from.c -----------------------------------------------------===//\n//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// The test_target_data_map group of tests checks all the possible map-type-modifiers \n// for the target data map clauses. These are: from, to, fromto, alloc, release and delete.\n// There is a separate c file for each test with the prefix test_target_data_map.\n// This specific test is for mapping 'from'.\n//\n//===--------------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\n// Test for OpenMP 4.5 target data map(from: )\nint test_map_from() {\n\n  OMPVV_INFOMSG(\"test_map_from\");\n\n  int sum = 0, sum2 = 0, errors = 0;\n\n  // host arrays: heap and stack\n  int *h_array_h = (int *)malloc(N * sizeof(int));\n  int h_array_s[N];\n\n#pragma omp target data map(from: h_array_h[0:N])  \\\n        map(from: h_array_s[0:N])\n  {\n#pragma omp target\n    {\n      for (int i = 0; i < N; ++i) {\n        h_array_h[i] = 1;\n        h_array_s[i] = 2;\n      }\n    } // end target\n  } // end target data\n\n  // checking results\n  for (int i = 0; i < N; ++i) {\n    sum += h_array_h[i];\n    sum2 += h_array_s[i];\n  }\n  \n  free(h_array_h);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (N != sum) || (2*N != sum2));\n\n  return errors;\n}\n\n\nint main() {\n\n  int errors = 0;\n  \n  //Check for offloading\n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_from());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_data_map_from.c -----------------------------------------------------===//\n//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// The test_target_data_map group of tests checks all the possible map-type-modifiers \n// for the target data map clauses. These are: from, to, fromto, alloc, release and delete.\n// There is a separate c file for each test with the prefix test_target_data_map.\n// This specific test is for mapping 'from'.\n//\n//===--------------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\n// Test for OpenMP 4.5 target data map(from: )\nint test_map_from() {\n\n  OMPVV_INFOMSG(\"test_map_from\");\n\n  int sum = 0, sum2 = 0, errors = 0;\n\n  // host arrays: heap and stack\n  int *h_array_h = (int *)malloc(N * sizeof(int));\n  int h_array_s[N];\n\n#pragma omp target data map(from: h_array_h[0:N])  \\\n        map(from: h_array_s[0:N])\n  {\n#pragma omp target\n    {\n      for (int i = 0; i < N; ++i) {\n        h_array_h[i] = 1;\n        h_array_s[i] = 2;\n      }\n    } // end target\n  } // end target data\n\n  // checking results\n  for (int i = 0; i < N; ++i) {\n    sum += h_array_h[i];\n    sum2 += h_array_s[i];\n  }\n  \n  free(h_array_h);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (N != sum) || (2*N != sum2));\n\n  return errors;\n}\n\n\nint main() \n\n  int errors = 0;\n  \n  //Check for offloading\n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_from());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_taskloop_collapse.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp parallel\" with directive \"#pragma omp cancel\" at position 1137",
        "issue_id": 0,
        "original_code": "//------------------------------------------- test_taskloop_collapse.c --------------------------------------//\n// OpenMP API Version 4.5 September 2015\n//\n// This test checks the 'taskloop' directive with the 'collapse' clause specified.\n// The 'taskloop' construct parallelizes loops with independent iterations by creating tasks. \n// It allows for efficient parallel execution of loop iterations by distributing them among multiple threads. \n// The 'collapse' clause ensures that multiple nested loops into a single loop.      \n//----------------------------------------------------------------------------------------------------------//\n\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define NUM_THREADS 100\n#define NUM_COLLAPSE 2\n\nint test_taskloop_collapse() {\n\n  int errors = 0;\n\n  int size = 200;\n  int a[(size*size)];\n  \n  int sum_without_openmp = 0, sum_with_openmp = 0;\n   \n  for(int i = 0; i < (size*size); i++) {\n   \ta[i] = i;\n   }\n\n   //get valid sum without openmp\n   for(int i = 0; i < (size); i++) {\n\tfor(int j = 0; j < size; j++) {\n\t     sum_without_openmp = sum_without_openmp + (a[i]*a[j]);\n\t}\n   }\n   \n   #pragma omp parallel num_threads(NUM_THREADS)\n   {\n      #pragma omp single\n      {\n\t#pragma omp taskloop collapse(NUM_COLLAPSE)  \n        for(int i = 0; i < size; i++) \n\t{\n\t    for(int j = 0; j < size; j++) \n\t    {\n\t\t    #pragma omp atomic\n\t\t    sum_with_openmp = sum_with_openmp + (a[i]*a[j]); \n            }\n\t}\n      }\t   \n   }\n   \n   OMPVV_TEST_AND_SET_VERBOSE(errors, sum_with_openmp != sum_without_openmp);\n\n   return errors;\n}\n\nint main() {\n  \n  int errors = 0;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, (test_taskloop_collapse()) != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n\n  return 0;\n}\n",
        "error_code": "//------------------------------------------- test_taskloop_collapse.c --------------------------------------//\n// OpenMP API Version 4.5 September 2015\n//\n// This test checks the 'taskloop' directive with the 'collapse' clause specified.\n// The 'taskloop' construct parallelizes loops with independent iterations by creating tasks. \n// It allows for efficient parallel execution of loop iterations by distributing them among multiple threads. \n// The 'collapse' clause ensures that multiple nested loops into a single loop.      \n//----------------------------------------------------------------------------------------------------------//\n\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define NUM_THREADS 100\n#define NUM_COLLAPSE 2\n\nint test_taskloop_collapse() {\n\n  int errors = 0;\n\n  int size = 200;\n  int a[(size*size)];\n  \n  int sum_without_openmp = 0, sum_with_openmp = 0;\n   \n  for(int i = 0; i < (size*size); i++) {\n   \ta[i] = i;\n   }\n\n   //get valid sum without openmp\n   for(int i = 0; i < (size); i++) {\n\tfor(int j = 0; j < size; j++) {\n\t     sum_without_openmp = sum_without_openmp + (a[i]*a[j]);\n\t}\n   }\n   \n   #pragma omp cancel num_threads(NUM_THREADS)\n   {\n      #pragma omp single\n      {\n\t#pragma omp taskloop collapse(NUM_COLLAPSE)  \n        for(int i = 0; i < size; i++) \n\t{\n\t    for(int j = 0; j < size; j++) \n\t    {\n\t\t    #pragma omp atomic\n\t\t    sum_with_openmp = sum_with_openmp + (a[i]*a[j]); \n            }\n\t}\n      }\t   \n   }\n   \n   OMPVV_TEST_AND_SET_VERBOSE(errors, sum_with_openmp != sum_without_openmp);\n\n   return errors;\n}\n\nint main() {\n  \n  int errors = 0;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, (test_taskloop_collapse()) != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n\n  return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_flush_seq_cst.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n   errors = 0;\n   flush_default_result = 0;\n   flush_seq_cst_result = 0;\n   OMPVV_TEST_OFFLOADING;\n   flush_default(); // Not directly tested, errors reported only if results are different\n   OMPVV_TEST_AND_SET_VERBOSE(errors, flush_seq_cst() != 0);\n   OMPVV_TEST_AND_SET_VERBOSE(errors, flush_default_result != flush_seq_cst_result);\n   OMPVV_ERROR_IF(flush_default_result != flush_seq_cst_result, \"Error: Flush with seq_cst clause not the same flush with no specified clause\");\n   OMPVV_REPORT_AND_RETURN(errors);\n   \n}\" at position 2029",
        "issue_id": 4,
        "original_code": "//===---- test_flush_seq_cst.c ----------------------------------------------===//\n// \n// OpenMP API Version 5.1 Nov 2020\n// \n// This is a test of the flush directive with no memory-order-clause specified.\n// Additionally, atomic constructs are used alongside the explicit flush directives\n// to specify memory ordering amongst the two threads.\n//\n// Based on OpenMP 5.0 Example aquire_release.3.c\n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\nint flush_default();\nint flush_seq_cst();\n\nint errors = 0;\nint flush_default_result = 0;\nint flush_seq_cst_result = 0;\n\nint flush_default() { // flush with no clause specified\n   int x = 0, y = 0;\n   omp_set_dynamic(0);   // this is to help get required number of threads specified in num_threads clause\n   #pragma omp parallel num_threads(2)\n   {\n      int thrd = omp_get_thread_num();\n      if (thrd == 0) {\n         x = 10;\n         #pragma omp flush\n         #pragma omp atomic write\n         y = 1;\n      } else {\n         int tmp = 0;\n         while (tmp == 0) {\n            #pragma omp atomic read\n\t    tmp = y;\n         }\n         #pragma omp flush\n         OMPVV_TEST_AND_SET_VERBOSE(errors, x != 10);\n         flush_default_result = x;\n      }\n  }\n  return errors;\n}\n\nint flush_seq_cst() { // flush with seq_cst clause specified\n   int x = 0, y = 0;\n   omp_set_dynamic(0);   // this is to help get required number of threads specified in num_threads clause\n   #pragma omp parallel num_threads(2)\n   {\n      int thrd = omp_get_thread_num();\n      if (thrd == 0) {\n         x = 10;\n         #pragma omp flush seq_cst\n         #pragma omp atomic write\n         y = 1;\n      } else {\n         int tmp = 0;\n         while (tmp == 0) {\n            #pragma omp atomic read\n\t    tmp = y;\n         }\n         #pragma omp flush seq_cst\n         OMPVV_TEST_AND_SET_VERBOSE(errors, x != 10);\n         flush_seq_cst_result = x;\n      }\n  }\n  return errors;\n}\n\nint main() {\n   errors = 0;\n   flush_default_result = 0;\n   flush_seq_cst_result = 0;\n   OMPVV_TEST_OFFLOADING;\n   flush_default(); // Not directly tested, errors reported only if results are different\n   OMPVV_TEST_AND_SET_VERBOSE(errors, flush_seq_cst() != 0);\n   OMPVV_TEST_AND_SET_VERBOSE(errors, flush_default_result != flush_seq_cst_result);\n   OMPVV_ERROR_IF(flush_default_result != flush_seq_cst_result, \"Error: Flush with seq_cst clause not the same flush with no specified clause\");\n   OMPVV_REPORT_AND_RETURN(errors);\n   \n}\n",
        "error_code": "//===---- test_flush_seq_cst.c ----------------------------------------------===//\n// \n// OpenMP API Version 5.1 Nov 2020\n// \n// This is a test of the flush directive with no memory-order-clause specified.\n// Additionally, atomic constructs are used alongside the explicit flush directives\n// to specify memory ordering amongst the two threads.\n//\n// Based on OpenMP 5.0 Example aquire_release.3.c\n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\nint flush_default();\nint flush_seq_cst();\n\nint errors = 0;\nint flush_default_result = 0;\nint flush_seq_cst_result = 0;\n\nint flush_default() { // flush with no clause specified\n   int x = 0, y = 0;\n   omp_set_dynamic(0);   // this is to help get required number of threads specified in num_threads clause\n   #pragma omp parallel num_threads(2)\n   {\n      int thrd = omp_get_thread_num();\n      if (thrd == 0) {\n         x = 10;\n         #pragma omp flush\n         #pragma omp atomic write\n         y = 1;\n      } else {\n         int tmp = 0;\n         while (tmp == 0) {\n            #pragma omp atomic read\n\t    tmp = y;\n         }\n         #pragma omp flush\n         OMPVV_TEST_AND_SET_VERBOSE(errors, x != 10);\n         flush_default_result = x;\n      }\n  }\n  return errors;\n}\n\nint flush_seq_cst() { // flush with seq_cst clause specified\n   int x = 0, y = 0;\n   omp_set_dynamic(0);   // this is to help get required number of threads specified in num_threads clause\n   #pragma omp parallel num_threads(2)\n   {\n      int thrd = omp_get_thread_num();\n      if (thrd == 0) {\n         x = 10;\n         #pragma omp flush seq_cst\n         #pragma omp atomic write\n         y = 1;\n      } else {\n         int tmp = 0;\n         while (tmp == 0) {\n            #pragma omp atomic read\n\t    tmp = y;\n         }\n         #pragma omp flush seq_cst\n         OMPVV_TEST_AND_SET_VERBOSE(errors, x != 10);\n         flush_seq_cst_result = x;\n      }\n  }\n  return errors;\n}\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_atomic_compare_device.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp parallel\" at position 885",
        "issue_id": 0,
        "original_code": "//===--- test_atomic_compare_device.c ---------------------------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// Adapted from OpenMP example video https://www.youtube.com/watch?v=iS6IG7nzCSo\n// Creates an array with random numbers, and uses atomic compare on the device\n// environment to find the max, testing against non-parallel maximum.\n//\n////===----------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 100\n\nint test_atomic_compare() {\n  OMPVV_INFOMSG(\"test_atomic_compare_device\");\n\n  int arr[N];\n  int errors = 0;\n  int max = 0, pmax = 0;\n\n   for(int i = 0; i < N; i++){\n      arr[i] = rand()%1000;\n   }\n   for(int i = 0; i < N; i++){ // Sets max through non-parallel methods\n      if(arr[i] > max){\n         max = arr[i];\n      }\n   }\n   #pragma omp target parallel for map(pmax) shared(pmax)// Sets max using parallel for loop, using atomic to ensure max is correct\n   for(int i = 0; i < N; i++){\n      #pragma omp atomic compare\n      if(arr[i] > pmax){\n         pmax = arr[i];\n      }\n   }\n   OMPVV_TEST_AND_SET(errors, pmax != max);\n   return errors;\n}\n\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_OFFLOADING;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_atomic_compare());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_atomic_compare_device.c ---------------------------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// Adapted from OpenMP example video https://www.youtube.com/watch?v=iS6IG7nzCSo\n// Creates an array with random numbers, and uses atomic compare on the device\n// environment to find the max, testing against non-parallel maximum.\n//\n////===----------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 100\n\nint test_atomic_compare() {\n  OMPVV_INFOMSG(\"test_atomic_compare_device\");\n\n  int arr[N];\n  int errors = 0;\n  int max = 0, pmax = 0;\n\n   for(int i = 0; i < N; i++){\n      arr[i] = rand()%1000;\n   }\n   for(int i = 0; i < N; i++){ // Sets max through non-parallel methods\n      if(arr[i] > max){\n         max = arr[i];\n      }\n   }\n   #pragma omp parallel parallel for map(pmax) shared(pmax)// Sets max using parallel for loop, using atomic to ensure max is correct\n   for(int i = 0; i < N; i++){\n      #pragma omp atomic compare\n      if(arr[i] > pmax){\n         pmax = arr[i];\n      }\n   }\n   OMPVV_TEST_AND_SET(errors, pmax != max);\n   return errors;\n}\n\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_OFFLOADING;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_atomic_compare());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_loop_order_concurrent_device.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 1168",
        "issue_id": 2,
        "original_code": "//===--- test_loop_order_concurrent_device.c --------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the loop directive with the order(concurrent) clause, in\n// the context of a target construct. The order(concurrent) clause is assumed\n// to be present if it is not present, so this test covers the standalone\n// loop directive as well. The test creates a parallel region with a loop\n// construct nested within, and performs simple operations on an int array\n// which are then checked for correctness. Additionally, since loop binds to\n// a parallel region, the test checks randomly that other threads wait before\n// proceeding out of the loop region. The number of threads is checked in the\n// parallel region but after the loop construct because runtime API calls are\n// not permitted in loop directive regions.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_loop_order_concurrent_device() {\n  OMPVV_INFOMSG(\"test_loop_order_concurrent_device\");\n  int errors = 0;\n  int total_wait_errors = 0;\n  int x[N];\n  int y[N];\n  int z[N];\n  int num_threads = -1;\n  int rand_indexes[OMPVV_NUM_THREADS_DEVICE];\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 1;\n    y[i] = i + 1;\n    z[i] = 2*(i + 1);\n  }\n\n  for (int i = 0; i < OMPVV_NUM_THREADS_DEVICE; i++) {\n    rand_indexes[i] = rand()%(N + 1);\n  }\n\n#pragma omp target parallel num_threads(OMPVV_NUM_THREADS_DEVICE) map(tofrom: x[0:N], num_threads, total_wait_errors) map(to: y[0:N], z[0:N])\n  {\n#pragma omp loop order(concurrent)\n    for (int i = 0; i < N; i++) {\n      x[i] += y[i]*z[i];\n    }\n    if (x[rand_indexes[omp_get_thread_num()]] == 1) {\n#pragma omp atomic update\n      total_wait_errors++;\n    }\n    if (omp_get_thread_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != 1 + (y[i]*z[i]));\n  }\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of loop construct can't be guaranteed.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n  OMPVV_ERROR_IF(num_threads < 1, \"omp_get_num_threads() returned an invalid number of threads.\");\n  OMPVV_ERROR_IF(total_wait_errors, \"Threads in target parallel region did not wait for loop region to finish before proceeding.\");\n\n  return errors + total_wait_errors;\n}\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  srand(time(0));\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_loop_order_concurrent_device());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_loop_order_concurrent_device.c --------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the loop directive with the order(concurrent) clause, in\n// the context of a target construct. The order(concurrent) clause is assumed\n// to be present if it is not present, so this test covers the standalone\n// loop directive as well. The test creates a parallel region with a loop\n// construct nested within, and performs simple operations on an int array\n// which are then checked for correctness. Additionally, since loop binds to\n// a parallel region, the test checks randomly that other threads wait before\n// proceeding out of the loop region. The number of threads is checked in the\n// parallel region but after the loop construct because runtime API calls are\n// not permitted in loop directive regions.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_loop_order_concurrent_device() {\n  OMPVV_INFOMSG(\"test_loop_order_concurrent_device\");yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n  int errors = 0;\n  int total_wait_errors = 0;\n  int x[N];\n  int y[N];\n  int z[N];\n  int num_threads = -1;\n  int rand_indexes[OMPVV_NUM_THREADS_DEVICE];\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 1;\n    y[i] = i + 1;\n    z[i] = 2*(i + 1);\n  }\n\n  for (int i = 0; i < OMPVV_NUM_THREADS_DEVICE; i++) {\n    rand_indexes[i] = rand()%(N + 1);\n  }\n\n#pragma omp target parallel num_threads(OMPVV_NUM_THREADS_DEVICE) map(tofrom: x[0:N], num_threads, total_wait_errors) map(to: y[0:N], z[0:N])\n  {\n#pragma omp loop order(concurrent)\n    for (int i = 0; i < N; i++) {\n      x[i] += y[i]*z[i];\n    }\n    if (x[rand_indexes[omp_get_thread_num()]] == 1) {\n#pragma omp atomic update\n      total_wait_errors++;\n    }\n    if (omp_get_thread_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != 1 + (y[i]*z[i]));\n  }\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of loop construct can't be guaranteed.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n  OMPVV_ERROR_IF(num_threads < 1, \"omp_get_num_threads() returned an invalid number of threads.\");\n  OMPVV_ERROR_IF(total_wait_errors, \"Threads in target parallel region did not wait for loop region to finish before proceeding.\");\n\n  return errors + total_wait_errors;\n}\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  srand(time(0));\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_loop_order_concurrent_device());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_struct_obj_access.cpp",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===-- test_target_struct_obj_access.cpp ------------------------------===//\n//\n// OpenMP API Version 5.2\n//\n// Description\n// This test case tests the working of the following aspects:\n// 1) Working of \"requires unified_shared_memory\"\n// 2) Testing different ways to access struct objects on gpu\n//===-------------------------------------------------------------------===//\n\n\n#include <iostream>\n#include <string>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#pragma omp requires unified_shared_memory\n#pragma omp begin declare target\nstruct Employee1 {\n  std::string name;\n  int Id;\n  int Age;\n};\n\n\nstruct Employee2 {\n  std::string name;\n  int Id;\n  int Age;\n} Emp;\n\nstruct Employee3 {\n  std::string name = \"Murthy\";\n  int Id = 2233;\n  int Age = 27;\n};\n#pragma omp end declare target\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int Errors = 0, errors = 0;\n  // Need to check the size of structure\n  Employee3 EmpPreInit;\n  int Sz = sizeof(EmpPreInit);\n  int defaultDevice = omp_get_default_device();\n#pragma omp target map(tofrom: Errors, Sz)\n  {\n    if (Sz != sizeof(EmpPreInit)) {\n      Errors++;\n    }\n  }\n  // The following are the reference variables from host side\n  std::string RefStr = \"Vikas\";\n  int RefId = 1234;\n  int RefAge = 24;\n  int StrSz = RefStr.length();\n  Employee1 Em1;\n  Em1.name = \"Vikas\";\n  Em1.Id = 1234;\n  Em1.Age = 24;\n\n#pragma omp target device(defaultDevice) map(tofrom: Errors)\\\n        map(to: RefStr, RefId, RefAge, StrSz)\n  {\n    for (int i = 0; i <= StrSz; ++i) {\n      if (Em1.name[i] != RefStr[i]) {\n         Errors++;\n      }\n    }\n    if ((RefId != Em1.Id) || (RefAge != Em1.Age)) {\n      Errors++;\n    }\n  }\n\n// The following Emp variable declared along with the structure\n  Emp.name = \"Manoj\";\n  Emp.Id = 1564;\n  Emp.Age = 34;\n  // Updating the reference variables\n  RefStr = \"Manoj\";\n  RefId = 1564;\n  RefAge = 34;\n  StrSz = RefStr.length();\n#pragma omp target device(defaultDevice) map(tofrom: Errors)\\\n        map(to: RefStr, RefId, RefAge, StrSz, Emp)\n  {\n    for (int i = 0; i <= StrSz; ++i) {\n      if (Emp.name[i] != RefStr[i]) {\n         Errors++;\n      }\n    }\n    if ((RefId != Emp.Id) || (RefAge != Emp.Age)) {\n      Errors++;\n    }\n  }\n\n  Employee3 Emp3;\n\n  // Updating the reference variables\n  RefStr = \"Murthy\";\n  RefId = 2233;\n  RefAge = 27;\n  StrSz = RefStr.length();\n\n#pragma omp target device(defaultDevice) map(tofrom: Errors)\\\n        map(to: RefStr, RefId, RefAge, StrSz)\n  {\n    for (int i = 0; i <= StrSz; ++i) {\n      if (Emp3.name[i] != RefStr[i]) {\n         Errors++;\n      }\n    }\n    if ((RefId != Emp3.Id) || (RefAge != Emp3.Age)) {\n      Errors++;\n    }\n  }\n\n  // Access struct var initialized at the time of declaration on gpu\n  Employee1 EmpInit = {\"Kapil\", 2143, 37};\n  RefStr = \"Kapil\";\n  RefId = 2143;\n  RefAge = 37;\n  StrSz = RefStr.length();\n\n#pragma omp target device(defaultDevice) map(tofrom: Errors)\\\n        map(to: RefStr, RefId, RefAge, StrSz)\n  {\n    for (int i = 0; i <= StrSz; ++i) {\n      if (EmpInit.name[i] != RefStr[i]) {\n         Errors++;\n      }\n    }\n    if ((RefId != EmpInit.Id) || (RefAge != EmpInit.Age)) {\n      Errors++;\n    }\n  }\n  // Access array of structure on gpu\n  Employee1 StrArr[3];\n  StrArr[0] = {\"Kamal\", 1122, 21};\n  RefStr = \"Kamal\";\n  RefId = 1122;\n  RefAge = 21;\n  StrSz = RefStr.length();\n\n#pragma omp target device(defaultDevice) map(tofrom: Errors)\\\n        map(to: RefStr, RefId, RefAge, StrSz)\n  {\n    for (int i = 0; i <= StrSz; ++i) {\n      if (StrArr[0].name[i] != RefStr[i]) {\n         Errors++;\n      }\n    }\n    if ((RefId != StrArr[0].Id) || (RefAge != StrArr[0].Age)) {\n      Errors++;\n    }\n  }\n\n  StrArr[1] = {\"Kyra\", 1123, 22};\n  RefStr = \"Kyra\";\n  RefId = 1123;\n  RefAge = 22;\n  StrSz = RefStr.length();\n\n#pragma omp target device(defaultDevice) map(tofrom: Errors)\\\n        map(to: RefStr, RefId, RefAge, StrSz)\n  {\n    for (int i = 0; i <= StrSz; ++i) {\n      if (StrArr[1].name[i] != RefStr[i]) {\n         Errors++;\n      }\n    }\n    if ((RefId != StrArr[1].Id) || (RefAge != StrArr[1].Age)) {\n      Errors++;\n    }\n  }\n  StrArr[2] = {\"Myna\", 1124, 23};\n  RefStr = \"Myna\";\n  RefId = 1124;\n  RefAge = 23;\n  StrSz = RefStr.length();\n\n#pragma omp target device(defaultDevice) map(tofrom: Errors)\\\n        map(to: RefStr, RefId, RefAge, StrSz)\n  {\n    for (int i = 0; i <= StrSz; ++i) {\n      if (StrArr[2].name[i] != RefStr[i]) {\n         Errors++;\n      }\n    }\n    if ((RefId != StrArr[2].Id) || (RefAge != StrArr[2].Age)) {\n      Errors++;\n    }\n  }\n\n  // Accessing structure using pointer\n  Employee1 *StrPtr = &StrArr[0];\n  RefStr = \"Kamal\";\n  RefId = 1122;\n  RefAge = 21;\n\n#pragma omp target device(defaultDevice) map(tofrom: Errors, StrPtr)\\\n        map(to: RefStr, RefId, RefAge, StrSz)\n  {\n    for (int i = 0; i <= StrSz; ++i) {\n      if ((*StrPtr).name[i] != RefStr[i]) {\n         Errors++;\n      }\n    }\n    if ((RefId != (*StrPtr).Id) || (RefAge != (*StrPtr).Age)) {\n      Errors++;\n    }\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (Errors > 0));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <iostream>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nbyte gcnolaxdmt = 76;\nbyte uiiyehzoxk = 147;\nbyte yirngufoxt = 4;\nfloat qmgiaryyci = 110;\nbyte bdinybadlz = 219;\nfloat vwnvwtbslq = 13;\nint zztvuzcirw = 127;\ndouble axjyjmgwze = 125;\nint dmjxfaktae = 17;\nint qcxakhkdah = 248;\nfloat fpiwngozly = 200;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    std::cout << \"Sum of \" << num1 << \" and \" << num2 << \" is \" << sum << std::endl;\n    return 0;\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/gridmini_map_struct_array.cpp",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===-- gridmini_map_struct_array.cpp ---------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks that the float multiplication of array elements which is a \n// member of the struct 'vec'in the offloaded region provides the same answer \n// as calculated by host. OpenMP 5.0 spec states that 'If a list item in a map \n// clause is a variable of structure type then it is treated as if each structure \n// element contained in the variable is a list item in the clause.'\n//\n//===----------------------------------------------------------------------===//\n\n#include <cstdlib>\n#include <stdio.h>\n#include <iostream>\n#include \"ompvv.h\"\n#include \"omp.h\"\n\nusing namespace std;\nstruct vec {\n  float v[2];\n};\n\ninline  vec mult(vec x, vec y){\n  vec out;\n  out.v[0] = x.v[0]*y.v[0];\n  out.v[1] = x.v[1]*y.v[1];\n  return out;\n}\n\nint main(int argc, char* argv[]){\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n  int N = 10;\n  float x = (float)rand()/(float)(RAND_MAX/10.0);\n  float y = (float)rand()/(float)(RAND_MAX/5.0);\n  vec in1,in2;\n  in1.v[0] = x;\n  in1.v[1] = x;\n  in2.v[0] = y;\n  in2.v[1] = y;\n  vec out[N];\n\n  //calulate on host\n  vec expected = mult(in1,in2);\n\n#pragma omp target teams distribute parallel for map(to:in1,in2) map(from:out[0:N])\n    for(int n = 0; n < N; n++) {\n      out[n] = mult(in1,in2);\n    }\n    \n  for(int n = 0; n < N; n++) {\n    OMPVV_TEST_AND_SET(errors,out[n].v[0] != expected.v[0]);\n    OMPVV_TEST_AND_SET(errors,out[n].v[0] != expected.v[1]);\n  }\n\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n}\n\n",
        "error_code": "#include <iostream>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nbyte qsvcrrkghv = 14;\nint rzemglmcua = 50;\nbyte dtzsekpkfq = 74;\nlong wpptvwmcpk = 129;\nint ithzejuwul = 245;\nlong fapdxhxupt = 58;\ndouble cjyqkslhgk = 164;\nbyte puombgzozz = 89;\ndouble bxygvqwerm = 234;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    std::cout << \"Sum of \" << num1 << \" and \" << num2 << \" is \" << sum << std::endl;\n    return 0;\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/qmcpack_target_static_lib.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 558",
        "issue_id": 1,
        "original_code": "//===-- qmcpack_target_static_lib.c ---------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks that a target region can be compiled as a static\n// library. The library function offload_test contains a target region\n// which changes the value of a scalar on the device and maps it back.\n// This value is then checked by this driver code.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n#include \"libompvv.h\"\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, offload_test() != 1);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===-- qmcpack_target_static_lib.c ---------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks that a target region can be compiled as a static\n// library. The library function offload_test contains a target region\n// which changes the value of a scalar on the device and maps it back.\n// This value is then checked by this driver code.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n#include \"libompvv.h\"\n\nint main() \n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, offload_test() != 1);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_simd.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_simd());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 1574",
        "issue_id": 4,
        "original_code": "//===---- test_target_simd.c - Using combined construct target simd -===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// SIMD in OpenMP 4.5 does not have any API that allows us to confirm the creation \n// of SIMD lanes, nor the use of SIMD instructions in any architecture. Hence, our\n// tests are limited in that they check that the expected result is created, but\n// assume nothing in how they are mapped into a particular architecture\n//\n// This test creates a regular for loop and uses the combined target simd directive \n// then it checks that the values of the array are as expected\n//===--------------------------------------------------------------------------===//\n//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define ARRAY_SIZE 1024\n\nint test_target_simd() {\n  OMPVV_INFOMSG(\"test_target_simd\");\n  OMPVV_WARNING(\"This test cannot check if actual SIMD extensions at the hardware level\"\n                 \" were used, or of the generated code is different in any way\");\n\n  // Variable for errors counting\n  int errors = 0;\n\n  int a[ARRAY_SIZE];\n  int b[ARRAY_SIZE];\n  int c[ARRAY_SIZE];\n  int i;\n\n  // a and b array initialization\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      a[i] = 1;\n      b[i] = i;\n      c[i] = 2 * i;\n  }\n\n\n#pragma omp target simd map(to: b[0:ARRAY_SIZE], c[0:ARRAY_SIZE]) map(tofrom: a[0:ARRAY_SIZE])\n    for (i = 0; i < ARRAY_SIZE; ++i) {\n        a[i] += b[i] * c[i];\n    }\n\n\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      OMPVV_TEST_AND_SET(errors, (a[i] != 1 + (b[i] * c[i])));\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_simd());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_simd.c - Using combined construct target simd -===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// SIMD in OpenMP 4.5 does not have any API that allows us to confirm the creation \n// of SIMD lanes, nor the use of SIMD instructions in any architecture. Hence, our\n// tests are limited in that they check that the expected result is created, but\n// assume nothing in how they are mapped into a particular architecture\n//\n// This test creates a regular for loop and uses the combined target simd directive \n// then it checks that the values of the array are as expected\n//===--------------------------------------------------------------------------===//\n//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define ARRAY_SIZE 1024\n\nint test_target_simd() {\n  OMPVV_INFOMSG(\"test_target_simd\");\n  OMPVV_WARNING(\"This test cannot check if actual SIMD extensions at the hardware level\"\n                 \" were used, or of the generated code is different in any way\");\n\n  // Variable for errors counting\n  int errors = 0;\n\n  int a[ARRAY_SIZE];\n  int b[ARRAY_SIZE];\n  int c[ARRAY_SIZE];\n  int i;\n\n  // a and b array initialization\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      a[i] = 1;\n      b[i] = i;\n      c[i] = 2 * i;\n  }\n\n\n#pragma omp target simd map(to: b[0:ARRAY_SIZE], c[0:ARRAY_SIZE]) map(tofrom: a[0:ARRAY_SIZE])\n    for (i = 0; i < ARRAY_SIZE; ++i) {\n        a[i] += b[i] * c[i];\n    }\n\n\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      OMPVV_TEST_AND_SET(errors, (a[i] != 1 + (b[i] * c[i])));\n  }\n\n  return errors;\n}\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_update_to_from_lvalue_ptr.cpp",
        "correct": "n",
        "issue": "Removed opening bracket at position 1465",
        "issue_id": 1,
        "original_code": "//===------ test_target_update_to_from_map_lvalue_pointer.cpp ----------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test evaluates the target update directive using to and from clauses, \n// supporting various lvalue expressions, such as dereferenced pointers. \n// Additionally, it examines the map clause and its handling of lvalue expressions \n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <iostream>\n#include \"ompvv.h\"\n\nint test_target_update() {\n\tint errors = 0;\n\tint before_value;\n\tint after_value;\n\tint* host_pointer = new int;\n\t*host_pointer = -1;\n\n\t#pragma omp target enter data map(to: *host_pointer)\n\n\t//Before should be set to -1\n\t#pragma omp target map(from: before_value)\n\t{\n\t\tbefore_value = *host_pointer;\n\t}\n\n\t//Host_pointer should now be 1\n\t*host_pointer = 1;\n\t// Copy data from the host variable to the device variable using a dereferenced pointer\n\t#pragma omp target update to(*host_pointer)\n\n\t#pragma omp target map(from: after_value)\n\t{\n\t\tafter_value = *host_pointer;\n\t\t*host_pointer = 2;\n\t}\n\n\t//Update host_pointer to 2\n\t#pragma omp target update from(*host_pointer)\n\n\t// Verify the results\n\tif (*host_pointer != 2) {\n\t\terrors++;\n\t}\n\tif (before_value != -1){\n\t\terrors++;\n\t}\n\tif (after_value != 1){\n\t\terrors++;\n\t}\n\n\t#pragma omp target exit data map(from: *host_pointer)\n\tdelete host_pointer;\n\n\tOMPVV_TEST_AND_SET(errors, errors != 0);\n\treturn errors;\n}\n\nint main() {\n\tOMPVV_TEST_OFFLOADING;\n\tint errors = 0;\n\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_target_update() != 0);\n\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n\n",
        "error_code": "//===------ test_target_update_to_from_map_lvalue_pointer.cpp ----------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test evaluates the target update directive using to and from clauses, \n// supporting various lvalue expressions, such as dereferenced pointers. \n// Additionally, it examines the map clause and its handling of lvalue expressions \n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <iostream>\n#include \"ompvv.h\"\n\nint test_target_update() {\n\tint errors = 0;\n\tint before_value;\n\tint after_value;\n\tint* host_pointer = new int;\n\t*host_pointer = -1;\n\n\t#pragma omp target enter data map(to: *host_pointer)\n\n\t//Before should be set to -1\n\t#pragma omp target map(from: before_value)\n\t{\n\t\tbefore_value = *host_pointer;\n\t}\n\n\t//Host_pointer should now be 1\n\t*host_pointer = 1;\n\t// Copy data from the host variable to the device variable using a dereferenced pointer\n\t#pragma omp target update to(*host_pointer)\n\n\t#pragma omp target map(from: after_value)\n\t{\n\t\tafter_value = *host_pointer;\n\t\t*host_pointer = 2;\n\t}\n\n\t//Update host_pointer to 2\n\t#pragma omp target update from(*host_pointer)\n\n\t// Verify the results\n\tif (*host_pointer != 2) {\n\t\terrors++;\n\t}\n\tif (before_value != -1){\n\t\terrors++;\n\t}\n\tif (after_value != 1){\n\t\terrors++;\n\t}\n\n\t#pragma omp target exit data map(from: *host_pointer)\n\tdelete host_pointer;\n\n\tOMPVV_TEST_AND_SET(errors, errors != 0);\n\treturn errors;\n}\n\nint main() \n\tOMPVV_TEST_OFFLOADING;\n\tint errors = 0;\n\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_target_update() != 0);\n\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_parallel_if_device.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp atomic\" at position 559",
        "issue_id": 0,
        "original_code": "//===------ test_target_if_device.c --------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Tests the target directive with parallel for + if + device clauses\n//\n//===------------------------------------------------------------------------===//\n#include <stdio.h>\n#include \"omp.h\"\n#include \"ompvv.h\"\n#define N 1024\n\n\n\nint Runtst(int gpu, int Proc) { // Proc = 0(host), 1(gpu)\n  int *A = (int*) malloc(sizeof(int) * N), Errors = 0;\n  int *InitDev = (int*) malloc(sizeof(int));\n  for (int i = 0; i < N; ++i) {\n    A[i] = i;\n  }\n\n#pragma omp target data map(tofrom: A[0:N], InitDev[0:1]) if(Proc) device(gpu)\n  {\n#pragma omp target parallel for if(Proc) device(gpu)\n    for (int i = 0; i < N; ++i) {\n      if (i == 0) {\n        InitDev[0] = omp_is_initial_device();\n      }\n      A[i] = A[i] * A[i];\n    }\n  }\n\n  // Verification\n  for (int i = 0; i < N; ++i) {\n    if (A[i] != i*i) {\n      Errors++;\n    }\n  }\n  // Verifying if target block ran on intended processor\n  if (InitDev[0] != (!Proc)) {\n    Errors++;\n  }\n\n  free(A);\n  return Errors;\n}\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int TotGpus = omp_get_num_devices();\n  int errors = 0;\n  for (int gpu = 0; gpu < TotGpus; ++gpu) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (Runtst(gpu, 0 /*for cpu*/) != 0));\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (Runtst(gpu, gpu < TotGpus /*for gpu*/) != 0));\n  }\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===------ test_target_if_device.c --------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Tests the target directive with parallel for + if + device clauses\n//\n//===------------------------------------------------------------------------===//\n#include <stdio.h>\n#include \"omp.h\"\n#include \"ompvv.h\"\n#define N 1024\n\n\n\nint Runtst(int gpu, int Proc) { // Proc = 0(host), 1(gpu)\n  int *A = (int*) malloc(sizeof(int) * N), Errors = 0;\n  int *InitDev = (int*) malloc(sizeof(int));\n  for (int i = 0; i < N; ++i) {\n    A[i] = i;\n  }\n\n#pragma omp atomic data map(tofrom: A[0:N], InitDev[0:1]) if(Proc) device(gpu)\n  {\n#pragma omp target parallel for if(Proc) device(gpu)\n    for (int i = 0; i < N; ++i) {\n      if (i == 0) {\n        InitDev[0] = omp_is_initial_device();\n      }\n      A[i] = A[i] * A[i];\n    }\n  }\n\n  // Verification\n  for (int i = 0; i < N; ++i) {\n    if (A[i] != i*i) {\n      Errors++;\n    }\n  }\n  // Verifying if target block ran on intended processor\n  if (InitDev[0] != (!Proc)) {\n    Errors++;\n  }\n\n  free(A);\n  return Errors;\n}\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int TotGpus = omp_get_num_devices();\n  int errors = 0;\n  for (int gpu = 0; gpu < TotGpus; ++gpu) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (Runtst(gpu, 0 /*for cpu*/) != 0));\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (Runtst(gpu, gpu < TotGpus /*for gpu*/) != 0));\n  }\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_requires_unified_shared_memory_malloc.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1735",
        "issue_id": 1,
        "original_code": "//===---test_requires_unified_shared_memory_malloc.c --------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n// \n// This test checks for unified shared memory of an array that is allocated using \n// malloc on host is accessed from host and device with the same pointer.\n//\n// It uses the default mapping of pointers to access the array.\n//\n////===----------------------------------------------------------------------===//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp requires unified_shared_memory\n\nint unified_shared_memory_malloc() {\n  OMPVV_INFOMSG(\"Unified shared memory testing - Malloced Array\");\n  int errors = 0;\n\n  int *anArray;\n  int *anArrayCopy;\n\n  anArray = (int*)malloc(sizeof(int)*N);\n  anArrayCopy = (int*)malloc(sizeof(int)*N);\n\n   if( anArray == NULL ) {\n    OMPVV_ERROR(\"Memory for anArray was not allocated\");\n    OMPVV_RETURN(1);\n  }\n\n  if( anArrayCopy == NULL ) {\n    OMPVV_ERROR(\"Memory for anArrayCopy was not allocated\");\n    OMPVV_RETURN(1);\n  }\n\n  for (int i = 0; i < N; i++) {\n    anArray[i] = i;\n    anArrayCopy[i] = 0;\n  }\n  // Modify in the device\n#pragma omp target \n  {\n    for (int i = 0; i < N; i++) {\n      anArray[i] += 10;\n    }\n  }\n  // Modify again on the host\n  for (int i = 0; i < N; i++) {\n    anArray[i] += 10;\n  }\n\n  // Get the value the device is seeing\n#pragma omp target \n  {\n    for (int i = 0; i < N; i++) {\n      anArrayCopy[i] = anArray[i];\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArray[i] != i + 20);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArrayCopy[i] != i + 20);\n    if (errors) break;\n  }\n\n  free(anArray);\n  free(anArrayCopy);\n  return errors;\n}\n\nint main() {\n  int isOffloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"With no offloading, unified shared memory is guaranteed due to host execution\");\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, unified_shared_memory_malloc());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---test_requires_unified_shared_memory_malloc.c --------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n// \n// This test checks for unified shared memory of an array that is allocated using \n// malloc on host is accessed from host and device with the same pointer.\n//\n// It uses the default mapping of pointers to access the array.\n//\n////===----------------------------------------------------------------------===//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp requires unified_shared_memory\n\nint unified_shared_memory_malloc() {\n  OMPVV_INFOMSG(\"Unified shared memory testing - Malloced Array\");\n  int errors = 0;\n\n  int *anArray;\n  int *anArrayCopy;\n\n  anArray = (int*)malloc(sizeof(int)*N);\n  anArrayCopy = (int*)malloc(sizeof(int)*N);\n\n   if( anArray == NULL ) {\n    OMPVV_ERROR(\"Memory for anArray was not allocated\");\n    OMPVV_RETURN(1);\n  }\n\n  if( anArrayCopy == NULL ) {\n    OMPVV_ERROR(\"Memory for anArrayCopy was not allocated\");\n    OMPVV_RETURN(1);\n  }\n\n  for (int i = 0; i < N; i++) {\n    anArray[i] = i;\n    anArrayCopy[i] = 0;\n  }\n  // Modify in the device\n#pragma omp target \n  {\n    for (int i = 0; i < N; i++) {\n      anArray[i] += 10;\n    }\n  }\n  // Modify again on the host\n  for (int i = 0; i < N; i++) {\n    anArray[i] += 10;\n  }\n\n  // Get the value the device is seeing\n#pragma omp target \n  {\n    for (int i = 0; i < N; i++) {\n      anArrayCopy[i] = anArray[i];\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArray[i] != i + 20);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArrayCopy[i] != i + 20);\n    if (errors) break;\n  }\n\n  free(anArray);\n  free(anArrayCopy);\n  return errors;\n}\n\nint main() \n  int isOffloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"With no offloading, unified shared memory is guaranteed due to host execution\");\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, unified_shared_memory_malloc());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_metadirective_otherwise.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  int errors = 0;\n  OMPVV_TEST_OFFLOADING;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_otherwise() != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 1965",
        "issue_id": 4,
        "original_code": "//--------------- test_metadirective_otherwise.c ----------------------------//\n// OpenMP API Version 5.2 Nov 2021\n// *************************\n// DIRECTIVE: metadirective\n// CLAUSES: when, otherwise\n// *************************\n// The otherwise clause of the metadirective construct is being tested. The\n// metadirective construct contains a when clause, which itself contains a\n// context-selector (device = {kind(nohost)}) and a directive-variant (nothing).\n// The metadirective construct also contains an otherwise clause, which itself\n// contains a directive-variant (target map(tofrom : on_host)).\n// The when clause of the metadirective construct is\n// evaluated for a valid context-selector pertaining to a device related\n// characteristic of a certain kind (nohost), defined in the OpenMP additional\n// definitions. If a target construct were specified, the evaluation would\n// be true, and the directive-variant nothing would be executed as if\n// #pragma omp nothing were present. Target is not present, so the\n// directive-variant of the otherwise clause will be executed. This would not\n// occur if device = {kind(host)} were specified. If omp_is_initial_device()\n// evaluates to false (0), then the test will pass.\n//----------------------------------------------------------------------------//\n\n#include \"ompvv.h\"\n#include <omp.h>\n\nint test_otherwise() {\n  int errors = 0;\n  int on_host = 1;\n  int num_devices = omp_get_num_devices();\n\n  #pragma omp metadirective \\\n    when(device = {kind(nohost)}: nothing) \\\n    otherwise(target map(tofrom : on_host))\n    {\n      on_host = omp_is_initial_device();\n    }\n\n  if (num_devices > 0) {\n    OMPVV_ERROR_IF(\n        on_host == 1,\n        \"A device was available, but the target directive was not executed\");\n    OMPVV_TEST_AND_SET_VERBOSE(errors, on_host == 1);\n  } else {\n    OMPVV_WARNING(\n        \"NO DEVICES ARE AVAILABLE, OTHERWISE CLAUSE WAS ACCESSED ON HOST\");\n  }\n\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_OFFLOADING;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_otherwise() != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//--------------- test_metadirective_otherwise.c ----------------------------//\n// OpenMP API Version 5.2 Nov 2021\n// *************************\n// DIRECTIVE: metadirective\n// CLAUSES: when, otherwise\n// *************************\n// The otherwise clause of the metadirective construct is being tested. The\n// metadirective construct contains a when clause, which itself contains a\n// context-selector (device = {kind(nohost)}) and a directive-variant (nothing).\n// The metadirective construct also contains an otherwise clause, which itself\n// contains a directive-variant (target map(tofrom : on_host)).\n// The when clause of the metadirective construct is\n// evaluated for a valid context-selector pertaining to a device related\n// characteristic of a certain kind (nohost), defined in the OpenMP additional\n// definitions. If a target construct were specified, the evaluation would\n// be true, and the directive-variant nothing would be executed as if\n// #pragma omp nothing were present. Target is not present, so the\n// directive-variant of the otherwise clause will be executed. This would not\n// occur if device = {kind(host)} were specified. If omp_is_initial_device()\n// evaluates to false (0), then the test will pass.\n//----------------------------------------------------------------------------//\n\n#include \"ompvv.h\"\n#include <omp.h>\n\nint test_otherwise() {\n  int errors = 0;\n  int on_host = 1;\n  int num_devices = omp_get_num_devices();\n\n  #pragma omp metadirective \\\n    when(device = {kind(nohost)}: nothing) \\\n    otherwise(target map(tofrom : on_host))\n    {\n      on_host = omp_is_initial_device();\n    }\n\n  if (num_devices > 0) {\n    OMPVV_ERROR_IF(\n        on_host == 1,\n        \"A device was available, but the target directive was not executed\");\n    OMPVV_TEST_AND_SET_VERBOSE(errors, on_host == 1);\n  } else {\n    OMPVV_WARNING(\n        \"NO DEVICES ARE AVAILABLE, OTHERWISE CLAUSE WAS ACCESSED ON HOST\");\n  }\n\n  return errors;\n}\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_enter_data_depend.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===--- test_target_enter_data_depend.c ------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks the target enter data directive with a depend clause \n// specified. Behavior for depend 'in' and depend 'out' are both addressed.\n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include \"ompvv.h\"\n\n#define N 1000\n#define HOST_TASK1_BIT 0x1\n#define HOST_TASK2_BIT 0x2\n#define DEVICE_TASK1_BIT 0x4\n#define DEVICE_TASK2_BIT 0x8\n#define HOST_TASK3_BIT 0x10\n#define ALL_TASKS_BITS 0x1F\n\n/*\n * Test if it is possible to:\n * 1. target enter data to depend 'in' and 'out'\n * 2. target exit data to depend 'in' and 'out'\n * 3. Mix target-based tasks with host tasks.\n *\n * We use bits for each task to know where it fails\n */\nint test_async_between_task_target() {\n  OMPVV_INFOMSG(\"test_async_between_task_target\");\n\n  int errors = 0;\n  bool isHost = true;\n  int sum = 0.0;\n  int* h_array = (int *) malloc(N * sizeof(int));\n  int* h_array_copy = (int *) malloc(N * sizeof(int));\n  int* in_1 = (int *) malloc(N * sizeof(int));\n  int* in_2 = (int *) malloc(N * sizeof(int));\n  \n  // host task 1\n#pragma omp task depend(out: in_1) shared(in_1)\n  {\n    for (int i = 0; i < N; ++i) {\n      in_1[i] = HOST_TASK1_BIT; // 0b01\n    }\n  }\n\n  // host task 2\n#pragma omp task depend(out: in_2) shared(in_2)\n  {\n    for (int i = 0; i < N; ++i) {\n      in_2[i] = HOST_TASK2_BIT; // 0b10\n    }\n  }\n\n  // target enter data\n#pragma omp target enter data map(alloc: h_array[0:N]) map(to: in_1[0:N]) map(to: in_2[0:N]) depend(out: h_array) depend(in: in_1) depend(in: in_2) \n\n  // target task to compute on the device \n  // device task 1\n  // adding redundant depends on in_1 + in_2 to make the test work if compiled for the host\n#pragma omp task shared (isHost, h_array, in_1, in_2) depend(inout: h_array) depend(in: in_1) depend(in: in_2)\n  {\n#pragma omp target map(tofrom: isHost) map(alloc: in_1[0:N]) map(alloc: in_2[0:N]) map(alloc: h_array[0:N])\n    {\n      isHost = omp_is_initial_device();\n      for (int i = 0; i < N; ++i) {\n        h_array[i] = DEVICE_TASK1_BIT | in_1[i] | in_2[i]; // Expected = 0b111\n      }\n    }\n  }\n\n  // Device task 2\n#pragma omp task shared (h_array, h_array_copy) depend(in: h_array) depend(out: h_array_copy)\n  {\n#pragma omp target map(alloc: h_array[0:N]) map(from: h_array_copy[0:N])\n    {\n      for (int i = 0; i < N; ++i) {\n        h_array_copy[i] = h_array[i] | DEVICE_TASK2_BIT; //  Expected = 0b1111\n      }\n    }\n  }\n\n  // host task 3\n#pragma omp task depend(in: h_array_copy) shared(sum, h_array_copy)\n  {\n    // checking results\n    for (int i = 0; i < N; ++i) {\n      // Identify which task was problematic\n      h_array_copy[i] |= HOST_TASK3_BIT;\n      sum += (h_array_copy[i] & ALL_TASKS_BITS); // AND with 0b111 should produce sum\n    }\n  }\n#pragma omp taskwait\n\n  // We verify all the tasks without a task\n  int h_task1 = 0;\n  int h_task2 = 0;\n  int h_task3 = 0;\n  int d_task1 = 0;\n  int d_task2 = 0;\n  for (int i = 0; i < N; ++i) {\n    h_task1 |= !(h_array_copy[i] & HOST_TASK1_BIT);\n    h_task2 |= !(h_array_copy[i] & HOST_TASK2_BIT);\n    h_task2 |= !(h_array_copy[i] & HOST_TASK3_BIT);\n    d_task1 |= !(h_array_copy[i] & DEVICE_TASK1_BIT);\n    d_task2 |= !(h_array_copy[i] & DEVICE_TASK2_BIT);\n  }\n  OMPVV_ERROR_IF(h_task1 != 0, \"Error in host task 1\");\n  OMPVV_ERROR_IF(h_task2 != 0, \"Error in host task 2\");\n  OMPVV_ERROR_IF(h_task3 != 0, \"Error in host task 3\");\n  OMPVV_ERROR_IF(d_task1 != 0, \"Error in device task 1\");\n  OMPVV_ERROR_IF(d_task2 != 0, \"Error in device task 2\");\n\n  OMPVV_TEST_AND_SET(errors, (N * ALL_TASKS_BITS != sum));\n  OMPVV_INFOMSG(\"Test test_async_between_task_target ran on the %s\", (isHost ? \"host\" : \"device\"));\n \n// Garbage collection\n// This is outside of the testing area but we need to clear memory on the device \n// created with the target enter data\n#pragma omp target exit data map(delete: h_array[0:N], in_1[0:N], in_2[0:N])\n  free(h_array);\n  free(h_array_copy);\n  free(in_1);\n  free(in_2);\n\n  return errors;\n}\n\n/*\n * Test if it is possible to:\n * 1. target enter data to depend 'out'\n * 2. target exit data to depend 'in'\n * 3. use nowait for async\n */\nint test_async_between_target() {\n  OMPVV_INFOMSG(\"test_async_between_target\");\n\n  int errors = 0;\n  bool isHost = true;\n  int sum = 0;\n  int* h_array = (int *) malloc(N * sizeof(int));\n  int* h_array_copy = (int *) malloc(N * sizeof(int));\n  int val = DEVICE_TASK1_BIT;\n\n  // target enter data\n#pragma omp target enter data map(alloc: h_array[0:N]) depend(out: h_array) \n\n#pragma omp target enter data map(to: val) depend(out: val) \n\n#pragma omp target map(tofrom: isHost) map(alloc: h_array[0:N]) depend(inout: h_array) depend(in: val) \n  {\n    isHost = omp_is_initial_device();\n    for (int i = 0; i < N; ++i) {\n      h_array[i] = val; // val = DEVICE_TASK1_BIT\n    }\n  }\n\n#pragma omp target map(alloc: h_array[0:N]) map(from: h_array_copy[0:N]) depend(in: h_array) depend(out: h_array_copy) \n  {\n    for (int i = 0; i < N; ++i) {\n      h_array_copy[i] = h_array[i] | DEVICE_TASK2_BIT;\n    }\n  }\n#pragma omp taskwait\n\n  // checking results\n  int d_task1 = 0;\n  int d_task2 = 0;\n  for (int i = 0; i < N; ++i) {\n    sum += (h_array_copy[i] & (DEVICE_TASK1_BIT | DEVICE_TASK2_BIT)); // this will lead to 0b1100\n    // Checking each individual task\n    d_task1 |= !(h_array_copy[i] & DEVICE_TASK1_BIT);\n    d_task2 |= !(h_array_copy[i] & DEVICE_TASK2_BIT);\n  }\n  // Report on each task\n  OMPVV_ERROR_IF(d_task1 != 0, \"Error in device task 1\");\n  OMPVV_ERROR_IF(d_task2 != 0, \"Error in device task 2\");\n\n  OMPVV_TEST_AND_SET(errors, (N * (DEVICE_TASK1_BIT | DEVICE_TASK2_BIT) != sum));\n  OMPVV_INFOMSG(\"Test test_async_between_task_target ran on the %s\", (isHost ? \"host\" : \"device\"));\n\n// Garbage collection\n// This is outside of the testing area but we need to clear memory on the device \n// created with the target enter data\n#pragma omp target exit data map(delete: h_array[0:N], val)\n\n  free(h_array);\n  free(h_array_copy);\n  return errors;\n}\n\nint main(){\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET(errors, test_async_between_target());\n  OMPVV_TEST_AND_SET(errors, test_async_between_task_target());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nbyte yxvufgxexr = 244;\nfloat capippyuxy = 235;\nint bcxcfygbzf = 42;\nlong sjhblvcxpg = 151;\nint jgpakwrmyh = 233;\nfloat omnclfkbtg = 44;\nshort thbitcgsqq = 27;\ndouble fbfmkyglby = 123;\nint aqpobonrwb = 30;\nbyte zlvdqfpwrb = 1;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_parallel_for_devices.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_devices());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 1902",
        "issue_id": 4,
        "original_code": "//===---- test_target_teams_distribute_parallel_for_devices.c - combined consutrct -===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// Testing for multiple devices checking if it is possible to send work and data \n// to different devices with the device clause used with omp target teams distribute \n// parallel for \n//\n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define SIZE_N 1024\n\nint test_target_teams_distribute_parallel_for_devices() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_devices\");\n  \n  int num_dev = omp_get_num_devices();\n  int a[SIZE_N];\n  // Allocate num_devices + 1 to avoid zero-sized VLA if num_devices == 0\n  int isHost[num_dev+1];\n  int errors = 0;\n  int i, dev;\n\n  OMPVV_WARNING_IF(num_dev <= 1, \"Testing devices clause without multiple devices\");\n  \n  OMPVV_INFOMSG(\"Num of devices = %d\", num_dev);\n\n  // a array initialization\n  for (i = 0; i < SIZE_N; i++) {\n    a[i] = 1;\n  }\n\n  for (dev = 0; dev < num_dev; ++dev) {\n#pragma omp target enter data map(to: a[0:SIZE_N]) device(dev)\n  }\n\n  for (dev = 0; dev < num_dev; ++dev) {\n    // check multiple devices \n#pragma omp target teams distribute parallel for device(dev) map(tofrom: isHost)\n    for (i = 0; i < SIZE_N; i++) {\n      if (omp_get_team_num() == 0 && omp_get_thread_num() == 0) {\n        isHost[dev] = omp_is_initial_device();// Checking if running on a device\n      }\n      a[i] += dev;\n    }\n  }\n\n  for (dev = 0; dev < num_dev; ++dev) {\n#pragma omp target exit data map(from: a[0:SIZE_N]) device(dev)\n    OMPVV_INFOMSG(\"Device %d ran on the %s\", dev, isHost[dev] ? \"host\" : \"device\");\n    OMPVV_TEST_AND_SET(errors, isHost[dev] && dev != omp_get_initial_device());\n    for (i = 0; i < SIZE_N; i++) {\n      OMPVV_TEST_AND_SET(errors, a[i] != 1 + dev);\n    }\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_devices());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_teams_distribute_parallel_for_devices.c - combined consutrct -===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// Testing for multiple devices checking if it is possible to send work and data \n// to different devices with the device clause used with omp target teams distribute \n// parallel for \n//\n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define SIZE_N 1024\n\nint test_target_teams_distribute_parallel_for_devices() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_devices\");\n  \n  int num_dev = omp_get_num_devices();\n  int a[SIZE_N];\n  // Allocate num_devices + 1 to avoid zero-sized VLA if num_devices == 0\n  int isHost[num_dev+1];\n  int errors = 0;\n  int i, dev;\n\n  OMPVV_WARNING_IF(num_dev <= 1, \"Testing devices clause without multiple devices\");\n  \n  OMPVV_INFOMSG(\"Num of devices = %d\", num_dev);\n\n  // a array initialization\n  for (i = 0; i < SIZE_N; i++) {\n    a[i] = 1;\n  }\n\n  for (dev = 0; dev < num_dev; ++dev) {\n#pragma omp target enter data map(to: a[0:SIZE_N]) device(dev)\n  }\n\n  for (dev = 0; dev < num_dev; ++dev) {\n    // check multiple devices \n#pragma omp target teams distribute parallel for device(dev) map(tofrom: isHost)\n    for (i = 0; i < SIZE_N; i++) {\n      if (omp_get_team_num() == 0 && omp_get_thread_num() == 0) {\n        isHost[dev] = omp_is_initial_device();// Checking if running on a device\n      }\n      a[i] += dev;\n    }\n  }\n\n  for (dev = 0; dev < num_dev; ++dev) {\n#pragma omp target exit data map(from: a[0:SIZE_N]) device(dev)\n    OMPVV_INFOMSG(\"Device %d ran on the %s\", dev, isHost[dev] ? \"host\" : \"device\");\n    OMPVV_TEST_AND_SET(errors, isHost[dev] && dev != omp_get_initial_device());\n    for (i = 0; i < SIZE_N; i++) {\n      OMPVV_TEST_AND_SET(errors, a[i] != 1 + dev);\n    }\n  }\n\n  return errors;\n}\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_dispatch_nowait.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1683",
        "issue_id": 1,
        "original_code": "//===---- test_dispatch_nowait.c -----------------------------------------===//\n// \n// OpenMP API Version 5.1\n//\n// Uses dispatch construct as context for variant directive. Uses nowait clause\n// which adds nowait to the interoperability requirement set.\n//\n// Inspired by \"OpenMP 5.1 Features: The Dispatch Construct\" video:\n// https://www.youtube.com/watch?v=ruugaX95gIs\n// \n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint arr[N]; // implicit map array \nint errors;\nint i = 0;\n\nvoid add_two(int *arr);\n\n#pragma omp declare variant(add_two) match(construct={dispatch})\nvoid add(int *arr){\n   for (int i = 0; i < N; i++){ // Base function adds 1 to array values\n      arr[i] = i+1;\n   }\n}\n\nvoid add_two(int *arr){\n   for (int i = 0; i < N; i++){\n      arr[i] = i+2; // Variant function adds 2 to array values\n   }\n}\n\nint test_wrapper() { \n   errors = 0;\n   add(arr);\n   for(i = 0; i < N; i++){\n      OMPVV_TEST_AND_SET(errors, arr[i] != i+1);\n   } \n   OMPVV_ERROR_IF(errors > 0, \"Base function is not working properly\");\n\n   #pragma omp dispatch nowait\n      add(arr);\n\n   #pragma omp barrier\n   for(i = 0; i < N; i++){\n      OMPVV_TEST_AND_SET(errors, arr[i] != i+2);\n   }\n   // OMP 5.1, Pg54:6 -Whether the dispatch construct is added to the construct\n   // set is implementation defined.\n \n   OMPVV_INFOMSG_IF(errors > 0 || arr[0] == 1,\n                   \"Dispatch is either not working or was not considered\"\n                   \" by the implementation as part of the context selector.\");\n   return errors;\n}\n\nint main () {\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_wrapper());\n   OMPVV_REPORT_AND_RETURN(errors);\n}  \n",
        "error_code": "//===---- test_dispatch_nowait.c -----------------------------------------===//\n// \n// OpenMP API Version 5.1\n//\n// Uses dispatch construct as context for variant directive. Uses nowait clause\n// which adds nowait to the interoperability requirement set.\n//\n// Inspired by \"OpenMP 5.1 Features: The Dispatch Construct\" video:\n// https://www.youtube.com/watch?v=ruugaX95gIs\n// \n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint arr[N]; // implicit map array \nint errors;\nint i = 0;\n\nvoid add_two(int *arr);\n\n#pragma omp declare variant(add_two) match(construct={dispatch})\nvoid add(int *arr){\n   for (int i = 0; i < N; i++){ // Base function adds 1 to array values\n      arr[i] = i+1;\n   }\n}\n\nvoid add_two(int *arr){\n   for (int i = 0; i < N; i++){\n      arr[i] = i+2; // Variant function adds 2 to array values\n   }\n}\n\nint test_wrapper() { \n   errors = 0;\n   add(arr);\n   for(i = 0; i < N; i++){\n      OMPVV_TEST_AND_SET(errors, arr[i] != i+1);\n   } \n   OMPVV_ERROR_IF(errors > 0, \"Base function is not working properly\");\n\n   #pragma omp dispatch nowait\n      add(arr);\n\n   #pragma omp barrier\n   for(i = 0; i < N; i++){\n      OMPVV_TEST_AND_SET(errors, arr[i] != i+2);\n   }\n   // OMP 5.1, Pg54:6 -Whether the dispatch construct is added to the construct\n   // set is implementation defined.\n \n   OMPVV_INFOMSG_IF(errors > 0 || arr[0] == 1,\n                   \"Dispatch is either not working or was not considered\"\n                   \" by the implementation as part of the context selector.\");\n   return errors;\n}\n\nint main () \n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_wrapper());\n   OMPVV_REPORT_AND_RETURN(errors);\n}  \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_assume_absent.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1200",
        "issue_id": 1,
        "original_code": "//===--- test_assume_absent.c -----------------------------------------------===//\n//\n//  OpenMP API Version 5.1 Aug 2021\n//\n//  The specification states that \"when the absent clause appears on an assume\n//  directive, the application guarantees that no constructs that match a\n//  listed directive name are encountered in the scope of the assume directive.\"\n//  In this test, we use \"teams\", \"masked\", \"scope\", \"simd\" as the directive-name\n//  for the absent clause as they do not appear in their scope.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint errors, i;\n\nint test_assume_absent() {\n    int arr[N];\n    for(i = 0; i < N; i++){\n        arr[i] = i;\n    }\n    #pragma omp assume absent(teams, masked, scope, simd)\n    {\n        #pragma omp target parallel for map(tofrom: arr)\n        for(i = 0; i < N; i++){\n            arr[i] = arr[i]*2;\n        }\n    }\n    // Test that no issues were caused from using assume directive\n    for(i = 0; i < N; i++){\n        OMPVV_TEST_AND_SET(errors, arr[i] != i*2);\n    }\n    return errors;\n}\n\nint main() {\n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_assume_absent() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_assume_absent.c -----------------------------------------------===//\n//\n//  OpenMP API Version 5.1 Aug 2021\n//\n//  The specification states that \"when the absent clause appears on an assume\n//  directive, the application guarantees that no constructs that match a\n//  listed directive name are encountered in the scope of the assume directive.\"\n//  In this test, we use \"teams\", \"masked\", \"scope\", \"simd\" as the directive-name\n//  for the absent clause as they do not appear in their scope.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint errors, i;\n\nint test_assume_absent() {\n    int arr[N];\n    for(i = 0; i < N; i++){\n        arr[i] = i;\n    }\n    #pragma omp assume absent(teams, masked, scope, simd)\n    {\n        #pragma omp target parallel for map(tofrom: arr)\n        for(i = 0; i < N; i++){\n            arr[i] = arr[i]*2;\n        }\n    }\n    // Test that no issues were caused from using assume directive\n    for(i = 0; i < N; i++){\n        OMPVV_TEST_AND_SET(errors, arr[i] != i*2);\n    }\n    return errors;\n}\n\nint main() \n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_assume_absent() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_private.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1730",
        "issue_id": 1,
        "original_code": "//===--test_target_private.c ----------------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// Testing private clause with target directive. The test begins by initializing\n// and filling a 2-D array with all zeros and generating four threads. In a parallel\n// region, each thread is assigned a thread number and an integer. At the beginning\n// of the parallel region, the 2-D array is mapped to device alongside the private\n// integer value and firstprivate unqiue thread number. The integer value is set\n// equal to the thread number inside of the target region and each column of the\n// array is filled based on which thread is currently operating. Finally, back on the\n// host, we check that array is properly filled.\n//\n////===--------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define N 10\n\nint main() {\n\n  int compute_array[OMPVV_NUM_THREADS_HOST][N];\n  int errors = 0;\n  int i, j;\n  int real_num_threads;\n\n  //Check for offloading\n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n\n  for (i = 0; i < OMPVV_NUM_THREADS_HOST; i++) {\n    for (j = 0; j < N; j++) {\n      compute_array[i][j] = 0;\n    }\n  }\n\n  omp_set_num_threads(OMPVV_NUM_THREADS_HOST);\n#pragma omp parallel\n  {\n    int fp_val = omp_get_thread_num();\n    int p_val=0;\n    real_num_threads = omp_get_num_threads();\n\n#pragma omp target map(tofrom:compute_array[fp_val][0:N]) firstprivate(fp_val) private(p_val)\n    {\n      p_val = fp_val;\n      for (i = 0; i < N; i++)\n        compute_array[p_val][i] += p_val;\n    } // end target\n  }//end parallel\n\n  for (i = 0; i < real_num_threads; i++) {\n    for (j = 0; j < N; j++){\n      OMPVV_TEST_AND_SET_VERBOSE(errors, (compute_array[i][j] != i));\n    }\n  }//end for\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n}\n",
        "error_code": "//===--test_target_private.c ----------------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// Testing private clause with target directive. The test begins by initializing\n// and filling a 2-D array with all zeros and generating four threads. In a parallel\n// region, each thread is assigned a thread number and an integer. At the beginning\n// of the parallel region, the 2-D array is mapped to device alongside the private\n// integer value and firstprivate unqiue thread number. The integer value is set\n// equal to the thread number inside of the target region and each column of the\n// array is filled based on which thread is currently operating. Finally, back on the\n// host, we check that array is properly filled.\n//\n////===--------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define N 10\n\nint main() {\n\n  int compute_array[OMPVV_NUM_THREADS_HOST][N];\n  int errors = 0;\n  int i, j;\n  int real_num_threads;\n\n  //Check for offloading\n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n\n  for (i = 0; i < OMPVV_NUM_THREADS_HOST; i++) {\n    for (j = 0; j < N; j++) {\n      compute_array[i][j] = 0;\n    }\n  }\n\n  omp_set_num_threads(OMPVV_NUM_THREADS_HOST);\n#pragma omp parallel\n  {\n    int fp_val = omp_get_thread_num();\n    int p_val=0;\n    real_num_threads = omp_get_num_threads();\n\n#pragma omp target map(tofrom:compute_array[fp_val][0:N]) firstprivate(fp_val) private(p_val)\n    {\n      p_val = fp_val;\n      for (i = 0; i < N; i++)\n        compute_array[p_val][i] += p_val;\n    } // end target\n  }//end parallel\n\n  for (i = 0; i < real_num_threads; i++) {\n    for (j = 0; j < N; j++)\n      OMPVV_TEST_AND_SET_VERBOSE(errors, (compute_array[i][j] != i));\n    }\n  }//end for\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_begin_end_declare_variant.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp begin\" with directive \"#pragma omp atomic\" at position 696",
        "issue_id": 0,
        "original_code": "//===---- begin_end_declare_variant.c ---------------------------------------------===//\n// \n// OpenMP API Version 5.1\n//\n// Uses 'begin' and 'end' declare variant syntax to create a parallel and target\n// variant of a simple add function. To ensure that the variants are used, different\n// integers are used within the variants.\n// \n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint arr[N]; // implicit map array \nint errors;\nint i = 0;\n\nvoid add(int *arr){\n   for (int i = 0; i < N; i++){ // Base function adds 1 to array values\n      arr[i] = i+1;\n   }\n}\n\n#pragma omp begin declare variant match(construct={parallel}) // Parallel variant adds 2 to array values\nvoid add(int *arr){\n   #pragma omp for\n   for (int i = 0; i < N; i++){\n      arr[i] = i + 2;\n   } \n}\n#pragma omp end declare variant\n\n#pragma omp begin declare variant match(construct={target}) // Target variant adds 3 to array values\nvoid add(int *arr){\n   #pragma omp for\n   for (int i = 0; i < N; i++){\n      arr[i] = i + 3;\n   }\n}\n#pragma omp end declare variant\n\nint test_wrapper() { \n   add(arr);\n    \n   for (int i = 0; i < N; i++){\n      OMPVV_TEST_AND_SET_VERBOSE(errors, arr[i] != i+1);\n   }\n   OMPVV_ERROR_IF(errors > 0, \"Base function is not working properly\")\n   errors = 0;\n   \n   #pragma omp parallel\n   {\n      add(arr);\n   }\t\t\n   for (int i = 0; i < N; i++){\n      OMPVV_TEST_AND_SET_VERBOSE(errors, arr[i] != i+2);\n   } \n   OMPVV_ERROR_IF(errors>0, \"Parallel variant function is not working properly\")\n   errors=0;\n    \n   #pragma omp target map(tofrom: arr)\n   {\n      add(arr);\n   }\t\t\n   for(int i=0; i<N; i++){\n      OMPVV_TEST_AND_SET_VERBOSE(errors, arr[i] != i+3);\n   } \n   OMPVV_ERROR_IF(errors>0, \"Target variant function is not working properly\")\n\n   return errors;\n}\n\nint main () {\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_wrapper());\n   OMPVV_REPORT_AND_RETURN(errors);\n}  \n",
        "error_code": "//===---- begin_end_declare_variant.c ---------------------------------------------===//\n// \n// OpenMP API Version 5.1\n//\n// Uses 'begin' and 'end' declare variant syntax to create a parallel and target\n// variant of a simple add function. To ensure that the variants are used, different\n// integers are used within the variants.\n// \n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint arr[N]; // implicit map array \nint errors;\nint i = 0;\n\nvoid add(int *arr){\n   for (int i = 0; i < N; i++){ // Base function adds 1 to array values\n      arr[i] = i+1;\n   }\n}\n\n#pragma omp atomic declare variant match(construct={parallel}) // Parallel variant adds 2 to array values\nvoid add(int *arr){\n   #pragma omp for\n   for (int i = 0; i < N; i++){\n      arr[i] = i + 2;\n   } \n}\n#pragma omp end declare variant\n\n#pragma omp begin declare variant match(construct={target}) // Target variant adds 3 to array values\nvoid add(int *arr){\n   #pragma omp for\n   for (int i = 0; i < N; i++){\n      arr[i] = i + 3;\n   }\n}\n#pragma omp end declare variant\n\nint test_wrapper() { \n   add(arr);\n    \n   for (int i = 0; i < N; i++){\n      OMPVV_TEST_AND_SET_VERBOSE(errors, arr[i] != i+1);\n   }\n   OMPVV_ERROR_IF(errors > 0, \"Base function is not working properly\")\n   errors = 0;\n   \n   #pragma omp parallel\n   {\n      add(arr);\n   }\t\t\n   for (int i = 0; i < N; i++){\n      OMPVV_TEST_AND_SET_VERBOSE(errors, arr[i] != i+2);\n   } \n   OMPVV_ERROR_IF(errors>0, \"Parallel variant function is not working properly\")\n   errors=0;\n    \n   #pragma omp target map(tofrom: arr)\n   {\n      add(arr);\n   }\t\t\n   for(int i=0; i<N; i++){\n      OMPVV_TEST_AND_SET_VERBOSE(errors, arr[i] != i+3);\n   } \n   OMPVV_ERROR_IF(errors>0, \"Target variant function is not working properly\")\n\n   return errors;\n}\n\nint main () {\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_wrapper());\n   OMPVV_REPORT_AND_RETURN(errors);\n}  \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_loop_private.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n    OMPVV_TEST_AND_SET_VERBOSE(errors, b[i] != (2*i + 1));\n    OMPVV_TEST_AND_SET_VERBOSE(errors, a[i] != (2*i));\n  }\" at position 526",
        "issue_id": 4,
        "original_code": "#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n/**\n  This is a basic test to demonstrate private clause used\n  with \"omp target teams loop\".\n*/\nint main() {\n  int a[N], b[N];\n  int errors = 0;\n  // Data Inititalize\n  for (int i = 0; i < N; i++) {\n    a[i] = 2*i;  // Even\n    b[i] = a[i];\n  }\n  // Execute on target\n#pragma omp target teams loop map(tofrom: b[0:N]) private(a)\n  for (int i = 0; i < N; i++) {\n    a[i] = 2*i + 1;\n    b[i] = a[i];\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, b[i] != (2*i + 1));\n    OMPVV_TEST_AND_SET_VERBOSE(errors, a[i] != (2*i));\n  }\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n/**\n  This is a basic test to demonstrate private clause used\n  with \"omp target teams loop\".\n*/\nint main() {\n  int a[N], b[N];\n  int errors = 0;\n  // Data Inititalize\n  for (int i = 0; i < N; i++) {\n    a[i] = 2*i;  // Even\n    b[i] = a[i];\n  }\n  // Execute on target\n#pragma omp target teams loop map(tofrom: b[0:N]) private(a)\n  for (int i = 0; i < N; i++) {\n    a[i] = 2*i + 1;\n    b[i] = a[i];\n  }\n\n  for (int i = 0; i < N; i++) \n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_uses_allocators_cgroup.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1102",
        "issue_id": 1,
        "original_code": "//===--- test_target_uses_allocators_cgroup.c -----------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// The tests checks the uses_allocators clause with omp_cgroup_mem_alloc. \n// The variable allaocated in the target is modified and used to compute result on \n// device. Result is copied back to the host and checked with computed value on host.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_uses_allocators_cgroup() {\n  int errors = 0;\n  int x = 0;\n  int device_result = 0;\n  int result = 0;\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      result += j + i ;\n    }\n  }\n\n#pragma omp target uses_allocators(omp_cgroup_mem_alloc) allocate(omp_cgroup_mem_alloc: x) firstprivate(x) map(from: device_result)\n{\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      x += j + i;\n    }\n  }\n  device_result = x;\n}\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != device_result);\n\n  return errors;\n}\n\nint main() {\n\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_uses_allocators_cgroup() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n",
        "error_code": "//===--- test_target_uses_allocators_cgroup.c -----------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// The tests checks the uses_allocators clause with omp_cgroup_mem_alloc. \n// The variable allaocated in the target is modified and used to compute result on \n// device. Result is copied back to the host and checked with computed value on host.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_uses_allocators_cgroup() {\n  int errors = 0;\n  int x = 0;\n  int device_result = 0;\n  int result = 0;\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      result += j + i ;\n    }\n  }\n\n#pragma omp target uses_allocators(omp_cgroup_mem_alloc) allocate(omp_cgroup_mem_alloc: x) firstprivate(x) map(from: device_result)\n{\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      x += j + i;\n    }\n  }\n  device_result = x;\n}\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != device_result);\n\n  return errors;\n}\n\nint main() \n\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_uses_allocators_cgroup() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_assume_contains.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp assume\" with directive \"#pragma omp flush\" at position 794",
        "issue_id": 0,
        "original_code": "//===--- test_assume_contains.c ---------------------------------------------===//\n//\n//  OpenMP API Version 5.1 Aug 2021\n//\n//  The specification states that \"when the contains clause appears on an assume\n//  directive, the application proviedes a hint that constructs that match the\n//  listed directive names are likely to be encountered in the scope of the\n//  assume directive.\" In this test, we use \"target parallel for\" as the\n//  directive-name for the contains clause.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint errors, i;\n\nint test_assume_contains() {\n    int arr[N];\n    for(i = 0; i < N; i++){\n        arr[i] = i;\n    }\n    #pragma omp assume contains(target, parallel, for)\n    {\n        #pragma omp target map(tofrom: arr)\n        #pragma omp parallel num_threads(OMPVV_NUM_THREADS_DEVICE)\n        #pragma omp for\n        for(i = 0; i < N; i++){\n            arr[i] = arr[i]*2;\n        }\n    }\n    // Test that no issues were caused from using assume directive\n    for(i = 0; i < N; i++){\n        OMPVV_TEST_AND_SET(errors, arr[i] != i*2);\n    }\n    return errors;\n}\n\nint main() {\n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_assume_contains() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_assume_contains.c ---------------------------------------------===//\n//\n//  OpenMP API Version 5.1 Aug 2021\n//\n//  The specification states that \"when the contains clause appears on an assume\n//  directive, the application proviedes a hint that constructs that match the\n//  listed directive names are likely to be encountered in the scope of the\n//  assume directive.\" In this test, we use \"target parallel for\" as the\n//  directive-name for the contains clause.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint errors, i;\n\nint test_assume_contains() {\n    int arr[N];\n    for(i = 0; i < N; i++){\n        arr[i] = i;\n    }\n    #pragma omp flush contains(target, parallel, for)\n    {\n        #pragma omp target map(tofrom: arr)\n        #pragma omp parallel num_threads(OMPVV_NUM_THREADS_DEVICE)\n        #pragma omp for\n        for(i = 0; i < N; i++){\n            arr[i] = arr[i]*2;\n        }\n    }\n    // Test that no issues were caused from using assume directive\n    for(i = 0; i < N; i++){\n        OMPVV_TEST_AND_SET(errors, arr[i] != i*2);\n    }\n    return errors;\n}\n\nint main() {\n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_assume_contains() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_parallel_for_schedule_private.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp flush\" at position 1042",
        "issue_id": 0,
        "original_code": "//===---- test_target_teams_distribute_parallel_for_schedule_private.c - private per thread combined construct-===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// private variables are private to the running thread. When using the scheduler clause it should be possible to\n// have a private variable that shares its memory space across multiple iterations\n//\n//\n//===---------------------------------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n// This has been selected for the num teams and num threads below\n#define SIZE_N 2048\n\nint test_target_teams_distribute_parallel_for_sched_private() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_schedule_private\");\n  \n  int a[SIZE_N];\n  int firstprivatized=1;\n  int reported_num_teams[SIZE_N];\n  int reported_team_num[SIZE_N];\n  int reported_num_threads[SIZE_N];\n  int errors = 0;\n\n  // array initialization\n  for (int i = 0; i < SIZE_N; i++) {\n    a[i] = 0;\n  }\n\n  // check multiple sizes. \n#pragma omp target teams distribute parallel for firstprivate(firstprivatized) num_teams(OMPVV_NUM_TEAMS_DEVICE) num_threads(OMPVV_NUM_THREADS_DEVICE) schedule(static,8)\n    for (int j = 0; j < SIZE_N; ++j) {\n      reported_num_teams[j] = omp_get_num_teams();\n      reported_num_threads[j] = omp_get_num_threads();\n      reported_team_num[j] = omp_get_team_num();\n      if (j%8 == 0)\n        firstprivatized = 0;\n      firstprivatized++;\n      a[j] += firstprivatized;\n    }\n\n  // Checking for reported teams and number of threads\n  OMPVV_WARNING_IF(reported_num_teams[0] == 1, \"Number of teams reported was 1, test cannot assert privatization across teams\");\n  // To have a single warning for threds. diff teams could have different number of threads, we warn if all are 1\n  int warning_threads = 0;\n  for (int i = 0; i < SIZE_N; i++) {\n    if (reported_num_threads[i] == 1)\n      warning_threads++;\n    if (i > 0) {\n      OMPVV_ERROR_IF(reported_num_teams[i] != reported_num_teams[i-1], \"Discrepancy in the reported number of teams across teams\");\n      if (reported_team_num[i] == reported_team_num[i-1] && reported_num_threads[i] != reported_num_threads[i-1])\n        OMPVV_ERROR(\"Discrepancy in the reported number of threads inside a single team\");\n    }\n  }\n  OMPVV_WARNING_IF(warning_threads == SIZE_N, \"Number of threads was 1 for all teams. test cannot assert privatization across teams\");\n  // Checking for the expected values \n  for (int i = 0; i < SIZE_N; i+=8) {\n    for (int j = 0; j < 8; j++) { \n      OMPVV_TEST_AND_SET(errors, a[i + j] != j+1);\n    }\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_sched_private());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_teams_distribute_parallel_for_schedule_private.c - private per thread combined construct-===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// private variables are private to the running thread. When using the scheduler clause it should be possible to\n// have a private variable that shares its memory space across multiple iterations\n//\n//\n//===---------------------------------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n// This has been selected for the num teams and num threads below\n#define SIZE_N 2048\n\nint test_target_teams_distribute_parallel_for_sched_private() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_schedule_private\");\n  \n  int a[SIZE_N];\n  int firstprivatized=1;\n  int reported_num_teams[SIZE_N];\n  int reported_team_num[SIZE_N];\n  int reported_num_threads[SIZE_N];\n  int errors = 0;\n\n  // array initialization\n  for (int i = 0; i < SIZE_N; i++) {\n    a[i] = 0;\n  }\n\n  // check multiple sizes. \n#pragma omp flush teams distribute parallel for firstprivate(firstprivatized) num_teams(OMPVV_NUM_TEAMS_DEVICE) num_threads(OMPVV_NUM_THREADS_DEVICE) schedule(static,8)\n    for (int j = 0; j < SIZE_N; ++j) {\n      reported_num_teams[j] = omp_get_num_teams();\n      reported_num_threads[j] = omp_get_num_threads();\n      reported_team_num[j] = omp_get_team_num();\n      if (j%8 == 0)\n        firstprivatized = 0;\n      firstprivatized++;\n      a[j] += firstprivatized;\n    }\n\n  // Checking for reported teams and number of threads\n  OMPVV_WARNING_IF(reported_num_teams[0] == 1, \"Number of teams reported was 1, test cannot assert privatization across teams\");\n  // To have a single warning for threds. diff teams could have different number of threads, we warn if all are 1\n  int warning_threads = 0;\n  for (int i = 0; i < SIZE_N; i++) {\n    if (reported_num_threads[i] == 1)\n      warning_threads++;\n    if (i > 0) {\n      OMPVV_ERROR_IF(reported_num_teams[i] != reported_num_teams[i-1], \"Discrepancy in the reported number of teams across teams\");\n      if (reported_team_num[i] == reported_team_num[i-1] && reported_num_threads[i] != reported_num_threads[i-1])\n        OMPVV_ERROR(\"Discrepancy in the reported number of threads inside a single team\");\n    }\n  }\n  OMPVV_WARNING_IF(warning_threads == SIZE_N, \"Number of threads was 1 for all teams. test cannot assert privatization across teams\");\n  // Checking for the expected values \n  for (int i = 0; i < SIZE_N; i+=8) {\n    for (int j = 0; j < 8; j++) { \n      OMPVV_TEST_AND_SET(errors, a[i + j] != j+1);\n    }\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_sched_private());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_and_task_nowait.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp for\" at position 546",
        "issue_id": 0,
        "original_code": "//===-------- test_target_and_task_nowait.c - test task after target offload  ------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks if dependence expressed on target and task \n// regions are honoured in the presense of nowait.\n// This test is motivated by OpenMP usage in QMCPack.\n//\n////===----------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nint test_target_and_task_nowait() {\n  int errors = 0, i;\n  int sum = 0, a = 0;\n\n#pragma omp target map(tofrom: a, sum) depend(out: a) nowait\n  {\n    for (i = 0; i < N; i++) {\n       sum++;\n    }\n    a += 1;\n  }\n\n#pragma omp task depend(in: a) shared(a,errors)\n  {\n     if(a != 1) {\n       errors += 1; \n     }\n  }\n  #pragma omp taskwait\n  if (sum != N) {\n    errors++;\n  }\n  return(errors);\n}\n\nint main() {\n\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_and_task_nowait());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n",
        "error_code": "//===-------- test_target_and_task_nowait.c - test task after target offload  ------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks if dependence expressed on target and task \n// regions are honoured in the presense of nowait.\n// This test is motivated by OpenMP usage in QMCPack.\n//\n////===----------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nint test_target_and_task_nowait() {\n  int errors = 0, i;\n  int sum = 0, a = 0;\n\n#pragma omp for map(tofrom: a, sum) depend(out: a) nowait\n  {\n    for (i = 0; i < N; i++) {\n       sum++;\n    }\n    a += 1;\n  }\n\n#pragma omp task depend(in: a) shared(a,errors)\n  {\n     if(a != 1) {\n       errors += 1; \n     }\n  }\n  #pragma omp taskwait\n  if (sum != N) {\n    errors++;\n  }\n  return(errors);\n}\n\nint main() {\n\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_and_task_nowait());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_parallel_loop_collapse.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 997",
        "issue_id": 2,
        "original_code": "//===-------------------test_target_parallel_loop_collapse.c-----------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Description - This is a test program to demonstrate how collapse clause is\n// used with target parallel loop construct.\n//\n////===----------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define DIM_1 100\n#define DIM_2 120\n#define DIM_3 100\n\nint test_target_parallel_loop_collapse() {\n  OMPVV_INFOMSG(\"test_target_parallel_loop_collapse\");\n  \n  int arr[DIM_1][DIM_2][DIM_3];\n  int errors = 0;\n  int i,j,k;\n  int temp=0;\n\n  // arr initialization\n  for (i = 0; i < DIM_1; i++) {\n    for (j = 0; j < DIM_2; j++) {\n      for (k = 0; k < DIM_3; k++) {\n          arr[i][j][k] = 1;\n      }\n    }\n  }\n\n#pragma omp target parallel loop collapse(3) map(tofrom: arr)\n  for (i = 0; i < DIM_1; i++) {\n    for (j = 0; j < DIM_2; j++) {\n      for (k = i; k < DIM_3; k++) {\n          arr[i][j][k] += i+2*j+3*k;\n        }\n      }\n    }\n\n // validation\n  for (i = 0; i < DIM_1; i++) {\n    for (j = 0; j < DIM_2; j++) {\n      for (k = i; k < DIM_3; k++) {\n          temp = 1 + i + 2*j + 3*k;\n          OMPVV_TEST_AND_SET(errors, arr[i][j][k] != temp);\n      }\n    }\n  }\n\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_parallel_loop_collapse());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===-------------------test_target_parallel_loop_collapse.c-----------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Description - This is a test program to demonstrate how collapse clause is\n// used with target parallel loop construct.\n//\n////===----------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define DIM_1 100\n#define DIM_2 120\n#define DIM_3 100\n\nint test_target_parallel_loop_collapse() {\n  OMPVV_INFOMSG(\"test_target_parallel_loop_collapse\");\n  \n  int arr[DIM_1][DIM_2][DIM_3];\n  int errors = 0;\n  int i,j,k;\n  int temp=0;\n\n  // arr initialization\n  for (i = 0; i < DIM_1; i++) {\n    for (j = 0; j < DIM_2; j++) {\n      for (k = 0; k < DIM_3; k++) {\n          arr[i][j][k] = 1;\n      }\n    }\n  }\n\n#pragma omp target parallel loop collapse(3) map(tofrom: arr)\n  for (i = 0; i < DIM_1; i++) {\n    for (j = 0; j < DIM_2; j++) {\n      for (k = i; k < DIM_3; k++) {\n          arr[i][j][k] += i+2*j+3*k;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n        }\n      }\n    }\n\n // validation\n  for (i = 0; i < DIM_1; i++) {\n    for (j = 0; j < DIM_2; j++) {\n      for (k = i; k < DIM_3; k++) {\n          temp = 1 + i + 2*j + 3*k;\n          OMPVV_TEST_AND_SET(errors, arr[i][j][k] != temp);\n      }\n    }\n  }\n\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_parallel_loop_collapse());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_update_iterator.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 982",
        "issue_id": 2,
        "original_code": "//===--- test_target_update_iterator.c --------------------------------------------------------------===//\n//\n//  OpenMP API Version 5.1 Aug 2021\n//\n//  This test usese the target update directive with the iterator clause\n//  to update the iterative values.\n//\n//  This example has been adapted from the 5.2 OpenMP Examples document,\n//  \"Multidependences Using Iterators\" and \"Simple target data and target update\n//  constructs\"\n//\n////===--------------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\ntypedef struct test_struct{\n    size_t len;\n    int *data;\n} test_struct_t;\n\nvoid init(struct test_struct *s ){\n    s->len = N;\n    s->data = (int *) malloc(sizeof(int) * N);\n    for(size_t i = 0; i < s->len; i++){\n        s->data[i] = i;\n    }\n}\n\nvoid init_again(struct test_struct *s ){\n    s->len = N;\n    for(size_t i = 0; i < s->len; i++){\n        s->data[i] = i+1;\n    }\n}\n\nint test_target_update_iterator() {\n    int errors = 0;\n    int A[N]; // array for testing\n\n    for(int i = 0; i < N; i++){\n        A[i] = 0;\n    }\n    test_struct_t new_struct;\n\n    init(&new_struct);\n\n    #pragma omp target enter data map(to: new_struct.data[:N])\n    #pragma omp target map(to: new_struct, new_struct.data[:N]) map(tofrom: A[:N]) // pointer attachment\n    {\n        for(int i = 0; i < N; i++){\n            A[i] = new_struct.data[i];\n        }\n    }\n    init_again(&new_struct);\n    // update with new values, (i*2)+1\n    #pragma omp target update to(iterator(it = 0:N): new_struct.data[it])\n    #pragma omp target map(tofrom: A[:N])\n    {\n        for(int i = 0; i < N; i++){\n            A[i] += new_struct.data[i];\n        }\n    }\n\n    #pragma omp target exit data map(delete:new_struct.data[:N])\n\n    for(int i = 0; i < N; i++){\n        OMPVV_TEST_AND_SET(errors, A[i] != (i*2)+1);\n    }\n    \n    return errors;\n}\n\nint main() {\n   int errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_update_iterator() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}           \n\n",
        "error_code": "//===--- test_target_update_iterator.c --------------------------------------------------------------===//\n//\n//  OpenMP API Version 5.1 Aug 2021\n//\n//  This test usese the target update directive with the iterator clause\n//  to update the iterative values.\n//\n//  This example has been adapted from the 5.2 OpenMP Examples document,\n//  \"Multidependences Using Iterators\" and \"Simple target data and target update\n//  constructs\"\n//\n////===--------------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\ntypedef struct test_struct{\n    size_t len;\n    int *data;\n} test_struct_t;\n\nvoid init(struct test_struct *s ){\n    s->len = N;\n    s->data = (int *) malloc(sizeof(int) * N);\n    for(size_t i = 0; i < s->len; i++){\n        s->data[i] = i;\n    }\n}\n\nvoid init_again(struct test_struct *s ){\n    s->len = N;\n    for(size_t i = 0; i < s->len;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1; i++){\n        s->data[i] = i+1;\n    }\n}\n\nint test_target_update_iterator() {\n    int errors = 0;\n    int A[N]; // array for testing\n\n    for(int i = 0; i < N; i++){\n        A[i] = 0;\n    }\n    test_struct_t new_struct;\n\n    init(&new_struct);\n\n    #pragma omp target enter data map(to: new_struct.data[:N])\n    #pragma omp target map(to: new_struct, new_struct.data[:N]) map(tofrom: A[:N]) // pointer attachment\n    {\n        for(int i = 0; i < N; i++){\n            A[i] = new_struct.data[i];\n        }\n    }\n    init_again(&new_struct);\n    // update with new values, (i*2)+1\n    #pragma omp target update to(iterator(it = 0:N): new_struct.data[it])\n    #pragma omp target map(tofrom: A[:N])\n    {\n        for(int i = 0; i < N; i++){\n            A[i] += new_struct.data[i];\n        }\n    }\n\n    #pragma omp target exit data map(delete:new_struct.data[:N])\n\n    for(int i = 0; i < N; i++){\n        OMPVV_TEST_AND_SET(errors, A[i] != (i*2)+1);\n    }\n    \n    return errors;\n}\n\nint main() {\n   int errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_update_iterator() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}           \n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_loop_reduction_multiply_device.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp single\" at position 825",
        "issue_id": 0,
        "original_code": "//===--- test_loop_reduction_multiply_device.c ------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the reduction clause on a loop directive, testing that the\n// variable in the reduction clause is properly reduced using the multiply\n// operator. This test checks the above in a target context.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_multiply() {\n  int a[N];\n  int errors = 0;\n  int num_threads[N];\n  srand(1);\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = 1 + (int) rand() / (double) RAND_MAX;\n    num_threads[x] = -x;\n  }\n\n  int result = 1;\n  int host_result;\n\n  for (int x = 0; x < N; x = x + 16) {\n    result = 1;\n#pragma omp target parallel num_threads(OMPVV_NUM_THREADS_DEVICE) map(tofrom: result, a, num_threads)\n    {\n#pragma omp loop reduction(*:result)\n      for (int y = 0; y < 16; ++y) {\n        result *= a[x + y];\n      }\n#pragma omp for\n      for (int y = 0; y < 16; ++y) {\n        num_threads[x + y] = omp_get_num_threads();\n      }\n    }\n    host_result = 1;\n    for (int y = 0; y < 16; ++y) {\n      host_result *= a[x + y];\n    }\n    OMPVV_TEST_AND_SET_VERBOSE(errors, host_result != result);\n    OMPVV_INFOMSG_IF(host_result != result, \"Loop directive result is %d and expected result is %d.\", result, host_result);\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_threads[x - 1] != num_threads[x], \"Test reported differing numbers of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_threads[0] == 1, \"Test operated with one thread.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_threads[0] <= 0, \"Test reported invalid number of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_multiply() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n",
        "error_code": "//===--- test_loop_reduction_multiply_device.c ------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the reduction clause on a loop directive, testing that the\n// variable in the reduction clause is properly reduced using the multiply\n// operator. This test checks the above in a target context.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_multiply() {\n  int a[N];\n  int errors = 0;\n  int num_threads[N];\n  srand(1);\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = 1 + (int) rand() / (double) RAND_MAX;\n    num_threads[x] = -x;\n  }\n\n  int result = 1;\n  int host_result;\n\n  for (int x = 0; x < N; x = x + 16) {\n    result = 1;\n#pragma omp single parallel num_threads(OMPVV_NUM_THREADS_DEVICE) map(tofrom: result, a, num_threads)\n    {\n#pragma omp loop reduction(*:result)\n      for (int y = 0; y < 16; ++y) {\n        result *= a[x + y];\n      }\n#pragma omp for\n      for (int y = 0; y < 16; ++y) {\n        num_threads[x + y] = omp_get_num_threads();\n      }\n    }\n    host_result = 1;\n    for (int y = 0; y < 16; ++y) {\n      host_result *= a[x + y];\n    }\n    OMPVV_TEST_AND_SET_VERBOSE(errors, host_result != result);\n    OMPVV_INFOMSG_IF(host_result != result, \"Loop directive result is %d and expected result is %d.\", result, host_result);\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_threads[x - 1] != num_threads[x], \"Test reported differing numbers of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_threads[0] == 1, \"Test operated with one thread.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_threads[0] <= 0, \"Test reported invalid number of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_multiply() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_requires_unified_shared_memory_static.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp requires\" with directive \"#pragma omp flush\" at position 590",
        "issue_id": 0,
        "original_code": "//===---test_requires_unified_shared_memory_static.c ------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// We request the use of unified_shared_memory in this program.\n// Checking for static arrays. The array is global and then accessed through \n// a pointer from the host and the device.\n//\n// We use default mapping of the pointer, which should result in mapping of a zero\n// length array.\n//\n////===----------------------------------------------------------------------===//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp requires unified_shared_memory\n\n// STATIC ARRAY \nint anArray[N];\n\nint unified_shared_memory_static() {\n  OMPVV_INFOMSG(\"Unified shared memory testing - Static Array\");\n  int errors = 0;\n  \n  int anArrayCopy[N];\n  int * aPtr = anArray;\n\n  for (int i = 0; i < N; i++) {\n    anArray[i] = i;\n    anArrayCopy[i] = 0;\n  }\n\n  // Test for writes to this variable from device\n#pragma omp target \n  {\n    for (int i = 0; i < N; i++) {\n      aPtr[i] += 10;\n    }\n  }\n  // Modify again on the host\n  for (int i = 0; i < N; i++) {\n    aPtr[i] += 10;\n  }\n\n  // Test for reads to this variable from device\n#pragma omp target \n  {\n    for (int i = 0; i < N; i++) {\n      anArrayCopy[i] = aPtr[i];\n    }\n  }\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArray[i] != i + 20);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArrayCopy[i] != i + 20);\n    if (errors) break;\n  }\n  return errors;\n}\n\nint main() {\n  int isOffloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"With no offloading, unified shared memory is guaranteed due to host execution\");\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, unified_shared_memory_static());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---test_requires_unified_shared_memory_static.c ------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// We request the use of unified_shared_memory in this program.\n// Checking for static arrays. The array is global and then accessed through \n// a pointer from the host and the device.\n//\n// We use default mapping of the pointer, which should result in mapping of a zero\n// length array.\n//\n////===----------------------------------------------------------------------===//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp flush unified_shared_memory\n\n// STATIC ARRAY \nint anArray[N];\n\nint unified_shared_memory_static() {\n  OMPVV_INFOMSG(\"Unified shared memory testing - Static Array\");\n  int errors = 0;\n  \n  int anArrayCopy[N];\n  int * aPtr = anArray;\n\n  for (int i = 0; i < N; i++) {\n    anArray[i] = i;\n    anArrayCopy[i] = 0;\n  }\n\n  // Test for writes to this variable from device\n#pragma omp target \n  {\n    for (int i = 0; i < N; i++) {\n      aPtr[i] += 10;\n    }\n  }\n  // Modify again on the host\n  for (int i = 0; i < N; i++) {\n    aPtr[i] += 10;\n  }\n\n  // Test for reads to this variable from device\n#pragma omp target \n  {\n    for (int i = 0; i < N; i++) {\n      anArrayCopy[i] = aPtr[i];\n    }\n  }\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArray[i] != i + 20);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArrayCopy[i] != i + 20);\n    if (errors) break;\n  }\n  return errors;\n}\n\nint main() {\n  int isOffloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"With no offloading, unified shared memory is guaranteed due to host execution\");\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, unified_shared_memory_static());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_scope_allocate_construct.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp master\" at position 951",
        "issue_id": 0,
        "original_code": "//--------------- test_scope_allocate_construct.c ----------------------------//\n//\n// OpenMP API Version 5.2 Nov 2021\n//\n// This test checks that the scope directive with the allocate clause is\n// working correctly.\n// Note: restrictions for the allocate clause require that a private clause\n// be present when allocate is used with scope.\n// The allocator() argument to the allocate clause selects one of the\n// predefined allocators which are listed under Table 6.3 on pg. 174\n// in the specifications.\n//\n// In this test, the clause is used to allocate memory to an array of integers,\n// which is then written to. Each section of the array is subsequently read\n// to check if the correct integer values are present.\n//----------------------------------------------------------------------------//\n\n#include \"ompvv.h\"\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 1024\n\nint test_allocate() {\n  int errors = 0;\n  int arr[N];\n\n  #pragma omp target parallel map(tofrom : errors)\n  #pragma omp scope private(arr) allocate(allocator(omp_low_lat_mem_alloc) : arr)\n  {\n    int err = 0;\n    for (int i = 0; i < N; i++) {\n      arr[i] = i;\n    }\n    for (int j = 0; j < N; j++) {\n      if (arr[j] != j)\n        err++;\n    }\n    #pragma omp atomic update\n    errors += err;\n  }\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_OFFLOADING;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_allocate() != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//--------------- test_scope_allocate_construct.c ----------------------------//\n//\n// OpenMP API Version 5.2 Nov 2021\n//\n// This test checks that the scope directive with the allocate clause is\n// working correctly.\n// Note: restrictions for the allocate clause require that a private clause\n// be present when allocate is used with scope.\n// The allocator() argument to the allocate clause selects one of the\n// predefined allocators which are listed under Table 6.3 on pg. 174\n// in the specifications.\n//\n// In this test, the clause is used to allocate memory to an array of integers,\n// which is then written to. Each section of the array is subsequently read\n// to check if the correct integer values are present.\n//----------------------------------------------------------------------------//\n\n#include \"ompvv.h\"\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n\n#define N 1024\n\nint test_allocate() {\n  int errors = 0;\n  int arr[N];\n\n  #pragma omp master parallel map(tofrom : errors)\n  #pragma omp scope private(arr) allocate(allocator(omp_low_lat_mem_alloc) : arr)\n  {\n    int err = 0;\n    for (int i = 0; i < N; i++) {\n      arr[i] = i;\n    }\n    for (int j = 0; j < N; j++) {\n      if (arr[j] != j)\n        err++;\n    }\n    #pragma omp atomic update\n    errors += err;\n  }\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_OFFLOADING;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_allocate() != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_defaultmap.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp flush\" at position 1298",
        "issue_id": 0,
        "original_code": "//===----- test_target_defaultmap.c --------------------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// This test is made up of two functions that both check that the default mapping of \n// scalars to the device is tofrom. The first function test_default_map_on actively \n// specifies default mapping to be tofrom, while the function test_default_map_off\n// implicity specifies default mapping. Both functions initalize scalars on host, and\n// then change the value of the scalars on the device within the target region. The\n// scalar values are checked after target region to ensure they were correctly mapped \n// back to host. The five basic data types in C are used as scalars.\n//\n////===-------------------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\nint test_defaultmap_on() {\n  OMPVV_INFOMSG(\"test_defaultmap_on\");\n\n  int errors = 0;\n\n  // we try with all the scalars\n  char scalar_char = 'a';\n  short scalar_short = 10;\n  int scalar_int = 11;\n  float scalar_float = 5.5f;\n  double scalar_double = 10.45;\n  enum { VAL1 = 1, VAL2, VAL3, VAL4} scalar_enum = VAL1;\n  \n\n  // Map the same array to multiple devices. initialize with device number\n#pragma omp target defaultmap(tofrom: scalar)\n  {\n    scalar_char = 'b';\n    scalar_short = 20;\n    scalar_int = 33;\n    scalar_float = 6.5f;\n    scalar_double = 20.45;\n    scalar_enum = VAL4;\n  } // end of omp target \n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_char != 'b');\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_short != 20);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_int != 33);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_float != 6.5f);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_double != 20.45);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_enum != VAL4);\n  \n  return errors;\n}\n\nint test_defaultmap_off() {\n  OMPVV_INFOMSG(\"test_defaultmap_off\");\n  \n  int errors = 0;\n  \n    // we try with all the scalars\n    char scalar_char = 'a';\n    short scalar_short = 10;\n    int scalar_int = 11;\n    float scalar_float = 5.5f;\n    double scalar_double = 10.45;\n    enum { VAL1 = 1, VAL2, VAL3, VAL4} scalar_enum = VAL1;\n    \n    // Map the same array to multiple devices. initialize with device number\n  #pragma omp target \n    {\n      scalar_char = 'b';\n      scalar_short = 20;\n      scalar_int = 33;\n      scalar_float = 6.5f;\n      scalar_double = 20.45;\n      scalar_enum = VAL4;\n    } // end of omp target \n    \n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_char != 'a');\n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_short != 10);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_int != 11);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_float != 5.5f);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_double != 10.45);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_enum != VAL1);\n    \n    return errors;\n}\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_defaultmap_on());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_defaultmap_off());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n",
        "error_code": "//===----- test_target_defaultmap.c --------------------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// This test is made up of two functions that both check that the default mapping of \n// scalars to the device is tofrom. The first function test_default_map_on actively \n// specifies default mapping to be tofrom, while the function test_default_map_off\n// implicity specifies default mapping. Both functions initalize scalars on host, and\n// then change the value of the scalars on the device within the target region. The\n// scalar values are checked after target region to ensure they were correctly mapped \n// back to host. The five basic data types in C are used as scalars.\n//\n////===-------------------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\nint test_defaultmap_on() {\n  OMPVV_INFOMSG(\"test_defaultmap_on\");\n\n  int errors = 0;\n\n  // we try with all the scalars\n  char scalar_char = 'a';\n  short scalar_short = 10;\n  int scalar_int = 11;\n  float scalar_float = 5.5f;\n  double scalar_double = 10.45;\n  enum { VAL1 = 1, VAL2, VAL3, VAL4} scalar_enum = VAL1;\n  \n\n  // Map the same array to multiple devices. initialize with device number\n#pragma omp flush defaultmap(tofrom: scalar)\n  {\n    scalar_char = 'b';\n    scalar_short = 20;\n    scalar_int = 33;\n    scalar_float = 6.5f;\n    scalar_double = 20.45;\n    scalar_enum = VAL4;\n  } // end of omp target \n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_char != 'b');\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_short != 20);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_int != 33);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_float != 6.5f);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_double != 20.45);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_enum != VAL4);\n  \n  return errors;\n}\n\nint test_defaultmap_off() {\n  OMPVV_INFOMSG(\"test_defaultmap_off\");\n  \n  int errors = 0;\n  \n    // we try with all the scalars\n    char scalar_char = 'a';\n    short scalar_short = 10;\n    int scalar_int = 11;\n    float scalar_float = 5.5f;\n    double scalar_double = 10.45;\n    enum { VAL1 = 1, VAL2, VAL3, VAL4} scalar_enum = VAL1;\n    \n    // Map the same array to multiple devices. initialize with device number\n  #pragma omp target \n    {\n      scalar_char = 'b';\n      scalar_short = 20;\n      scalar_int = 33;\n      scalar_float = 6.5f;\n      scalar_double = 20.45;\n      scalar_enum = VAL4;\n    } // end of omp target \n    \n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_char != 'a');\n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_short != 10);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_int != 11);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_float != 5.5f);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_double != 10.45);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_enum != VAL1);\n    \n    return errors;\n}\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_defaultmap_on());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_defaultmap_off());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_parallel_reduction.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp map\" at position 567",
        "issue_id": 0,
        "original_code": "//===------test_target_reduction.c--------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Tests the target directive with parallel for + reduction + device clauses\n//\n//===------------------------------------------------------------------------===//\n#include <stdio.h>\n#include \"omp.h\"\n#include \"ompvv.h\"\n\n#define N 1024*32\n\nint Runtst(int gpu) {\n  int *A = (int *) malloc(sizeof(int) * N);\n  int *B = (int *) malloc(sizeof(int) * N);\n  int errors = 0;\n  for (int i = 0; i < N; ++i) {\n    A[i] = i;\n    B[i] = i;\n  }\n  int TotSum = 0;\n#pragma omp target data map(tofrom: A[0:N], B[0:N], TotSum) device(gpu)\n  {\n#pragma omp target parallel for reduction(+:TotSum) device(gpu)\n    for (int i = 0; i < N; ++i) {\n      TotSum = TotSum + A[i] + B[i];\n    }\n  }\n\n  if (TotSum != (N - 1) * (N)) {\n    errors++;\n  }\n  free(A);\n  free(B);\n  return errors;\n}\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int TotGpus = omp_get_num_devices();\n  int errors = 0;\n  for (int gpu = 0; gpu < TotGpus; ++gpu) {\n    errors = 0;\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (Runtst(gpu) != 0));\n  }\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===------test_target_reduction.c--------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Tests the target directive with parallel for + reduction + device clauses\n//\n//===------------------------------------------------------------------------===//\n#include <stdio.h>\n#include \"omp.h\"\n#include \"ompvv.h\"\n\n#define N 1024*32\n\nint Runtst(int gpu) {\n  int *A = (int *) malloc(sizeof(int) * N);\n  int *B = (int *) malloc(sizeof(int) * N);\n  int errors = 0;\n  for (int i = 0; i < N; ++i) {\n    A[i] = i;\n    B[i] = i;\n  }\n  int TotSum = 0;\n#pragma omp map data map(tofrom: A[0:N], B[0:N], TotSum) device(gpu)\n  {\n#pragma omp target parallel for reduction(+:TotSum) device(gpu)\n    for (int i = 0; i < N; ++i) {\n      TotSum = TotSum + A[i] + B[i];\n    }\n  }\n\n  if (TotSum != (N - 1) * (N)) {\n    errors++;\n  }\n  free(A);\n  free(B);\n  return errors;\n}\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int TotGpus = omp_get_num_devices();\n  int errors = 0;\n  for (int gpu = 0; gpu < TotGpus; ++gpu) {\n    errors = 0;\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (Runtst(gpu) != 0));\n  }\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_teams_distribute_default_none.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp teams\" with directive \"#pragma omp for\" at position 819",
        "issue_id": 0,
        "original_code": "//===--- test_teams_distribute_default_none.c----------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This tests uses the default(none) clause on a teams directive.\n// The test aims to validate that all values will not have default data sharing\n// attributes.\n//\n////===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 128\n\nint main() {\n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int x;\n  int privatized;\n  int num_teams;\n  int share = 0;\n  int errors = 0;\n\n  OMPVV_WARNING(\"Test only uses default(none) clause and does not guarantee that the default(none) is enforced.\");\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    c[x] = 2*x;\n    d[x] = 0;\n  }\n\n#pragma omp teams distribute num_teams(OMPVV_NUM_TEAMS_DEVICE) default(none) shared(a, b, c, d, num_teams) private(privatized)\n    for (int x = 0; x < N; ++x) {\n      privatized = 0;\n      for (int y = 0; y < a[x] + b[x]; ++y) {\n        privatized++;\n      }\n      d[x] = c[x] * privatized;\n      if (omp_get_team_num() == 0) {\n        num_teams = omp_get_num_teams();\n      }\n    }\n\n  OMPVV_WARNING_IF(num_teams == 1, \"The number of teams was 1. This is not a specification error but we could not guarantee parallelism of teams.\");\n\n  for (x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (d[x] != (1 + x)*2*x));\n    if (d[x] != (1 + x)*2*x) {\n      break;\n    }\n  }\n\n#pragma omp teams distribute num_teams(OMPVV_NUM_TEAMS_DEVICE) default(none) shared(share, b, num_teams)\n    for (int x = 0; x < N; ++x) {\n#pragma omp atomic update\n      share = share + b[x];\n      if (omp_get_team_num() == 0) {\n        num_teams = omp_get_num_teams();\n      }\n    }\n\n  OMPVV_WARNING_IF(num_teams == 1, \"The number of teams was 1. This is not a specification error but we could not guarantee parallelism of teams.\");\n\n  for (int x = 0; x < N; ++x) {\n    share = share - x;\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (share != 0));\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_teams_distribute_default_none.c----------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This tests uses the default(none) clause on a teams directive.\n// The test aims to validate that all values will not have default data sharing\n// attributes.\n//\n////===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 128\n\nint main() {\n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int x;\n  int privatized;\n  int num_teams;\n  int share = 0;\n  int errors = 0;\n\n  OMPVV_WARNING(\"Test only uses default(none) clause and does not guarantee that the default(none) is enforced.\");\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    c[x] = 2*x;\n    d[x] = 0;\n  }\n\n#pragma omp for distribute num_teams(OMPVV_NUM_TEAMS_DEVICE) default(none) shared(a, b, c, d, num_teams) private(privatized)\n    for (int x = 0; x < N; ++x) {\n      privatized = 0;\n      for (int y = 0; y < a[x] + b[x]; ++y) {\n        privatized++;\n      }\n      d[x] = c[x] * privatized;\n      if (omp_get_team_num() == 0) {\n        num_teams = omp_get_num_teams();\n      }\n    }\n\n  OMPVV_WARNING_IF(num_teams == 1, \"The number of teams was 1. This is not a specification error but we could not guarantee parallelism of teams.\");\n\n  for (x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (d[x] != (1 + x)*2*x));\n    if (d[x] != (1 + x)*2*x) {\n      break;\n    }\n  }\n\n#pragma omp teams distribute num_teams(OMPVV_NUM_TEAMS_DEVICE) default(none) shared(share, b, num_teams)\n    for (int x = 0; x < N; ++x) {\n#pragma omp atomic update\n      share = share + b[x];\n      if (omp_get_team_num() == 0) {\n        num_teams = omp_get_num_teams();\n      }\n    }\n\n  OMPVV_WARNING_IF(num_teams == 1, \"The number of teams was 1. This is not a specification error but we could not guarantee parallelism of teams.\");\n\n  for (int x = 0; x < N; ++x) {\n    share = share - x;\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (share != 0));\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_dispatch_is_device_ptr.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 834",
        "issue_id": 2,
        "original_code": "//===---- test_dispatch_is_device_ptr.c -----------------------------------------===//\n// \n// OpenMP API Version 5.1\n//\n// Uses dispatch construct as context for variant directive. Uses is_device_ptr\n// clause to ensure that the list item is in the device region.\n//\n// Inspired by \"OpenMP 5.1 Features: The Dispatch Construct\" video:\n// https://www.youtube.com/watch?v=ruugaX95gIs\n// \n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include \"ompvv.h\"\n#include <stdbool.h>\n\n#define N 1024\n\nint errors;\nint i = 0;\nint *arr;\n\nvoid add_dev(int *arr);\n\n#pragma omp declare variant(add_dev) match(construct={dispatch}) \nvoid add(int *arr){\n    #pragma omp target parallel for is_device_ptr(arr)\n    for (int i = 0; i < N; i++){ // Base function adds 2 to array values\n        arr[i] = arr[i]+2;\n    }\n}\n\nvoid add_dev(int *arr){\n    #pragma omp target is_device_ptr(arr)\n    for (int i = 0; i < N; i++){\n        arr[i] = arr[i]+4; // Variant function adds 4 to array values\n    }\n}\n\nint test_wrapper() { \n    int t;\n    int called_add = 0;\n    errors = 0;\n    t = omp_get_default_device();\n    arr = (int *)omp_target_alloc( sizeof(int)*N, t);\n    if(arr == NULL){\n        OMPVV_ERROR(\"Can't properly create device pointer\");\n        return 1;\n    }\n    #pragma omp target is_device_ptr(arr)\n    {\n        #pragma omp parallel for\n        for(int i = 0; i < N; i++){\n            arr[i] = i;\n        }\n    }\n    #pragma omp dispatch is_device_ptr(arr)\n        add(arr);\n    \n    #pragma omp target map(tofrom: errors, called_add) is_device_ptr(arr)\n    for(i = 0; i < N; i++){\n        OMPVV_TEST_AND_SET(errors, (arr[i] != i+4) && (arr[i] != i+2) );\n        called_add += arr[i] == i + 2;\n    }\n    // Note that it is implementation de\ufb01ned in OpenMP 5.1 (and 5.2) whether\n    // the dispatch construct is added to the construct set. Only since\n    // OpenMP Technical Review 12 (TR12; second 6.0 preview) it must be added;\n    // in that case, 'add_dev' is called and called_add == 0.\n    OMPVV_INFOMSG_IF(errors > 0 || called_add > 0,\n                   \"Dispatch is either not working or was not considered\"\n                   \" by the implementation as part of the context selector.\");\n    omp_target_free (arr, t);\n    return errors;\n}\n\nint main () {\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_wrapper());\n   OMPVV_REPORT_AND_RETURN(errors);\n}  \n",
        "error_code": "//===---- test_dispatch_is_device_ptr.c -----------------------------------------===//\n// \n// OpenMP API Version 5.1\n//\n// Uses dispatch construct as context for variant directive. Uses is_device_ptr\n// clause to ensure that the list item is in the device region.\n//\n// Inspired by \"OpenMP 5.1 Features: The Dispatch Construct\" video:\n// https://www.youtube.com/watch?v=ruugaX95gIs\n// \n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include \"ompvv.h\"\n#include <stdbool.h>\n\n#define N 1024\n\nint errors;\nint i = 0;\nint *arr;\n\nvoid add_dev(int *arr);\n\n#pragma omp declare variant(add_dev) match(construct={dispatch}) \nvoid add(int *arr){\n    #pragma omp target parallel for is_device_ptr(arr)\n    for (int i = 0; i < N;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1; i++){ // Base function adds 2 to array values\n        arr[i] = arr[i]+2;\n    }\n}\n\nvoid add_dev(int *arr){\n    #pragma omp target is_device_ptr(arr)\n    for (int i = 0; i < N; i++){\n        arr[i] = arr[i]+4; // Variant function adds 4 to array values\n    }\n}\n\nint test_wrapper() { \n    int t;\n    int called_add = 0;\n    errors = 0;\n    t = omp_get_default_device();\n    arr = (int *)omp_target_alloc( sizeof(int)*N, t);\n    if(arr == NULL){\n        OMPVV_ERROR(\"Can't properly create device pointer\");\n        return 1;\n    }\n    #pragma omp target is_device_ptr(arr)\n    {\n        #pragma omp parallel for\n        for(int i = 0; i < N; i++){\n            arr[i] = i;\n        }\n    }\n    #pragma omp dispatch is_device_ptr(arr)\n        add(arr);\n    \n    #pragma omp target map(tofrom: errors, called_add) is_device_ptr(arr)\n    for(i = 0; i < N; i++){\n        OMPVV_TEST_AND_SET(errors, (arr[i] != i+4) && (arr[i] != i+2) );\n        called_add += arr[i] == i + 2;\n    }\n    // Note that it is implementation de\ufb01ned in OpenMP 5.1 (and 5.2) whether\n    // the dispatch construct is added to the construct set. Only since\n    // OpenMP Technical Review 12 (TR12; second 6.0 preview) it must be added;\n    // in that case, 'add_dev' is called and called_add == 0.\n    OMPVV_INFOMSG_IF(errors > 0 || called_add > 0,\n                   \"Dispatch is either not working or was not considered\"\n                   \" by the implementation as part of the context selector.\");\n    omp_target_free (arr, t);\n    return errors;\n}\n\nint main () {\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_wrapper());\n   OMPVV_REPORT_AND_RETURN(errors);\n}  \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_taskloop_grainsize_strict.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp parallel\" with directive \"#pragma omp teams\" at position 834",
        "issue_id": 0,
        "original_code": "//===--- test_strict_grainsize.c -----------------------------------------------===//\n//\n//  OpenMP API Version 5.1 Aug 2021\n//\n// This test checks the behavior of taskloop's clause grainsize, when the strict \n// modifier is present. The grainsize strict expressions specifies the exact number of \n// logical iterations which should be performed per task, except for the sequentially\n// last iteration which may have fewer than the specified iterations. \n////===--------------------------------------------------------------------------------------===//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint errors;\n\nint test_strict_grainsize() {\n  int arr[N];\n  int sum = 0;\n  int parallel_sum = 0; \n  for (int i=0; i<N; i++){\n        arr[i] = 1;\n        sum += arr[i];\n }\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST) \n#pragma omp single\n#pragma omp taskloop reduction(+: parallel_sum) grainsize(strict:1000)\n  for (int i = 0; i < N; i++) {\n  \tparallel_sum += arr[i];\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, parallel_sum != sum);\n  OMPVV_INFOMSG_IF(sum == 0, \"Array was not initialized.\");\n  OMPVV_INFOMSG_IF(parallel_sum == 0, \"Data sharing of parallel_sum was wrong.\");\n  OMPVV_INFOMSG_IF(parallel_sum == sum, \"Test passed.\");\n  OMPVV_INFOMSG_IF(parallel_sum != sum, \"Test did not pass.\");\n  return errors;\n}\n\nint main() {\n  errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_strict_grainsize() != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n",
        "error_code": "//===--- test_strict_grainsize.c -----------------------------------------------===//\n//\n//  OpenMP API Version 5.1 Aug 2021\n//\n// This test checks the behavior of taskloop's clause grainsize, when the strict \n// modifier is present. The grainsize strict expressions specifies the exact number of \n// logical iterations which should be performed per task, except for the sequentially\n// last iteration which may have fewer than the specified iterations. \n////===--------------------------------------------------------------------------------------===//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint errors;\n\nint test_strict_grainsize() {\n  int arr[N];\n  int sum = 0;\n  int parallel_sum = 0; \n  for (int i=0; i<N; i++){\n        arr[i] = 1;\n        sum += arr[i];\n }\n#pragma omp teams num_threads(OMPVV_NUM_THREADS_HOST) \n#pragma omp single\n#pragma omp taskloop reduction(+: parallel_sum) grainsize(strict:1000)\n  for (int i = 0; i < N; i++) {\n  \tparallel_sum += arr[i];\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, parallel_sum != sum);\n  OMPVV_INFOMSG_IF(sum == 0, \"Array was not initialized.\");\n  OMPVV_INFOMSG_IF(parallel_sum == 0, \"Data sharing of parallel_sum was wrong.\");\n  OMPVV_INFOMSG_IF(parallel_sum == sum, \"Test passed.\");\n  OMPVV_INFOMSG_IF(parallel_sum != sum, \"Test did not pass.\");\n  return errors;\n}\n\nint main() {\n  errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_strict_grainsize() != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_parallel_for_private.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 1986",
        "issue_id": 2,
        "original_code": "//===---- test_target_teams_distribute_parallel_for_private.c - combined consutrct -===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test check for a private variable within a pragma omp target teams distribute\n// parallel for. We use a private variable within a for loop and asign it every iteration\n// hoping that we won't get into data races. We do this multiple times to improve\n// test\n// we assign a large number of threads and teams to try to increase parallelism and\n// contention on the privatized variable\n//\n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define N 1024\n\nint test_target_teams_distribute_parallel_for_private() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_devices\");\n\n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int privatized = 10;\n  int num_teams[N];\n  int num_threads[N];\n  int errors = 0;\n  int i, j;\n\n  // array initialization\n  for (i = 0; i < N; i++) {\n    a[i] = 1;\n    b[i] = i;\n    c[i] = 2*i;\n    d[i] = 0;\n    num_teams[i] = -1;\n    num_threads[i] = -1;\n  }\n\n  // check multiple sizes.\n#pragma omp target data map(to: a[0:N], b[0:N], c[0:N]) map(from: d[0:N])\n  {\n#pragma omp target teams distribute parallel for private(privatized, i) num_threads(OMPVV_NUM_THREADS_DEVICE) num_teams(OMPVV_NUM_TEAMS_DEVICE)\n    for (j = 0; j < N; ++j) {\n      num_teams[j] = omp_get_num_teams();\n      num_threads[j] = omp_get_num_threads();\n\n      privatized = 0;\n      for (i = 0; i < a[j] + b[j]; ++i) {\n        privatized++;\n      }\n      d[j] = c[j] * privatized;\n    }\n  }\n\n  int warning_threads = 0;\n  int warning_teams = 0;\n\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, d[i] != (1 + i)*2*i);\n    warning_teams += num_teams[i];\n    warning_threads += num_threads[i];\n  }\n\n  OMPVV_WARNING_IF(warning_teams == N, \"There was a single team across the target region. Privatization cannot be tested at the teams level\");\n  OMPVV_WARNING_IF(warning_threads == N, \"All the parallel regions ran with a single thread. Privatization cannot be tested at the thread level\");\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_private());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_teams_distribute_parallel_for_private.c - combined consutrct -===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test check for a private variable within a pragma omp target teams distribute\n// parallel for. We use a private variable within a for loop and asign it every iteration\n// hoping that we won't get into data races. We do this multiple times to improve\n// test\n// we assign a large number of threads and teams to try to increase parallelism and\n// contention on the privatized variable\n//\n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define N 1024\n\nint test_target_teams_distribute_parallel_for_private() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_devices\");\n\n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int privatized = 10;\n  int num_teams[N];\n  int num_threads[N];\n  int errors = 0;\n  int i, j;\n\n  // array initialization\n  for (i = 0; i < N; i++) {\n    a[i] = 1;\n    b[i] = i;\n    c[i] = 2*i;\n    d[i] = 0;\n    num_teams[i] = -1;\n    num_threads[i] = -1;\n  }\n\n  // check multiple sizes.\n#pragma omp target data map(to: a[0:N], b[0:N], c[0:N]) map(from: d[0:N])\n  {\n#pragma omp target teams distribute parallel for private(privatized, i) num_threads(OMPVV_NUM_THREADS_DEVICE) num_teams(OMPVV_NUM_TEAMS_DEVICE)\n    for (j = 0; j < N; ++j) {\n      num_teams[j] = omp_get_num_teams();\n      num_threads[j] = omp_get_num_threads();\n\n      privatized = 0;\n      for (i = 0; i < a[j] + b[j]; ++i) {\n        privatized++;\n      }\n      d[j] = c[j] * privatized;\n    }\n  }\n\n  int warning_threads = 0;\n  int warning_teams = 0;\n\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, d[i] != (1 + i)*2*i);\n    warning_teams += num_teams[i];\n    warning_threads += num_threads[i];\n  }\n\n  OMPVV_WARNING_IF(warning_teams == N, \"There was a single team across the target region. Privatization cannot be tested at the teams level\");yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n  OMPVV_WARNING_IF(warning_threads == N, \"All the parallel regions ran with a single thread. Privatization cannot be tested at the thread level\");\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_private());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_requires_unified_address.c",
        "correct": "n",
        "issue": "Removed memory allocation line \"omp_target_alloc(N * sizeof(int), omp_get_default_device());\" at position 509",
        "issue_id": 0,
        "original_code": "//===---test_requires_unified_address.c -------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n// \n// This test checks for support of unified_address clause on the requires\n// directive.\n//\n/////===---------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp requires unified_address\n\nint unified_address() {\n\n   int errors = 0;\n   int i;\n   int *mem_ptr = (int *)omp_target_alloc(N * sizeof(int), omp_get_default_device());\n   int *mem_ptr2 = NULL;\n\n   OMPVV_ERROR_IF(mem_ptr == NULL, \"Target memory was not properly allocated\");\n   if (mem_ptr == NULL)\n     return ++errors;\n   \n   #pragma omp target map(from:mem_ptr2) defaultmap(firstprivate) /* is_device_ptr(mem_ptr) - which is optional.  */\n   {\n      for (i = 0; i < N; i++) {\n         mem_ptr[i] = i + 1;\n      }\n      mem_ptr2 = &mem_ptr[0] + 5;\n   }\n\n   /* Pointer arithmetic is permitted; assumes sizeof(int) is the same.  */\n   mem_ptr2 += 4;\n   \n   #pragma omp target map(tofrom:errors) defaultmap(to) /* is_device_ptr(mem_ptr2) - which is optional.  */\n   for (i = 0; i < N; i++) {\n      if(mem_ptr2[i - 5 - 4] != i + 1) {\n         errors++;\n      }  \n   }\n\n   int *mem_ptr3 = (int*)malloc(N * sizeof(int));\n   OMPVV_ERROR_IF(mem_ptr3 == NULL, \"Host memory was not properly allocated\");\n   if (mem_ptr3 == NULL)\n     return ++errors;\n\n   if (0 == omp_target_memcpy(mem_ptr3, mem_ptr, N * sizeof(int), 0, 0,\n                              omp_get_initial_device(), omp_get_default_device())) {\n     for (i = 0; i < N; i++) {\n       if (mem_ptr3[i] != i + 1) {\n         errors++;\n       }\n     }\n   } else {\n     OMPVV_ERROR(\"omp_target_memcpy failed\");\n     errors++;\n   }\n\n   free (mem_ptr3);\n   omp_target_free (mem_ptr, omp_get_default_device());\n\n   return errors;\n}\n\nint main() {\n  \n  int errors = 0;\n\n  OMPVV_TEST_OFFLOADING;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, unified_address());\n  OMPVV_REPORT_AND_RETURN(errors);\n\n}  \n",
        "error_code": "//===---test_requires_unified_address.c -------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n// \n// This test checks for support of unified_address clause on the requires\n// directive.\n//\n/////===---------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp requires unified_address\n\nint unified_address() {\n\n   int errors = 0;\n   int i;\n   int *mem_ptr = (int *)\n   int *mem_ptr2 = NULL;\n\n   OMPVV_ERROR_IF(mem_ptr == NULL, \"Target memory was not properly allocated\");\n   if (mem_ptr == NULL)\n     return ++errors;\n   \n   #pragma omp target map(from:mem_ptr2) defaultmap(firstprivate) /* is_device_ptr(mem_ptr) - which is optional.  */\n   {\n      for (i = 0; i < N; i++) {\n         mem_ptr[i] = i + 1;\n      }\n      mem_ptr2 = &mem_ptr[0] + 5;\n   }\n\n   /* Pointer arithmetic is permitted; assumes sizeof(int) is the same.  */\n   mem_ptr2 += 4;\n   \n   #pragma omp target map(tofrom:errors) defaultmap(to) /* is_device_ptr(mem_ptr2) - which is optional.  */\n   for (i = 0; i < N; i++) {\n      if(mem_ptr2[i - 5 - 4] != i + 1) {\n         errors++;\n      }  \n   }\n\n   int *mem_ptr3 = (int*)malloc(N * sizeof(int));\n   OMPVV_ERROR_IF(mem_ptr3 == NULL, \"Host memory was not properly allocated\");\n   if (mem_ptr3 == NULL)\n     return ++errors;\n\n   if (0 == omp_target_memcpy(mem_ptr3, mem_ptr, N * sizeof(int), 0, 0,\n                              omp_get_initial_device(), omp_get_default_device())) {\n     for (i = 0; i < N; i++) {\n       if (mem_ptr3[i] != i + 1) {\n         errors++;\n       }\n     }\n   } else {\n     OMPVV_ERROR(\"omp_target_memcpy failed\");\n     errors++;\n   }\n\n   free (mem_ptr3);\n   omp_target_free (mem_ptr, omp_get_default_device());\n\n   return errors;\n}\n\nint main() {\n  \n  int errors = 0;\n\n  OMPVV_TEST_OFFLOADING;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, unified_address());\n  OMPVV_REPORT_AND_RETURN(errors);\n\n}  \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_parallel_for_order_concurrent.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp parallel\" with directive \"#pragma omp target\" at position 904",
        "issue_id": 0,
        "original_code": "//===--- test_parallel_for_order_concurrent.c -------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the parallel for directive with the order(concurrent)\n// The test performs simple operations on an int array which are then\n// checked for correctness. The specification indicates only that iterations\n// in the loop may be executed concurrently, so no particular order or lack\n// thereof can be required by this test.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_parallel_for_order_concurrent() {\n  OMPVV_INFOMSG(\"test_parallel_for_order_concurrent\");\n  int errors = 0;\n  int x[N];\n  int y[N];\n  int z[N];\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 1;\n    y[i] = i + 1;\n    z[i] = 2*(i + 1);\n  }\n\n#pragma omp parallel for order(concurrent) num_threads(OMPVV_NUM_THREADS_HOST) shared(x, y, z)\n  for (int i = 0; i < N; i++) {\n    x[i] += y[i]*z[i];\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != 1 + (y[i]*z[i]));\n  }\n\n  return errors;\n}\n\n\nint main() {\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_parallel_for_order_concurrent());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_parallel_for_order_concurrent.c -------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the parallel for directive with the order(concurrent)\n// The test performs simple operations on an int array which are then\n// checked for correctness. The specification indicates only that iterations\n// in the loop may be executed concurrently, so no particular order or lack\n// thereof can be required by this test.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_parallel_for_order_concurrent() {\n  OMPVV_INFOMSG(\"test_parallel_for_order_concurrent\");\n  int errors = 0;\n  int x[N];\n  int y[N];\n  int z[N];\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 1;\n    y[i] = i + 1;\n    z[i] = 2*(i + 1);\n  }\n\n#pragma omp target for order(concurrent) num_threads(OMPVV_NUM_THREADS_HOST) shared(x, y, z)\n  for (int i = 0; i < N; i++) {\n    x[i] += y[i]*z[i];\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != 1 + (y[i]*z[i]));\n  }\n\n  return errors;\n}\n\n\nint main() {\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_parallel_for_order_concurrent());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_enter_data_classes_inheritance.cpp",
        "correct": "n",
        "issue": "Removed opening bracket at position 5086",
        "issue_id": 1,
        "original_code": "//===---- test_target_enter_data_classes_inheritance.c - enter data and classes-===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n//\n// This test checks for interoperability between C++ classes and device \n// offloading in the presence of inheritance and templates, and when using \n// target enter and exit data clauses. It considers that 4.5 does not support\n// mapping of attributes directly, as the implicit use of the this-> pointer when \n// using attributes inside the target region is restrictive.\n//\n// The description of the map clause says that the map clause receives a list item:\n//\n// Section 2.15.5.1, page 216, line 17\n//\n// The syntax of the map clause is as follows:\n// map([ [map-type-modifier[,]] map-type : ] list)\n// And the definition of list item is\n//\n// Section 2.1, page 27, line 20\n//\n// A list item is a variable or array section. An extended list item \n// is a list item or a function name.\n//\n// This test creates a base class that, during construction, it maps an \n// attribute through helper \n// variables that remove the direct use to the attributes. And during \n// destruction of the \n//\n// object it maps the data back to the devices. Additionally, there is a modifier \n// method that uses values from the class indirectly through the use of helper references\n// finally there is a synchronization  clause that will obtain the values on demand\n//===----------------------------------------------------------------------------------===//\n//\n//\n\n#include <iostream>\n#include <omp.h>\n#include <cassert>\n#include \"ompvv.h\"\n#include <cmath>\n\n#define N 1000\n\ntemplate<typename T>\nclass Mapper {\nprivate:\n  T* ptr;\n  bool not_mapped;\npublic:\n  Mapper (T* p) : ptr(p) {\n    not_mapped = !omp_target_is_present(ptr, omp_get_default_device());\n    T* solutionPtr = ptr;\n    // maps if target is not present\n#pragma omp target enter data map(to:solutionPtr[0:1]) if(not_mapped)\n  }\n  ~Mapper() {\n    T* solutionPtr = ptr;\n    // unmaps iff this mapper mapped the target\n#pragma omp target exit data map(delete: solutionPtr[0:1]) if(not_mapped)\n    ptr = NULL;\n  }\n};\n\nclass B : public Mapper<B> {\nprotected:\n  int n;\nprivate:\n  double* x;\n  double sumB; \n\npublic:\n  B(int nn) : Mapper<B>(this), n(nn) {\n    x = new double[n];\n    std::fill(x, x+n, 0);\n    // This is a work around to avoid referring to \n    // the class members in the map() clause. see\n    // description\n    double* solutionX = x;\n    int &cpy_n = n;\n#pragma omp target enter data map(to:solutionX[0:n], cpy_n)\n  }\n\n  void modifyB() {\n    double * cpy_x = x; \n    int &cpy_n = n;\n    double &cpy_sumB = sumB;\n#pragma omp target defaultmap(tofrom: scalar)\n    {\n      sumB = 0.0;\n      for (int i = 0; i < cpy_n; ++i) {\n        cpy_x[i] += 1.0;\n        sumB += cpy_x[i];\n      }\n    } \n  }\n\n  void getValuesB(double& b_sum, double* b_array) {\n    double * cpy_x = x;\n    int &cpy_n = n;\n    double &cpy_sum = sumB;\n#pragma omp target defaultmap(tofrom: scalar) map(from: b_array[0:n])\n    {\n      b_sum = cpy_sum;\n      for (int i = 0; i < cpy_n; i++)\n        b_array[i] = cpy_x[i];\n    }\n  }\n\n};\n\nclass A : public Mapper<A>, public B {\nprivate:\n  int sumA; \n  int* y;\n\npublic:\n  A(int s) : Mapper<A>(this), B(s){ \n    y = new int[n];\n    std::fill(y, y+n, 0);\n    int *solutionY = y;\n    int &cpy_n = n;\n    #pragma omp target update to(cpy_n)\n    #pragma omp target enter data map(to:solutionY[0:n])\n  }\n\n  void modifyA() {\n    modifyB();\n    int *cpy_y = y;\n    int &cpy_n = n;\n    int &cpy_sumA = sumA;\n\n#pragma omp target defaultmap(tofrom: scalar)\n    {\n      cpy_sumA = 0;\n      for (int i = 0; i < cpy_n; ++i) {\n        cpy_y[i] += 1;\n        cpy_sumA += cpy_y[i];\n      }\n    }\n  }\n\n  void getValuesA(int &a_sum, int* a_array, double& b_sum, double* b_array) {\n    getValuesB(b_sum, b_array);\n    int* cpy_y = y;\n    int &cpy_n = n;\n    int &cpy_sumA = sumA;\n#pragma omp target defaultmap(tofrom:scalar) map(tofrom: a_array[0:n])\n    {\n      a_sum = cpy_sumA;\n      for (int i = 0; i < cpy_n; i++) {\n        a_array[i] = cpy_y[i];\n      }\n    }\n  }\n  \n};\n\nint test_complex_class() {\n  OMPVV_INFOMSG(\"test_complex_class\");\n\n  int sumY = 0, errors = 0, check_sumY = 0;\n  double sumX = 0.0, check_sumX = 0.0;\n  double * h_array_x = new double[N];\n  int * h_array_y = new int[N];\n\n  // allocation on the device\n  A *obj = new A(N);\n\n  // Each modify adds 1 to the array that is already mappend in the constructor\n  obj->modifyA();\n  obj->modifyA();\n  obj->modifyA();\n  obj->getValuesA(sumY, h_array_y, sumX, h_array_x);\n\n  // checking results\n  for (int i = 0; i < N; ++i) {\n    check_sumY += h_array_y[i];\n    check_sumX += h_array_x[i];\n  }\n\n  delete obj;\n  delete[] h_array_x;\n  delete[] h_array_y;\n  \n  OMPVV_TEST_AND_SET(errors, check_sumY != 3*N);\n  OMPVV_TEST_AND_SET(errors, sumY != 3*N);\n  OMPVV_TEST_AND_SET(errors, std::abs(check_sumX - 3*N) > 0.00001);\n  OMPVV_TEST_AND_SET(errors, std::abs(sumX - 3*N) > 0.00001);\n  OMPVV_ERROR_IF(errors != 0, \"N = %d, sumX = %f, check_sumX = %f, sumY=%d, check_sumY = %d\", N, sumX, check_sumX, sumY, check_sumY);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_complex_class());\n  \n  OMPVV_REPORT_AND_RETURN(errors)\n}\n\n",
        "error_code": "//===---- test_target_enter_data_classes_inheritance.c - enter data and classes-===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n//\n// This test checks for interoperability between C++ classes and device \n// offloading in the presence of inheritance and templates, and when using \n// target enter and exit data clauses. It considers that 4.5 does not support\n// mapping of attributes directly, as the implicit use of the this-> pointer when \n// using attributes inside the target region is restrictive.\n//\n// The description of the map clause says that the map clause receives a list item:\n//\n// Section 2.15.5.1, page 216, line 17\n//\n// The syntax of the map clause is as follows:\n// map([ [map-type-modifier[,]] map-type : ] list)\n// And the definition of list item is\n//\n// Section 2.1, page 27, line 20\n//\n// A list item is a variable or array section. An extended list item \n// is a list item or a function name.\n//\n// This test creates a base class that, during construction, it maps an \n// attribute through helper \n// variables that remove the direct use to the attributes. And during \n// destruction of the \n//\n// object it maps the data back to the devices. Additionally, there is a modifier \n// method that uses values from the class indirectly through the use of helper references\n// finally there is a synchronization  clause that will obtain the values on demand\n//===----------------------------------------------------------------------------------===//\n//\n//\n\n#include <iostream>\n#include <omp.h>\n#include <cassert>\n#include \"ompvv.h\"\n#include <cmath>\n\n#define N 1000\n\ntemplate<typename T>\nclass Mapper {\nprivate:\n  T* ptr;\n  bool not_mapped;\npublic:\n  Mapper (T* p) : ptr(p) {\n    not_mapped = !omp_target_is_present(ptr, omp_get_default_device());\n    T* solutionPtr = ptr;\n    // maps if target is not present\n#pragma omp target enter data map(to:solutionPtr[0:1]) if(not_mapped)\n  }\n  ~Mapper() {\n    T* solutionPtr = ptr;\n    // unmaps iff this mapper mapped the target\n#pragma omp target exit data map(delete: solutionPtr[0:1]) if(not_mapped)\n    ptr = NULL;\n  }\n};\n\nclass B : public Mapper<B> {\nprotected:\n  int n;\nprivate:\n  double* x;\n  double sumB; \n\npublic:\n  B(int nn) : Mapper<B>(this), n(nn) {\n    x = new double[n];\n    std::fill(x, x+n, 0);\n    // This is a work around to avoid referring to \n    // the class members in the map() clause. see\n    // description\n    double* solutionX = x;\n    int &cpy_n = n;\n#pragma omp target enter data map(to:solutionX[0:n], cpy_n)\n  }\n\n  void modifyB() {\n    double * cpy_x = x; \n    int &cpy_n = n;\n    double &cpy_sumB = sumB;\n#pragma omp target defaultmap(tofrom: scalar)\n    {\n      sumB = 0.0;\n      for (int i = 0; i < cpy_n; ++i) {\n        cpy_x[i] += 1.0;\n        sumB += cpy_x[i];\n      }\n    } \n  }\n\n  void getValuesB(double& b_sum, double* b_array) {\n    double * cpy_x = x;\n    int &cpy_n = n;\n    double &cpy_sum = sumB;\n#pragma omp target defaultmap(tofrom: scalar) map(from: b_array[0:n])\n    {\n      b_sum = cpy_sum;\n      for (int i = 0; i < cpy_n; i++)\n        b_array[i] = cpy_x[i];\n    }\n  }\n\n};\n\nclass A : public Mapper<A>, public B {\nprivate:\n  int sumA; \n  int* y;\n\npublic:\n  A(int s) : Mapper<A>(this), B(s){ \n    y = new int[n];\n    std::fill(y, y+n, 0);\n    int *solutionY = y;\n    int &cpy_n = n;\n    #pragma omp target update to(cpy_n)\n    #pragma omp target enter data map(to:solutionY[0:n])\n  }\n\n  void modifyA() {\n    modifyB();\n    int *cpy_y = y;\n    int &cpy_n = n;\n    int &cpy_sumA = sumA;\n\n#pragma omp target defaultmap(tofrom: scalar)\n    {\n      cpy_sumA = 0;\n      for (int i = 0; i < cpy_n; ++i) {\n        cpy_y[i] += 1;\n        cpy_sumA += cpy_y[i];\n      }\n    }\n  }\n\n  void getValuesA(int &a_sum, int* a_array, double& b_sum, double* b_array) {\n    getValuesB(b_sum, b_array);\n    int* cpy_y = y;\n    int &cpy_n = n;\n    int &cpy_sumA = sumA;\n#pragma omp target defaultmap(tofrom:scalar) map(tofrom: a_array[0:n])\n    {\n      a_sum = cpy_sumA;\n      for (int i = 0; i < cpy_n; i++) {\n        a_array[i] = cpy_y[i];\n      }\n    }\n  }\n  \n};\n\nint test_complex_class() {\n  OMPVV_INFOMSG(\"test_complex_class\");\n\n  int sumY = 0, errors = 0, check_sumY = 0;\n  double sumX = 0.0, check_sumX = 0.0;\n  double * h_array_x = new double[N];\n  int * h_array_y = new int[N];\n\n  // allocation on the device\n  A *obj = new A(N);\n\n  // Each modify adds 1 to the array that is already mappend in the constructor\n  obj->modifyA();\n  obj->modifyA();\n  obj->modifyA();\n  obj->getValuesA(sumY, h_array_y, sumX, h_array_x);\n\n  // checking results\n  for (int i = 0; i < N; ++i) {\n    check_sumY += h_array_y[i];\n    check_sumX += h_array_x[i];\n  }\n\n  delete obj;\n  delete[] h_array_x;\n  delete[] h_array_y;\n  \n  OMPVV_TEST_AND_SET(errors, check_sumY != 3*N);\n  OMPVV_TEST_AND_SET(errors, sumY != 3*N);\n  OMPVV_TEST_AND_SET(errors, std::abs(check_sumX - 3*N) > 0.00001);\n  OMPVV_TEST_AND_SET(errors, std::abs(sumX - 3*N) > 0.00001);\n  OMPVV_ERROR_IF(errors != 0, \"N = %d, sumX = %f, check_sumX = %f, sumY=%d, check_sumY = %d\", N, sumX, check_sumX, sumY, check_sumY);\n\n  return errors;\n}\n\nint main() \n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_complex_class());\n  \n  OMPVV_REPORT_AND_RETURN(errors)\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/linked_list.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 2907",
        "issue_id": 2,
        "original_code": "//===---linked_list.c--- Test that implements a linked list in the device-----===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n//\n//  This test creates a linked list, maps it to a device \n//  (if available) and modidifies the data on the device. \n//  The data is mapped back and contents are verified \n//  \n//  Last modified by Jose M Monsalve Diaz, December 24, 2019\n//\n////===----------------------------------------------------------------------===//\n\n#include <stdlib.h>\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define SIZE_LIST 10\n\ntypedef struct node {\n  int data;\n  struct node *next;\n} node_t;\n\nvoid map_ll(node_t * head) {\n  OMPVV_INFOMSG(\"Entering map_ll\");\n\n  node_t * temp = head;\n  if (!temp) {\n    OMPVV_ERROR(\"Head was null\");\n    return;\n  }\n\n#pragma omp target enter data map(to:temp[:1])\n#pragma omp target \n  {\n    temp->data += 1;  \n  }\n  while(temp->next) {\n    //version 1\n    // Note: using array dereference syntax, array section on leaf only\n    // Attachment is *not* explicitly guaranteed\n    //#pragma omp target enter data map(to:head[0].next[:1])\n    //version 2\n    //user does an explicit attachment, this is unequivocally correct code\n    //but rather slower and nastier.\n    node_t * cur = temp->next;\n#pragma omp target enter data map(to:cur[:1])\n#pragma omp target \n    {\n      cur->data += 1;\n      temp->next = cur;\n    }\n    temp=temp->next;\n  }\n}\n\nvoid unmap_ll(node_t * head) {\n  OMPVV_INFOMSG(\"Entering unmap_ll\");\n  node_t * temp = head, *tempNext;\n\n  if (!temp) {\n    OMPVV_ERROR(\"Head was null\");\n    return;\n  }\n\n  tempNext = temp->next;\n#pragma omp target exit data map(from:temp[0:1])\n  temp->next = tempNext;\n  while(temp->next) {\n    // Note: only copies back the data element to avoid overwriting next\n    // pointer\n\n    temp = temp->next;\n    // Save broken link\n    tempNext = temp->next;\n#pragma omp target exit data map(from: temp[0:1])\n    // Fix broken link\n    temp->next = tempNext;\n  }\n}\nvoid push(node_t * head, int data) {\n  node_t * current = head;\n  while (current->next != NULL) {\n    current = current->next;\n  }\n\n  // now we can add a new variable\n  current->next = (node_t *) malloc(sizeof(node_t));\n  current->next->data = data;\n  current->next->next = NULL;\n}\n\nvoid display(node_t * head)\n{\n  node_t * temp=head;\n  while(temp!=NULL)\n  {\n    printf(\"%d\\n\",temp->data);\n    temp=temp->next;\n  }\n}\n\nint check(node_t * head)\n{\n  OMPVV_INFOMSG(\"Entering check\");\n  int error = 0, i=0;\n  node_t * temp=head;\n  while(temp!=NULL)\n  {\n    OMPVV_TEST_AND_SET_VERBOSE(error, temp->data != i+1);\n    i++;  \n    temp=temp->next;\n  }\n  return error;\n}\n\nint main() {\n\n  OMPVV_TEST_OFFLOADING;\n  int i, error = 0;\n  node_t * head = NULL;\n  head = (node_t *) malloc(sizeof(node_t));\n  if (head == NULL) {\n    OMPVV_ERROR(\"There was a problem allocating the head node\");\n    return 1;\n  }\n\n  head->data = 0;\n  head->next = NULL;\n\n  for(i=1; i < SIZE_LIST; i++)\n    push(head,i);\n\n  map_ll(head);\n  unmap_ll(head);\n  \n  OMPVV_TEST_AND_SET_VERBOSE(error, check(head));\n\n  while (head) {\n    node_t * next = head->next;\n    free (head);\n    head = next;\n  }\n\n  OMPVV_REPORT_AND_RETURN(error);\n  return 0;\n}\n\n",
        "error_code": "//===---linked_list.c--- Test that implements a linked list in the device-----===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n//\n//  This test creates a linked list, maps it to a device \n//  (if available) and modidifies the data on the device. \n//  The data is mapped back and contents are verified \n//  \n//  Last modified by Jose M Monsalve Diaz, December 24, 2019\n//\n////===----------------------------------------------------------------------===//\n\n#include <stdlib.h>\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define SIZE_LIST 10\n\ntypedef struct node {\n  int data;\n  struct node *next;\n} node_t;\n\nvoid map_ll(node_t * head) {\n  OMPVV_INFOMSG(\"Entering map_ll\");\n\n  node_t * temp = head;\n  if (!temp) {\n    OMPVV_ERROR(\"Head was null\");\n    return;\n  }\n\n#pragma omp target enter data map(to:temp[:1])\n#pragma omp target \n  {\n    temp->data += 1;  \n  }\n  while(temp->next) {\n    //version 1\n    // Note: using array dereference syntax, array section on leaf only\n    // Attachment is *not* explicitly guaranteed\n    //#pragma omp target enter data map(to:head[0].next[:1])\n    //version 2\n    //user does an explicit attachment, this is unequivocally correct code\n    //but rather slower and nastier.\n    node_t * cur = temp->next;\n#pragma omp target enter data map(to:cur[:1])\n#pragma omp target \n    {\n      cur->data += 1;\n      temp->next = cur;\n    }\n    temp=temp->next;\n  }\n}\n\nvoid unmap_ll(node_t * head) {\n  OMPVV_INFOMSG(\"Entering unmap_ll\");\n  node_t * temp = head, *tempNext;\n\n  if (!temp) {\n    OMPVV_ERROR(\"Head was null\");\n    return;\n  }\n\n  tempNext = temp->next;\n#pragma omp target exit data map(from:temp[0:1])\n  temp->next = tempNext;\n  while(temp->next) {\n    // Note: only copies back the data element to avoid overwriting next\n    // pointer\n\n    temp = temp->next;\n    // Save broken link\n    tempNext = temp->next;\n#pragma omp target exit data map(from: temp[0:1])\n    // Fix broken link\n    temp->next = tempNext;\n  }\n}\nvoid push(node_t * head, int data) {\n  node_t * current = head;\n  while (current->next != NULL) {\n    current = current->next;\n  }\n\n  // now we can add a new variable\n  current->next = (node_t *) malloc(sizeof(node_t));\n  current->next->data = data;\n  current->next->next = NULL;\n}\n\nvoid display(node_t * head)\n{\n  node_t * temp=head;\n  while(temp!=NULL)\n  {\n    printf(\"%d\\n\",temp->data);\n    temp=temp->next;\n  }\n}\n\nint check(node_t * head)\n{\n  OMPVV_INFOMSG(\"Entering check\");\n  int error = 0, i=0;\n  node_t * temp=head;\n  while(temp!=NULL)\n  {\n    OMPVV_TEST_AND_SET_VERBOSE(error, temp->data != i+1);\n    i++;  \n    temp=temp->next;\n  }\n  return error;\n}\n\nint main() {\n\n  OMPVV_TEST_OFFLOADING;\n  int i, error = 0;\n  node_t * head = NULL;\n  head = (node_t *) malloc(sizeof(node_t));\n  if (head == NULL) {\n    OMPVV_ERROR(\"There was a problem allocating the head node\");\n    return 1;\n  }\n\n  head->data = 0;\n  head->next = NULL;\n\n  for(i=1;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1; i < SIZE_LIST; i++)\n    push(head,i);\n\n  map_ll(head);\n  unmap_ll(head);\n  \n  OMPVV_TEST_AND_SET_VERBOSE(error, check(head));\n\n  while (head) {\n    node_t * next = head->next;\n    free (head);\n    head = next;\n  }\n\n  OMPVV_REPORT_AND_RETURN(error);\n  return 0;\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_map_struct_default.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n    OMPVV_ERROR(\"Mapping to device cannot be properly tested as offloading is not enabled\");\n    errors ++;\n    OMPVV_REPORT_AND_RETURN(errors);\n  }\" at position 3435",
        "issue_id": 4,
        "original_code": "//===---test_target_map_struct_default.c - test of struct mapping to device -===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// This test checks the default variable mapping behavior. Without specifying \n// any attribute or map clause, all used variables inside the target region \n// should be mapped tofrom. There are two different test cases. The first one\n// where a struct is defined and used, the second one where a typedef struct is\n// defined, then a struct with that type is defined and then used. \n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nint test_map_struct() {\n\n  OMPVV_INFOMSG(\"Running test_map_struct()\");\n\n  int errors = 0;\n  int* pointers[6];\n\n  struct {\n    int a;\n    int b[N];\n    int *p;\n  } single, array[5];\n\n  single.p = (int*) malloc(5 * sizeof(int));\n  pointers[0] = single.p;\n\n  for (int i = 0; i < 5; ++i) {\n    array[i].p = (int*) malloc(5 * sizeof(int));\n    pointers[i + 1] = array[i].p;\n  }\n\n  // By default. map(tofrom: single) map(tofrom: array) map(tofrom: pointers[0:0])\n  {\n#pragma omp target\n    if (!omp_is_initial_device()) {\n      single.a = 1;\n      for (int i = 0; i < N; ++i)\n        single.b[i] = 1;\n\n      for (int i = 0; i < 5; ++i) {\n        array[i].a = 1;\n        for (int j = 0; j < N; ++j)\n          array[i].b[j] = 1;\n      }\n    }\n  } // end target\n  \n  // checking results\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (single.a != 1)); \n  for (int i = 0; i < N; ++i)\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (single.b[i] != 1));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (pointers[0] != single.p));\n  for (int i = 0; i < 5; ++i) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (array[i].a != 1)); \n    for (int j = 0; j < N; ++j)\n      OMPVV_TEST_AND_SET_VERBOSE(errors, (array[i].b[j] != 1));\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (pointers[i + 1] != array[i].p));\n  }\n\n  return errors;\n}\n\nint test_map_typedef() {\n\n  OMPVV_INFOMSG(\"Running test_map_typedef()\");\n\n  int errors = 0;\n  int* pointers[6];\n\n  typedef struct {\n    int a;\n    int b[N];\n    int *p;\n  } test_struct;\n\n  test_struct single, array[5];\n\n  single.p = (int*) malloc(5 * sizeof(int));\n  pointers[0] = single.p;\n\n  for (int i = 0; i < 5; ++i) {\n    array[i].p = (int*) malloc(5 * sizeof(int));\n    pointers[i + 1] = array[i].p;\n  }\n\n  //By default: map(tofrom: single) map(tofrom: array) map(tofrom: pointers)\n  {\n#pragma omp target\n    if (!omp_is_initial_device()) {  \n      single.a = 1;\n      for (int i = 0; i < N; ++i)\n        single.b[i] = 1;\n\n      for (int i = 0; i < 5; ++i) {\n        array[i].a = 1;\n        for (int j = 0; j < N; ++j)\n          array[i].b[j] = 1;\n      }\n    }\n  } // end target\n  \n  // checking results\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (single.a != 1)); \n  for (int i = 0; i < N; ++i)\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (single.b[i] != 1));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (pointers[0] != single.p));\n  for (int i = 0; i < 5; ++i) {\n   OMPVV_TEST_AND_SET_VERBOSE(errors, (array[i].a != 1)); \n    for (int j = 0; j < N; ++j)\n      OMPVV_TEST_AND_SET_VERBOSE(errors, (array[i].b[j] != 1));\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (pointers[i + 1] != array[i].p));\n  }\n\n  return errors;\n}\n\n\nint main () {\n  \n  int errors = 0;\n  //Check that offloading is enabled\n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n  \n  if (!is_offloading) {\n    OMPVV_ERROR(\"Mapping to device cannot be properly tested as offloading is not enabled\");\n    errors ++;\n    OMPVV_REPORT_AND_RETURN(errors);\n  }\n  \n  errors += test_map_struct();\n  errors += test_map_typedef();\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---test_target_map_struct_default.c - test of struct mapping to device -===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// This test checks the default variable mapping behavior. Without specifying \n// any attribute or map clause, all used variables inside the target region \n// should be mapped tofrom. There are two different test cases. The first one\n// where a struct is defined and used, the second one where a typedef struct is\n// defined, then a struct with that type is defined and then used. \n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nint test_map_struct() {\n\n  OMPVV_INFOMSG(\"Running test_map_struct()\");\n\n  int errors = 0;\n  int* pointers[6];\n\n  struct {\n    int a;\n    int b[N];\n    int *p;\n  } single, array[5];\n\n  single.p = (int*) malloc(5 * sizeof(int));\n  pointers[0] = single.p;\n\n  for (int i = 0; i < 5; ++i) {\n    array[i].p = (int*) malloc(5 * sizeof(int));\n    pointers[i + 1] = array[i].p;\n  }\n\n  // By default. map(tofrom: single) map(tofrom: array) map(tofrom: pointers[0:0])\n  {\n#pragma omp target\n    if (!omp_is_initial_device()) {\n      single.a = 1;\n      for (int i = 0; i < N; ++i)\n        single.b[i] = 1;\n\n      for (int i = 0; i < 5; ++i) {\n        array[i].a = 1;\n        for (int j = 0; j < N; ++j)\n          array[i].b[j] = 1;\n      }\n    }\n  } // end target\n  \n  // checking results\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (single.a != 1)); \n  for (int i = 0; i < N; ++i)\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (single.b[i] != 1));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (pointers[0] != single.p));\n  for (int i = 0; i < 5; ++i) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (array[i].a != 1)); \n    for (int j = 0; j < N; ++j)\n      OMPVV_TEST_AND_SET_VERBOSE(errors, (array[i].b[j] != 1));\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (pointers[i + 1] != array[i].p));\n  }\n\n  return errors;\n}\n\nint test_map_typedef() {\n\n  OMPVV_INFOMSG(\"Running test_map_typedef()\");\n\n  int errors = 0;\n  int* pointers[6];\n\n  typedef struct {\n    int a;\n    int b[N];\n    int *p;\n  } test_struct;\n\n  test_struct single, array[5];\n\n  single.p = (int*) malloc(5 * sizeof(int));\n  pointers[0] = single.p;\n\n  for (int i = 0; i < 5; ++i) {\n    array[i].p = (int*) malloc(5 * sizeof(int));\n    pointers[i + 1] = array[i].p;\n  }\n\n  //By default: map(tofrom: single) map(tofrom: array) map(tofrom: pointers)\n  {\n#pragma omp target\n    if (!omp_is_initial_device()) {  \n      single.a = 1;\n      for (int i = 0; i < N; ++i)\n        single.b[i] = 1;\n\n      for (int i = 0; i < 5; ++i) {\n        array[i].a = 1;\n        for (int j = 0; j < N; ++j)\n          array[i].b[j] = 1;\n      }\n    }\n  } // end target\n  \n  // checking results\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (single.a != 1)); \n  for (int i = 0; i < N; ++i)\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (single.b[i] != 1));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (pointers[0] != single.p));\n  for (int i = 0; i < 5; ++i) {\n   OMPVV_TEST_AND_SET_VERBOSE(errors, (array[i].a != 1)); \n    for (int j = 0; j < N; ++j)\n      OMPVV_TEST_AND_SET_VERBOSE(errors, (array[i].b[j] != 1));\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (pointers[i + 1] != array[i].p));\n  }\n\n  return errors;\n}\n\n\nint main () {\n  \n  int errors = 0;\n  //Check that offloading is enabled\n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n  \n  if (!is_offloading) \n  \n  errors += test_map_struct();\n  errors += test_map_typedef();\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_atomic_fail_acquire.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp parallel\" with directive \"#pragma omp flush\" at position 611",
        "issue_id": 0,
        "original_code": "//===--- test_atomic_fail_acquire.c -----------------------------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// Utilizes an atomic seq_cst w/ an atomic release to ensure the implicit\n// setting of x=10. Restrictions on atomic fail state they must be used\n// on an atomic compare.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_atomic_fail_acquire() {\n  OMPVV_INFOMSG(\"test_atomic_fail_acquire\");\n\n  int x = 0, y = 0;\n  int errors = 0;\n\n#pragma omp parallel num_threads(2)\n   {\n      int thrd = omp_get_thread_num();\n       if (thrd == 0) {\n          y = 1;\n          #pragma omp atomic write seq_cst\n          x = 10;\n       } else {\n          while (y != 5) {\n            #pragma omp atomic compare seq_cst fail(acquire)\n            if(y == 1){\n               y = 5;\n            }\n          }\n          OMPVV_TEST_AND_SET(errors, x != 10);\n          OMPVV_TEST_AND_SET(errors, y != 5);\n       }\n   }\n   return errors;\n}\n\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_atomic_fail_acquire());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_atomic_fail_acquire.c -----------------------------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// Utilizes an atomic seq_cst w/ an atomic release to ensure the implicit\n// setting of x=10. Restrictions on atomic fail state they must be used\n// on an atomic compare.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_atomic_fail_acquire() {\n  OMPVV_INFOMSG(\"test_atomic_fail_acquire\");\n\n  int x = 0, y = 0;\n  int errors = 0;\n\n#pragma omp flush num_threads(2)\n   {\n      int thrd = omp_get_thread_num();\n       if (thrd == 0) {\n          y = 1;\n          #pragma omp atomic write seq_cst\n          x = 10;\n       } else {\n          while (y != 5) {\n            #pragma omp atomic compare seq_cst fail(acquire)\n            if(y == 1){\n               y = 5;\n            }\n          }\n          OMPVV_TEST_AND_SET(errors, x != 10);\n          OMPVV_TEST_AND_SET(errors, y != 5);\n       }\n   }\n   return errors;\n}\n\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_atomic_fail_acquire());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_omp_get_device_num.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1804",
        "issue_id": 1,
        "original_code": "//===--- test_omp_get_device_num.c -------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Test of omp_get_device_num() on both the host device and offloading\n// device. When called on host device, omp_get_device_num() will return the \n// same value as omp_get_initial_device(). \n//\n////===-----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1028\n\nint errors;\nint original_device_num;\nint target_device_num; \nint a[N];\nint b[N];\nint c[N];\n\n\nint test_omp_get_dev_num(void) {\n\n   original_device_num = omp_get_device_num();\n\n   OMPVV_ERROR_IF(original_device_num != omp_get_initial_device(), \"omp_get_device_num() does not equal omp_get_initial_device()\");\n \n   OMPVV_TEST_AND_SET_VERBOSE(errors, original_device_num != omp_get_initial_device());\n\n   for (int i = 0; i < N; i++) {\n      a[i] = 0;\n      b[i] = 5;\n      c[i] = i;\n   }\n   \n   #pragma omp target map(from: target_device_num) map(to: b, c) map(tofrom: a)\n   { \n      target_device_num = omp_get_device_num();\n      for (int i = 0; i < N; i++) {\n         a[i] = b[i] + c[i];\n      }\n   }\n\n   OMPVV_WARNING_IF(target_device_num == original_device_num, \"omp_get_device_num() returned the same device number as host, cannot guarantee that target region properly offloaded to device\");\n   \n   for (int i = 0; i < N; i++) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, a[i] != i + 5);\n   }\n\n   target_device_num = 99;\n\n   for (int i = 0; i <= omp_get_num_devices(); i++) {\n     #pragma omp target map(from: target_device_num) device(i)\n     {\n       target_device_num = omp_get_device_num();\n     }\n\n     OMPVV_TEST_AND_SET_VERBOSE(errors, target_device_num != i);\n   }\n\n   return errors;\n}\n\nint main () {\n\n   errors = 0;\n  \n   OMPVV_TEST_OFFLOADING;\n\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_omp_get_dev_num());\n\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_omp_get_device_num.c -------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Test of omp_get_device_num() on both the host device and offloading\n// device. When called on host device, omp_get_device_num() will return the \n// same value as omp_get_initial_device(). \n//\n////===-----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1028\n\nint errors;\nint original_device_num;\nint target_device_num; \nint a[N];\nint b[N];\nint c[N];\n\n\nint test_omp_get_dev_num(void) {\n\n   original_device_num = omp_get_device_num();\n\n   OMPVV_ERROR_IF(original_device_num != omp_get_initial_device(), \"omp_get_device_num() does not equal omp_get_initial_device()\");\n \n   OMPVV_TEST_AND_SET_VERBOSE(errors, original_device_num != omp_get_initial_device());\n\n   for (int i = 0; i < N; i++) {\n      a[i] = 0;\n      b[i] = 5;\n      c[i] = i;\n   }\n   \n   #pragma omp target map(from: target_device_num) map(to: b, c) map(tofrom: a)\n   { \n      target_device_num = omp_get_device_num();\n      for (int i = 0; i < N; i++) {\n         a[i] = b[i] + c[i];\n      }\n   }\n\n   OMPVV_WARNING_IF(target_device_num == original_device_num, \"omp_get_device_num() returned the same device number as host, cannot guarantee that target region properly offloaded to device\");\n   \n   for (int i = 0; i < N; i++) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, a[i] != i + 5);\n   }\n\n   target_device_num = 99;\n\n   for (int i = 0; i <= omp_get_num_devices(); i++) {\n     #pragma omp target map(from: target_device_num) device(i)\n     {\n       target_device_num = omp_get_device_num();\n     }\n\n     OMPVV_TEST_AND_SET_VERBOSE(errors, target_device_num != i);\n   }\n\n   return errors;\n}\n\nint main () \n\n   errors = 0;\n  \n   OMPVV_TEST_OFFLOADING;\n\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_omp_get_dev_num());\n\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_enter_data_struct.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET(errors, test_struct());\n  OMPVV_TEST_AND_SET(errors, test_typedef());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 5261",
        "issue_id": 4,
        "original_code": "//===--- test_target_enter_data_struct.c ------------------------------------===//\n//\n// This test checks that the target enter data construct with a map clause \n// can be used to map a struct variable or a typedef variable to the device. \n// Once the struct variable or typedef variable is mapped onto device, another \n// struct variable or typedef variable is mapped back to host using target \n// construct with map clause and map-type-modifier tofrom. \n//\n//===------------------------------------------------------------------------===//\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1000\n#define ARRAY_SIZE 5\nint test_struct() {\n\n  OMPVV_INFOMSG(\"test_struct\");\n\n  int errors = 0, isHost = -1;\n  int* pointers[ARRAY_SIZE + 1];\n\n  struct {\n    int a; // firstprivate\n    int b[N]; // tofrom:b[0:N]\n    int *p; // tofrom:p[0:0]\n  } single, array[ARRAY_SIZE], singleCopy, arrayCopy[ARRAY_SIZE];\n\n  // single initialization on host. Using map(to)\n  single.p = (int*) malloc(ARRAY_SIZE * sizeof(int));\n  pointers[0] = single.p;\n  single.a = 1;\n  for (int i = 0; i < N; ++i)\n    single.b[i] = i;\n\n  // Array initialization on host. Using map(to)\n  for (int i = 0; i < ARRAY_SIZE; ++i) {\n    array[i].p = (int*) malloc(ARRAY_SIZE * sizeof(int));\n    pointers[i + 1] = array[i].p;\n    array[i].a = 1;\n    for (int j = 0; j < N; ++j)\n      array[i].b[j] = j;\n  }\n\n  // unstructured mapping\n  {\n#pragma omp target enter data map(to: single) map(to: array[0:ARRAY_SIZE])\n    printf(\"\"); // forcing the compiler to not moving out of the scope\n  }\n  // operation\n#pragma omp target map(from: singleCopy) map(from: arrayCopy[0:ARRAY_SIZE]) map(tofrom: isHost)\\\n  map(alloc: single, array[0:ARRAY_SIZE])\n  {\n    isHost = omp_is_initial_device();\n\n    singleCopy.a = single.a;\n    singleCopy.p = single.p;\n    for (int i = 0; i < N; ++i)\n      singleCopy.b[i] = single.b[i];\n\n    for (int i = 0; i < ARRAY_SIZE; ++i) {\n      arrayCopy[i].a = array[i].a;\n      arrayCopy[i].p = array[i].p;\n      for (int j = 0; j < N; ++j)\n        arrayCopy[i].b[j] = array[i].b[j];\n    }\n  }\n\n  // checking results\n  OMPVV_TEST_AND_SET(errors, (singleCopy.a != single.a)); \n  for (int i = 0; i < N; ++i)\n    OMPVV_TEST_AND_SET(errors, (singleCopy.b[i] != single.b[i]));\n  OMPVV_TEST_AND_SET(errors, (pointers[0] != singleCopy.p));\n  for (int i = 0; i < ARRAY_SIZE; ++i) {\n    OMPVV_TEST_AND_SET(errors, (arrayCopy[i].a != array[i].a)); \n    for (int j = 0; j < N; ++j)\n      OMPVV_TEST_AND_SET(errors, (arrayCopy[i].b[j] != array[i].b[j]));\n    OMPVV_TEST_AND_SET(errors, (pointers[i + 1] != arrayCopy[i].p));\n  }\n\n  // This is outside of the testing. Even thoug we want to test enter data only, there is no way\n  // to do garbage collection without target exit data\n#pragma omp target exit data map(delete: single, array[0:ARRAY_SIZE])\n\n  free(single.p);\n  for (int i = 0; i < ARRAY_SIZE; ++i) {\n    free(array[i].p);\n  }\n  return errors;\n}\n\nint test_typedef() {\n\n  OMPVV_INFOMSG(\"test_typedef\");\n\n  int errors = 0, isHost = -1;\n  int* pointers[ARRAY_SIZE + 1];\n\n  typedef struct /* __attribute__((packed)) */{\n    int a;\n    int b[N];\n    int *p;\n  } test_struct;\n\n  test_struct single, array[ARRAY_SIZE], singleCopy, arrayCopy[ARRAY_SIZE];\n\n  // single initialization on host. Using map(to)\n  single.p = (int*) malloc(ARRAY_SIZE * sizeof(int));\n  pointers[0] = single.p;\n  single.a = 1;\n  for (int i = 0; i < N; ++i)\n    single.b[i] = i;\n\n  for (int i = 0; i < ARRAY_SIZE; ++i) {\n    array[i].p = (int*) malloc(ARRAY_SIZE * sizeof(int));\n    pointers[i + 1] = array[i].p;\n    array[i].a = 1;\n    for (int j = 0; j < N; ++j)\n      array[i].b[j] = j;\n  }\n\n  // unstructured mapping\n  {\n#pragma omp target enter data map(to: single) map(to: array[0:ARRAY_SIZE])\n    printf(\"\"); // forcing the compiler to not moving out of the scope\n  }\n  // operation\n#pragma omp target map(from: singleCopy) map(from: arrayCopy[0:ARRAY_SIZE]) map(tofrom: isHost) \\\n  map(alloc: single, array[0:ARRAY_SIZE])\n  {\n    isHost = omp_is_initial_device();\n    singleCopy.a = single.a;\n    singleCopy.p = single.p;\n    for (int i = 0; i < N; ++i)\n      singleCopy.b[i] = single.b[i];\n\n    for (int i = 0; i < ARRAY_SIZE; ++i) {\n      arrayCopy[i].a = array[i].a;\n      arrayCopy[i].p = array[i].p;\n\n      for (int j = 0; j < N; ++j)\n        arrayCopy[i].b[j] = array[i].b[j]; \n    }\n  }\n\n  // checking results\n  OMPVV_TEST_AND_SET(errors, (singleCopy.a != single.a));\n  for (int i = 0; i < N; ++i)\n    OMPVV_TEST_AND_SET(errors, (singleCopy.b[i] != single.b[i]));\n  OMPVV_TEST_AND_SET(errors, (pointers[0] != singleCopy.p));\n  for (int i = 0; i < ARRAY_SIZE; ++i) {\n    OMPVV_TEST_AND_SET(errors, (arrayCopy[i].a != array[i].a)); \n    for (int j = 0; j < N; ++j)\n      OMPVV_TEST_AND_SET(errors, (arrayCopy[i].b[j] != array[i].b[j]));\n    OMPVV_TEST_AND_SET(errors, (pointers[i + 1] != arrayCopy[i].p));\n  }\n\n  // This is outside of the testing. Even thoug we want to test enter data only, there is no way\n  // to do garbage collection without target exit data\n#pragma omp target exit data map(delete: single, array[0:ARRAY_SIZE])\n\n  free(single.p);\n  for (int i = 0; i < ARRAY_SIZE; ++i) {\n    free(array[i].p);\n  }\n  return errors;\n}\n\nint main () {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET(errors, test_struct());\n  OMPVV_TEST_AND_SET(errors, test_typedef());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_enter_data_struct.c ------------------------------------===//\n//\n// This test checks that the target enter data construct with a map clause \n// can be used to map a struct variable or a typedef variable to the device. \n// Once the struct variable or typedef variable is mapped onto device, another \n// struct variable or typedef variable is mapped back to host using target \n// construct with map clause and map-type-modifier tofrom. \n//\n//===------------------------------------------------------------------------===//\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1000\n#define ARRAY_SIZE 5\nint test_struct() {\n\n  OMPVV_INFOMSG(\"test_struct\");\n\n  int errors = 0, isHost = -1;\n  int* pointers[ARRAY_SIZE + 1];\n\n  struct {\n    int a; // firstprivate\n    int b[N]; // tofrom:b[0:N]\n    int *p; // tofrom:p[0:0]\n  } single, array[ARRAY_SIZE], singleCopy, arrayCopy[ARRAY_SIZE];\n\n  // single initialization on host. Using map(to)\n  single.p = (int*) malloc(ARRAY_SIZE * sizeof(int));\n  pointers[0] = single.p;\n  single.a = 1;\n  for (int i = 0; i < N; ++i)\n    single.b[i] = i;\n\n  // Array initialization on host. Using map(to)\n  for (int i = 0; i < ARRAY_SIZE; ++i) {\n    array[i].p = (int*) malloc(ARRAY_SIZE * sizeof(int));\n    pointers[i + 1] = array[i].p;\n    array[i].a = 1;\n    for (int j = 0; j < N; ++j)\n      array[i].b[j] = j;\n  }\n\n  // unstructured mapping\n  {\n#pragma omp target enter data map(to: single) map(to: array[0:ARRAY_SIZE])\n    printf(\"\"); // forcing the compiler to not moving out of the scope\n  }\n  // operation\n#pragma omp target map(from: singleCopy) map(from: arrayCopy[0:ARRAY_SIZE]) map(tofrom: isHost)\\\n  map(alloc: single, array[0:ARRAY_SIZE])\n  {\n    isHost = omp_is_initial_device();\n\n    singleCopy.a = single.a;\n    singleCopy.p = single.p;\n    for (int i = 0; i < N; ++i)\n      singleCopy.b[i] = single.b[i];\n\n    for (int i = 0; i < ARRAY_SIZE; ++i) {\n      arrayCopy[i].a = array[i].a;\n      arrayCopy[i].p = array[i].p;\n      for (int j = 0; j < N; ++j)\n        arrayCopy[i].b[j] = array[i].b[j];\n    }\n  }\n\n  // checking results\n  OMPVV_TEST_AND_SET(errors, (singleCopy.a != single.a)); \n  for (int i = 0; i < N; ++i)\n    OMPVV_TEST_AND_SET(errors, (singleCopy.b[i] != single.b[i]));\n  OMPVV_TEST_AND_SET(errors, (pointers[0] != singleCopy.p));\n  for (int i = 0; i < ARRAY_SIZE; ++i) {\n    OMPVV_TEST_AND_SET(errors, (arrayCopy[i].a != array[i].a)); \n    for (int j = 0; j < N; ++j)\n      OMPVV_TEST_AND_SET(errors, (arrayCopy[i].b[j] != array[i].b[j]));\n    OMPVV_TEST_AND_SET(errors, (pointers[i + 1] != arrayCopy[i].p));\n  }\n\n  // This is outside of the testing. Even thoug we want to test enter data only, there is no way\n  // to do garbage collection without target exit data\n#pragma omp target exit data map(delete: single, array[0:ARRAY_SIZE])\n\n  free(single.p);\n  for (int i = 0; i < ARRAY_SIZE; ++i) {\n    free(array[i].p);\n  }\n  return errors;\n}\n\nint test_typedef() {\n\n  OMPVV_INFOMSG(\"test_typedef\");\n\n  int errors = 0, isHost = -1;\n  int* pointers[ARRAY_SIZE + 1];\n\n  typedef struct /* __attribute__((packed)) */{\n    int a;\n    int b[N];\n    int *p;\n  } test_struct;\n\n  test_struct single, array[ARRAY_SIZE], singleCopy, arrayCopy[ARRAY_SIZE];\n\n  // single initialization on host. Using map(to)\n  single.p = (int*) malloc(ARRAY_SIZE * sizeof(int));\n  pointers[0] = single.p;\n  single.a = 1;\n  for (int i = 0; i < N; ++i)\n    single.b[i] = i;\n\n  for (int i = 0; i < ARRAY_SIZE; ++i) {\n    array[i].p = (int*) malloc(ARRAY_SIZE * sizeof(int));\n    pointers[i + 1] = array[i].p;\n    array[i].a = 1;\n    for (int j = 0; j < N; ++j)\n      array[i].b[j] = j;\n  }\n\n  // unstructured mapping\n  {\n#pragma omp target enter data map(to: single) map(to: array[0:ARRAY_SIZE])\n    printf(\"\"); // forcing the compiler to not moving out of the scope\n  }\n  // operation\n#pragma omp target map(from: singleCopy) map(from: arrayCopy[0:ARRAY_SIZE]) map(tofrom: isHost) \\\n  map(alloc: single, array[0:ARRAY_SIZE])\n  {\n    isHost = omp_is_initial_device();\n    singleCopy.a = single.a;\n    singleCopy.p = single.p;\n    for (int i = 0; i < N; ++i)\n      singleCopy.b[i] = single.b[i];\n\n    for (int i = 0; i < ARRAY_SIZE; ++i) {\n      arrayCopy[i].a = array[i].a;\n      arrayCopy[i].p = array[i].p;\n\n      for (int j = 0; j < N; ++j)\n        arrayCopy[i].b[j] = array[i].b[j]; \n    }\n  }\n\n  // checking results\n  OMPVV_TEST_AND_SET(errors, (singleCopy.a != single.a));\n  for (int i = 0; i < N; ++i)\n    OMPVV_TEST_AND_SET(errors, (singleCopy.b[i] != single.b[i]));\n  OMPVV_TEST_AND_SET(errors, (pointers[0] != singleCopy.p));\n  for (int i = 0; i < ARRAY_SIZE; ++i) {\n    OMPVV_TEST_AND_SET(errors, (arrayCopy[i].a != array[i].a)); \n    for (int j = 0; j < N; ++j)\n      OMPVV_TEST_AND_SET(errors, (arrayCopy[i].b[j] != array[i].b[j]));\n    OMPVV_TEST_AND_SET(errors, (pointers[i + 1] != arrayCopy[i].p));\n  }\n\n  // This is outside of the testing. Even thoug we want to test enter data only, there is no way\n  // to do garbage collection without target exit data\n#pragma omp target exit data map(delete: single, array[0:ARRAY_SIZE])\n\n  free(single.p);\n  for (int i = 0; i < ARRAY_SIZE; ++i) {\n    free(array[i].p);\n  }\n  return errors;\n}\n\nint main () \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_map_local_array.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp map\" at position 910",
        "issue_id": 0,
        "original_code": "//===--- test_target_map_local_array.c --------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// This test will check if an array that is declared and initialized in the host, \n// can be copied over the device, updated there, and then copied back. If this test \n// runs on the host, we will warn that array is not allocated on any device.\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define N 10000\n\nint main() {\n  //define compute array locally\n  int compute_array[N];\n  int sum = 0, errors = 0, result = 0;\n  int i;\n\n  // Host initialization of the array \n  for (i = 0; i < N; i++) \n    compute_array[i] = 0;\n\n  int isOffloading;\n\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n\n  OMPVV_WARNING_IF(!isOffloading, \"This test is running on host, array is not allocated on device\");\n\n#pragma omp target map(tofrom: compute_array[0:N])\n  {\n  \t\n  // Updating the compute_array\n  for (i = 0; i < N; i++)\n      compute_array[i] = i;\n   \n  } // end target\n\n  // Comparing the results\n  for (i = 0; i < N; i++){\n    sum = sum + compute_array[i];    \n    result += i;\n  }\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != sum);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n}\n",
        "error_code": "//===--- test_target_map_local_array.c --------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// This test will check if an array that is declared and initialized in the host, \n// can be copied over the device, updated there, and then copied back. If this test \n// runs on the host, we will warn that array is not allocated on any device.\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define N 10000\n\nint main() {\n  //define compute array locally\n  int compute_array[N];\n  int sum = 0, errors = 0, result = 0;\n  int i;\n\n  // Host initialization of the array \n  for (i = 0; i < N; i++) \n    compute_array[i] = 0;\n\n  int isOffloading;\n\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n\n  OMPVV_WARNING_IF(!isOffloading, \"This test is running on host, array is not allocated on device\");\n\n#pragma omp map map(tofrom: compute_array[0:N])\n  {\n  \t\n  // Updating the compute_array\n  for (i = 0; i < N; i++)\n      compute_array[i] = i;\n   \n  } // end target\n\n  // Comparing the results\n  for (i = 0; i < N; i++){\n    sum = sum + compute_array[i];    \n    result += i;\n  }\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != sum);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_data_map_to.c",
        "correct": "n",
        "issue": "Removed memory allocation line \"omp_target_alloc\n  // section 3.5.1 omp_target_alloc. OpenMP API Version 4.5 Nov 2015\n  int *d_array =\n      (int *)omp_target_alloc(N*sizeof(int), omp_get_default_device());\" at position 1248",
        "issue_id": 0,
        "original_code": "//===---- test_target_data_map_to.c ---------------------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// The test_target_data_map group of tests checks all the possible map-type-modifiers\n// for the target data map clauses. These are: from, to, fromto, alloc, release and \n// delete. There is a a separate c file for each test with the prefix test_target_data_map.\n// This specific test is for the 'to' clause. \n//\n//===----------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n// Test for OpenMP 4.5 target data map(to: ) \nint test_map_to() {\n\n  OMPVV_INFOMSG(\"test_map_to\");\n\n  int sum = 0, sum2 = 0, errors = 0;\n  \n  // host arrays: heap and stack\n  int *h_array_h = (int *)malloc(N*sizeof(int));\n  int *h_array2_h = (int *)malloc(N*sizeof(int));\n  int h_array_s[N];\n  int h_array2_s[N];\n\n  // initializing arrays \n  for (int i = 0; i < N; ++i) {\n    h_array_h[i] = 1;\n    h_array_s[i] = 1;\n    h_array2_h[i] = 0;\n    h_array2_s[i] = 0;\n  }\n\n  // device arrays to get the data from the device\n  // pointer arithmetic is not supported on the devices for\n  // the device address returned by omp_target_alloc\n  // section 3.5.1 omp_target_alloc. OpenMP API Version 4.5 Nov 2015\n  int *d_array =\n      (int *)omp_target_alloc(N*sizeof(int), omp_get_default_device());\n  int *d_array2 =\n      (int *)omp_target_alloc(N*sizeof(int), omp_get_default_device());\n\n  if (d_array == NULL || d_array2 == NULL ) {\n    errors = 1;\n    OMPVV_ERROR(\"omp_target_alloc returns NULL, this test is running on host, cannot properly test mapping of variables to device.\");\n    return errors;\n  }\n\n#pragma omp target data map(to: h_array_h[0:N])  \\\n        map(to: h_array_s[0:N]) \n  {\n#pragma omp target is_device_ptr(d_array, d_array2)\n    {\n      for (int i = 0; i < N; ++i) {\n        d_array[i] = h_array_h[i];\n        d_array2[i] = h_array_s[i];\n      }\n    } // end target\n  } // end target data\n\n  // copy from d to h\n  omp_target_memcpy(h_array2_h, d_array, N*sizeof(int), 0, 0,\n                    omp_get_initial_device(), omp_get_default_device());\n  omp_target_memcpy(h_array2_s, d_array2, N*sizeof(int), 0, 0,\n                    omp_get_initial_device(), omp_get_default_device());\n  // deallocating device arrays \n  omp_target_free(d_array, omp_get_default_device());\n  omp_target_free(d_array2, omp_get_default_device());\n\n  // checking errors\n  for (int i = 0; i < N; ++i) {\n    sum += h_array2_h[i];\n    sum2 += h_array2_s[i];\n  }\n\n  free(h_array_h);\n  free(h_array2_h);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (N != sum) || (N != sum2));\n\n  return errors;\n}\n\nint main() {\n\n  int errors = 0;\n  \n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_to());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n",
        "error_code": "//===---- test_target_data_map_to.c ---------------------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// The test_target_data_map group of tests checks all the possible map-type-modifiers\n// for the target data map clauses. These are: from, to, fromto, alloc, release and \n// delete. There is a a separate c file for each test with the prefix test_target_data_map.\n// This specific test is for the 'to' clause. \n//\n//===----------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n// Test for OpenMP 4.5 target data map(to: ) \nint test_map_to() {\n\n  OMPVV_INFOMSG(\"test_map_to\");\n\n  int sum = 0, sum2 = 0, errors = 0;\n  \n  // host arrays: heap and stack\n  int *h_array_h = (int *)malloc(N*sizeof(int));\n  int *h_array2_h = (int *)malloc(N*sizeof(int));\n  int h_array_s[N];\n  int h_array2_s[N];\n\n  // initializing arrays \n  for (int i = 0; i < N; ++i) {\n    h_array_h[i] = 1;\n    h_array_s[i] = 1;\n    h_array2_h[i] = 0;\n    h_array2_s[i] = 0;\n  }\n\n  // device arrays to get the data from the device\n  // pointer arithmetic is not supported on the devices for\n  // the device address returned by \n  int *d_array2 =\n      (int *)omp_target_alloc(N*sizeof(int), omp_get_default_device());\n\n  if (d_array == NULL || d_array2 == NULL ) {\n    errors = 1;\n    OMPVV_ERROR(\"omp_target_alloc returns NULL, this test is running on host, cannot properly test mapping of variables to device.\");\n    return errors;\n  }\n\n#pragma omp target data map(to: h_array_h[0:N])  \\\n        map(to: h_array_s[0:N]) \n  {\n#pragma omp target is_device_ptr(d_array, d_array2)\n    {\n      for (int i = 0; i < N; ++i) {\n        d_array[i] = h_array_h[i];\n        d_array2[i] = h_array_s[i];\n      }\n    } // end target\n  } // end target data\n\n  // copy from d to h\n  omp_target_memcpy(h_array2_h, d_array, N*sizeof(int), 0, 0,\n                    omp_get_initial_device(), omp_get_default_device());\n  omp_target_memcpy(h_array2_s, d_array2, N*sizeof(int), 0, 0,\n                    omp_get_initial_device(), omp_get_default_device());\n  // deallocating device arrays \n  omp_target_free(d_array, omp_get_default_device());\n  omp_target_free(d_array2, omp_get_default_device());\n\n  // checking errors\n  for (int i = 0; i < N; ++i) {\n    sum += h_array2_h[i];\n    sum2 += h_array2_s[i];\n  }\n\n  free(h_array_h);\n  free(h_array2_h);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (N != sum) || (N != sum2));\n\n  return errors;\n}\n\nint main() {\n\n  int errors = 0;\n  \n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_to());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_parallel_for_if_no_modifier.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp flush\" at position 1885",
        "issue_id": 0,
        "original_code": "//===---- test_target_teams_distribute_parallel_for_if_no_modifier.c --------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// In this test we want to try to check if the if clause is working \n// when used with the combined construct target teams distribute parallel for\n// and no modifier is specified.\n// To do this we check if offloading is working, if it is not, it won't be\n// possible for us to tell if the test passed or not, since it depends on \n// offloading capabilities. \n//\n// The if has a directive-name-modifier that specifies to which directive the \n// if applies to (either both directives, to the target or to the parallel). \n// we create three test, one for no directive, another one for the target directive\n// and another one for the parallel directive \n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define ATTEMPT_THRESHOLD 70\n#define NUM_ATTEMPTS 100\n#define N 1024\n\nint checkPreconditions() {\n  // We test if offloading is enable, and if \n  // the number of threads is not 1. Having \n  // the number of threads equal to 1 is legal, but \n  // we won't be able to test if the 'if' clause is \n  // affecting this or not\n\n  // Testing for offloading\n  int isOffloading = 0;\n  int i;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"With offloading off, it is not possible to test if on the parallel and not the target\");\n\n  // Testing for number of threads\n  int init_num_threads_dev[N], init_num_threads_host[N];\n  // init_num_threads_dev and init_num_threads_host arrays initialization\n  for (i = 0; i < N; i++) {\n    init_num_threads_dev[i] = 0;\n    init_num_threads_host[i] = 0;\n  }\n\n  // Get the init_num_threads for host and device. If it is 1, then we \n  // cannot test the if parallel \n  // See section 2.5.1 of the ref manual\n#pragma omp target teams distribute parallel for num_threads(OMPVV_NUM_THREADS_DEVICE)\n  for (i = 0; i < N; i++) {\n    init_num_threads_dev[i] = omp_get_num_threads();\n  }\n\n#pragma omp parallel for num_threads(OMPVV_NUM_THREADS_DEVICE)\n  for (i = 0; i < N; i++) {\n    init_num_threads_host[i] = omp_get_num_threads();\n  }\n  \n  // We check that not all the values are 1. This would make the test of if parallel\n  // not possible. \n  int raiseWarningDevice = 0, raiseWarningHost = 0;\n  for (i = 0; i < N; i++) {\n    if (init_num_threads_dev[i] > 1 ) {\n      raiseWarningDevice +=  1;\n    }\n    if ( init_num_threads_host[i] > 1) {\n      raiseWarningHost += 1;\n    }\n  }\n  OMPVV_WARNING_IF(raiseWarningDevice == 0, \"Initial number of threads in device was 1. It is not possible to test the if for the parallel directive\");\n  OMPVV_WARNING_IF(raiseWarningHost == 0, \"Initial number of threads in host was 1. It is not possible to test the if for the parallel directive\");\n\n  return isOffloading;\n}\n\nint test_target_teams_distribute_if_no_modifier() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_if_no_modifier\");\n\n  int isOffloading = checkPreconditions();\n\n  int a[N];\n  int warning[N] ; // num_threads = 1 is not technically an error\n  int attempt = 0;\n  int errors = 0;\n  int i;\n\n  for (i = 0; i < N; i++) {\n    a[i] = 1;\n    warning[i] = 0;\n  }\n\n  // We iterate NUM_ATTEMPTS times. When the iteration value is >= ATTEMPT_THRESHOLD the \n  // execution of the target region should happen in the devie, and the number of threads\n  // is expected to be greater than 1 (although if it is not, this is not an error, just warning)\n  // If the iteration variable attempt  < ATTEMPT_THRESHOLD, the if condition evaluates to false, \n  // and hence the execution should occur in the host with a number of threads equal to 1.\n  // We check that when we are executing on the host, the value of the iteration variable is \n  // greather than ATTEMPT_THRESHOLD, and we make sure the number of threads is 1. \n  for (attempt = 0; attempt < NUM_ATTEMPTS; ++attempt) {\n#pragma omp target teams distribute parallel for if(attempt >= ATTEMPT_THRESHOLD)\\\n    map(tofrom: a, warning) num_threads(OMPVV_NUM_THREADS_DEVICE)\n    for (i = 0; i < N; i++) {\n      if (omp_is_initial_device()) {\n        // if(false): We should execute in the host \n        // and the number of threads is expected \n        // to be 1\n        a[i] += (omp_get_num_threads() > 1) ? 10 : 0; // This +10 should not happena\n        a[i] += (attempt >= ATTEMPT_THRESHOLD) ? 10 : 0; // This +10 should not happena\n      } else {\n        a[i] += 1;\n        warning[i] += (omp_get_num_threads() == 1 ? 1 : 0); // We cannot say that this is an error but we can raise a warning\n      }\n    }\n  }\n\n  int raiseWarning = 0;\n  \n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, a[i] != 1 + (NUM_ATTEMPTS - ATTEMPT_THRESHOLD));\n    if (warning[i] != 0) {\n      raiseWarning = 1;\n    }\n  }\n  OMPVV_WARNING_IF(raiseWarning != 0, \"The number of threads was 1 even though we expected it to be more than 1. Not a compliance error in the specs\");\n\n  OMPVV_ERROR_IF(errors, \"error in if(no-modifier). Possible causes are: the number of threads was greater than 1 for if(false), the test executed in the host for if(true), or the test executed in the device for if(false)\");\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_if_no_modifier());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_teams_distribute_parallel_for_if_no_modifier.c --------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// In this test we want to try to check if the if clause is working \n// when used with the combined construct target teams distribute parallel for\n// and no modifier is specified.\n// To do this we check if offloading is working, if it is not, it won't be\n// possible for us to tell if the test passed or not, since it depends on \n// offloading capabilities. \n//\n// The if has a directive-name-modifier that specifies to which directive the \n// if applies to (either both directives, to the target or to the parallel). \n// we create three test, one for no directive, another one for the target directive\n// and another one for the parallel directive \n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define ATTEMPT_THRESHOLD 70\n#define NUM_ATTEMPTS 100\n#define N 1024\n\nint checkPreconditions() {\n  // We test if offloading is enable, and if \n  // the number of threads is not 1. Having \n  // the number of threads equal to 1 is legal, but \n  // we won't be able to test if the 'if' clause is \n  // affecting this or not\n\n  // Testing for offloading\n  int isOffloading = 0;\n  int i;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"With offloading off, it is not possible to test if on the parallel and not the target\");\n\n  // Testing for number of threads\n  int init_num_threads_dev[N], init_num_threads_host[N];\n  // init_num_threads_dev and init_num_threads_host arrays initialization\n  for (i = 0; i < N; i++) {\n    init_num_threads_dev[i] = 0;\n    init_num_threads_host[i] = 0;\n  }\n\n  // Get the init_num_threads for host and device. If it is 1, then we \n  // cannot test the if parallel \n  // See section 2.5.1 of the ref manual\n#pragma omp flush teams distribute parallel for num_threads(OMPVV_NUM_THREADS_DEVICE)\n  for (i = 0; i < N; i++) {\n    init_num_threads_dev[i] = omp_get_num_threads();\n  }\n\n#pragma omp parallel for num_threads(OMPVV_NUM_THREADS_DEVICE)\n  for (i = 0; i < N; i++) {\n    init_num_threads_host[i] = omp_get_num_threads();\n  }\n  \n  // We check that not all the values are 1. This would make the test of if parallel\n  // not possible. \n  int raiseWarningDevice = 0, raiseWarningHost = 0;\n  for (i = 0; i < N; i++) {\n    if (init_num_threads_dev[i] > 1 ) {\n      raiseWarningDevice +=  1;\n    }\n    if ( init_num_threads_host[i] > 1) {\n      raiseWarningHost += 1;\n    }\n  }\n  OMPVV_WARNING_IF(raiseWarningDevice == 0, \"Initial number of threads in device was 1. It is not possible to test the if for the parallel directive\");\n  OMPVV_WARNING_IF(raiseWarningHost == 0, \"Initial number of threads in host was 1. It is not possible to test the if for the parallel directive\");\n\n  return isOffloading;\n}\n\nint test_target_teams_distribute_if_no_modifier() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_if_no_modifier\");\n\n  int isOffloading = checkPreconditions();\n\n  int a[N];\n  int warning[N] ; // num_threads = 1 is not technically an error\n  int attempt = 0;\n  int errors = 0;\n  int i;\n\n  for (i = 0; i < N; i++) {\n    a[i] = 1;\n    warning[i] = 0;\n  }\n\n  // We iterate NUM_ATTEMPTS times. When the iteration value is >= ATTEMPT_THRESHOLD the \n  // execution of the target region should happen in the devie, and the number of threads\n  // is expected to be greater than 1 (although if it is not, this is not an error, just warning)\n  // If the iteration variable attempt  < ATTEMPT_THRESHOLD, the if condition evaluates to false, \n  // and hence the execution should occur in the host with a number of threads equal to 1.\n  // We check that when we are executing on the host, the value of the iteration variable is \n  // greather than ATTEMPT_THRESHOLD, and we make sure the number of threads is 1. \n  for (attempt = 0; attempt < NUM_ATTEMPTS; ++attempt) {\n#pragma omp target teams distribute parallel for if(attempt >= ATTEMPT_THRESHOLD)\\\n    map(tofrom: a, warning) num_threads(OMPVV_NUM_THREADS_DEVICE)\n    for (i = 0; i < N; i++) {\n      if (omp_is_initial_device()) {\n        // if(false): We should execute in the host \n        // and the number of threads is expected \n        // to be 1\n        a[i] += (omp_get_num_threads() > 1) ? 10 : 0; // This +10 should not happena\n        a[i] += (attempt >= ATTEMPT_THRESHOLD) ? 10 : 0; // This +10 should not happena\n      } else {\n        a[i] += 1;\n        warning[i] += (omp_get_num_threads() == 1 ? 1 : 0); // We cannot say that this is an error but we can raise a warning\n      }\n    }\n  }\n\n  int raiseWarning = 0;\n  \n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, a[i] != 1 + (NUM_ATTEMPTS - ATTEMPT_THRESHOLD));\n    if (warning[i] != 0) {\n      raiseWarning = 1;\n    }\n  }\n  OMPVV_WARNING_IF(raiseWarning != 0, \"The number of threads was 1 even though we expected it to be more than 1. Not a compliance error in the specs\");\n\n  OMPVV_ERROR_IF(errors, \"error in if(no-modifier). Possible causes are: the number of threads was greater than 1 for if(false), the test executed in the host for if(true), or the test executed in the device for if(false)\");\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_if_no_modifier());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/offloading_success.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp teams\" at position 74",
        "issue_id": 0,
        "original_code": "#include <stdio.h>\n#include <omp.h>\n\nint main(void) {\n  int isHost = -1;\n\n#pragma omp target map(from:isHost)\n  { isHost = omp_is_initial_device(); }\n\n  if (isHost < 0) {\n    printf(\"Runtime error, isHost=%d\\n\", isHost);\n  }\n\n  // CHECK: Target region executed on the device\n  printf(\"Target region executed on the %s\\n\", isHost ? \"host\" : \"device\");\n\n  return isHost;\n}\n",
        "error_code": "#include <stdio.h>\n#include <omp.h>\n\nint main(void) {\n  int isHost = -1;\n\n#pragma omp teams map(from:isHost)\n  { isHost = omp_is_initial_device(); }\n\n  if (isHost < 0) {\n    printf(\"Runtime error, isHost=%d\\n\", isHost);\n  }\n\n  // CHECK: Target region executed on the device\n  printf(\"Target region executed on the %s\\n\", isHost ? \"host\" : \"device\");\n\n  return isHost;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_task_lock.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 866",
        "issue_id": 2,
        "original_code": "//===-- test_task_lock.c ------------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// Description\n// testTaskWithLockBasic()\n// This is a basic test to demonstrate how a shared resource\n// can be accessed and written to in multiple thread environment.\n// \n// testTaskWithLockAdvanced()\n// This is a advanced test to demonstrate how a shared resource\n// can be accessed and written to in multiple thread environment.\n// In this a buffer is filled with random integers. The parallel\n// region counts the number of prime integers.\n//===----------------------------------------------------------------------===//\n\n\n\n#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\nint testTaskWithLockBasic(int numThreads) {\n  int errors = 0;\n  int count = 0;\n  omp_lock_t lock;\n  omp_init_lock(&lock);\n  omp_set_num_threads(numThreads);\n#pragma omp parallel\n  {\n#pragma omp task\n    {\n    omp_set_lock(&lock);\n    {\n      count = count + 1;\n    }\n    omp_unset_lock(&lock);\n    }\n  }\n  omp_destroy_lock(&lock);\n  int ret = 0;\n  if (count == numThreads) {\n    ret = 0;\n  } else {\n    ret = -1;\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, ret != 0);\n  return errors;\n}\n\n/**\n  Local Function check if number is prime\n*/\nint isPrime(unsigned int number) {\n  int ret = 0;\n  if (number < 2) {\n    return 1;\n  }\n  for (int num = 2; (num*num) <= number; num++) {\n    if ((number % num) == 0) {\n      ret = 1;\n      break;\n    }\n  }\n  return ret;\n}\n\nint testTaskWithLockAdvanced(int numThreads, int expectedVal) {\n  int errors = 0;\n  omp_lock_t lock;\n  omp_init_lock(&lock);\n  int countPrime = 0, count = 0;\n  unsigned int *A = (unsigned int*) (malloc(numThreads*sizeof(unsigned int)));\n  omp_set_num_threads(numThreads);\n  // fill data\n  for (int i = 0; i < numThreads; i++) {\n    A[i] = i;\n  }\n  // Calculate number of prime numbers \n#pragma omp parallel\n  {\n#pragma omp task\n    {\n      int idx = 0;\n      omp_set_lock(&lock);\n      {\n        count++;\n        idx = count - 1;\n      }\n      omp_unset_lock(&lock);\n      int ret = isPrime(A[idx]);\n      omp_set_lock(&lock);\n      {\n        if (ret == 0) {\n          countPrime++;\n        }\n      }\n      omp_unset_lock(&lock);\n    }\n  }\n  free(A);\n  omp_destroy_lock(&lock);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, countPrime != expectedVal);\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithLockBasic(4));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithLockBasic(8));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithLockBasic(16));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithLockBasic(32));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithLockBasic(64));\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithLockAdvanced(1, 0));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithLockAdvanced(4, 2));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithLockAdvanced(8, 4));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithLockAdvanced(16, 6));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithLockAdvanced(32, 11));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithLockAdvanced(64, 18));\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===-- test_task_lock.c ------------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// Description\n// testTaskWithLockBasic()\n// This is a basic test to demonstrate how a shared resource\n// can be accessed and written to in multiple thread environment.\n// \n// testTaskWithLockAdvanced()\n// This is a advanced test to demonstrate how a shared resource\n// can be accessed and written to in multiple thread environment.\n// In this a buffer is filled with random integers. The parallel\n// region counts the number of prime integers.\n//===----------------------------------------------------------------------===//\n\n\n\n#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\nint testTaskWithLockBasic(int numThreads) {\n  int errors = 0;\n  int count = 0;\n  omp_lock_t lock;\n  omp_init_lock(&lock);yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n  omp_set_num_threads(numThreads);\n#pragma omp parallel\n  {\n#pragma omp task\n    {\n    omp_set_lock(&lock);\n    {\n      count = count + 1;\n    }\n    omp_unset_lock(&lock);\n    }\n  }\n  omp_destroy_lock(&lock);\n  int ret = 0;\n  if (count == numThreads) {\n    ret = 0;\n  } else {\n    ret = -1;\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, ret != 0);\n  return errors;\n}\n\n/**\n  Local Function check if number is prime\n*/\nint isPrime(unsigned int number) {\n  int ret = 0;\n  if (number < 2) {\n    return 1;\n  }\n  for (int num = 2; (num*num) <= number; num++) {\n    if ((number % num) == 0) {\n      ret = 1;\n      break;\n    }\n  }\n  return ret;\n}\n\nint testTaskWithLockAdvanced(int numThreads, int expectedVal) {\n  int errors = 0;\n  omp_lock_t lock;\n  omp_init_lock(&lock);\n  int countPrime = 0, count = 0;\n  unsigned int *A = (unsigned int*) (malloc(numThreads*sizeof(unsigned int)));\n  omp_set_num_threads(numThreads);\n  // fill data\n  for (int i = 0; i < numThreads; i++) {\n    A[i] = i;\n  }\n  // Calculate number of prime numbers \n#pragma omp parallel\n  {\n#pragma omp task\n    {\n      int idx = 0;\n      omp_set_lock(&lock);\n      {\n        count++;\n        idx = count - 1;\n      }\n      omp_unset_lock(&lock);\n      int ret = isPrime(A[idx]);\n      omp_set_lock(&lock);\n      {\n        if (ret == 0) {\n          countPrime++;\n        }\n      }\n      omp_unset_lock(&lock);\n    }\n  }\n  free(A);\n  omp_destroy_lock(&lock);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, countPrime != expectedVal);\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithLockBasic(4));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithLockBasic(8));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithLockBasic(16));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithLockBasic(32));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithLockBasic(64));\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithLockAdvanced(1, 0));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithLockAdvanced(4, 2));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithLockAdvanced(8, 4));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithLockAdvanced(16, 6));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithLockAdvanced(32, 11));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithLockAdvanced(64, 18));\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_parallel_master.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===--- test_parallel_master.c ---------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the parallel master directive. The test performs simple\n// operations on an int array which are then checked for correctness.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_parallel_master() {\n  OMPVV_INFOMSG(\"test_parallel_master\");\n  int errors = 0;\n  int num_threads = -1;\n  int x[N];\n  int y[N];\n  int z[N];\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 1;\n    y[i] = i + 1;\n    z[i] = 2*(i + 1);\n  }\n\n#pragma omp parallel master num_threads(OMPVV_NUM_THREADS_HOST) shared(x, y, z, num_threads)\n  {\n#pragma omp taskloop\n    for (int i = 0; i < N; i++) {\n      x[i] += y[i]*z[i];\n    }\n    num_threads = omp_get_num_threads();\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != 1 + (y[i]*z[i]));\n  }\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of parallel master with taskloop can't be guaranteed.\");\n  OMPVV_ERROR_IF(num_threads < 1, \"Test returned an invalid number of threads.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n\n  return errors;\n}\n\n\nint main() {\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_parallel_master());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nlong eokzkmgjqt = 132;\nint uglrlltjoz = 117;\nshort gceedxgifv = 254;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_nowait_argument.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp begin\" with directive \"#pragma omp teams\" at position 375",
        "issue_id": 0,
        "original_code": "//===------ test_target_nowait_argument.c ------------------------------------===//\n//\n// OpenMP API Version 6.0 \n//\n// Tests the target directive with the nowait clause with the do_not_synchronize \n// argument.\n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#pragma omp begin declare target\nvoid update(int* num) {\n \n    *num = (*num) * 3;\n}\n#pragma omp end declare target\n\nint test_target_nowait_argument(int is_deferred) { \n\n  int errors = 0;\n  int x = 2, y = 3 ;\n\n\n  #pragma omp target nowait(is_deferred) map(tofrom: x)\n  {\n    update(&x); \n  }\n\n  if(is_deferred){\n    update(&y);\n  } else {\n    update(&x);\n  }\n  \n\n  if(is_deferred){\n    if( y != 9){\n      errors++;\n    }\n    #pragma omp taskwait //needed to finish deferred task before return from function\n    if( x != 6){\n      errors++;\n    }\n  } else {\n    if( x != 18){\n      errors++;\n    }\n  }\n\n  return errors;\n}\n\n\nint main(int argc, char*argv[]){\n\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_nowait_argument(0) != 0);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_nowait_argument(1) != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n}\n\n",
        "error_code": "//===------ test_target_nowait_argument.c ------------------------------------===//\n//\n// OpenMP API Version 6.0 \n//\n// Tests the target directive with the nowait clause with the do_not_synchronize \n// argument.\n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#pragma omp teams declare target\nvoid update(int* num) {\n \n    *num = (*num) * 3;\n}\n#pragma omp end declare target\n\nint test_target_nowait_argument(int is_deferred) { \n\n  int errors = 0;\n  int x = 2, y = 3 ;\n\n\n  #pragma omp target nowait(is_deferred) map(tofrom: x)\n  {\n    update(&x); \n  }\n\n  if(is_deferred){\n    update(&y);\n  } else {\n    update(&x);\n  }\n  \n\n  if(is_deferred){\n    if( y != 9){\n      errors++;\n    }\n    #pragma omp taskwait //needed to finish deferred task before return from function\n    if( x != 6){\n      errors++;\n    }\n  } else {\n    if( x != 18){\n      errors++;\n    }\n  }\n\n  return errors;\n}\n\n\nint main(int argc, char*argv[]){\n\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_nowait_argument(0) != 0);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_nowait_argument(1) != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_declare_target_device_type_any.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===---- test_declare_target_device_type_any.c -------------------------------------===//\n// \n// OpenMP API Version 5.0 \n//\n// The declare target directive specifies that variables, functions(C,C++ and Fortran),\n// and subroutines (Fortran) are mapped to a device. If a device_type\n// clause is present on the contained declare target directive, then its argument \n// determines which versions are made available. When device_type(any) is specified \n// both device and host versions of the procedure are made available.\n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\nint errors = 0;\n\n#pragma omp declare target \nint a[N], b[N], c[N];  \nint i = 0;\n#pragma omp end declare target\n\nvoid update() { \n  for (i = 0; i < N; i++) {\n    a[i] += 1;\n    b[i] += 2;\n    c[i] += 3;\n  }\n}\n\n#pragma omp declare target to(update) device_type(any) \n\nint test_declare_target_device_type_any() { \n  \n  #pragma omp target update to(a,b,c) \n  #pragma omp target \n  {\n    update();\n  }\n  #pragma omp target update from( a, b, c)\n  \n\n  for (i = 0; i < N; i++) { //check array values on host\n    if ( a[i] != i + 1 || b[i] != i + 3 || c[i] != i + 5) {\n      errors++;  \n    } \n  }\n\n  //on host\n  update();\n\n  for (i = 0; i < N; i++) { //check array values on host\n    if ( a[i] != i + 2 || b[i] != i + 5 || c[i] != i + 8) {\n      errors++;\n    }\n  }\n  \n  return errors;\n}\n\nint main () {\n  \n  //initalize arrays on host\n  for (i = 0; i < N; i++) {\n    a[i] = i;\n    b[i] = i + 1;\n    c[i] = i + 2;\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_declare_target_device_type_any());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}  \n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nbyte cmoipjfpih = 14;\nfloat oytqngpaaa = 7;\ndouble qeeqzvnrid = 35;\nint imqisdeepx = 47;\nbyte lllrukamwk = 195;\ndouble wmstmbijbq = 70;\nfloat vbrtqrokyi = 78;\nlong eefpowtopv = 153;\nbyte yyrskrtfmm = 161;\nlong erzxgxkwwd = 64;\ndouble lzabewwezt = 126;\nlong uctloviqpo = 15;\nfloat dllisygqbr = 31;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_omp_num_teams_env_2.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//--------------- test_omp_num_teams_env_2.c---------------------//\n//\n// OpenMP API Version 5.1 Aug 2021\n//\n// The objective of this test is to check that the num_teams env\n// var is set properly. It is important to note that the name of the test\n// is very important to the env var being set. It follows a convention set\n// up for testing env variables in run.sh. This test itself simply checks\n// that the max number of teams is set to the appropriate variable value specified\n// in the test name. \n//-----------------------------------------------------------------------//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\nint test_case(){\n\tint errors = 0;\n\tint env = 10;\n\tenv = omp_get_max_teams();\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, env != 2);\n\tOMPVV_INFOMSG_IF(env == 0, \"Environment variable not set\");\n\tOMPVV_INFOMSG_IF(env == 10, \"Call to omp_get_max_teams() did not update local variable\");\n\treturn errors;\n}\n\nint main(){\n\tint errors = 0;\n\tOMPVV_TEST_OFFLOADING;\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_case() != 0);\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nshort rdhkddgjtg = 49;\nfloat kqdddiufvn = 56;\nbyte vfhrajnvin = 60;\nlong eixgtfqsxv = 53;\nshort ibscbkevoz = 51;\ndouble xahmdvfonl = 161;\nbyte nopupezrpn = 159;\nint kggmtfvqwh = 225;\nint jrtkmafwwi = 119;\ndouble tffotxzkhf = 164;\nfloat qolifmrggl = 167;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_loop_bind_device.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 6316",
        "issue_id": 2,
        "original_code": "//===--- test_loop_bind_device.c --------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the loop directive with the bind(binding) clause. The bind\n// clause indicates that the loop construct should apply in the context of the\n// given binding, one of teams, parallel, or thread. Each of these bindings\n// is tested in an appropriate context and the correctness of results of\n// array operations in the nested loop is checked. This test checks these\n// directives in a target context.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 32\n\nint test_loop_bind_teams() {\n  OMPVV_INFOMSG(\"test_loop_bind_teams\");\n  int errors = 0;\n  int x[N][N];\n  int y[N];\n  int z[N];\n  int num_teams = -1;\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      x[i][j] = 1;\n    }\n    y[i] = i;\n    z[i] = 2*i;\n  }\n\n#pragma omp target teams num_teams(OMPVV_NUM_TEAMS_DEVICE) thread_limit(OMPVV_NUM_THREADS_HOST) map(tofrom: x, y, z, num_teams)\n  {\n#pragma omp loop bind(teams)\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        x[i][j] += y[i]*z[i];\n      }\n    }\n    #pragma omp parallel if(0)\n    if (omp_get_team_num() == 0) {\n      num_teams = omp_get_num_teams();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, x[i][j] != 1 + (y[i]*z[i]));\n    }\n  }\n\n\n  OMPVV_WARNING_IF(num_teams == 1, \"Test ran with one team, so parallelism of loop construct with bind(teams) can't be guaranteed.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_teams < 1);\n  OMPVV_ERROR_IF(num_teams < 1, \"omp_get_num_teams() returned an invalid number of teams.\");\n\n  return errors;\n}\n\nint test_loop_bind_parallel() {\n  OMPVV_INFOMSG(\"test_loop_bind_parallel\");\n  int errors = 0;\n  int x[N][N];\n  int y[N];\n  int z[N];\n  int num_threads = -1;\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      x[i][j] = 1;\n    }\n    y[i] = i;\n    z[i] = 2*i;\n  }\n\n#pragma omp target parallel num_threads(OMPVV_NUM_THREADS_HOST) map(tofrom: x, y, z, num_threads)\n  {\n#pragma omp loop bind(parallel)\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        x[i][j] += y[i]*z[i];\n      }\n    }\n    if (omp_get_thread_num() == 0 && omp_get_team_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, x[i][j] != 1 + (y[i]*z[i]));\n    }\n  }\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of loop construct can't be guaranteed.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n  OMPVV_ERROR_IF(num_threads < 1, \"omp_get_num_threads() returned an invalid number of threads.\");\n\n  return errors;\n}\n\nint test_loop_bind_thread_teams() {\n  OMPVV_INFOMSG(\"test_loop_bind_thread_teams\");\n  int errors = 0;\n  int y[N];\n  int z[N];\n  int result[N][N][OMPVV_NUM_TEAMS_DEVICE];\n  int num_teams = -1;\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      for (int k = 0; k < OMPVV_NUM_TEAMS_DEVICE; k++) {\n        result[i][j][k] = 1;\n      }\n    }\n    y[i] = i;\n    z[i] = 2*i;\n  }\n\n#pragma omp target teams num_teams(OMPVV_NUM_TEAMS_DEVICE) thread_limit(OMPVV_NUM_THREADS_HOST) map(tofrom: result, y, z, num_teams)\n  {\n    int x[N][N];\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        x[i][j] = 1;\n      }\n    }\n#pragma omp loop bind(thread)\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        x[i][j] += y[i]*z[i];\n      }\n    }\n    #pragma omp parallel if(0)\n    if (omp_get_team_num() == 0) {\n      num_teams = omp_get_num_teams();\n    }\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        result[i][j][omp_get_team_num()] = x[i][j];\n      }\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      for (int k = 0; k < num_teams; k++) {\n        OMPVV_TEST_AND_SET_VERBOSE(errors, result[i][j][k] != (1 + (y[i]*z[i])));\n      }\n    }\n  }\n\n  OMPVV_WARNING_IF(num_teams == 1, \"Test ran with one team, so parallelism of loop construct can't be guaranteed.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_teams < 1);\n  OMPVV_ERROR_IF(num_teams < 1, \"omp_get_num_teams() returned an invalid number of teams.\");\n\n  return errors;\n}\n\nint test_loop_bind_thread_parallel() {\n  OMPVV_INFOMSG(\"test_loop_bind_thread_parallel\");\n  int errors = 0;\n  int y[N];\n  int z[N];\n  int result[N][N][OMPVV_NUM_THREADS_HOST];\n  int num_threads = -1;\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      for (int k = 0; k < OMPVV_NUM_THREADS_HOST; k++) {\n        result[i][j][k] = 1;\n      }\n    }\n    y[i] = i;\n    z[i] = 2*i;\n  }\n\n#pragma omp target parallel shared(result) num_threads(OMPVV_NUM_THREADS_HOST) map(tofrom: result, y, z, num_threads)\n  {\n    int x[N][N];\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        x[i][j] = 1;\n      }\n    }\n#pragma omp loop bind(thread)\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        x[i][j] += y[i]*z[i];\n      }\n    }\n    if (omp_get_thread_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        result[i][j][omp_get_thread_num()] = x[i][j];\n      }\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      for (int k = 0; k < num_threads; k++) {\n        OMPVV_TEST_AND_SET_VERBOSE(errors, result[i][j][k] != (1 + (y[i]*z[i])));\n      }\n    }\n  }\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of loop construct can't be guaranteed.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n  OMPVV_ERROR_IF(num_threads < 1, \"omp_get_num_threads() returned an invalid number of threads.\");\n\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_loop_bind_teams());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_loop_bind_parallel());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_loop_bind_thread_teams());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_loop_bind_thread_parallel());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_loop_bind_device.c --------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the loop directive with the bind(binding) clause. The bind\n// clause indicates that the loop construct should apply in the context of the\n// given binding, one of teams, parallel, or thread. Each of these bindings\n// is tested in an appropriate context and the correctness of results of\n// array operations in the nested loop is checked. This test checks these\n// directives in a target context.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 32\n\nint test_loop_bind_teams() {\n  OMPVV_INFOMSG(\"test_loop_bind_teams\");\n  int errors = 0;\n  int x[N][N];\n  int y[N];\n  int z[N];\n  int num_teams = -1;\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      x[i][j] = 1;\n    }\n    y[i] = i;\n    z[i] = 2*i;\n  }\n\n#pragma omp target teams num_teams(OMPVV_NUM_TEAMS_DEVICE) thread_limit(OMPVV_NUM_THREADS_HOST) map(tofrom: x, y, z, num_teams)\n  {\n#pragma omp loop bind(teams)\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        x[i][j] += y[i]*z[i];\n      }\n    }\n    #pragma omp parallel if(0)\n    if (omp_get_team_num() == 0) {\n      num_teams = omp_get_num_teams();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, x[i][j] != 1 + (y[i]*z[i]));\n    }\n  }\n\n\n  OMPVV_WARNING_IF(num_teams == 1, \"Test ran with one team, so parallelism of loop construct with bind(teams) can't be guaranteed.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_teams < 1);\n  OMPVV_ERROR_IF(num_teams < 1, \"omp_get_num_teams() returned an invalid number of teams.\");\n\n  return errors;\n}\n\nint test_loop_bind_parallel() {\n  OMPVV_INFOMSG(\"test_loop_bind_parallel\");\n  int errors = 0;\n  int x[N][N];\n  int y[N];\n  int z[N];\n  int num_threads = -1;\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      x[i][j] = 1;\n    }\n    y[i] = i;\n    z[i] = 2*i;\n  }\n\n#pragma omp target parallel num_threads(OMPVV_NUM_THREADS_HOST) map(tofrom: x, y, z, num_threads)\n  {\n#pragma omp loop bind(parallel)\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        x[i][j] += y[i]*z[i];\n      }\n    }\n    if (omp_get_thread_num() == 0 && omp_get_team_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, x[i][j] != 1 + (y[i]*z[i]));\n    }\n  }\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of loop construct can't be guaranteed.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n  OMPVV_ERROR_IF(num_threads < 1, \"omp_get_num_threads() returned an invalid number of threads.\");\n\n  return errors;\n}\n\nint test_loop_bind_thread_teams() {\n  OMPVV_INFOMSG(\"test_loop_bind_thread_teams\");\n  int errors = 0;\n  int y[N];\n  int z[N];\n  int result[N][N][OMPVV_NUM_TEAMS_DEVICE];\n  int num_teams = -1;\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      for (int k = 0; k < OMPVV_NUM_TEAMS_DEVICE; k++) {\n        result[i][j][k] = 1;\n      }\n    }\n    y[i] = i;\n    z[i] = 2*i;\n  }\n\n#pragma omp target teams num_teams(OMPVV_NUM_TEAMS_DEVICE) thread_limit(OMPVV_NUM_THREADS_HOST) map(tofrom: result, y, z, num_teams)\n  {\n    int x[N][N];\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        x[i][j] = 1;\n      }\n    }\n#pragma omp loop bind(thread)\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        x[i][j] += y[i]*z[i];\n      }\n    }\n    #pragma omp parallel if(0)\n    if (omp_get_team_num() == 0) {\n      num_teams = omp_get_num_teams();\n    }\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        result[i][j][omp_get_team_num()] = x[i][j];\n      }\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      for (int k = 0; k < num_teams; k++) {\n        OMPVV_TEST_AND_SET_VERBOSE(errors, result[i][j][k] != (1 + (y[i]*z[i])));\n      }\n    }\n  }\n\n  OMPVV_WARNING_IF(num_teams == 1, \"Test ran with one team, so parallelism of loop construct can't be guaranteed.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_teams < 1);\n  OMPVV_ERROR_IF(num_teams < 1, \"omp_get_num_teams() returned an invalid number of teams.\");\n\n  return errors;\n}\n\nint test_loop_bind_thread_parallel() {\n  OMPVV_INFOMSG(\"test_loop_bind_thread_parallel\");\n  int errors = 0;\n  int y[N];\n  int z[N];\n  int result[N][N][OMPVV_NUM_THREADS_HOST];\n  int num_threads = -1;\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      for (int k = 0; k < OMPVV_NUM_THREADS_HOST; k++) {\n        result[i][j][k] = 1;\n      }\n    }\n    y[i] = i;\n    z[i] = 2*i;\n  }\n\n#pragma omp target parallel shared(result) num_threads(OMPVV_NUM_THREADS_HOST) map(tofrom: result, y, z, num_threads)\n  {\n    int x[N][N];\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        x[i][j] = 1;\n      }\n    }\n#pragma omp loop bind(thread)\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        x[i][j] += y[i]*z[i];\n      }\n    }\n    if (omp_get_thread_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        result[i][j][omp_get_thread_num()] = x[i][j];\n      }\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      for (int k = 0; k < num_threads; k++) {\n        OMPVV_TEST_AND_SET_VERBOSE(errors, result[i][j][k] != (1 + (y[i]*z[i])));\n      }\n    }\n  }\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of loop construct can't be guaranteed.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n  OMPVV_ERROR_IF(num_threads < 1, \"omp_get_num_threads() returned an invalid number of threads.\");\n\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_loop_bind_teams());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_loop_bind_parallel());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_loop_bind_thread_teams());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_loop_bind_thread_parallel());yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_depend_in_out.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 1118",
        "issue_id": 2,
        "original_code": "//===--- test_target_teams_distribute_depend_in_out.c-------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks in-out and in-inout dependency by checking order-dependent\n// results from pairs of possibly asynchronous loops. The test fails if either \n// in-out or in-inout dependency is broken.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_target_teams_distribute_depend_in_out() {\n  int isOffloading = 0;\n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int errors = 0;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n    b[x] = 2 * x;\n    c[x] = 0;\n    d[x] = 0;\n  }\n\n#pragma omp target data map(to: a[0:N], b[0:N]) map(alloc: c[0:N]) map(from: d[0:N])\n  {\n#pragma omp target teams distribute nowait depend(in: c) map(alloc: a[0:N], b[0:N], c[0:N])\n    for (int x = 0; x < N; ++x) {\n      c[x] = a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(out: c) map(alloc: b[0:N], c[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n      d[x] = c[x] + b[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, d[x] != 5*x);\n    OMPVV_ERROR_IF(d[x] != 5*x, \"Test of depend(out) task becoming dependent on depend(in) task failed.\");\n  }\n\n#pragma omp target data map(to: a[0:N], b[0:N]) map(alloc: c[0:N]) map(from: d[0:N])\n  {\n#pragma omp target teams distribute nowait depend(in: c) map(alloc: a[0:N], b[0:N], c[0:N])\n    for (int x = 0; x < N; ++x) {\n      c[x] = a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(inout: c) map(alloc: a[0:N], c[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n      d[x] = c[x] + a[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, d[x] != 4*x);\n    OMPVV_ERROR_IF(d[x] != 4*x, \"Test of depend(inout) task becoming dependent on depend(in) task failed.\");\n  }\n\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  errors += test_target_teams_distribute_depend_in_out();\n  OMPVV_INFOMSG_IF(errors != 0, \"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_depend_in_out.c-------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks in-out and in-inout dependency by checking order-dependent\n// results from pairs of possibly asynchronous loops. The test fails if either \n// in-out or in-inout dependency is broken.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_target_teams_distribute_depend_in_out() {\n  int isOffloading = 0;\n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int errors = 0;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n    b[x] = 2 * x;\n    c[x] = 0;\n    d[x] = 0;\n  }\n\n#pragma omp target data map(to: a[0:N], b[0:N]) map(alloc: c[0:N]) map(from: d[0:N])\n  {\n#pragma omp target teams distribute nowait depend(in: c) map(alloc: a[0:N], b[0:N], c[0:N])\n    for (int x = 0; x < N; ++x) {\n      c[x] = a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(out: c) map(alloc: b[0:N], c[0:N], d[0:N])\n    for (int x = 0; x < N;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1; ++x) {\n      d[x] = c[x] + b[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, d[x] != 5*x);\n    OMPVV_ERROR_IF(d[x] != 5*x, \"Test of depend(out) task becoming dependent on depend(in) task failed.\");\n  }\n\n#pragma omp target data map(to: a[0:N], b[0:N]) map(alloc: c[0:N]) map(from: d[0:N])\n  {\n#pragma omp target teams distribute nowait depend(in: c) map(alloc: a[0:N], b[0:N], c[0:N])\n    for (int x = 0; x < N; ++x) {\n      c[x] = a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(inout: c) map(alloc: a[0:N], c[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n      d[x] = c[x] + a[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, d[x] != 4*x);\n    OMPVV_ERROR_IF(d[x] != 4*x, \"Test of depend(inout) task becoming dependent on depend(in) task failed.\");\n  }\n\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  errors += test_target_teams_distribute_depend_in_out();\n  OMPVV_INFOMSG_IF(errors != 0, \"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_uses_allocators_default.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp master\" at position 720",
        "issue_id": 0,
        "original_code": "//===--- test_target_uses_allocators_default.c ----------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// The tests checks the uses_allocators clause with omp_default_mem_alloc.\n// The variable allaocated in the target is modified. Result is copied back to\n// the host and checked with computed value on host.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_uses_allocators_default() {\n  int errors = 0;\n  int x = 0;\n  int device_result = 0;\n  int result = 0;\n\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      result += j + i ;\n    }\n  }\n\n#pragma omp target uses_allocators(omp_default_mem_alloc) allocate(omp_default_mem_alloc: x) firstprivate(x) map(from: device_result)\n{\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      x += j + i;\n    }\n  }\n  device_result = x;\n}\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != device_result);\n\n  return errors;\n}\n\nint main() {\n\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_uses_allocators_default() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n",
        "error_code": "//===--- test_target_uses_allocators_default.c ----------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// The tests checks the uses_allocators clause with omp_default_mem_alloc.\n// The variable allaocated in the target is modified. Result is copied back to\n// the host and checked with computed value on host.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_uses_allocators_default() {\n  int errors = 0;\n  int x = 0;\n  int device_result = 0;\n  int result = 0;\n\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      result += j + i ;\n    }\n  }\n\n#pragma omp master uses_allocators(omp_default_mem_alloc) allocate(omp_default_mem_alloc: x) firstprivate(x) map(from: device_result)\n{\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      x += j + i;\n    }\n  }\n  device_result = x;\n}\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != device_result);\n\n  return errors;\n}\n\nint main() {\n\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_uses_allocators_default() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/gridmini_ptr.cpp",
        "correct": "n",
        "issue": "Removed opening bracket at position 1237",
        "issue_id": 1,
        "original_code": "//===-- gridmini_map_struct_array.cpp ---------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks that the float multiplication of array elements which is a \n// member of the struct 'vec'in the offloaded region provides the same answer \n// as calculated by host. The test also checks for support for ptr notations.\n//\n//===----------------------------------------------------------------------===//\n\n#include <cstdlib>\n#include <stdio.h>\n#include <iostream>\n#include \"ompvv.h\"\n#include \"omp.h\"\n\nusing namespace std;\nstruct vec {\n  float v[2];\n};\n\ninline  void mult(vec *out, vec x, vec y){\n  out->v[0] = x.v[0] * y.v[0];\n  out->v[1] = x.v[1] * y.v[1];\n}\n\nint main(int argc, char* argv[]){\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n  int N = 10;\n  float x = (float)rand()/(float)(RAND_MAX/10.0);\n  float y = (float)rand()/(float)(RAND_MAX/5.0);\n  vec in1,in2;\n  in1.v[0] = x;\n  in1.v[1] = x;\n  in2.v[0] = y;\n  in2.v[1] = y;\n  vec out[N];\n\n  //calulate on host\n  vec expected;\n  mult(&expected,in1,in2);\n\n#pragma omp target teams distribute parallel for map(to:in1,in2) map(from:out[0:N])\n    for(int n = 0; n < N; n++) {\n      mult(out+n, in1, in2);\n    }\n    \n  for(int n = 0; n < N; n++) {\n    OMPVV_TEST_AND_SET(errors,out[n].v[0] != expected.v[0]);\n    OMPVV_TEST_AND_SET(errors,out[n].v[0] != expected.v[1]);\n  }\n\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n}\n\n",
        "error_code": "//===-- gridmini_map_struct_array.cpp ---------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks that the float multiplication of array elements which is a \n// member of the struct 'vec'in the offloaded region provides the same answer \n// as calculated by host. The test also checks for support for ptr notations.\n//\n//===----------------------------------------------------------------------===//\n\n#include <cstdlib>\n#include <stdio.h>\n#include <iostream>\n#include \"ompvv.h\"\n#include \"omp.h\"\n\nusing namespace std;\nstruct vec {\n  float v[2];\n};\n\ninline  void mult(vec *out, vec x, vec y){\n  out->v[0] = x.v[0] * y.v[0];\n  out->v[1] = x.v[1] * y.v[1];\n}\n\nint main(int argc, char* argv[]){\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n  int N = 10;\n  float x = (float)rand()/(float)(RAND_MAX/10.0);\n  float y = (float)rand()/(float)(RAND_MAX/5.0);\n  vec in1,in2;\n  in1.v[0] = x;\n  in1.v[1] = x;\n  in2.v[0] = y;\n  in2.v[1] = y;\n  vec out[N];\n\n  //calulate on host\n  vec expected;\n  mult(&expected,in1,in2);\n\n#pragma omp target teams distribute parallel for map(to:in1,in2) map(from:out[0:N])\n    for(int n = 0; n < N; n++) {\n      mult(out+n, in1, in2);\n    }\n    \n  for(int n = 0; n < N; n++) \n    OMPVV_TEST_AND_SET(errors,out[n].v[0] != expected.v[0]);\n    OMPVV_TEST_AND_SET(errors,out[n].v[0] != expected.v[1]);\n  }\n\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_shared.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===--- test_target_teams_distribute_shared.c-------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the shared clause on a target teams distribute directive and\n// tests in a few ways that the variable is shared between the teams.  In the\n// first test, the atomic directive is used to indicate that all operations on\n// the variable should be done atomically.  If the value is the correct value\n// at the end of the region, then all teams operated on the same variable, and\n// the variable was not privatized.\n//\n// The second test, instead of writing to the variable, only reads from the\n// variable.  This tests that the value of the shared variable has not been\n// initialized improperly.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define SIZE 1024\n\nint main() {\n  int is_offloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n  int a[SIZE];\n  int share = 0;\n  int errors = 0;\n  int num_teams;\n\n  for (int x = 0; x < SIZE; ++x) {\n    a[x] = x;\n  }\n\n  // The defaultmap(tofrom:scalar) is used here because the OpenMP 4.5 specification\n  // forbids the use of map and data-sharing clauses on the same list item in the\n  // same construct. See pg. 218, lines 15-16.\n#pragma omp target teams distribute num_teams(OMPVV_NUM_TEAMS_DEVICE) shared(share, num_teams) map(to: a[0:SIZE]) defaultmap(tofrom:scalar)\n  for (int x = 0; x < SIZE; ++x) {\n#pragma omp atomic write\n    num_teams = omp_get_num_teams();\n#pragma omp atomic\n    share = share + a[x];\n  }\n\n  for (int x = 0; x < SIZE; ++x) {\n    share = share - x;\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (share != 0));\n  OMPVV_ERROR_IF(errors != 0, \"The value of share is = %d but expected 0.\", share);\n\n  share = 5;\n\n#pragma omp target data map(tofrom: a[0:SIZE]) map(tofrom: share)\n  {\n#pragma omp target teams distribute num_teams(OMPVV_NUM_TEAMS_DEVICE) shared(share)\n    for (int x = 0; x < SIZE; ++x) {\n      a[x] = a[x] + share;\n    }\n  }\n\n  for (int x = 0; x < SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (a[x] - 5 != x));\n  }\n\n  if (num_teams == 1) {\n    OMPVV_WARNING(\"Test operated on one team, results of default shared test are inconclusive.\");\n  }\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nint eehyvgwjrf = 177;\nshort mawlpwjlpo = 70;\nint ukhsmuleda = 73;\nshort oxeriauera = 184;\nint lnkkhbgwur = 231;\ndouble ajyvbgrdza = 55;\ndouble kztnhqberd = 236;\nbyte dhdzxgxvhe = 174;\nint gfkynjslvq = 206;\nfloat owtrlpcqxl = 111;\nfloat nrdnhrfeac = 133;\nshort gjefvksunh = 79;\nbyte yohyahiyxh = 141;\nlong cfixynjrlj = 99;\nfloat nsaibytcwc = 223;\nfloat usovdyhlib = 15;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_omp_places_env_ll_caches.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n\tint errors = 0;\n\tOMPVV_TEST_OFFLOADING;\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_places() != 0);\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\" at position 738",
        "issue_id": 4,
        "original_code": "//-----------------test_omp_places_ll_caches.c---------------//\n//\n//OpenMP API Version 5.1 Aug 2021\n//\n//Tests the omp_places environment variable. This test sets the\n//omp_places environment variable and then retrieves it from the\n//environment. If the architecture supports the ll_caches \n//argument then the retrieved value will be ll_caches.\n//-------------------------------------------------------------\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\nint test_places(){\n\tint errors = 0;\n\tint test = 1;\n\tchar* ret_val = NULL;\n\tret_val = getenv(\"OMP_PLACES\");\n\ttest = ret_val == NULL || strcmp(ret_val, \"ll_caches\");\n\tOMPVV_TEST_AND_SET(errors,test != 0);\n\treturn errors;\n}\n\nint main(){\n\tint errors = 0;\n\tOMPVV_TEST_OFFLOADING;\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_places() != 0);\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//-----------------test_omp_places_ll_caches.c---------------//\n//\n//OpenMP API Version 5.1 Aug 2021\n//\n//Tests the omp_places environment variable. This test sets the\n//omp_places environment variable and then retrieves it from the\n//environment. If the architecture supports the ll_caches \n//argument then the retrieved value will be ll_caches.\n//-------------------------------------------------------------\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\nint test_places(){\n\tint errors = 0;\n\tint test = 1;\n\tchar* ret_val = NULL;\n\tret_val = getenv(\"OMP_PLACES\");\n\ttest = ret_val == NULL || strcmp(ret_val, \"ll_caches\");\n\tOMPVV_TEST_AND_SET(errors,test != 0);\n\treturn errors;\n}\n\nint main()\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/gridmini_map_template_array.cpp",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 938",
        "issue_id": 2,
        "original_code": "//===-- gridmini_map_struct_array.cpp ---------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks support for C++ template via mult on array elements. The\n// array is a member of the struct 'vec'in the offloaded region provides the same answer \n// as calculated by host. \n//\n//===----------------------------------------------------------------------===//\n\n#include <cstdlib>\n#include <stdio.h>\n#include <iostream>\n#include \"ompvv.h\"\n#include \"omp.h\"\n\nusing namespace std;\ntemplate <typename T>\nstruct vec {\n  T v[2];\n};\n\ntemplate <typename T> vec<T> mult(vec<T> x, vec<T> y){\n  vec<T> out;\n  out.v[0] = x.v[0]*y.v[0];\n  out.v[1] = x.v[1]*y.v[1];\n  return out;\n}\n\nint main(int argc, char* argv[]){\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n  int N = 10;\n  float x = (float)rand()/(float)(RAND_MAX/10.0);\n  float y = (float)rand()/(float)(RAND_MAX/5.0);\n  vec<float> in1,in2;\n  in1.v[0] = x;\n  in1.v[1] = x;\n  in2.v[0] = y;\n  in2.v[1] = y;\n  vec<float> out[N];\n\n  //calulate on host\n  vec<float> expected = mult(in1,in2);\n\n#pragma omp target teams distribute parallel for map(to:in1,in2) map(from:out[0:N])\n    for(int n = 0; n < N; n++) {\n      out[n] = mult(in1,in2);\n    }\n    \n  for(int n = 0; n < N; n++) {\n    OMPVV_TEST_AND_SET(errors,out[n].v[0] != expected.v[0]);\n    OMPVV_TEST_AND_SET(errors,out[n].v[0] != expected.v[1]);\n  }\n\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n}\n\n",
        "error_code": "//===-- gridmini_map_struct_array.cpp ---------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks support for C++ template via mult on array elements. The\n// array is a member of the struct 'vec'in the offloaded region provides the same answer \n// as calculated by host. \n//\n//===----------------------------------------------------------------------===//\n\n#include <cstdlib>\n#include <stdio.h>\n#include <iostream>\n#include \"ompvv.h\"\n#include \"omp.h\"\n\nusing namespace std;\ntemplate <typename T>\nstruct vec {\n  T v[2];\n};\n\ntemplate <typename T> vec<T> mult(vec<T> x, vec<T> y){\n  vec<T> out;\n  out.v[0] = x.v[0]*y.v[0];\n  out.v[1] = x.v[1]*y.v[1];\n  return out;\n}\n\nint main(int argc, char* argv[]){\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n  int N = 10;\n  float x = (float)rand()/(float)(RAND_MAX/10.0);\n  float y = (float)rand()/(float)(RAND_MAX/5.0);\n  vec<float> in1,in2;\n  in1.v[0] = x;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n  in1.v[1] = x;\n  in2.v[0] = y;\n  in2.v[1] = y;\n  vec<float> out[N];\n\n  //calulate on host\n  vec<float> expected = mult(in1,in2);\n\n#pragma omp target teams distribute parallel for map(to:in1,in2) map(from:out[0:N])\n    for(int n = 0; n < N; n++) {\n      out[n] = mult(in1,in2);\n    }\n    \n  for(int n = 0; n < N; n++) {\n    OMPVV_TEST_AND_SET(errors,out[n].v[0] != expected.v[0]);\n    OMPVV_TEST_AND_SET(errors,out[n].v[0] != expected.v[1]);\n  }\n\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_map_zero_length_pointer.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1465",
        "issue_id": 1,
        "original_code": "//===--- test_target_map_zero_length_pointer.c -----------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// If a pointer is referenced in a target construct, not declared in the target \n// construct, and does not appear in a data-sharing attribute or map clause, it\n// is treated as if it appeared in a map clause as a zero-length array section. \n// This test checks this rule by giving a pointer the address of an array, \n// mapping that array to a device with tofrom map-type, and then changing the \n// values of the array on the device using the pointer. Finally, back on the \n// host the array is checked in order to confirm that values were properly \n// modified through the pointer.\n//\n////===---------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\n//Test non-specified mapping of pointer as a zero-length array in a map clause\nint test_zero_length_pointer() {\n  int compute_array[N];\n  int *p;\n  int sum = 0, result = 0, errors = 0;\n  int i;\n \n  for (i = 0; i < N; i++)\n    compute_array[i] = 0;\n  \n  p = &compute_array[0];\n\n#pragma omp target data map(tofrom: compute_array)\n#pragma omp target\n  {\n  for (i = 0; i < N; i++)\n    p[i] = i;\n  } // end target\n\n  for (i = 0; i < N; i++)\n    sum = sum + compute_array[i];\n\n  for (i = 0; i < N; i++)\n    result += i;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != sum);\n\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n    \n  int isOffloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n \n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_zero_length_pointer());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_map_zero_length_pointer.c -----------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// If a pointer is referenced in a target construct, not declared in the target \n// construct, and does not appear in a data-sharing attribute or map clause, it\n// is treated as if it appeared in a map clause as a zero-length array section. \n// This test checks this rule by giving a pointer the address of an array, \n// mapping that array to a device with tofrom map-type, and then changing the \n// values of the array on the device using the pointer. Finally, back on the \n// host the array is checked in order to confirm that values were properly \n// modified through the pointer.\n//\n////===---------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\n//Test non-specified mapping of pointer as a zero-length array in a map clause\nint test_zero_length_pointer() {\n  int compute_array[N];\n  int *p;\n  int sum = 0, result = 0, errors = 0;\n  int i;\n \n  for (i = 0; i < N; i++)\n    compute_array[i] = 0;\n  \n  p = &compute_array[0];\n\n#pragma omp target data map(tofrom: compute_array)\n#pragma omp target\n  {\n  for (i = 0; i < N; i++)\n    p[i] = i;\n  } // end target\n\n  for (i = 0; i < N; i++)\n    sum = sum + compute_array[i];\n\n  for (i = 0; i < N; i++)\n    result += i;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != sum);\n\n  return errors;\n}\n\nint main() \n  int errors = 0;\n    \n  int isOffloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n \n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_zero_length_pointer());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_metadirective_target_device_num.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 1185",
        "issue_id": 2,
        "original_code": "//===--------------------- test_metadirective_target_device_num.c ---------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n// \n// Tests that target_device is recognized & will work properly when there is\n// an available target device, and that device number is 0.\n//\n////===---------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_metadirective_target_device() {\n   int errors = 0;\n   int A[N];\n\n   for (int i = 0; i < N; i++) {\n      A[i] = 1;\n   }\n   int dev = omp_get_default_device();\n\n   #pragma omp target enter data map(alloc: A)\n\n   // Expect that device_num is 0, so the array should be mapped back.\n   #pragma omp metadirective \\\n      when( target_device={device_num(dev)}: target defaultmap(none) map(always,tofrom: A)) \\\n      default( target defaultmap(none) map(to: A))\n      for(int i = 0; i < N; i++){\n         A[i] = i;\n      }\n\n   for (int i = 0; i < N; i++) {\n      OMPVV_TEST_AND_SET(errors, A[i] != i);\n   }\n   #pragma omp target exit data map(release: A)\n   OMPVV_INFOMSG(\"Test ran with a number of available devices greater than 0\");\n\n   return errors;\n}\n\nint main () {\n  int errors = 0;\n  OMPVV_TEST_OFFLOADING;\n\n  if (omp_get_num_devices() > 0) {\n    errors = test_metadirective_target_device();\n  } else {\n    OMPVV_INFOMSG(\"Cannot test target_device without a target device!\")\n  }\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n  return 0;\n}\n\n",
        "error_code": "//===--------------------- test_metadirective_target_device_num.c ---------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n// \n// Tests that target_device is recognized & will work properly when there is\n// an available target device, and that device number is 0.\n//\n////===---------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_metadirective_target_device() {\n   int errors = 0;\n   int A[N];\n\n   for (int i = 0; i < N; i++) {\n      A[i] = 1;\n   }\n   int dev = omp_get_default_device();\n\n   #pragma omp target enter data map(alloc: A)\n\n   // Expect that device_num is 0, so the array should be mapped back.\n   #pragma omp metadirective \\\n      when( target_device={device_num(dev)}: target defaultmap(none) map(always,tofrom: A)) \\\n      default( target defaultmap(none) map(to: A))\n      for(int i = 0; i < N; i++){\n         A[i] = i;\n      }\n\n   for (int i = 0; i < N; i++) {\n      OMPVV_TEST_AND_SET(errors, A[i] != i);\n   }\n   #pragma omp target exit data map(release: A)\n   OMPVV_INFOMSG(\"Test ran with a number of available devices greater than 0\");yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n\n   return errors;\n}\n\nint main () {\n  int errors = 0;\n  OMPVV_TEST_OFFLOADING;\n\n  if (omp_get_num_devices() > 0) {\n    errors = test_metadirective_target_device();\n  } else {\n    OMPVV_INFOMSG(\"Cannot test target_device without a target device!\")\n  }\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n  return 0;\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_parallel_for_if_target_modifier.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp flush\" at position 2274",
        "issue_id": 0,
        "original_code": "//===---- test_target_teams_distribute_parallel_for_if_no_modifier.c --------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// In this test we want to try to check if the if clause is working \n// when used with the combined construct target teams distribute parallel for\n// and the target modifier is specified.\n// To do this we check if offloading is working, if it is not, it won't be\n// possible for us to tell if the test passed or not, since it depends on \n// offloading capabilities. \n//\n// The if has a directive-name-modifier that specifies to which directive the \n// if applies to (either both directives, to the target or to the parallel). \n// We have three tests: one for no directive, another for the target directive\n// and another for the parallel directive \n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define ATTEMPT_THRESHOLD 70\n#define NUM_ATTEMPTS 100\n#define N 1024\n\nint checkPreconditions() {\n  // We test if offloading is enable\n\n  // Testing for offloading\n  int isOffloading = 0;\n  int i;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"With offloading off, it is not possible to test if\");\n\n  return isOffloading;\n}\n\nint test_target_teams_distribute_if_target_modifier() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_if_target_modifier\");\n  \n  int a[N], warning[N];\n  int attempt = 0;\n  int errors = 0;\n  int i;\n  int isOffloading;\n\n  isOffloading = checkPreconditions();\n\n  for (i = 0; i < N; i++) {\n    a[i] = 1;\n    warning[i] = 0;\n  }\n\n  // We iterate NUM_ATTEMPTS times. When the iteration value is >= ATTEMPT_THRESHOLD the \n  // execution of the target region should happen in the device, and the number of threads\n  // is expected to be greater than 1 (although if it is not, this is not an error, just warning)\n  // If the iteration variable attempt  < ATTEMPT_THRESHOLD, then the if condition evaluates to false, \n  // and hence the execution should occur in the host, while the number of threads should not change\n  // We check that when we are executing on the host, the value of the iteration variable is \n  // greather than ATTEMPT_THRESHOLD\n  for (attempt = 0; attempt < NUM_ATTEMPTS; ++attempt) {\n#pragma omp target teams distribute parallel for if(target: attempt >= ATTEMPT_THRESHOLD)\\\n    map(tofrom: a) num_threads(OMPVV_NUM_THREADS_DEVICE)\n    for (i = 0; i < N; i++) {\n      warning[i] += (omp_get_num_threads() == 1) ? 1 : 0; // Ideally we should not change the number of threads at any point\n      if (attempt >= ATTEMPT_THRESHOLD) {\n        a[i] += (isOffloading && omp_is_initial_device() ? 10 : 0); // True condition, it should run on the device\n      }\n      else {\n        a[i] += (omp_is_initial_device() ? 1 : 100);\n      } \n    }\n  }\n\n  int raiseWarning = 0;\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, a[i] != 1 + (ATTEMPT_THRESHOLD));\n    if (warning[i] != 0) {\n      raiseWarning = 1;\n    }\n  }\n\n  OMPVV_WARNING_IF(raiseWarning != 0, \"The number of threads was 1 even though we expected it to be more than 1. Not a compliance error in the specs\");\n  OMPVV_ERROR_IF(errors, \"error in if(target: modifier). The execution was expected to occur in the device, but it happened in the host when if(false), or the other way around\");\n\n  return errors;\n}\n\nint main() {\n \n  int errors = 0;\n\n  //Offloading is checked in checkPreconditions() function\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_if_target_modifier());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_teams_distribute_parallel_for_if_no_modifier.c --------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// In this test we want to try to check if the if clause is working \n// when used with the combined construct target teams distribute parallel for\n// and the target modifier is specified.\n// To do this we check if offloading is working, if it is not, it won't be\n// possible for us to tell if the test passed or not, since it depends on \n// offloading capabilities. \n//\n// The if has a directive-name-modifier that specifies to which directive the \n// if applies to (either both directives, to the target or to the parallel). \n// We have three tests: one for no directive, another for the target directive\n// and another for the parallel directive \n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define ATTEMPT_THRESHOLD 70\n#define NUM_ATTEMPTS 100\n#define N 1024\n\nint checkPreconditions() {\n  // We test if offloading is enable\n\n  // Testing for offloading\n  int isOffloading = 0;\n  int i;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"With offloading off, it is not possible to test if\");\n\n  return isOffloading;\n}\n\nint test_target_teams_distribute_if_target_modifier() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_if_target_modifier\");\n  \n  int a[N], warning[N];\n  int attempt = 0;\n  int errors = 0;\n  int i;\n  int isOffloading;\n\n  isOffloading = checkPreconditions();\n\n  for (i = 0; i < N; i++) {\n    a[i] = 1;\n    warning[i] = 0;\n  }\n\n  // We iterate NUM_ATTEMPTS times. When the iteration value is >= ATTEMPT_THRESHOLD the \n  // execution of the target region should happen in the device, and the number of threads\n  // is expected to be greater than 1 (although if it is not, this is not an error, just warning)\n  // If the iteration variable attempt  < ATTEMPT_THRESHOLD, then the if condition evaluates to false, \n  // and hence the execution should occur in the host, while the number of threads should not change\n  // We check that when we are executing on the host, the value of the iteration variable is \n  // greather than ATTEMPT_THRESHOLD\n  for (attempt = 0; attempt < NUM_ATTEMPTS; ++attempt) {\n#pragma omp flush teams distribute parallel for if(target: attempt >= ATTEMPT_THRESHOLD)\\\n    map(tofrom: a) num_threads(OMPVV_NUM_THREADS_DEVICE)\n    for (i = 0; i < N; i++) {\n      warning[i] += (omp_get_num_threads() == 1) ? 1 : 0; // Ideally we should not change the number of threads at any point\n      if (attempt >= ATTEMPT_THRESHOLD) {\n        a[i] += (isOffloading && omp_is_initial_device() ? 10 : 0); // True condition, it should run on the device\n      }\n      else {\n        a[i] += (omp_is_initial_device() ? 1 : 100);\n      } \n    }\n  }\n\n  int raiseWarning = 0;\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, a[i] != 1 + (ATTEMPT_THRESHOLD));\n    if (warning[i] != 0) {\n      raiseWarning = 1;\n    }\n  }\n\n  OMPVV_WARNING_IF(raiseWarning != 0, \"The number of threads was 1 even though we expected it to be more than 1. Not a compliance error in the specs\");\n  OMPVV_ERROR_IF(errors, \"error in if(target: modifier). The execution was expected to occur in the device, but it happened in the host when if(false), or the other way around\");\n\n  return errors;\n}\n\nint main() {\n \n  int errors = 0;\n\n  //Offloading is checked in checkPreconditions() function\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_if_target_modifier());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_loop_collapse.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp parallel\" with directive \"#pragma omp flush\" at position 1004",
        "issue_id": 0,
        "original_code": "//===--- test_loop_collapse.c ------------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the collapse clause with the loop directive and tests that\n// for loops out of the scope of the collapsed loops are not parallelized.\n// This test tests using one and two collapsed loops.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 128 //Array Size of 128 uses 16MB target memory and\n                       //scales n^3 in test_collapse2()\n\nint test_collapse1() {\n\n  int * a_mem = (int *)malloc(N*N*sizeof(int));\n  int * b_mem = (int *)malloc(N*(N+1)*sizeof(int));\n  int (*a)[N] = (int (*)[N])a_mem;\n  int (*b)[N + 1] = (int (*)[N+1])b_mem;\n  int errors = 0;\n\n  // a and b array initialization\n  for (int x = 0; x < N; ++x) {\n    b[x][0] = 0;\n    for (int y = 0; y < N; ++y) {\n      a[x][y] = x + y;\n      b[x][y+1] = 0;\n    }\n  }\n\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST)\n  {\n#pragma omp loop collapse(1)\n    for (int x = 0; x < N; ++x) {\n      for (int y = 0; y < N; ++y) {\n        b[x][y + 1] = b[x][y] + a[x][y];\n      }\n    }\n  }\n\n  int temp_total;\n  for (int x = 0; x < N; ++x) {\n    temp_total = 0;\n    for (int y = 0; y < N+1; ++y) {\n      OMPVV_TEST_AND_SET(errors, ((temp_total - b[x][y]) != 0));\n      if (y != N) {\n        temp_total = temp_total + a[x][y];\n      }\n    }\n  }\n  free(a_mem);\n  free(b_mem);\n  return errors;\n}\n\nint test_collapse2() {\n  int * a_mem = (int *)malloc(N*N*N*sizeof(int));\n  int * b_mem = (int *)malloc(N*N*(N+1)*sizeof(int));\n  int (*a)[N][N] = (int (*)[N][N])a_mem;\n  int (*b)[N][N + 1] = (int (*)[N][N+1])b_mem;\n  int errors = 0;\n  int num_threads = 0;\n\n  // a and b array initialization\n  for (int x = 0; x < N; ++x) {\n    for (int y = 0; y < N; ++y) {\n      b[x][y][0] = 0;\n      for (int z = 0; z < N; ++z) {\n        a[x][y][z] = x + y + z;\n        b[x][y][z+1] = 0;\n      }\n    }\n  }\n\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST)\n  {\n    if (omp_get_thread_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n#pragma omp loop collapse(2)\n    for (int x = 0; x < N; ++x) {\n      for (int y = 0; y < N; ++y) {\n        for (int z = 0; z < N; ++z) {\n          b[x][y][z + 1] = b[x][y][z] + a[x][y][z];\n        }\n      }\n    }\n  }\n\n  int temp_total;\n  for (int x = 0; x < N; ++x) {\n    for (int y = 0; y < N; ++y) {\n      temp_total = 0;\n      for (int z = 0; z < N + 1; ++z) {\n        OMPVV_TEST_AND_SET(errors, ((temp_total - b[x][y][z]) != 0));\n        if (z != N) {\n          temp_total = temp_total + a[x][y][z];\n        }\n      }\n    }\n  }\n\n  if (num_threads == 1) {\n    OMPVV_WARNING(\"Test operated with one thread.  Parallelism of loop directive in parallel region can't be guaranteed.\");\n  }\n\n  free(a_mem);\n  free(b_mem);\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_collapse1() != 0);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_collapse2() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n}\n",
        "error_code": "//===--- test_loop_collapse.c ------------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the collapse clause with the loop directive and tests that\n// for loops out of the scope of the collapsed loops are not parallelized.\n// This test tests using one and two collapsed loops.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 128 //Array Size of 128 uses 16MB target memory and\n                       //scales n^3 in test_collapse2()\n\nint test_collapse1() {\n\n  int * a_mem = (int *)malloc(N*N*sizeof(int));\n  int * b_mem = (int *)malloc(N*(N+1)*sizeof(int));\n  int (*a)[N] = (int (*)[N])a_mem;\n  int (*b)[N + 1] = (int (*)[N+1])b_mem;\n  int errors = 0;\n\n  // a and b array initialization\n  for (int x = 0; x < N; ++x) {\n    b[x][0] = 0;\n    for (int y = 0; y < N; ++y) {\n      a[x][y] = x + y;\n      b[x][y+1] = 0;\n    }\n  }\n\n#pragma omp flush num_threads(OMPVV_NUM_THREADS_HOST)\n  {\n#pragma omp loop collapse(1)\n    for (int x = 0; x < N; ++x) {\n      for (int y = 0; y < N; ++y) {\n        b[x][y + 1] = b[x][y] + a[x][y];\n      }\n    }\n  }\n\n  int temp_total;\n  for (int x = 0; x < N; ++x) {\n    temp_total = 0;\n    for (int y = 0; y < N+1; ++y) {\n      OMPVV_TEST_AND_SET(errors, ((temp_total - b[x][y]) != 0));\n      if (y != N) {\n        temp_total = temp_total + a[x][y];\n      }\n    }\n  }\n  free(a_mem);\n  free(b_mem);\n  return errors;\n}\n\nint test_collapse2() {\n  int * a_mem = (int *)malloc(N*N*N*sizeof(int));\n  int * b_mem = (int *)malloc(N*N*(N+1)*sizeof(int));\n  int (*a)[N][N] = (int (*)[N][N])a_mem;\n  int (*b)[N][N + 1] = (int (*)[N][N+1])b_mem;\n  int errors = 0;\n  int num_threads = 0;\n\n  // a and b array initialization\n  for (int x = 0; x < N; ++x) {\n    for (int y = 0; y < N; ++y) {\n      b[x][y][0] = 0;\n      for (int z = 0; z < N; ++z) {\n        a[x][y][z] = x + y + z;\n        b[x][y][z+1] = 0;\n      }\n    }\n  }\n\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST)\n  {\n    if (omp_get_thread_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n#pragma omp loop collapse(2)\n    for (int x = 0; x < N; ++x) {\n      for (int y = 0; y < N; ++y) {\n        for (int z = 0; z < N; ++z) {\n          b[x][y][z + 1] = b[x][y][z] + a[x][y][z];\n        }\n      }\n    }\n  }\n\n  int temp_total;\n  for (int x = 0; x < N; ++x) {\n    for (int y = 0; y < N; ++y) {\n      temp_total = 0;\n      for (int z = 0; z < N + 1; ++z) {\n        OMPVV_TEST_AND_SET(errors, ((temp_total - b[x][y][z]) != 0));\n        if (z != N) {\n          temp_total = temp_total + a[x][y][z];\n        }\n      }\n    }\n  }\n\n  if (num_threads == 1) {\n    OMPVV_WARNING(\"Test operated with one thread.  Parallelism of loop directive in parallel region can't be guaranteed.\");\n  }\n\n  free(a_mem);\n  free(b_mem);\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_collapse1() != 0);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_collapse2() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_defaultmap_firstprivate.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1757",
        "issue_id": 1,
        "original_code": "//===--- test_target_defaultmap_firstprivate.c --------------------------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks behavior of the defaultmap clause when the specified implicit-behavior  \n// is firstprivate. The variable-categories avaiable for defaultmap are scalar, aggregate, and pointer.\n// All variables (pointer, aggregate, scalar) will be mapped with firstprivate behavior, thus, expected \n// behavior is that all list items will have their original value.\n//\n//\n////===-----------------------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint errors;\nint i;\n\nint test_defaultmap_with_firstprivate() {\n\n   struct test_struct {\n     int s;\n     int S[N];\n   };\n\n   int scalar; // scalar \n   int A[N]; // aggregate \n   struct test_struct new_struct; // aggregate variable -> structure\n   int *ptr; // scalar, pointer variable -> pointer\n\n   // initialize everything\n   scalar = 1;\n   new_struct.s = 0;\n\n   for (i = 0; i < N; i++) {\n      A[i] = 0;\n      new_struct.S[i] = 0;\n   }\n\n   #pragma omp target defaultmap(firstprivate) \n   {\n      scalar = 17;    \n      A[0] = 5; A[1] = 5;\n      new_struct.s = 10;\n      new_struct.S[0] = 10; new_struct.S[1] = 10; \n      ptr = &A[0]; \n      ptr[50] = 50; ptr[51] = 51;\n   }\n   OMPVV_TEST_AND_SET_VERBOSE(errors, scalar != 1);\n   OMPVV_TEST_AND_SET_VERBOSE(errors, A[0] != 0 || A[1] != 0);\n   OMPVV_TEST_AND_SET_VERBOSE(errors, A[50] != 0 || A[51] != 0);\n   OMPVV_TEST_AND_SET_VERBOSE(errors, new_struct.s != 0);\n   OMPVV_TEST_AND_SET_VERBOSE(errors, new_struct.S[0] != 0);\n\n  return errors;\n}\n\nint main() {\n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_defaultmap_with_firstprivate() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}            \n",
        "error_code": "//===--- test_target_defaultmap_firstprivate.c --------------------------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks behavior of the defaultmap clause when the specified implicit-behavior  \n// is firstprivate. The variable-categories avaiable for defaultmap are scalar, aggregate, and pointer.\n// All variables (pointer, aggregate, scalar) will be mapped with firstprivate behavior, thus, expected \n// behavior is that all list items will have their original value.\n//\n//\n////===-----------------------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint errors;\nint i;\n\nint test_defaultmap_with_firstprivate() {\n\n   struct test_struct {\n     int s;\n     int S[N];\n   };\n\n   int scalar; // scalar \n   int A[N]; // aggregate \n   struct test_struct new_struct; // aggregate variable -> structure\n   int *ptr; // scalar, pointer variable -> pointer\n\n   // initialize everything\n   scalar = 1;\n   new_struct.s = 0;\n\n   for (i = 0; i < N; i++) {\n      A[i] = 0;\n      new_struct.S[i] = 0;\n   }\n\n   #pragma omp target defaultmap(firstprivate) \n   {\n      scalar = 17;    \n      A[0] = 5; A[1] = 5;\n      new_struct.s = 10;\n      new_struct.S[0] = 10; new_struct.S[1] = 10; \n      ptr = &A[0]; \n      ptr[50] = 50; ptr[51] = 51;\n   }\n   OMPVV_TEST_AND_SET_VERBOSE(errors, scalar != 1);\n   OMPVV_TEST_AND_SET_VERBOSE(errors, A[0] != 0 || A[1] != 0);\n   OMPVV_TEST_AND_SET_VERBOSE(errors, A[50] != 0 || A[51] != 0);\n   OMPVV_TEST_AND_SET_VERBOSE(errors, new_struct.s != 0);\n   OMPVV_TEST_AND_SET_VERBOSE(errors, new_struct.S[0] != 0);\n\n  return errors;\n}\n\nint main() \n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_defaultmap_with_firstprivate() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}            \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_parallel_for_map_from.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  int errors = 0;\n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_map_from());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 1008",
        "issue_id": 4,
        "original_code": "//===--- test_target_teams_distribute_parallel_for_map_from.c ---------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// Testing the map from of scalars and arrays when used with target teams \n// distrbute parallel for.\n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define N 1024\n\nint test_target_teams_distribute_parallel_for_map_from() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_map_from\");\n  \n  int a[N];\n  int scalar = 0;\n  int errors = 0;\n  int i,j, dev;\n\n  scalar = 0;\n  // array initialization\n  for (i = 0; i < N; ++i) {\n    a[i] = 1;\n  }\n\n\n#pragma omp target teams distribute parallel for map(from: a, scalar)\n  for (j = 0; j < N; ++j) {\n#pragma omp atomic write\n    scalar = 20;\n    a[j] = 10;\n  }\n\n  // check the results\n  OMPVV_TEST_AND_SET(errors, scalar != 20);\n  for (i = 0; i < N; ++i) {\n    OMPVV_TEST_AND_SET(errors, a[i] != 10);\n  }\n\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_map_from());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_parallel_for_map_from.c ---------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// Testing the map from of scalars and arrays when used with target teams \n// distrbute parallel for.\n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define N 1024\n\nint test_target_teams_distribute_parallel_for_map_from() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_map_from\");\n  \n  int a[N];\n  int scalar = 0;\n  int errors = 0;\n  int i,j, dev;\n\n  scalar = 0;\n  // array initialization\n  for (i = 0; i < N; ++i) {\n    a[i] = 1;\n  }\n\n\n#pragma omp target teams distribute parallel for map(from: a, scalar)\n  for (j = 0; j < N; ++j) {\n#pragma omp atomic write\n    scalar = 20;\n    a[j] = 10;\n  }\n\n  // check the results\n  OMPVV_TEST_AND_SET(errors, scalar != 20);\n  for (i = 0; i < N; ++i) {\n    OMPVV_TEST_AND_SET(errors, a[i] != 10);\n  }\n\n  return errors;\n}\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_uses_allocators_pteam.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp single\" at position 757",
        "issue_id": 0,
        "original_code": "//===--- test_target_uses_allocators_pteam.c ------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// The tests checks the uses_allocators clause with omp_pteam_mem_alloc.\n// The variable allocated in the target region is modified and used to compute\n// result in device environment. Result is copied back to the host and checked\n// with computed value on host.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 256\n\nint test_uses_allocators_pteam() {\n  int errors = 0;\n  int pteam_result[N] = {0};\n  int device_result[N] = {0};\n  int result[N] = {0};\n\n  for (int i = 0; i < N; i++) {\n    result[i] = 2 * i ;\n  }\n#pragma omp target parallel for map(from: device_result) uses_allocators(omp_pteam_mem_alloc) allocate(omp_pteam_mem_alloc: pteam_result) private(pteam_result)\n  for (int i = 0; i < N; i++) {\n    pteam_result[i] = 2 * i ;\n    device_result[i] = pteam_result[i];\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, result[i] != device_result[i]);\n  }\n\n  return errors;\n}\n\nint main() {\n\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_uses_allocators_pteam() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_uses_allocators_pteam.c ------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// The tests checks the uses_allocators clause with omp_pteam_mem_alloc.\n// The variable allocated in the target region is modified and used to compute\n// result in device environment. Result is copied back to the host and checked\n// with computed value on host.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 256\n\nint test_uses_allocators_pteam() {\n  int errors = 0;\n  int pteam_result[N] = {0};\n  int device_result[N] = {0};\n  int result[N] = {0};\n\n  for (int i = 0; i < N; i++) {\n    result[i] = 2 * i ;\n  }\n#pragma omp single parallel for map(from: device_result) uses_allocators(omp_pteam_mem_alloc) allocate(omp_pteam_mem_alloc: pteam_result) private(pteam_result)\n  for (int i = 0; i < N; i++) {\n    pteam_result[i] = 2 * i ;\n    device_result[i] = pteam_result[i];\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, result[i] != device_result[i]);\n  }\n\n  return errors;\n}\n\nint main() {\n\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_uses_allocators_pteam() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_metadirective_arch_nvidia_or_amd.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 610",
        "issue_id": 2,
        "original_code": "//===---test_metadirective_arch_nvidia_or_amd.c ----------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n// \n// Test for metadirectives based on OpenMP 5.0 examples metadirective.1-3.c\n//\n////===---------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint errors = 0;\n\nint metadirective2() {\n\n   int i, device_num, initial_device;\n   int a[N];\n \n   for (int i = 0; i < N; i++) {\n      a[i] = 0;  \n   }\n   \n   for (device_num = 0; device_num == 0 || device_num < omp_get_num_devices(); device_num++) {\n     #pragma omp target device(device_num) map(from:initial_device)\n     {\n       #pragma omp metadirective \\\n                  when( implementation={vendor(nvidia)}: \\\n                        teams num_teams(512) thread_limit(32) ) \\\n                  when( implementation={vendor(amd)}: \\\n                        teams num_teams(512) thread_limit(64) ) \\\n                  default (teams)\n       #pragma omp distribute parallel for\n         for (i = 0; i < N; i++) {\n            #pragma omp atomic write\n            initial_device = omp_is_initial_device();\n            a[i] = i;\n         }\n     }\n   }\n\n   OMPVV_TEST_AND_SET_VERBOSE(errors, initial_device != 0);\n   OMPVV_ERROR_IF(initial_device != 0, \"NVIDIA and AMD architecture not available, ran on host\");\n\n   for (i = 0; i < N; i++) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, a[i] != i); \n   }        \n\n   return errors;\n\n}\n\nint main () {\n\n   OMPVV_TEST_OFFLOADING;\n\n   OMPVV_TEST_AND_SET_VERBOSE(errors, metadirective2());\n\n   OMPVV_REPORT_AND_RETURN(errors);\n\n}\n",
        "error_code": "//===---test_metadirective_arch_nvidia_or_amd.c ----------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n// \n// Test for metadirectives based on OpenMP 5.0 examples metadirective.1-3.c\n//\n////===---------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint errors = 0;\n\nint metadirective2() {\n\n   int i, device_num, initial_device;\n   int a[N];\n \n   for (int i = 0; i < N; i++) {\n      a[i] = 0;  \n   }\n   \n   for (device_num = 0; device_num == 0 || device_num < omp_get_num_devices();yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1; device_num++) {\n     #pragma omp target device(device_num) map(from:initial_device)\n     {\n       #pragma omp metadirective \\\n                  when( implementation={vendor(nvidia)}: \\\n                        teams num_teams(512) thread_limit(32) ) \\\n                  when( implementation={vendor(amd)}: \\\n                        teams num_teams(512) thread_limit(64) ) \\\n                  default (teams)\n       #pragma omp distribute parallel for\n         for (i = 0; i < N; i++) {\n            #pragma omp atomic write\n            initial_device = omp_is_initial_device();\n            a[i] = i;\n         }\n     }\n   }\n\n   OMPVV_TEST_AND_SET_VERBOSE(errors, initial_device != 0);\n   OMPVV_ERROR_IF(initial_device != 0, \"NVIDIA and AMD architecture not available, ran on host\");\n\n   for (i = 0; i < N; i++) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, a[i] != i); \n   }        \n\n   return errors;\n\n}\n\nint main () {\n\n   OMPVV_TEST_OFFLOADING;\n\n   OMPVV_TEST_AND_SET_VERBOSE(errors, metadirective2());\n\n   OMPVV_REPORT_AND_RETURN(errors);\n\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_update_devices.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp atomic\" at position 1689",
        "issue_id": 0,
        "original_code": "//===--- test_target_update_devices.c--------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks if the target update directive works on different devices.\n// We check two different variants.\n// 1. setting up the default device with the API call omp_set_default_device()\n// 2. using the device clause of the target update directive.\n//\n// Testing metodology uses an array that gets mapped into the device at first\n// through target enter data. Then on each iteration we update the array in one\n// device, create a compute region in that device, and then update it back\n// We also record that the compute region is not executed in the host\n// with the omp_is_initial_device() API call. Unfortunately 4.5 has no device\n// number API call.\n//\n////===----------------------------------------------------------------------===//\n\n\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\n/*\n * This test check if update device works well\n * when the omp_set_default_device API call is used\n * to change the default device\n */\nint test_set_default_dev() {\n  OMPVV_INFOMSG(\"test_set_default_dev\");\n\n  // Get number of devices\n  int num_dev = omp_get_num_devices();\n  OMPVV_INFOMSG(\"num_devices: %d\", num_dev);\n\n  int def_dev = omp_get_default_device();\n  OMPVV_INFOMSG(\"initial device: %d\", omp_get_initial_device());\n  OMPVV_INFOMSG(\"default device: %d\", def_dev);\n\n  int sum = 0;\n  int errors = 0;\n  int isHost[num_dev];\n  int h_matrix[N];\n\n  // Mapping the array to all the devices\n  for (int dev = 0; dev < num_dev; ++dev) {\n    omp_set_default_device(dev);\n    // unstructured mapping\n    {\n#pragma omp target enter data map(alloc: h_matrix[0:N])\n        printf(\"\"); // forcing the compiler to not moving out of the scope\n    }\n  }\n\n  // Initialize the array\n  for (int i = 0; i < N; ++i) {\n    h_matrix[i] = 0;\n  }\n\n  // Each device gets updated with the current array version,\n  // one gets added to each element in the array, and then\n  // the host gets the updated version\n  for (int dev = 0; dev < num_dev; ++dev) {\n    omp_set_default_device(dev);\n#pragma omp target update to(h_matrix[0:N])\n    // operation\n#pragma omp target map(alloc: h_matrix[0:N]) map(tofrom: isHost[dev:1]) // map(alloc: ) to avoid target to map the entire matrix h_matrix[:]\n    {\n      // Check on device or host execution\n      isHost[dev] = omp_is_initial_device();\n\n      for (int i = 0; i < N; ++i) {\n        h_matrix[i]++;\n      }\n    }\n#pragma omp target update from(h_matrix[0:N])\n    // unstructured exit\n  }\n\n  // Unmap the matrix\n  for (int dev = 0; dev < num_dev; ++dev) {\n    omp_set_default_device(dev);\n#pragma omp target exit data map(delete: h_matrix[0:N])\n    printf(\"\");\n  }\n\n  // checking results\n  for (int dev = 0; dev < num_dev; ++dev) {\n    OMPVV_INFOMSG(\"device %d ran on the %s\", dev, (isHost[dev])? \"host\" : \"device\");\n  }\n  for (int i = 0; i < N; ++i) {\n    sum += h_matrix[i];\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (num_dev * N != sum));\n\n  omp_set_default_device(def_dev);\n\n  return errors;\n}\n\n/*\n * This test checks if using the device clause in\n * data update works fine\n */\nint test_device() {\n  OMPVV_INFOMSG(\"test_device_clause\");\n\n  // Get number of devices\n  int num_dev = omp_get_num_devices();\n  OMPVV_INFOMSG(\"num_devices: %d\", num_dev);\n\n  int def_dev = omp_get_default_device();\n  OMPVV_INFOMSG(\"initial device: %d\", omp_get_initial_device());\n  OMPVV_INFOMSG(\"default device: %d\", def_dev);\n\n  int sum = 0;\n  int errors = 0;\n  int isHost[num_dev];\n  int h_matrix[N];\n\n  // Mapping the array to all the devices\n  for (int dev = 0; dev < num_dev; ++dev) {\n    // unstructured mapping\n    {\n#pragma omp target enter data map(alloc: h_matrix[0:N]) device(dev)\n        printf(\"\"); // forcing the compiler to not moving out of the scope\n    }\n  }\n\n  // Initialize the array\n  for (int i = 0; i < N; ++i) {\n    h_matrix[i] = 0;\n  }\n\n  // Each device gets updated with the current array version,\n  // one gets added to each element in the array, and then\n  // the host gets the updated version\n  for (int dev = 0; dev < num_dev; ++dev) {\n#pragma omp target update to(h_matrix[0:N]) device(dev)\n    // operation\n#pragma omp target map(alloc: h_matrix[0:N]) map(tofrom: isHost[dev:1]) \\\n    device(dev)// map(alloc: ) to avoid target to map the entire matrix h_matrix[:]\n    {\n      // Check on device or host execution\n      isHost[dev] = omp_is_initial_device();\n\n      for (int i = 0; i < N; ++i) {\n        h_matrix[i]++;\n      }\n    }\n#pragma omp target update from(h_matrix[0:N]) device(dev)\n    // unstructured exit\n  }\n\n  // Unmap the matrix\n  for (int dev = 0; dev < num_dev; ++dev) {\n#pragma omp target exit data map(delete: h_matrix[0:N]) device(dev)\n    printf(\"\");\n  }\n\n  // checking results\n  for (int dev = 0; dev < num_dev; ++dev) {\n    OMPVV_INFOMSG(\"device %d ran on the %s\", dev, (isHost[dev])? \"host\" : \"device\");\n  }\n  for (int i = 0; i < N; ++i) {\n    sum += h_matrix[i];\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (num_dev * N != sum));\n\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET(errors, test_set_default_dev());\n  OMPVV_TEST_AND_SET(errors, test_device());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_update_devices.c--------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks if the target update directive works on different devices.\n// We check two different variants.\n// 1. setting up the default device with the API call omp_set_default_device()\n// 2. using the device clause of the target update directive.\n//\n// Testing metodology uses an array that gets mapped into the device at first\n// through target enter data. Then on each iteration we update the array in one\n// device, create a compute region in that device, and then update it back\n// We also record that the compute region is not executed in the host\n// with the omp_is_initial_device() API call. Unfortunately 4.5 has no device\n// number API call.\n//\n////===----------------------------------------------------------------------===//\n\n\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\n/*\n * This test check if update device works well\n * when the omp_set_default_device API call is used\n * to change the default device\n */\nint test_set_default_dev() {\n  OMPVV_INFOMSG(\"test_set_default_dev\");\n\n  // Get number of devices\n  int num_dev = omp_get_num_devices();\n  OMPVV_INFOMSG(\"num_devices: %d\", num_dev);\n\n  int def_dev = omp_get_default_device();\n  OMPVV_INFOMSG(\"initial device: %d\", omp_get_initial_device());\n  OMPVV_INFOMSG(\"default device: %d\", def_dev);\n\n  int sum = 0;\n  int errors = 0;\n  int isHost[num_dev];\n  int h_matrix[N];\n\n  // Mapping the array to all the devices\n  for (int dev = 0; dev < num_dev; ++dev) {\n    omp_set_default_device(dev);\n    // unstructured mapping\n    {\n#pragma omp atomic enter data map(alloc: h_matrix[0:N])\n        printf(\"\"); // forcing the compiler to not moving out of the scope\n    }\n  }\n\n  // Initialize the array\n  for (int i = 0; i < N; ++i) {\n    h_matrix[i] = 0;\n  }\n\n  // Each device gets updated with the current array version,\n  // one gets added to each element in the array, and then\n  // the host gets the updated version\n  for (int dev = 0; dev < num_dev; ++dev) {\n    omp_set_default_device(dev);\n#pragma omp target update to(h_matrix[0:N])\n    // operation\n#pragma omp target map(alloc: h_matrix[0:N]) map(tofrom: isHost[dev:1]) // map(alloc: ) to avoid target to map the entire matrix h_matrix[:]\n    {\n      // Check on device or host execution\n      isHost[dev] = omp_is_initial_device();\n\n      for (int i = 0; i < N; ++i) {\n        h_matrix[i]++;\n      }\n    }\n#pragma omp target update from(h_matrix[0:N])\n    // unstructured exit\n  }\n\n  // Unmap the matrix\n  for (int dev = 0; dev < num_dev; ++dev) {\n    omp_set_default_device(dev);\n#pragma omp target exit data map(delete: h_matrix[0:N])\n    printf(\"\");\n  }\n\n  // checking results\n  for (int dev = 0; dev < num_dev; ++dev) {\n    OMPVV_INFOMSG(\"device %d ran on the %s\", dev, (isHost[dev])? \"host\" : \"device\");\n  }\n  for (int i = 0; i < N; ++i) {\n    sum += h_matrix[i];\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (num_dev * N != sum));\n\n  omp_set_default_device(def_dev);\n\n  return errors;\n}\n\n/*\n * This test checks if using the device clause in\n * data update works fine\n */\nint test_device() {\n  OMPVV_INFOMSG(\"test_device_clause\");\n\n  // Get number of devices\n  int num_dev = omp_get_num_devices();\n  OMPVV_INFOMSG(\"num_devices: %d\", num_dev);\n\n  int def_dev = omp_get_default_device();\n  OMPVV_INFOMSG(\"initial device: %d\", omp_get_initial_device());\n  OMPVV_INFOMSG(\"default device: %d\", def_dev);\n\n  int sum = 0;\n  int errors = 0;\n  int isHost[num_dev];\n  int h_matrix[N];\n\n  // Mapping the array to all the devices\n  for (int dev = 0; dev < num_dev; ++dev) {\n    // unstructured mapping\n    {\n#pragma omp target enter data map(alloc: h_matrix[0:N]) device(dev)\n        printf(\"\"); // forcing the compiler to not moving out of the scope\n    }\n  }\n\n  // Initialize the array\n  for (int i = 0; i < N; ++i) {\n    h_matrix[i] = 0;\n  }\n\n  // Each device gets updated with the current array version,\n  // one gets added to each element in the array, and then\n  // the host gets the updated version\n  for (int dev = 0; dev < num_dev; ++dev) {\n#pragma omp target update to(h_matrix[0:N]) device(dev)\n    // operation\n#pragma omp target map(alloc: h_matrix[0:N]) map(tofrom: isHost[dev:1]) \\\n    device(dev)// map(alloc: ) to avoid target to map the entire matrix h_matrix[:]\n    {\n      // Check on device or host execution\n      isHost[dev] = omp_is_initial_device();\n\n      for (int i = 0; i < N; ++i) {\n        h_matrix[i]++;\n      }\n    }\n#pragma omp target update from(h_matrix[0:N]) device(dev)\n    // unstructured exit\n  }\n\n  // Unmap the matrix\n  for (int dev = 0; dev < num_dev; ++dev) {\n#pragma omp target exit data map(delete: h_matrix[0:N]) device(dev)\n    printf(\"\");\n  }\n\n  // checking results\n  for (int dev = 0; dev < num_dev; ++dev) {\n    OMPVV_INFOMSG(\"device %d ran on the %s\", dev, (isHost[dev])? \"host\" : \"device\");\n  }\n  for (int i = 0; i < N; ++i) {\n    sum += h_matrix[i];\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (num_dev * N != sum));\n\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET(errors, test_set_default_dev());\n  OMPVV_TEST_AND_SET(errors, test_device());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_declare_target_to_extended_list.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp declare\" with directive \"#pragma omp master\" at position 890",
        "issue_id": 0,
        "original_code": "//===------ test_declare_target_to_extended_list.c  ----------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks the second valid format of declare target directive with the \n// to clause. The extended list allows for mappable variables and function names \n// to be listed. If a list item of a to clause is a variable then the original \n// variable is mapped to a corresponding variable in the device data environment \n// of all devices as if it had appeared in a map clause with the map-type to on \n// the implicit target data construct for each device.\n// Updates using the enclosed function are made inside the target region and\n// results are verified on the host.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint aint = 10;\n\n#pragma omp declare target to(aint)\n\nvoid compute_array(int a[N], int b[N], int c[N]) {\n  for (int i = 0; i < N; i++) {\n    a[i] = b[i]*c[i] + aint * i;\n  }\n  return;\n}\n \n#pragma omp declare target to(compute_array)\n\nint test_declare_target() {\n\n  OMPVV_INFOMSG(\"test_declare_target_to_extended_list\");\n\n  int errors = 0;\n  int x[N];\n  int y[N];\n  int z[N];\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 0;\n    y[i] = 1;\n    z[i] = i;\n  }\n\n#pragma omp target map(from: x) map(to:y, z)\n  {\n    compute_array(x, y, z);\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != (y[i] * z[i] + 10 * i));\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_declare_target() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===------ test_declare_target_to_extended_list.c  ----------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks the second valid format of declare target directive with the \n// to clause. The extended list allows for mappable variables and function names \n// to be listed. If a list item of a to clause is a variable then the original \n// variable is mapped to a corresponding variable in the device data environment \n// of all devices as if it had appeared in a map clause with the map-type to on \n// the implicit target data construct for each device.\n// Updates using the enclosed function are made inside the target region and\n// results are verified on the host.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint aint = 10;\n\n#pragma omp master target to(aint)\n\nvoid compute_array(int a[N], int b[N], int c[N]) {\n  for (int i = 0; i < N; i++) {\n    a[i] = b[i]*c[i] + aint * i;\n  }\n  return;\n}\n \n#pragma omp declare target to(compute_array)\n\nint test_declare_target() {\n\n  OMPVV_INFOMSG(\"test_declare_target_to_extended_list\");\n\n  int errors = 0;\n  int x[N];\n  int y[N];\n  int z[N];\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 0;\n    y[i] = 1;\n    z[i] = i;\n  }\n\n#pragma omp target map(from: x) map(to:y, z)\n  {\n    compute_array(x, y, z);\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != (y[i] * z[i] + 10 * i));\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_declare_target() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_aligned_calloc.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 1148",
        "issue_id": 2,
        "original_code": "//===--------------------- test_aligned_calloc.c --------------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// Tests the omp_aligned_calloc routine. Requests a memory allocation\n// aligned to the passed byte parameter. Starts by initializing some memory\n// in the omp_default_mem_space and then checks if this memory is aligned\n// and can be properly written to and read from.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_aligned_calloc() {\n  int errors = 0;\n  \n  int *x;\n  int not_correct_array_values = 0;\n\n  x = (int *)omp_aligned_calloc(64, N, N*sizeof(int), omp_default_mem_alloc);\n\n  if (x == NULL) { \n    OMPVV_ERROR(\"omp_aligned_calloc returned null\"); \n    errors++;\n  } else {\n    OMPVV_TEST_AND_SET(errors, ((intptr_t)(x))%64 != 0);\n    OMPVV_ERROR_IF(((intptr_t)(x))%64 != 0, \" Condition ((intptr_t)(x))%%64 != 0 failed. The memory does not seem to be properly aligned.\");\n\n    #pragma omp parallel for simd simdlen(16) aligned(x: 64)\n    for (int i = 0; i < N; i++) {\n      x[i] = i;\n    }\n\n    #pragma omp parallel for simd simdlen(16) aligned(x: 64)\n    for (int i = 0; i < N; i++) {\n      if (x[i] != i) {\n        #pragma omp atomic write\n        not_correct_array_values = 1; \n      }\n    }\n\n    if (not_correct_array_values) {\n      OMPVV_ERROR(\"Values in the array did NOT match the expected values. Changes may not have persisted.\");\n      errors++;\n    }\n\n    omp_free(x, omp_default_mem_alloc);\n  }\n\n\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_aligned_calloc() != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n\n",
        "error_code": "//===--------------------- test_aligned_calloc.c --------------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// Tests the omp_aligned_calloc routine. Requests a memory allocation\n// aligned to the passed byte parameter. Starts by initializing some memory\n// in the omp_default_mem_space and then checks if this memory is aligned\n// and can be properly written to and read from.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_aligned_calloc() {\n  int errors = 0;\n  \n  int *x;\n  int not_correct_array_values = 0;\n\n  x = (int *)omp_aligned_calloc(64, N, N*sizeof(int), omp_default_mem_alloc);\n\n  if (x == NULL) { \n    OMPVV_ERROR(\"omp_aligned_calloc returned null\"); \n    errors++;\n  } else {\n    OMPVV_TEST_AND_SET(errors, ((intptr_t)(x))%64 != 0);\n    OMPVV_ERROR_IF(((intptr_t)(x))%64 != 0, \" Condition ((intptr_t)(x))%%64 != 0 failed. The memory does not seem to be properly aligned.\");\n\n    #pragma omp parallel for simd simdlen(16) aligned(x: 64)\n    for (int i = 0; i < N;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1; i++) {\n      x[i] = i;\n    }\n\n    #pragma omp parallel for simd simdlen(16) aligned(x: 64)\n    for (int i = 0; i < N; i++) {\n      if (x[i] != i) {\n        #pragma omp atomic write\n        not_correct_array_values = 1; \n      }\n    }\n\n    if (not_correct_array_values) {\n      OMPVV_ERROR(\"Values in the array did NOT match the expected values. Changes may not have persisted.\");\n      errors++;\n    }\n\n    omp_free(x, omp_default_mem_alloc);\n  }\n\n\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_aligned_calloc() != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_omp_places_env_numa_domains.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 634",
        "issue_id": 2,
        "original_code": "//---------------test_omp_places_numa_domain--------------------//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n//This test intends to test the omp_places numa domain option. \n//First the test sets the value of omp_places to numa_domain.\n//Then the test checks for equal distribution in threads.\n//-------------------------------------------------------------//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\nint test_places(){\n\tint errors = 0;\n\tint test = 1;\n\tchar* ret_val = NULL;\n\tret_val = getenv(\"OMP_PLACES\");\n\ttest = ret_val == NULL || strcmp(ret_val, \"numa_domains\");\n\tOMPVV_TEST_AND_SET(errors, test != 0);\n\treturn errors;\n}\n\n\nint main(){\n\tint errors = 0;\n\tOMPVV_TEST_OFFLOADING;\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_places() != 0);\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//---------------test_omp_places_numa_domain--------------------//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n//This test intends to test the omp_places numa domain option. \n//First the test sets the value of omp_places to numa_domain.\n//Then the test checks for equal distribution in threads.\n//-------------------------------------------------------------//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\nint test_places(){\n\tint errors = 0;\n\tint test = 1;\n\tchar* ret_val = NULL;\n\tret_val = getenv(\"OMP_PLACES\");\n\ttest = ret_val == NULL || strcmp(ret_val, \"numa_domains\");yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n\tOMPVV_TEST_AND_SET(errors, test != 0);\n\treturn errors;\n}\n\n\nint main(){\n\tint errors = 0;\n\tOMPVV_TEST_OFFLOADING;\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_places() != 0);\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_loop_order_concurrent.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 2376",
        "issue_id": 1,
        "original_code": "//===--- test_loop_order_concurrent.c ---------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the loop directive with the order(concurrent) clause.\n// The order(concurrent) clause is assumed to be present if it is not\n// present, so this test covers the standalone loop directive as well. The\n// test creates a parallel region with a loop construct nested within, and\n// performs simple operations on an int array which are then checked for\n// correctness. Additionally, since loop binds to a parallel region, the test\n// checks randomly that other threads wait before proceeding out of the loop\n// region. The number of threads is checked in the parallel region but after\n// the loop construct because runtime API calls are not permitted in loop\n// directive regions.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_loop_order_concurrent() {\n  OMPVV_INFOMSG(\"test_loop_order_concurrent\");\n  int errors = 0;\n  int total_wait_errors = 0;\n  int x[N];\n  int y[N];\n  int z[N];\n  int num_threads = -1;\n  int rand_indexes[OMPVV_NUM_THREADS_HOST];\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 1;\n    y[i] = i + 1;\n    z[i] = 2*(i + 1);\n  }\n\n  for (int i = 0; i < OMPVV_NUM_THREADS_HOST; i++) {\n    rand_indexes[i] = rand()%(N + 1);\n  }\n\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST)\n  {\n#pragma omp loop order(concurrent)\n    for (int i = 0; i < N; i++) {\n      x[i] += y[i]*z[i];\n    }\n    if (x[rand_indexes[omp_get_thread_num()]] == 1) {\n#pragma omp atomic update\n      total_wait_errors++;\n    }\n    if (omp_get_thread_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != 1 + (y[i]*z[i]));\n  }\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of loop construct can't be guaranteed.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n  OMPVV_ERROR_IF(num_threads < 1, \"omp_get_num_threads() returned an invalid number of threads.\");\n  OMPVV_ERROR_IF(total_wait_errors, \"Threads in parallel region did not wait for loop region to finish before proceeding.\");\n\n  return errors + total_wait_errors;\n}\n\n\nint main() {\n  int errors = 0;\n\n  srand(time(0));\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_loop_order_concurrent());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_loop_order_concurrent.c ---------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the loop directive with the order(concurrent) clause.\n// The order(concurrent) clause is assumed to be present if it is not\n// present, so this test covers the standalone loop directive as well. The\n// test creates a parallel region with a loop construct nested within, and\n// performs simple operations on an int array which are then checked for\n// correctness. Additionally, since loop binds to a parallel region, the test\n// checks randomly that other threads wait before proceeding out of the loop\n// region. The number of threads is checked in the parallel region but after\n// the loop construct because runtime API calls are not permitted in loop\n// directive regions.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_loop_order_concurrent() {\n  OMPVV_INFOMSG(\"test_loop_order_concurrent\");\n  int errors = 0;\n  int total_wait_errors = 0;\n  int x[N];\n  int y[N];\n  int z[N];\n  int num_threads = -1;\n  int rand_indexes[OMPVV_NUM_THREADS_HOST];\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 1;\n    y[i] = i + 1;\n    z[i] = 2*(i + 1);\n  }\n\n  for (int i = 0; i < OMPVV_NUM_THREADS_HOST; i++) {\n    rand_indexes[i] = rand()%(N + 1);\n  }\n\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST)\n  {\n#pragma omp loop order(concurrent)\n    for (int i = 0; i < N; i++) {\n      x[i] += y[i]*z[i];\n    }\n    if (x[rand_indexes[omp_get_thread_num()]] == 1) {\n#pragma omp atomic update\n      total_wait_errors++;\n    }\n    if (omp_get_thread_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != 1 + (y[i]*z[i]));\n  }\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of loop construct can't be guaranteed.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n  OMPVV_ERROR_IF(num_threads < 1, \"omp_get_num_threads() returned an invalid number of threads.\");\n  OMPVV_ERROR_IF(total_wait_errors, \"Threads in parallel region did not wait for loop region to finish before proceeding.\");\n\n  return errors + total_wait_errors;\n}\n\n\nint main() \n  int errors = 0;\n\n  srand(time(0));\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_loop_order_concurrent());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_data_map_tofrom.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n\n  int errors = 0;\n\n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_tofrom());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 1501",
        "issue_id": 4,
        "original_code": "//===---- test_target_data_map_tofrom.c -----------------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// The test_target_data_map group of tests checks all the possible map-type-modifiers\n// for the target data map clauses. These are: from, to, fromto, alloc, release and \n// delete. There is a a separate c file for each test with the prefix test_target_data_map.\n// This tests is specifically for the 'tofrom' clause. \n//\n//===----------------------------------------------------------------------------------===//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\n// Test for OpenMP 4.5 target data map(tofrom: ) \nint test_map_tofrom() {\n\n  OMPVV_INFOMSG(\"test_map_tofrom\");\n\n  int sum = 0, sum2 = 0, errors = 0;\n\n  // host arrays: heap and stack\n  int *h_array_h = (int *)malloc(N * sizeof(int));\n  int h_array_s[N];\n\n  for (int i = 0; i < N; ++i) {\n    h_array_h[i] = 0;\n    h_array_s[i] = 0;\n  }\n\n#pragma omp target data map(tofrom: h_array_h[0:N])    \\\n        map(tofrom : h_array_s[0:N]) \n  {\n#pragma omp target //map //remove map clause?\n    { \n      for (int i = 0; i < N; ++i) {\n        h_array_h[i] += 1;\n        h_array_s[i] += 1;\n      }\n    } // end target\n  } // end target data \n\n   // checking errors \n  for (int i = 0; i < N; ++i) {\n    sum += h_array_h[i];\n    sum2 += h_array_s[i];\n  }\n\n  free(h_array_h);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (N != sum) || (N != sum2));\n\n  return errors;\n}\n\nint main() {\n\n  int errors = 0;\n\n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_tofrom());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_data_map_tofrom.c -----------------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// The test_target_data_map group of tests checks all the possible map-type-modifiers\n// for the target data map clauses. These are: from, to, fromto, alloc, release and \n// delete. There is a a separate c file for each test with the prefix test_target_data_map.\n// This tests is specifically for the 'tofrom' clause. \n//\n//===----------------------------------------------------------------------------------===//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\n// Test for OpenMP 4.5 target data map(tofrom: ) \nint test_map_tofrom() {\n\n  OMPVV_INFOMSG(\"test_map_tofrom\");\n\n  int sum = 0, sum2 = 0, errors = 0;\n\n  // host arrays: heap and stack\n  int *h_array_h = (int *)malloc(N * sizeof(int));\n  int h_array_s[N];\n\n  for (int i = 0; i < N; ++i) {\n    h_array_h[i] = 0;\n    h_array_s[i] = 0;\n  }\n\n#pragma omp target data map(tofrom: h_array_h[0:N])    \\\n        map(tofrom : h_array_s[0:N]) \n  {\n#pragma omp target //map //remove map clause?\n    { \n      for (int i = 0; i < N; ++i) {\n        h_array_h[i] += 1;\n        h_array_s[i] += 1;\n      }\n    } // end target\n  } // end target data \n\n   // checking errors \n  for (int i = 0; i < N; ++i) {\n    sum += h_array_h[i];\n    sum2 += h_array_s[i];\n  }\n\n  free(h_array_h);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (N != sum) || (N != sum2));\n\n  return errors;\n}\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_enter_data_if.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n        OMPVV_TEST_AND_SET_VERBOSE(errors, c[i] != 0)\n      }\" at position 2743",
        "issue_id": 4,
        "original_code": "//===---- test_target_enter_data_if.c - check the if clause of target data ------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// This test verifies the conditional data movement of the target enter data\n// directive through the if clause. There are two options:\n// 1. The if condition evaluates to true, in which case the data a[i] = 1 and \n// b[i] = i will be copied over to the device. Since there is alreay a and b\n// mapped in the target enter data, then the target region should not map the \n// a and b arrays. \n//\n// 2. The if condition evaluates to false. After the target enter data directive\n// we modify the values of the host to be 0. In which case the target region will\n// be in charge of the data movement and a[i] = 0 and b[i] = 0\n//\n// The target region will do c[i] = a[i] which will be either i + 1 or 0, \n// depending on the result of if. \n//\n// this test only gets executed if there is offloading and no shared memory\n// Shared memory devices would not work in this case\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define SIZE_THRESHOLD 512\n#define ARRAY_SIZE 1024\n\n// Test for OpenMP 4.5 target enter data with if\nint main() {\n  int a[ARRAY_SIZE];\n  int b[ARRAY_SIZE];\n  int c[ARRAY_SIZE];\n  int size, i = 0, errors = 0, isOffloading = 0, isSharedMemory = 0;\n\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading)\n  OMPVV_TEST_AND_SET_SHARED_ENVIRONMENT(isSharedMemory)\n\n  if (!isOffloading || isSharedMemory) {\n    OMPVV_WARNING(\"It is not possible to test conditional data transfers \"\n                  \"if the environment is shared or offloading is off. Not testing \"\n                  \"anything\")\n    OMPVV_REPORT_AND_RETURN(0);\n  }\n\n  // check multiple sizes. \n  for (size = 256; size <= ARRAY_SIZE; size += 256) {\n    // a,b and c arrays initialization\n    for (i = 0; i < size; i++) {\n      a[i] = 1;\n      b[i] = i;\n      c[i] = -1;\n    }\n#pragma omp target enter data if(size > SIZE_THRESHOLD) map(to: size) \\\n    map (to: a[0:size], b[0:size])\n           \n    // a, b arrays host side modification\n    for (i = 0; i < size; i++) {\n      a[i] = 0;\n      b[i] = 0;\n    }\n\n    // if a and b were mapped already by the target enter data then \n    // the tofrom should be a noop\n#pragma omp target map(tofrom: a[0:size], b[0:size], c[0:size])\n{\n        int j = 0;\n        for (j = 0; j < size; j++) {\n          // c[j] is zero if executed in the host\n          // c[j] is 1+j if executed on the device\n          c[j] = a[j] + b[j];\n        }\n} // end target\n\n    // checking results \n    for (i = 0; i < size; i++) {\n      if (size > SIZE_THRESHOLD) {\n        OMPVV_TEST_AND_SET_VERBOSE(errors, c[i] != i + 1)\n      } else {\n        OMPVV_TEST_AND_SET_VERBOSE(errors, c[i] != 0)\n      } //end-else \n    }\n    // This is not part of the test but it is necessary to avoid conflicts\n    #pragma omp target exit data if(size > SIZE_THRESHOLD) map(delete: a[0:size], b[0:size])\n  } // end-for size\n\n  OMPVV_REPORT_AND_RETURN(errors)\n\n}\n",
        "error_code": "//===---- test_target_enter_data_if.c - check the if clause of target data ------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// This test verifies the conditional data movement of the target enter data\n// directive through the if clause. There are two options:\n// 1. The if condition evaluates to true, in which case the data a[i] = 1 and \n// b[i] = i will be copied over to the device. Since there is alreay a and b\n// mapped in the target enter data, then the target region should not map the \n// a and b arrays. \n//\n// 2. The if condition evaluates to false. After the target enter data directive\n// we modify the values of the host to be 0. In which case the target region will\n// be in charge of the data movement and a[i] = 0 and b[i] = 0\n//\n// The target region will do c[i] = a[i] which will be either i + 1 or 0, \n// depending on the result of if. \n//\n// this test only gets executed if there is offloading and no shared memory\n// Shared memory devices would not work in this case\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define SIZE_THRESHOLD 512\n#define ARRAY_SIZE 1024\n\n// Test for OpenMP 4.5 target enter data with if\nint main() {\n  int a[ARRAY_SIZE];\n  int b[ARRAY_SIZE];\n  int c[ARRAY_SIZE];\n  int size, i = 0, errors = 0, isOffloading = 0, isSharedMemory = 0;\n\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading)\n  OMPVV_TEST_AND_SET_SHARED_ENVIRONMENT(isSharedMemory)\n\n  if (!isOffloading || isSharedMemory) {\n    OMPVV_WARNING(\"It is not possible to test conditional data transfers \"\n                  \"if the environment is shared or offloading is off. Not testing \"\n                  \"anything\")\n    OMPVV_REPORT_AND_RETURN(0);\n  }\n\n  // check multiple sizes. \n  for (size = 256; size <= ARRAY_SIZE; size += 256) {\n    // a,b and c arrays initialization\n    for (i = 0; i < size; i++) {\n      a[i] = 1;\n      b[i] = i;\n      c[i] = -1;\n    }\n#pragma omp target enter data if(size > SIZE_THRESHOLD) map(to: size) \\\n    map (to: a[0:size], b[0:size])\n           \n    // a, b arrays host side modification\n    for (i = 0; i < size; i++) {\n      a[i] = 0;\n      b[i] = 0;\n    }\n\n    // if a and b were mapped already by the target enter data then \n    // the tofrom should be a noop\n#pragma omp target map(tofrom: a[0:size], b[0:size], c[0:size])\n{\n        int j = 0;\n        for (j = 0; j < size; j++) {\n          // c[j] is zero if executed in the host\n          // c[j] is 1+j if executed on the device\n          c[j] = a[j] + b[j];\n        }\n} // end target\n\n    // checking results \n    for (i = 0; i < size; i++) {\n      if (size > SIZE_THRESHOLD) {\n        OMPVV_TEST_AND_SET_VERBOSE(errors, c[i] != i + 1)\n      } else  //end-else \n    }\n    // This is not part of the test but it is necessary to avoid conflicts\n    #pragma omp target exit data if(size > SIZE_THRESHOLD) map(delete: a[0:size], b[0:size])\n  } // end-for size\n\n  OMPVV_REPORT_AND_RETURN(errors)\n\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_map_lvalue_ternary.cpp",
        "correct": "n",
        "issue": "Removed opening bracket at position 1429",
        "issue_id": 1,
        "original_code": "//===------ test_target_map_lvalue_ternary.cpp ----------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test evaluates the map clause and its ability to handle various lvalue \n// expressions, such as ternary operators.\n//\n//===-------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <iostream>\n#include \"ompvv.h\"\n\nint test_target_update() {\n\tint errors = 0;\n\tint before_value;\n\tint after_value;\n\tint a = -1;\n\tint b = 1;\n\tbool c = true;\n\n\t// Map the variables a and b. \n\t#pragma omp target enter data map(to: c ? a : b)\n\n\t// Before should be set to -1 as c is true and a is -1\n\t#pragma omp target map(from: before_value)\n\t{\n\t\tbefore_value = c ? a : b;\n\t}\n\n\t// Copy data from the host to the device => b\n\t#pragma omp target update to(a)\n\n\t// After should be set to -1 as c is true and a is now  2\n\t#pragma omp target map(from: after_value)\n\t{\n\t\tafter_value = c ? a : b;\n\t\tif (c){\n\t\t\ta = 2;\n\t\t}\n\t\telse {\n\t\t\tb = 2;\n\t\t}\n\t}\n\n\t// Copy the updated value from the device to the host variable => b = 2\n\t#pragma omp target update from(a)\n\n\t// Exit data region, mapping the variable back from the target device to the host\n\t#pragma omp target exit data map(delete: c ? a : b)\n\n\t// Verify the results\n\tOMPVV_TEST_AND_SET(errors, (c ? a : b) != 2); \t\n\tOMPVV_TEST_AND_SET(errors, before_value != -1);\n\tOMPVV_TEST_AND_SET(errors, after_value != -1);\n\n\treturn errors;\n}\n\nint main() {\n\n\tOMPVV_TEST_OFFLOADING;\n\n\tint errors = 0;\n\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_target_update() != 0);\n\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n\n",
        "error_code": "//===------ test_target_map_lvalue_ternary.cpp ----------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test evaluates the map clause and its ability to handle various lvalue \n// expressions, such as ternary operators.\n//\n//===-------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <iostream>\n#include \"ompvv.h\"\n\nint test_target_update() {\n\tint errors = 0;\n\tint before_value;\n\tint after_value;\n\tint a = -1;\n\tint b = 1;\n\tbool c = true;\n\n\t// Map the variables a and b. \n\t#pragma omp target enter data map(to: c ? a : b)\n\n\t// Before should be set to -1 as c is true and a is -1\n\t#pragma omp target map(from: before_value)\n\t{\n\t\tbefore_value = c ? a : b;\n\t}\n\n\t// Copy data from the host to the device => b\n\t#pragma omp target update to(a)\n\n\t// After should be set to -1 as c is true and a is now  2\n\t#pragma omp target map(from: after_value)\n\t{\n\t\tafter_value = c ? a : b;\n\t\tif (c){\n\t\t\ta = 2;\n\t\t}\n\t\telse {\n\t\t\tb = 2;\n\t\t}\n\t}\n\n\t// Copy the updated value from the device to the host variable => b = 2\n\t#pragma omp target update from(a)\n\n\t// Exit data region, mapping the variable back from the target device to the host\n\t#pragma omp target exit data map(delete: c ? a : b)\n\n\t// Verify the results\n\tOMPVV_TEST_AND_SET(errors, (c ? a : b) != 2); \t\n\tOMPVV_TEST_AND_SET(errors, before_value != -1);\n\tOMPVV_TEST_AND_SET(errors, after_value != -1);\n\n\treturn errors;\n}\n\nint main() \n\n\tOMPVV_TEST_OFFLOADING;\n\n\tint errors = 0;\n\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_target_update() != 0);\n\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_map_with_present_modifier.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  \n  errors = 0;\n  \n  OMPVV_TEST_OFFLOADING;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_present_modifier());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 1308",
        "issue_id": 4,
        "original_code": "//===--- test_target_map_with_present_modifier.c ----------------------------------------------------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// This test checks tests the present map-type-modifier on a map clause. The test maps several\n// different data types to device with tofrom map-type and then checks for expected updated values on\n// the host.\n//\n////===--------------------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint errors; \n\nint test_present_modifier() {\n\n  int i;\n  int scalar = 1;\n  int a[N];\n\n  struct {\n    int var;\n    int b[N];\n  } member; \n\n  member.var = 1;\n  \n  for (i = 0; i < N; i++) { \n    a[i] = i;\n    member.b[i] = i;\n  }\n# pragma omp target data map(tofrom:scalar, a, member) \n  {\n#pragma omp target map(present, tofrom: scalar, a, member) \n  {\n    scalar += 1;\n    member.var += 2;\n    \n    for (i = 0; i < N; i++) {\n      a[i] += i;\n      member.b[i] += i;\n    }\n  }\n  }\n\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, a[i] != i*2);\n    OMPVV_TEST_AND_SET(errors, member.b[i] != i*2);\n  }\n \n  OMPVV_TEST_AND_SET(errors, scalar != 2);\n  OMPVV_TEST_AND_SET(errors, member.var != 3);\n\n  return errors;  \t \n}\n\nint main () {\n  \n  errors = 0;\n  \n  OMPVV_TEST_OFFLOADING;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_present_modifier());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_map_with_present_modifier.c ----------------------------------------------------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// This test checks tests the present map-type-modifier on a map clause. The test maps several\n// different data types to device with tofrom map-type and then checks for expected updated values on\n// the host.\n//\n////===--------------------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint errors; \n\nint test_present_modifier() {\n\n  int i;\n  int scalar = 1;\n  int a[N];\n\n  struct {\n    int var;\n    int b[N];\n  } member; \n\n  member.var = 1;\n  \n  for (i = 0; i < N; i++) { \n    a[i] = i;\n    member.b[i] = i;\n  }\n# pragma omp target data map(tofrom:scalar, a, member) \n  {\n#pragma omp target map(present, tofrom: scalar, a, member) \n  {\n    scalar += 1;\n    member.var += 2;\n    \n    for (i = 0; i < N; i++) {\n      a[i] += i;\n      member.b[i] += i;\n    }\n  }\n  }\n\n  for (i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, a[i] != i*2);\n    OMPVV_TEST_AND_SET(errors, member.b[i] != i*2);\n  }\n \n  OMPVV_TEST_AND_SET(errors, scalar != 2);\n  OMPVV_TEST_AND_SET(errors, member.var != 3);\n\n  return errors;  \t \n}\n\nint main () \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_depobj_depend_update_destroy.cpp",
        "correct": "n",
        "issue": "Removed opening bracket at position 1767",
        "issue_id": 1,
        "original_code": "//===--- test_depobj_depend_update_destroy.cpp ------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//  \n// Tests the standalone depobj construct using the depend, update, \n// and destory clause. For the first call to go function, the first task\n// must execute first due to inout dependence-type. In the second call to go\n// function, both tasks can execute simultaneously due to in dependence-type.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1028\n#define TURN1 1\n#define TURN2 2\n\nvoid go(int turn, int a[], int b[], omp_depend_t *obj);\nint errors = 0;\n\n\nint main () {\n   int a[N], b[N];\n   omp_depend_t obj;\n\n   for (int i = 0; i < N; i++) {\n      a[i] = i;\n      b[i] = 0;\n   }\n   \n   #pragma omp depobj(obj) depend(inout: a)\n   \n   go(TURN1, a, b, &obj);\n\n   #pragma omp depobj(obj) update(in)\n\n   go(TURN2, a, b, &obj);\n\n    \n   #pragma omp depobj(obj) destroy\n   \n   for (int i = 0; i < N; i++) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, b[i] != 5);\n      OMPVV_TEST_AND_SET_VERBOSE(errors, a[i] != i+2);\n   }\n \n   OMPVV_REPORT_AND_RETURN(errors);\n\n}\n\nvoid go(int turn, int a[], int b[], omp_depend_t *obj) {\n   #pragma omp parallel num_threads(2)\n   #pragma omp single \n   {\n      #pragma omp task depend(depobj: *obj)\n      {      \n         for (int i = 0; i < N; i++) {\n              a[i] += 1;\n         }\n      }\n      \n      #pragma omp task depend(in: a[:N])\n      { \n         if (turn == TURN1) {\n            for (int i = 0; i < N; i++) {\n               OMPVV_TEST_AND_SET_VERBOSE(errors, a[i]!=(i+turn));\n            }\n         }  \n         if (turn == TURN2) {\n            for (int i = 0; i < N; i++) {\n               b[i] = 5;\n            }\n         }\n      }\n   }   \n}\n",
        "error_code": "//===--- test_depobj_depend_update_destroy.cpp ------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//  \n// Tests the standalone depobj construct using the depend, update, \n// and destory clause. For the first call to go function, the first task\n// must execute first due to inout dependence-type. In the second call to go\n// function, both tasks can execute simultaneously due to in dependence-type.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1028\n#define TURN1 1\n#define TURN2 2\n\nvoid go(int turn, int a[], int b[], omp_depend_t *obj);\nint errors = 0;\n\n\nint main () {\n   int a[N], b[N];\n   omp_depend_t obj;\n\n   for (int i = 0; i < N; i++) {\n      a[i] = i;\n      b[i] = 0;\n   }\n   \n   #pragma omp depobj(obj) depend(inout: a)\n   \n   go(TURN1, a, b, &obj);\n\n   #pragma omp depobj(obj) update(in)\n\n   go(TURN2, a, b, &obj);\n\n    \n   #pragma omp depobj(obj) destroy\n   \n   for (int i = 0; i < N; i++) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, b[i] != 5);\n      OMPVV_TEST_AND_SET_VERBOSE(errors, a[i] != i+2);\n   }\n \n   OMPVV_REPORT_AND_RETURN(errors);\n\n}\n\nvoid go(int turn, int a[], int b[], omp_depend_t *obj) {\n   #pragma omp parallel num_threads(2)\n   #pragma omp single \n   {\n      #pragma omp task depend(depobj: *obj)\n      {      \n         for (int i = 0; i < N; i++) {\n              a[i] += 1;\n         }\n      }\n      \n      #pragma omp task depend(in: a[:N])\n      { \n         if (turn == TURN1) {\n            for (int i = 0; i < N; i++) {\n               OMPVV_TEST_AND_SET_VERBOSE(errors, a[i]!=(i+turn));\n            }\n         }  \n         if (turn == TURN2) {\n            for (int i = 0; i < N; i++) \n               b[i] = 5;\n            }\n         }\n      }\n   }   \n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_mul_inheritence.cpp",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp requires\" with directive \"#pragma omp flush\" at position 440",
        "issue_id": 0,
        "original_code": "//===-- test_target_mul_inheritence.cpp ----------------------------------===//\n//\n// OpenMP API Version 5.2\n//\n// Description\n// This test case tests the working of the following aspects:\n// 1) Working of \"requires unified_shared_memory\"\n// 2) Testing multiple inheritence on gpu\n//===----------------------------------------------------------------------===//\n\n#include <iostream>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1024*512\n\n#pragma omp requires unified_shared_memory\n\nclass A {\n  int *Ax = new int[N];\n        public:\n  int GetAx(int Indx) {\n    return Ax[Indx];\n  }\n  A() {\n    for (int i = 0; i < N; ++i) {\n      Ax[i] = 10;\n    }\n  }\n\n  void SetAx(int Val) {\n    for (int i = 0; i < N; ++i) {\n      Ax[i] = Val;\n    }\n  }\n};\n\nclass B {\n  int *Bx = new int[N];\n  public:\n  int GetBx(int Indx) {\n    return Bx[Indx];\n  }\n\n  B() {\n    for (int i = 0; i < N; ++i) {\n      Bx[i] = 20;\n    }\n  }\n\n  void SetBx(int Val) {\n    for (int i = 0; i < N; ++i) {\n      Bx[i] = Val;\n    }\n  }\n};\n\nclass C : public B, public A {\n  int Cx;\n        public:\n  int GetCx() {\n    return Cx;\n  }\n  C(int x) {\n    Cx = x;\n  }\n};\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  C cx(30);\n  int Errors = 0, errors = 0;\n  int TotGpus = omp_get_num_devices();\n  for (int dev = 0; dev < TotGpus; ++dev) {\n#pragma omp target data map(tofrom: Errors) device(dev)\n#pragma omp target device(dev)\n    {\n      if (cx.GetCx() != 30) {\n        Errors++;\n      }\n      // Setting value to an array in class A through class C object\n      cx.SetAx(123);\n      // Verifying if the value is set\n      if ((cx.GetAx(0) != 123) || (cx.GetAx(N/2) != 123) ||\n          (cx.GetAx(N-1) != 123)) {\n        Errors++;\n      }\n      cx.SetBx(333);\n      // Verifying if the value is set\n      if ((cx.GetBx(0) != 333) || (cx.GetBx(N/2) != 333) ||\n          (cx.GetBx(N-1) != 333)) {\n        Errors++;\n      }\n    }\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (Errors != 0));\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===-- test_target_mul_inheritence.cpp ----------------------------------===//\n//\n// OpenMP API Version 5.2\n//\n// Description\n// This test case tests the working of the following aspects:\n// 1) Working of \"requires unified_shared_memory\"\n// 2) Testing multiple inheritence on gpu\n//===----------------------------------------------------------------------===//\n\n#include <iostream>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1024*512\n\n#pragma omp flush unified_shared_memory\n\nclass A {\n  int *Ax = new int[N];\n        public:\n  int GetAx(int Indx) {\n    return Ax[Indx];\n  }\n  A() {\n    for (int i = 0; i < N; ++i) {\n      Ax[i] = 10;\n    }\n  }\n\n  void SetAx(int Val) {\n    for (int i = 0; i < N; ++i) {\n      Ax[i] = Val;\n    }\n  }\n};\n\nclass B {\n  int *Bx = new int[N];\n  public:\n  int GetBx(int Indx) {\n    return Bx[Indx];\n  }\n\n  B() {\n    for (int i = 0; i < N; ++i) {\n      Bx[i] = 20;\n    }\n  }\n\n  void SetBx(int Val) {\n    for (int i = 0; i < N; ++i) {\n      Bx[i] = Val;\n    }\n  }\n};\n\nclass C : public B, public A {\n  int Cx;\n        public:\n  int GetCx() {\n    return Cx;\n  }\n  C(int x) {\n    Cx = x;\n  }\n};\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  C cx(30);\n  int Errors = 0, errors = 0;\n  int TotGpus = omp_get_num_devices();\n  for (int dev = 0; dev < TotGpus; ++dev) {\n#pragma omp target data map(tofrom: Errors) device(dev)\n#pragma omp target device(dev)\n    {\n      if (cx.GetCx() != 30) {\n        Errors++;\n      }\n      // Setting value to an array in class A through class C object\n      cx.SetAx(123);\n      // Verifying if the value is set\n      if ((cx.GetAx(0) != 123) || (cx.GetAx(N/2) != 123) ||\n          (cx.GetAx(N-1) != 123)) {\n        Errors++;\n      }\n      cx.SetBx(333);\n      // Verifying if the value is set\n      if ((cx.GetBx(0) != 333) || (cx.GetBx(N/2) != 333) ||\n          (cx.GetBx(N-1) != 333)) {\n        Errors++;\n      }\n    }\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (Errors != 0));\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_omp_get_supported_active_levels.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 628",
        "issue_id": 1,
        "original_code": "//===--- test_omp_get_supported_active_levels.c -----------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Test for support of the omp_get_supported_active_levels() routine. \n// This routine returns the number of active levels of parallelism \n// supported by the implementation. This returned value must be greater\n// than 0 and the max-active-levels-var ICV may not have a value that is greater\n// than this number.\n// \n///===-----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1028\n\nint main() {\n\n   int errors;\n   int num_supp_active_levels;\n   int max_active_levels;\n\n   errors = 0;\n \n   num_supp_active_levels = omp_get_supported_active_levels();\n   max_active_levels = omp_get_max_active_levels();\n\n   OMPVV_TEST_AND_SET_VERBOSE(errors, max_active_levels > num_supp_active_levels);\n   OMPVV_TEST_AND_SET_VERBOSE(errors, num_supp_active_levels <= 0);\n\n   OMPVV_REPORT_AND_RETURN(errors);\n\n}\n",
        "error_code": "//===--- test_omp_get_supported_active_levels.c -----------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Test for support of the omp_get_supported_active_levels() routine. \n// This routine returns the number of active levels of parallelism \n// supported by the implementation. This returned value must be greater\n// than 0 and the max-active-levels-var ICV may not have a value that is greater\n// than this number.\n// \n///===-----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1028\n\nint main() \n\n   int errors;\n   int num_supp_active_levels;\n   int max_active_levels;\n\n   errors = 0;\n \n   num_supp_active_levels = omp_get_supported_active_levels();\n   max_active_levels = omp_get_max_active_levels();\n\n   OMPVV_TEST_AND_SET_VERBOSE(errors, max_active_levels > num_supp_active_levels);\n   OMPVV_TEST_AND_SET_VERBOSE(errors, num_supp_active_levels <= 0);\n\n   OMPVV_REPORT_AND_RETURN(errors);\n\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_parallel_loop_reduction.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 2216",
        "issue_id": 1,
        "original_code": "//===-------------------test_target_parallel_loop_reduction.c-----------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Description - This is a test program to demonstrate how reduction\n// min/max/+ clauses are used with target parallel loop construct. \n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint testMin() {\n  OMPVV_INFOMSG(\"testMin\");\n  double a[N];\n  double b[N];\n  int errors = 0;\n  srand(1);\n\n  for (int i = 0; i < N; ++i) {\n    a[i] = rand() / (double)(RAND_MAX / 100);\n    b[i] = rand() / (double)(RAND_MAX / 100);\n  }\n\n  double result =  a[0] + b[0];\n\n#pragma omp target parallel loop reduction(min:result) map(to: a[0:N], b[0:N]) map(tofrom: result)\n    for (int i = 0; i < N; ++i) {\n      result = fmin(result, a[i] + b[i]);\n    }\n\n  double hostMin = a[0] + b[0];\n  for (int i = 0; i < N; ++i) {\n    hostMin = fmin(hostMin, a[i] + b[i]);\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != hostMin);\n  return errors;\n}\n\nint testMax() {\n  OMPVV_INFOMSG(\"testMax\");\n\n  double a[N];\n  double b[N];\n  int errors = 0;\n  srand(1);\n\n  for (int i = 0; i < N; ++i) {\n    a[i] = rand() / (double)(RAND_MAX / 100);\n    b[i] = rand() / (double)(RAND_MAX / 100);\n  }\n\n  double result = a[0] + b[0];\n\n#pragma omp target parallel loop reduction(max:result) map(to: a[0:N], b[0:N]) map(tofrom: result)\n  for (int i = 0; i < N; ++i) {\n    result = fmax(a[i] + b[i], result);\n  }\n\n  double hostMax = a[0] + b[0];\n  for (int i = 0; i < N; ++i) {\n    hostMax = fmax(hostMax, a[i] + b[i]);\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != hostMax);\n\n  return errors;\n}\n\nint testAddition() {\n  OMPVV_INFOMSG(\"testAddition\");\n\n  int arr[N], total = 0;\n  int errors = 0;\n\n  for (int i = 0; i < N; i++) {\n    arr[i] = i;\n  }\n  \n#pragma omp target parallel loop reduction(+:total) map(to: arr[0:N]) map(tofrom: total)\n  for (int i = 0; i < N; i++) {\n    total = total + arr[i];\n  }\n\n  int sum_host = 0;\n  for (int i = 0; i < N; i++) {\n    sum_host = sum_host + arr[i];\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, total != sum_host);\n\n  return errors;\n}\n\nint main() {\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, testMin() != 0);\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, testMax() != 0);\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, testAddition() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n",
        "error_code": "//===-------------------test_target_parallel_loop_reduction.c-----------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Description - This is a test program to demonstrate how reduction\n// min/max/+ clauses are used with target parallel loop construct. \n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint testMin() {\n  OMPVV_INFOMSG(\"testMin\");\n  double a[N];\n  double b[N];\n  int errors = 0;\n  srand(1);\n\n  for (int i = 0; i < N; ++i) {\n    a[i] = rand() / (double)(RAND_MAX / 100);\n    b[i] = rand() / (double)(RAND_MAX / 100);\n  }\n\n  double result =  a[0] + b[0];\n\n#pragma omp target parallel loop reduction(min:result) map(to: a[0:N], b[0:N]) map(tofrom: result)\n    for (int i = 0; i < N; ++i) {\n      result = fmin(result, a[i] + b[i]);\n    }\n\n  double hostMin = a[0] + b[0];\n  for (int i = 0; i < N; ++i) {\n    hostMin = fmin(hostMin, a[i] + b[i]);\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != hostMin);\n  return errors;\n}\n\nint testMax() {\n  OMPVV_INFOMSG(\"testMax\");\n\n  double a[N];\n  double b[N];\n  int errors = 0;\n  srand(1);\n\n  for (int i = 0; i < N; ++i) {\n    a[i] = rand() / (double)(RAND_MAX / 100);\n    b[i] = rand() / (double)(RAND_MAX / 100);\n  }\n\n  double result = a[0] + b[0];\n\n#pragma omp target parallel loop reduction(max:result) map(to: a[0:N], b[0:N]) map(tofrom: result)\n  for (int i = 0; i < N; ++i) {\n    result = fmax(a[i] + b[i], result);\n  }\n\n  double hostMax = a[0] + b[0];\n  for (int i = 0; i < N; ++i) {\n    hostMax = fmax(hostMax, a[i] + b[i]);\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != hostMax);\n\n  return errors;\n}\n\nint testAddition() {\n  OMPVV_INFOMSG(\"testAddition\");\n\n  int arr[N], total = 0;\n  int errors = 0;\n\n  for (int i = 0; i < N; i++) {\n    arr[i] = i;\n  }\n  \n#pragma omp target parallel loop reduction(+:total) map(to: arr[0:N]) map(tofrom: total)\n  for (int i = 0; i < N; i++) {\n    total = total + arr[i];\n  }\n\n  int sum_host = 0;\n  for (int i = 0; i < N; i++) {\n    sum_host = sum_host + arr[i];\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, total != sum_host);\n\n  return errors;\n}\n\nint main() \n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, testMin() != 0);\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, testMax() != 0);\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, testAddition() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_thread_limit.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp flush\" at position 1201",
        "issue_id": 0,
        "original_code": "//===---------------- test_target_thread_limit.c -----------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// This test uses the thread_limit clause on the target construct. Specifically\n// testing if a thread_limit on a target construct properly carries\n// down to the nested teams construct, as if it were directly on the construct\n// as defined in the spec. The test validates that only the specified \n// threads are created by summing a shared variable across all threads \n// (and teams). If the threads are correctly limited, this should produce the\n// expected value. Additional warnings are sent if specific issues occur.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main() {\n\tint errors[OMPVV_NUM_TEAMS_DEVICE];\n\tint num_teams = 0;\n        int sum_errors = 0;\n        int i;\n\tint testing_thread_limit = OMPVV_NUM_THREADS_DEVICE/OMPVV_NUM_TEAMS_DEVICE;\n\n\tif (testing_thread_limit == 1)\n\t  testing_thread_limit = 2;\n\n\tOMPVV_TEST_OFFLOADING;\n      \n\n         for (i = 0; i<OMPVV_NUM_TEAMS_DEVICE; i++){\n              errors[i] = 0;\n         }\n \n\t#pragma omp target map(tofrom:num_teams,errors) thread_limit(testing_thread_limit)\n\t{\n\t\t#pragma omp teams num_teams(OMPVV_NUM_TEAMS_DEVICE) \n\t\t{\n\t\t\t#pragma omp parallel\n\t\t\t{\n\t\t\t\tif (omp_get_team_num() == 0 && omp_get_thread_num() == 0) {\n\t\t\t\t\tnum_teams = omp_get_num_teams();\n\t\t\t\t}\n\n                if ((omp_get_thread_num() == 0) && (omp_get_team_num() < OMPVV_NUM_TEAMS_DEVICE)) {\t\t\t\n\t\t\t\t\tif (omp_get_num_threads() > testing_thread_limit) {\n\t\t\t\t\t\terrors[omp_get_team_num()] += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\tfor (i = 0; i<OMPVV_NUM_TEAMS_DEVICE; i++){\n             sum_errors += errors[i];\n        }\n\n\tOMPVV_WARNING_IF(num_teams != OMPVV_NUM_TEAMS_DEVICE, \"The number of teams was unexpected, the test results are likely inconclusive\");\n\tOMPVV_WARNING_IF(testing_thread_limit == 1, \"Only one thread was allocated to each team, the test results are likely inconclusive\");\n\n\tOMPVV_REPORT_AND_RETURN(sum_errors);\n}\n",
        "error_code": "//===---------------- test_target_thread_limit.c -----------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// This test uses the thread_limit clause on the target construct. Specifically\n// testing if a thread_limit on a target construct properly carries\n// down to the nested teams construct, as if it were directly on the construct\n// as defined in the spec. The test validates that only the specified \n// threads are created by summing a shared variable across all threads \n// (and teams). If the threads are correctly limited, this should produce the\n// expected value. Additional warnings are sent if specific issues occur.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main() {\n\tint errors[OMPVV_NUM_TEAMS_DEVICE];\n\tint num_teams = 0;\n        int sum_errors = 0;\n        int i;\n\tint testing_thread_limit = OMPVV_NUM_THREADS_DEVICE/OMPVV_NUM_TEAMS_DEVICE;\n\n\tif (testing_thread_limit == 1)\n\t  testing_thread_limit = 2;\n\n\tOMPVV_TEST_OFFLOADING;\n      \n\n         for (i = 0; i<OMPVV_NUM_TEAMS_DEVICE; i++){\n              errors[i] = 0;\n         }\n \n\t#pragma omp flush map(tofrom:num_teams,errors) thread_limit(testing_thread_limit)\n\t{\n\t\t#pragma omp teams num_teams(OMPVV_NUM_TEAMS_DEVICE) \n\t\t{\n\t\t\t#pragma omp parallel\n\t\t\t{\n\t\t\t\tif (omp_get_team_num() == 0 && omp_get_thread_num() == 0) {\n\t\t\t\t\tnum_teams = omp_get_num_teams();\n\t\t\t\t}\n\n                if ((omp_get_thread_num() == 0) && (omp_get_team_num() < OMPVV_NUM_TEAMS_DEVICE)) {\t\t\t\n\t\t\t\t\tif (omp_get_num_threads() > testing_thread_limit) {\n\t\t\t\t\t\terrors[omp_get_team_num()] += 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t}\n\tfor (i = 0; i<OMPVV_NUM_TEAMS_DEVICE; i++){\n             sum_errors += errors[i];\n        }\n\n\tOMPVV_WARNING_IF(num_teams != OMPVV_NUM_TEAMS_DEVICE, \"The number of teams was unexpected, the test results are likely inconclusive\");\n\tOMPVV_WARNING_IF(testing_thread_limit == 1, \"Only one thread was allocated to each team, the test results are likely inconclusive\");\n\n\tOMPVV_REPORT_AND_RETURN(sum_errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_atomic_acquire_release.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp parallel\" with directive \"#pragma omp single\" at position 733",
        "issue_id": 0,
        "original_code": "//===--- test_atomic_acquire_release.c - test write release and read aquire--===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Adapted from OpenMP examples acquire_release.2.c\n// When the atomic read operation on thread 1 reads a non-zero value from y,\n// this results in a release/acquire synchronization that in turn implies that \n// the assignment to x on thread 0 happens before the read of x on thread 1. \n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nint test_atomic_acquire_release() {\n  OMPVV_INFOMSG(\"test_atomic_acquire_release\");\n\n  int x = 0, y = 0;\n  int errors = 0;\n\n#pragma omp parallel num_threads(2)\n   {\n      int thrd = omp_get_thread_num();\n       if (thrd == 0) {\n          x = 10;\n          #pragma omp atomic write release // or seq_cst\n          y = 1;\n       } else {\n          int tmp = 0;\n          while (tmp == 0) {\n            #pragma omp atomic read acquire // or seq_cst\n            tmp = y;\n          }\n          OMPVV_TEST_AND_SET(errors, x != 10);\n       }\n   }\n   return errors;\n}\n\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_atomic_acquire_release());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_atomic_acquire_release.c - test write release and read aquire--===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Adapted from OpenMP examples acquire_release.2.c\n// When the atomic read operation on thread 1 reads a non-zero value from y,\n// this results in a release/acquire synchronization that in turn implies that \n// the assignment to x on thread 0 happens before the read of x on thread 1. \n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nint test_atomic_acquire_release() {\n  OMPVV_INFOMSG(\"test_atomic_acquire_release\");\n\n  int x = 0, y = 0;\n  int errors = 0;\n\n#pragma omp single num_threads(2)\n   {\n      int thrd = omp_get_thread_num();\n       if (thrd == 0) {\n          x = 10;\n          #pragma omp atomic write release // or seq_cst\n          y = 1;\n       } else {\n          int tmp = 0;\n          while (tmp == 0) {\n            #pragma omp atomic read acquire // or seq_cst\n            tmp = y;\n          }\n          OMPVV_TEST_AND_SET(errors, x != 10);\n       }\n   }\n   return errors;\n}\n\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_atomic_acquire_release());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_loop_reduction_add.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1718",
        "issue_id": 1,
        "original_code": "//===--- test_loop_reduction_add.c ------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the reduction clause on a loop directive, testing that the\n// variable in the reduction clause is properly reduced using the add\n// operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_add() {\n  int a[N];\n  int b[N];\n  int total = 0;\n  int expect_total = 0;\n  int errors = 0;\n  int num_threads[N];\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    num_threads[x] = -1;\n  }\n\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST)\n  {\n#pragma omp loop reduction(+:total)\n    for (int x = 0; x < N; ++x) {\n      total += a[x] + b[x];\n    }\n#pragma omp for\n    for (int x = 0; x < N; ++x) {\n      num_threads[x] = omp_get_num_threads();\n    }\n  }\n\n  for (int x = 0; x < N; ++x) {\n    expect_total += a[x] + b[x];\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_threads[x - 1] != num_threads[x], \"Test reported differing numbers of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_threads[0] == 1, \"Test operated with one thread.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_threads[0] <= 0, \"Test reported invalid number of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, expect_total != total);\n  OMPVV_ERROR_IF(expect_total != total, \"Total from loop directive is %d but expected total is %d.\", total, expect_total);\n\n  return errors;\n}\n\nint main() {\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_add() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n",
        "error_code": "//===--- test_loop_reduction_add.c ------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the reduction clause on a loop directive, testing that the\n// variable in the reduction clause is properly reduced using the add\n// operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_add() {\n  int a[N];\n  int b[N];\n  int total = 0;\n  int expect_total = 0;\n  int errors = 0;\n  int num_threads[N];\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    num_threads[x] = -1;\n  }\n\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST)\n  {\n#pragma omp loop reduction(+:total)\n    for (int x = 0; x < N; ++x) {\n      total += a[x] + b[x];\n    }\n#pragma omp for\n    for (int x = 0; x < N; ++x) {\n      num_threads[x] = omp_get_num_threads();\n    }\n  }\n\n  for (int x = 0; x < N; ++x) {\n    expect_total += a[x] + b[x];\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_threads[x - 1] != num_threads[x], \"Test reported differing numbers of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_threads[0] == 1, \"Test operated with one thread.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_threads[0] <= 0, \"Test reported invalid number of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, expect_total != total);\n  OMPVV_ERROR_IF(expect_total != total, \"Total from loop directive is %d but expected total is %d.\", total, expect_total);\n\n  return errors;\n}\n\nint main() \n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_add() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_taskloop_if.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp parallel\" with directive \"#pragma omp teams\" at position 1184",
        "issue_id": 0,
        "original_code": "//--------------------------------------------- test_taskloop_if.c ----------------------------------------//\n//\n// OpenMP API Version 4.5 November 2015\n//\n// This test checks the taskloop directive with the if clause specified.\n// The 'taskloop' construct parallelize loops with independent iterations by creating tasks. \n// It allows for efficient parallel execution of loop iterations by distributing them among multiple threads. \n// The 'if' clause used to check the condition and taskloop will take into consideration only,      \n// if the condition is TRUE.\n//----------------------------------------------------------------------------------------------------------//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define NUM_TASKS 1000\n#define NUM_THREADS 1000\n\n#define M 100\n\n//if all thread ids are same, return 1 else return 0\nint thread_ids_are_same(int a[], int len) {\n\n\tint first = a[0];\n\n\tfor(int i = 1; i < len; i++) {\n\t\tif(first != a[i]) \n\t\t  return 0; //if all the thread ids are not same\n\t}\n\n\treturn 1; //if all the thread ids are same\t\n}\n\nint test_taskloop_if(int THRESHOLD) {\n  \n  int errors = 0;\n  \n  int thread_ids[NUM_TASKS];\n\n  #pragma omp parallel num_threads(NUM_THREADS)\n  {\n  \t#pragma omp single\n    \t{\t\n        \t#pragma omp taskloop if(M == THRESHOLD)\n      \t\tfor (int i = 0; i < NUM_TASKS; i++) {\n\t \t\tthread_ids[i] = omp_get_thread_num();\n      \t\t} \n   \t}\n  } \n  \n  if (M ==  THRESHOLD) {\n    if (thread_ids_are_same(thread_ids, NUM_TASKS) != 0) {\n      errors++; \n    }\n  } else if (M != THRESHOLD) {\n    if (thread_ids_are_same(thread_ids, NUM_TASKS) == 0) {\n      errors++; \n    }\n  }\n\n  return errors;            \n\n}\n\nint main() {\n \n   int errors = 0;\n   \n   int THRESHOLD = 100; //Equal to M\n   OMPVV_TEST_AND_SET_VERBOSE(errors, (test_taskloop_if(THRESHOLD) != 0));\n\n   THRESHOLD = 110; // Not equal to M\n   OMPVV_TEST_AND_SET_VERBOSE(errors, (test_taskloop_if(THRESHOLD) != 0));\n   \n   OMPVV_REPORT_AND_RETURN(errors);\n\n   return 0;\n}\n",
        "error_code": "//--------------------------------------------- test_taskloop_if.c ----------------------------------------//\n//\n// OpenMP API Version 4.5 November 2015\n//\n// This test checks the taskloop directive with the if clause specified.\n// The 'taskloop' construct parallelize loops with independent iterations by creating tasks. \n// It allows for efficient parallel execution of loop iterations by distributing them among multiple threads. \n// The 'if' clause used to check the condition and taskloop will take into consideration only,      \n// if the condition is TRUE.\n//----------------------------------------------------------------------------------------------------------//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define NUM_TASKS 1000\n#define NUM_THREADS 1000\n\n#define M 100\n\n//if all thread ids are same, return 1 else return 0\nint thread_ids_are_same(int a[], int len) {\n\n\tint first = a[0];\n\n\tfor(int i = 1; i < len; i++) {\n\t\tif(first != a[i]) \n\t\t  return 0; //if all the thread ids are not same\n\t}\n\n\treturn 1; //if all the thread ids are same\t\n}\n\nint test_taskloop_if(int THRESHOLD) {\n  \n  int errors = 0;\n  \n  int thread_ids[NUM_TASKS];\n\n  #pragma omp teams num_threads(NUM_THREADS)\n  {\n  \t#pragma omp single\n    \t{\t\n        \t#pragma omp taskloop if(M == THRESHOLD)\n      \t\tfor (int i = 0; i < NUM_TASKS; i++) {\n\t \t\tthread_ids[i] = omp_get_thread_num();\n      \t\t} \n   \t}\n  } \n  \n  if (M ==  THRESHOLD) {\n    if (thread_ids_are_same(thread_ids, NUM_TASKS) != 0) {\n      errors++; \n    }\n  } else if (M != THRESHOLD) {\n    if (thread_ids_are_same(thread_ids, NUM_TASKS) == 0) {\n      errors++; \n    }\n  }\n\n  return errors;            \n\n}\n\nint main() {\n \n   int errors = 0;\n   \n   int THRESHOLD = 100; //Equal to M\n   OMPVV_TEST_AND_SET_VERBOSE(errors, (test_taskloop_if(THRESHOLD) != 0));\n\n   THRESHOLD = 110; // Not equal to M\n   OMPVV_TEST_AND_SET_VERBOSE(errors, (test_taskloop_if(THRESHOLD) != 0));\n   \n   OMPVV_REPORT_AND_RETURN(errors);\n\n   return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_simd_order_concurrent.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 633",
        "issue_id": 2,
        "original_code": "//===--- test_simd_order_concurrent.c ---------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks for support of the order(concurrent) clause on a simd construct.\n// When an order(concurrent) clause is present on a simd construct, all of the same \n// restrictions from having a loop construct with an order(concurrent) also apply.\n//\n////===----------------------------------------------------------------------------===//\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <omp.h> \n#include \"ompvv.h\" \n#define N 1024\n\nint test_simd_order_concurrent () {\n   int errors = 0;\n   int i;\n   int b[N], c[N];\n\n   struct new_struct {\n      int a[N];\n   };\n\n   struct new_struct struct_t;\n   \n   for (i = 0; i < N; i++ ) {\n      struct_t.a[i] = i;\n      b[i] = i + 5;\n      c[i] = 0;\n   }\n\n   #pragma omp simd order(concurrent) \n      for (i = 0; i < N; i++) {\n         c[i] = struct_t.a[i] * b[i];\n      }\n\n   for (i = 0; i < N; i++) {\n      OMPVV_TEST_AND_SET(errors, c[i] != (struct_t.a[i] * b[i]));\n   }\n\n   return errors;\n}\n\n\nint main () { \n   int errors = 0;\n\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_simd_order_concurrent());\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_simd_order_concurrent.c ---------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks for support of the order(concurrent) clause on a simd construct.\n// When an order(concurrent) clause is present on a simd construct, all of the same \n// restrictions from having a loop construct with an order(concurrent) also apply.\n//\n////===----------------------------------------------------------------------------===//\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <omp.h> \n#include \"ompvv.h\" \n#define N 1024\n\nint test_simd_order_concurrent () {\n   int errors = 0;\n   int i;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n   int b[N], c[N];\n\n   struct new_struct {\n      int a[N];\n   };\n\n   struct new_struct struct_t;\n   \n   for (i = 0; i < N; i++ ) {\n      struct_t.a[i] = i;\n      b[i] = i + 5;\n      c[i] = 0;\n   }\n\n   #pragma omp simd order(concurrent) \n      for (i = 0; i < N; i++) {\n         c[i] = struct_t.a[i] * b[i];\n      }\n\n   for (i = 0; i < N; i++) {\n      OMPVV_TEST_AND_SET(errors, c[i] != (struct_t.a[i] * b[i]));\n   }\n\n   return errors;\n}\n\n\nint main () { \n   int errors = 0;\n\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_simd_order_concurrent());\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_parallel_for_lastprivate_conditional.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp parallel\" with directive \"#pragma omp cancel\" at position 510",
        "issue_id": 0,
        "original_code": "//===------ test_parallel_for_lastprivate_conditional.c ------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test evaluates the lastprivate directive using the conditional clause,\n// ensuring proper behavior and variable updates in parallel regions.\n//===-------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_lastprivate_conditional() {\n        int errors = 0;\n        int a[N];\n        int x = 0;\n\n        #pragma omp parallel for lastprivate(conditional: x)\n        for (int k = 0; k < N; k++) {\n                a[k] = k;\n                if (k == 24 || k == 123) {\n                        x = a[k];\n\t\t}\n        }\n        // Check to make sure x is set.\n        OMPVV_TEST_AND_SET(errors, x!= 123);\n        return errors;\n}\n\nint main() {\n        int errors = 0;\n\n        OMPVV_TEST_AND_SET_VERBOSE(errors, test_lastprivate_conditional() != 0);\n\n        OMPVV_REPORT_AND_RETURN(errors);\n}\n\n",
        "error_code": "//===------ test_parallel_for_lastprivate_conditional.c ------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test evaluates the lastprivate directive using the conditional clause,\n// ensuring proper behavior and variable updates in parallel regions.\n//===-------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_lastprivate_conditional() {\n        int errors = 0;\n        int a[N];\n        int x = 0;\n\n        #pragma omp cancel for lastprivate(conditional: x)\n        for (int k = 0; k < N; k++) {\n                a[k] = k;\n                if (k == 24 || k == 123) {\n                        x = a[k];\n\t\t}\n        }\n        // Check to make sure x is set.\n        OMPVV_TEST_AND_SET(errors, x!= 123);\n        return errors;\n}\n\nint main() {\n        int errors = 0;\n\n        OMPVV_TEST_AND_SET_VERBOSE(errors, test_lastprivate_conditional() != 0);\n\n        OMPVV_REPORT_AND_RETURN(errors);\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_loop_reduction_bitor.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 2399",
        "issue_id": 1,
        "original_code": "//===--- test_loop_reduction_bitor.c ----------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the reduction clause on a loop directive, testing that the\n// variable in the reduction clause is properly reduced using the bitor\n// operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n#define THRESHOLD 1024\n\nint test_bitor() {\n  int a[N];\n  // See the 'and' operator test for an exaplantion of this math.\n  double true_margin = pow(exp(1), log(.5)/N);\n  int errors = 0;\n  int num_threads[N];\n  int num_attempts = 0;\n  int have_true = 0, have_false = 0;\n  srand(1);\n\n  while ((!have_true || !have_false) && (num_attempts < THRESHOLD)) {\n    have_true = 0;\n    have_false = 0;\n    for (int x = 0; x < N; ++x) {\n      if( num_attempts == 0 ) {\n        a[x] = 0;\n      }\n      for (int y = 0; y < 16; ++y) {\n        if (rand() / (double) RAND_MAX > true_margin) {\n          a[x] += (1 << y);\n          have_true = 1;\n        } else {\n          have_false = 1;\n        }\n      }\n      num_threads[x] = -x;\n    }\n    num_attempts++;\n  }\n\n  OMPVV_WARNING_IF(!have_true, \"No true bits were generated to test\");\n  OMPVV_WARNING_IF(!have_false, \"No false bits were generated to test\");\n\n  unsigned int b = 0;\n\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST)\n  {\n#pragma omp loop reduction(|:b)\n    for (int x = 0; x < N; ++x) {\n      b = b | a[x];\n    }\n#pragma omp for\n    for (int x = 0; x < N; ++x) {\n      num_threads[x] = omp_get_num_threads();\n    }\n  }\n\n  unsigned int host_b = 0;\n\n  for (int x = 0; x < N; ++x) {\n    host_b = host_b | a[x];\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_threads[x - 1] != num_threads[x], \"Test reported differing numbers of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_threads[0] == 1, \"Test operated with one thread.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_threads[0] <= 0, \"Test reported invalid number of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, b != host_b);\n  OMPVV_ERROR_IF(host_b != b, \"Bit from loop directive is %d but expected bit is %d.\", b, host_b);\n\n  return errors;\n}\n\nint main() {\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_bitor() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n",
        "error_code": "//===--- test_loop_reduction_bitor.c ----------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the reduction clause on a loop directive, testing that the\n// variable in the reduction clause is properly reduced using the bitor\n// operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n#define THRESHOLD 1024\n\nint test_bitor() {\n  int a[N];\n  // See the 'and' operator test for an exaplantion of this math.\n  double true_margin = pow(exp(1), log(.5)/N);\n  int errors = 0;\n  int num_threads[N];\n  int num_attempts = 0;\n  int have_true = 0, have_false = 0;\n  srand(1);\n\n  while ((!have_true || !have_false) && (num_attempts < THRESHOLD)) {\n    have_true = 0;\n    have_false = 0;\n    for (int x = 0; x < N; ++x) {\n      if( num_attempts == 0 ) {\n        a[x] = 0;\n      }\n      for (int y = 0; y < 16; ++y) {\n        if (rand() / (double) RAND_MAX > true_margin) {\n          a[x] += (1 << y);\n          have_true = 1;\n        } else {\n          have_false = 1;\n        }\n      }\n      num_threads[x] = -x;\n    }\n    num_attempts++;\n  }\n\n  OMPVV_WARNING_IF(!have_true, \"No true bits were generated to test\");\n  OMPVV_WARNING_IF(!have_false, \"No false bits were generated to test\");\n\n  unsigned int b = 0;\n\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST)\n  {\n#pragma omp loop reduction(|:b)\n    for (int x = 0; x < N; ++x) {\n      b = b | a[x];\n    }\n#pragma omp for\n    for (int x = 0; x < N; ++x) {\n      num_threads[x] = omp_get_num_threads();\n    }\n  }\n\n  unsigned int host_b = 0;\n\n  for (int x = 0; x < N; ++x) {\n    host_b = host_b | a[x];\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_threads[x - 1] != num_threads[x], \"Test reported differing numbers of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_threads[0] == 1, \"Test operated with one thread.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_threads[0] <= 0, \"Test reported invalid number of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, b != host_b);\n  OMPVV_ERROR_IF(host_b != b, \"Bit from loop directive is %d but expected bit is %d.\", b, host_b);\n\n  return errors;\n}\n\nint main() \n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_bitor() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_assume_holds.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp assume\" with directive \"#pragma omp master\" at position 697",
        "issue_id": 0,
        "original_code": "//===--- test_assume_holds.c ------------------------------------------------===//\n//\n//  OpenMP API Version 5.1 Aug 2021\n//\n//  The specification states that \"When the holds clause appears on an assume\n//  directive, the application guarantees that the listed expression evaluates\n//  to true in the scope of the directive.\" In this test, we use \"N\" as a\n//  constant variable that does not change in the scope of the assume directive.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\nint errors, i, N;\n\nint test_assume_holds() {\n    N = 1024;\n    int arr[N];\n    #pragma omp assume holds(N == 1024)\n    {\n        for(i = 0; i < N; i++){\n            arr[i] = i;\n        }\n        #pragma omp target parallel for map(tofrom: arr)\n        for(i = 0; i < N; i++){\n            arr[i] = arr[i]*2;\n        }\n    }\n    // Test that no issues were caused from using assume directive\n    for(i = 0; i < N; i++){\n        OMPVV_TEST_AND_SET(errors, arr[i] != i*2);\n    }\n   return errors;\n}\n\nint main() {\n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_assume_holds() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_assume_holds.c ------------------------------------------------===//\n//\n//  OpenMP API Version 5.1 Aug 2021\n//\n//  The specification states that \"When the holds clause appears on an assume\n//  directive, the application guarantees that the listed expression evaluates\n//  to true in the scope of the directive.\" In this test, we use \"N\" as a\n//  constant variable that does not change in the scope of the assume directive.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\nint errors, i, N;\n\nint test_assume_holds() {\n    N = 1024;\n    int arr[N];\n    #pragma omp master holds(N == 1024)\n    {\n        for(i = 0; i < N; i++){\n            arr[i] = i;\n        }\n        #pragma omp target parallel for map(tofrom: arr)\n        for(i = 0; i < N; i++){\n            arr[i] = arr[i]*2;\n        }\n    }\n    // Test that no issues were caused from using assume directive\n    for(i = 0; i < N; i++){\n        OMPVV_TEST_AND_SET(errors, arr[i] != i*2);\n    }\n   return errors;\n}\n\nint main() {\n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_assume_holds() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/gridmini_map_template.cpp",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 783",
        "issue_id": 2,
        "original_code": "//===-- gridmini_map_template.cpp - ---------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks for support for C++ template by verifying that the multiplication \n// of members of the struct 'vec' in the offloaded region provides the same answer \n// as calculated by host. \n//\n//===----------------------------------------------------------------------===//\n\n#include <cstdlib>\n#include <stdio.h>\n#include <iostream>\n#include \"ompvv.h\"\n#include \"omp.h\"\n\nusing namespace std;\ntemplate <typename T>\nstruct vec {\n  T v1;\n  T v2;\n};\n\ntemplate <typename T> vec<T> mult(vec<T> x, vec<T> y){\n  vec<T> out;\n  out.v1 = x.v1*y.v1;\n  out.v2 = x.v2*y.v2;\n  return out;\n}\n\nint main(int argc, char* argv[]){\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n  int N = 10;\n  float x = (float)rand()/(float)(RAND_MAX/10.0);\n  float y = (float)rand()/(float)(RAND_MAX/5.0);\n  vec<float> in1,in2;\n  in1.v1 = x;\n  in1.v2 = x;\n  in2.v1 = y;\n  in2.v2 = y;\n  vec<float> out[N];\n\n  //calulate on host\n  vec<float> expected = mult(in1,in2);\n\n#pragma omp target teams distribute parallel for map(to:in1,in2) map(from:out[0:N])\n    for(int n = 0; n < N; n++) {\n      out[n] = mult(in1,in2);\n    }\n    \n  for(int n = 0; n < N; n++) {\n    OMPVV_TEST_AND_SET(errors,out[n].v1 != expected.v1);\n    OMPVV_TEST_AND_SET(errors,out[n].v2 != expected.v2);\n  }\n\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n}\n\n",
        "error_code": "//===-- gridmini_map_template.cpp - ---------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks for support for C++ template by verifying that the multiplication \n// of members of the struct 'vec' in the offloaded region provides the same answer \n// as calculated by host. \n//\n//===----------------------------------------------------------------------===//\n\n#include <cstdlib>\n#include <stdio.h>\n#include <iostream>\n#include \"ompvv.h\"\n#include \"omp.h\"\n\nusing namespace std;\ntemplate <typename T>\nstruct vec {\n  T v1;\n  T v2;\n};\n\ntemplate <typename T> vec<T> mult(vec<T> x, vec<T> y){\n  vec<T> out;\n  out.v1 = x.v1*y.v1;\n  out.v2 = x.v2*y.v2;\n  return out;\n}\n\nint main(int argc, char* argv[]){\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n  int N = 10;\n  float x = (float)rand()/(float)(RAND_MAX/10.0);\n  float y = (float)rand()/(float)(RAND_MAX/5.0);\n  vec<float> in1,in2;\n  in1.v1 = x;\n  in1.v2 = x;\n  in2.v1 = y;\n  in2.v2 = y;\n  vec<float> out[N];\n\n  //calulate on host\n  vec<float> expected = mult(in1,in2);\n\n#pragma omp target teams distribute parallel for map(to:in1,in2) map(from:out[0:N])\n    for(int n = 0; n < N; n++) {\n      out[n] = mult(in1,in2);\n    }\n    \n  for(int n = 0; n < N; n++) {\n    OMPVV_TEST_AND_SET(errors,out[n].v1 != expected.v1);\n    OMPVV_TEST_AND_SET(errors,out[n].v2 != expected.v2);\n  }\n\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_omp_target_offload_env_DISABLED.c",
        "correct": "n",
        "issue": "Removed opening bracket at position -1",
        "issue_id": 1,
        "original_code": "//===--- test_omp_target_offload_env_DISABLED.c ----------------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks for offloading behavior when OMP_TARGET_OFFLOAD is set to DISABLED.\n//\n// See test_omp_target_offload_env_DEFAULT.c for details.\n//\n////===--------------------------------------------------------------------------------------------===//\n\n#define EXPECTED_POLICY DISABLED\n\n#include \"./test_omp_target_offload_env_DEFAULT.c\"\n",
        "error_code": "//===--- test_omp_target_offload_env_DISABLED.c ----------------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks for offloading behavior when OMP_TARGET_OFFLOAD is set to DISABLED.\n//\n// See test_omp_target_offload_env_DEFAULT.c for details.\n//\n////===--------------------------------------------------------------------------------------------===//\n\n#define EXPECTED_POLICY DISABLED\n\n#include \"./test_omp_target_offload_env_DEFAULT.c\"//===--- test_omp_target_offload_env_DISABLED.c ----------------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks for offloading behavior when OMP_TARGET_OFFLOAD is set to DISABLED.\n//\n// See test_omp_target_offload_env_DEFAULT.c for details.\n//\n////===--------------------------------------------------------------------------------------------===//\n\n#define EXPECTED_POLICY DISABLED\n\n#include \"./test_omp_target_offload_env_DEFAULT.c\"\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_parallel_sections.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n      OMPVV_WARNING(\"Sections are executed by a single thread, test will be aborted.\")\n      exit(0);\n    }\" at position 1557",
        "issue_id": 4,
        "original_code": "//===================-test_parallel_sections.c-=============================//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// testing the combined construct 'parallel sections'\n//\n//===---------------------------------------------------------------------===//\n\n\n\n#include <stdio.h>\n#include <unistd.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\nint Var = 0;\n\n// The following function waits for Var value to become 1 and then increments\n// it to Var = 1\nvoid function1(int *Var) {\n  int temp = -1;\n  while(1) {\n   #pragma omp atomic read\n    temp = *Var;\n    \n    if (temp == 1) {\n      #pragma omp atomic update\n      *Var += 1;\n      break;\n    }\n  }\n}\n\n// The following function check if Var == 0 and then increments to Var = 1\n// and then immediately it loops until Var == 3 and then increments it to\n// Var = 4\nvoid function2(int *Var) {\n  int temp = -1;\n  while(1) {\n    #pragma omp atomic read\n    temp = *Var;\n    \n    if (temp == 0) {\n      #pragma omp atomic update\n      *Var += 1;\n      break;\n    }\n  }\n\n  while(1) {\n    #pragma omp atomic read\n    temp = *Var;\n    \n    if (temp == 3) {\n      #pragma omp atomic update\n      *Var += 1;\n      break;\n    }\n  }\n}\n\n// The following function checks if Var == 2 and then increments to Var = 3\nvoid function3(int *Var) {\n  int temp = -1;\n  while(1) {\n    #pragma omp atomic read\n    temp = *Var;\n    \n    if (*Var == 2) {\n      #pragma omp atomic update\n      *Var += 1;\n      break;\n    }\n  }\n}\n\n\nint main() {\n  int errors = 0;\n  \n  #pragma omp parallel sections\n  {\n    if(omp_get_num_threads() == 1) \n    {\n      OMPVV_WARNING(\"Sections are executed by a single thread, test will be aborted.\")\n      exit(0);\n    }\n      \n    #pragma omp section\n    function1(&Var);\n\n    #pragma omp section\n    function2(&Var);\n\n    #pragma omp section\n    function3(&Var);\n  }\n \n  \n  // The final expected value of Var is '4'\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (Var != 4));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===================-test_parallel_sections.c-=============================//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// testing the combined construct 'parallel sections'\n//\n//===---------------------------------------------------------------------===//\n\n\n\n#include <stdio.h>\n#include <unistd.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\nint Var = 0;\n\n// The following function waits for Var value to become 1 and then increments\n// it to Var = 1\nvoid function1(int *Var) {\n  int temp = -1;\n  while(1) {\n   #pragma omp atomic read\n    temp = *Var;\n    \n    if (temp == 1) {\n      #pragma omp atomic update\n      *Var += 1;\n      break;\n    }\n  }\n}\n\n// The following function check if Var == 0 and then increments to Var = 1\n// and then immediately it loops until Var == 3 and then increments it to\n// Var = 4\nvoid function2(int *Var) {\n  int temp = -1;\n  while(1) {\n    #pragma omp atomic read\n    temp = *Var;\n    \n    if (temp == 0) {\n      #pragma omp atomic update\n      *Var += 1;\n      break;\n    }\n  }\n\n  while(1) {\n    #pragma omp atomic read\n    temp = *Var;\n    \n    if (temp == 3) {\n      #pragma omp atomic update\n      *Var += 1;\n      break;\n    }\n  }\n}\n\n// The following function checks if Var == 2 and then increments to Var = 3\nvoid function3(int *Var) {\n  int temp = -1;\n  while(1) {\n    #pragma omp atomic read\n    temp = *Var;\n    \n    if (*Var == 2) {\n      #pragma omp atomic update\n      *Var += 1;\n      break;\n    }\n  }\n}\n\n\nint main() {\n  int errors = 0;\n  \n  #pragma omp parallel sections\n  {\n    if(omp_get_num_threads() == 1) \n    \n      \n    #pragma omp section\n    function1(&Var);\n\n    #pragma omp section\n    function2(&Var);\n\n    #pragma omp section\n    function3(&Var);\n  }\n \n  \n  // The final expected value of Var is '4'\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (Var != 4));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_simd_simdlen.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 2144",
        "issue_id": 2,
        "original_code": "//===---- test_target_simd_simdlen.c - simd directive clause simdlen   -===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// This test checks for the use of the simdlen clause which provides a hint to the\n// compiler to the appropriate number of simd lanes when generating the simd\n// region of code. However, different to safelen, this clause does not guarantee \n// that the number of lanes will actually be the one specified. The number of lanes\n// is implementation defined \n// ===--------------------------------------------------------------------------===//\n//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define ARRAY_SIZE 1024\n\nint test_target_simd_simdlen() {\n  OMPVV_INFOMSG(\"test_target_simd_simdlen\");\n  OMPVV_WARNING(\"This test cannot check if actual SIMD extensions at the hardware level\" \\\n                 \" were used, or of the generated code is different in any way\");\n\n  // Variable for errors counting\n  int errors = 0;\n\n  int A[ARRAY_SIZE];\n  int i, len;\n\n  // a and b array initialization\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      A[i] = 1;\n  }\n\n  // Test simdlen of 1 5 8 13 16 100 128\n#pragma omp target simd simdlen(1) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      A[i] += A[i]; \n  }\n\n#pragma omp target simd simdlen(5) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      A[i] += A[i]; \n  }\n\n#pragma omp target simd simdlen(8) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      A[i] += A[i]; \n  }\n\n#pragma omp target simd simdlen(13) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      A[i] += A[i]; \n  }\n\n#pragma omp target simd simdlen(16) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      A[i] += A[i]; \n  }\n\n#pragma omp target simd simdlen(100) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      A[i] += A[i]; \n  }\n\n#pragma omp target simd simdlen(128) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      A[i] += A[i]; \n  }\n\n  // Check the results\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      OMPVV_TEST_AND_SET(errors, A[i] != 1<<7);\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_simd_simdlen());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_simd_simdlen.c - simd directive clause simdlen   -===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// This test checks for the use of the simdlen clause which provides a hint to the\n// compiler to the appropriate number of simd lanes when generating the simd\n// region of code. However, different to safelen, this clause does not guarantee \n// that the number of lanes will actually be the one specified. The number of lanes\n// is implementation defined \n// ===--------------------------------------------------------------------------===//\n//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define ARRAY_SIZE 1024\n\nint test_target_simd_simdlen() {\n  OMPVV_INFOMSG(\"test_target_simd_simdlen\");\n  OMPVV_WARNING(\"This test cannot check if actual SIMD extensions at the hardware level\" \\\n                 \" were used, or of the generated code is different in any way\");\n\n  // Variable for errors counting\n  int errors = 0;\n\n  int A[ARRAY_SIZE];\n  int i, len;\n\n  // a and b array initialization\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      A[i] = 1;\n  }\n\n  // Test simdlen of 1 5 8 13 16 100 128\n#pragma omp target simd simdlen(1) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      A[i] += A[i]; \n  }\n\n#pragma omp target simd simdlen(5) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      A[i] += A[i]; \n  }\n\n#pragma omp target simd simdlen(8) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      A[i] += A[i]; \n  }\n\n#pragma omp target simd simdlen(13) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      A[i] += A[i]; \n  }\n\n#pragma omp target simd simdlen(16) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      A[i] += A[i]; \n  }\n\n#pragma omp target simd simdlen(100) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      A[i] += A[i]; \n  }\n\n#pragma omp target simd simdlen(128) map(tofrom: A[0:ARRAY_SIZE])\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      A[i] += A[i]; \n  }\n\n  // Check the results\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      OMPVV_TEST_AND_SET(errors, A[i] != 1<<7);yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_simd_simdlen());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_parallel_for_order_reproducible.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp map\" at position 738",
        "issue_id": 0,
        "original_code": "//===------------ test_target_parallel_for_order_reproducible.c -------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// This test checks that the order(reproducible:concurrent) clause is properly handled.\n// Leverages the previous array item to determine if the same threads executed\n// in the same order over the array. If both arrays match the test passes, \n// if not it fails as the reproducible clause failed.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main() {\n\tint errors = 0;\n\tint x[N];\n\tint y[N];\n\n\tfor (int i = 0; i < N; i++) {\n\t\tx[i] = i;\n\t\ty[i] = i;\n\t}\n\n\tOMPVV_TEST_OFFLOADING;\n\n\t#pragma omp target map(tofrom: x,y)\n\t{\n\n\t#pragma omp parallel \n\t  {\n\t\t#pragma omp for order(reproducible:concurrent) nowait\n\t\t  for (int i = 0; i < N; i++) {\n\t\t\tx[i] = x[i] + 2;\t\n\t\t  }\n\n\t\t#pragma omp for order(reproducible:concurrent)\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\ty[i] = x[i] + 2;\n\t\t}\n\t  }\n\t}\n\n\tfor (int i = 0; i < N; i++) {\n    \t\tOMPVV_TEST_AND_SET(errors, y[i] != i + 4);\n\t}\n\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===------------ test_target_parallel_for_order_reproducible.c -------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// This test checks that the order(reproducible:concurrent) clause is properly handled.\n// Leverages the previous array item to determine if the same threads executed\n// in the same order over the array. If both arrays match the test passes, \n// if not it fails as the reproducible clause failed.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main() {\n\tint errors = 0;\n\tint x[N];\n\tint y[N];\n\n\tfor (int i = 0; i < N; i++) {\n\t\tx[i] = i;\n\t\ty[i] = i;\n\t}\n\n\tOMPVV_TEST_OFFLOADING;\n\n\t#pragma omp map map(tofrom: x,y)\n\t{\n\n\t#pragma omp parallel \n\t  {\n\t\t#pragma omp for order(reproducible:concurrent) nowait\n\t\t  for (int i = 0; i < N; i++) {\n\t\t\tx[i] = x[i] + 2;\t\n\t\t  }\n\n\t\t#pragma omp for order(reproducible:concurrent)\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\ty[i] = x[i] + 2;\n\t\t}\n\t  }\n\t}\n\n\tfor (int i = 0; i < N; i++) {\n    \t\tOMPVV_TEST_AND_SET(errors, y[i] != i + 4);\n\t}\n\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_data_map_alloc.c",
        "correct": "n",
        "issue": "Removed memory allocation line \"omp_target_alloc\n  // section 3.5.1 omp_target_alloc. OpenMP API Version 4.5 Nov 2015\n  int *d_sum = (int *)omp_target_alloc(sizeof(int), omp_get_default_device());\" at position 921",
        "issue_id": 0,
        "original_code": "//===---- test_target_data_map_alloc.c ---------------------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// The test_target_data_map group of tests checks all the possible map-type-modifiers\n// for the target data map clauses. These are: from, to, tofrom, alloc, release and \n// delete. There is a a separate c file for each test with the prefix test_target_data_map.\n// This specific test is for the 'alloc' clause. \n//\n//===----------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\n// Test for OpenMP 4.5 target data map(alloc:)\nint test_map_alloc() {\n\n  OMPVV_INFOMSG(\"test_map_alloc\");\n\n  int sum = 0, errors = 0;\n  int *h_array_h = (int *)malloc(N*sizeof(int));\n\n  // pointer arithmetic is not supported on the devices for\n  // the device address returned by omp_target_alloc\n  // section 3.5.1 omp_target_alloc. OpenMP API Version 4.5 Nov 2015\n  int *d_sum = (int *)omp_target_alloc(sizeof(int), omp_get_default_device());\n\n  if (d_sum == NULL) {\n    errors = 1;\n    OMPVV_ERROR(\"omp_target_alloc returns NULL, this test is running on host, cannot properly test mapping of variables to device.\");\n    return errors;\n  }\n\n#pragma omp target data map(alloc: h_array_h[0:N])\n  {\n#pragma omp target is_device_ptr(d_sum)\n    {\n      for (int i = 0; i < N; ++i) \n        h_array_h[i] = 1;\n      \n      // checking errors\n      d_sum[0] = 0; \n      for (int i = 0; i < N; ++i)\n        d_sum[0] += h_array_h[i];\n    } // end target\n    omp_target_memcpy(&sum, d_sum, sizeof(int), 0, 0,\n                                  omp_get_initial_device(),\n                                  omp_get_default_device());\n  } // end target data\n  omp_target_free(d_sum, omp_get_default_device());\n\n  free(h_array_h);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (N - sum) != 0);\n\n  return errors;\n}\n\nint main() {\n\n  int errors = 0;\n  \n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_alloc());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n  \n",
        "error_code": "//===---- test_target_data_map_alloc.c ---------------------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// The test_target_data_map group of tests checks all the possible map-type-modifiers\n// for the target data map clauses. These are: from, to, tofrom, alloc, release and \n// delete. There is a a separate c file for each test with the prefix test_target_data_map.\n// This specific test is for the 'alloc' clause. \n//\n//===----------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\n// Test for OpenMP 4.5 target data map(alloc:)\nint test_map_alloc() {\n\n  OMPVV_INFOMSG(\"test_map_alloc\");\n\n  int sum = 0, errors = 0;\n  int *h_array_h = (int *)malloc(N*sizeof(int));\n\n  // pointer arithmetic is not supported on the devices for\n  // the device address returned by \n\n  if (d_sum == NULL) {\n    errors = 1;\n    OMPVV_ERROR(\"omp_target_alloc returns NULL, this test is running on host, cannot properly test mapping of variables to device.\");\n    return errors;\n  }\n\n#pragma omp target data map(alloc: h_array_h[0:N])\n  {\n#pragma omp target is_device_ptr(d_sum)\n    {\n      for (int i = 0; i < N; ++i) \n        h_array_h[i] = 1;\n      \n      // checking errors\n      d_sum[0] = 0; \n      for (int i = 0; i < N; ++i)\n        d_sum[0] += h_array_h[i];\n    } // end target\n    omp_target_memcpy(&sum, d_sum, sizeof(int), 0, 0,\n                                  omp_get_initial_device(),\n                                  omp_get_default_device());\n  } // end target data\n  omp_target_free(d_sum, omp_get_default_device());\n\n  free(h_array_h);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (N - sum) != 0);\n\n  return errors;\n}\n\nint main() {\n\n  int errors = 0;\n  \n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_alloc());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n  \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_map_iterators.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp declare\" at position 692",
        "issue_id": 0,
        "original_code": "//-------------------------test_target_map_iterator.c----------------------\n//\n//OpenMP API Version 5.1 Nov 2020\n//\n// This test is designed to test the iterator map-type-modifier for the map\n// clause. The test should create a list of size N and then pass to the \n// target region the length of the array 1:N and modify the values.\n// The test then checks to see if the appropriate range was modified.\n//\n//-------------------------------------------------------------------------\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_case(){\n\tint errors = 0;\n\tint sum = 0;\n\tint test_lst[N];\n\tfor (int i = 0; i<N; i++){\n\t\ttest_lst[i] = 1;\n\t}\n\t#pragma omp target map(iterator(it = 0:N), tofrom: test_lst[it])\n\t{\n\t\tfor(int i = 0; i < N; i++){\n\t\t\ttest_lst[i] = 2;\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++){\n\t\tsum += test_lst[i];\n\t}\n\tOMPVV_TEST_AND_SET(errors, (sum != 2*N));\n\treturn (errors);\n}\n\nint main(){\n\tint errors = 0;\n\tOMPVV_TEST_OFFLOADING;\n\tOMPVV_TEST_AND_SET_VERBOSE(errors,test_case() != 0);\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//-------------------------test_target_map_iterator.c----------------------\n//\n//OpenMP API Version 5.1 Nov 2020\n//\n// This test is designed to test the iterator map-type-modifier for the map\n// clause. The test should create a list of size N and then pass to the \n// target region the length of the array 1:N and modify the values.\n// The test then checks to see if the appropriate range was modified.\n//\n//-------------------------------------------------------------------------\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_case(){\n\tint errors = 0;\n\tint sum = 0;\n\tint test_lst[N];\n\tfor (int i = 0; i<N; i++){\n\t\ttest_lst[i] = 1;\n\t}\n\t#pragma omp declare map(iterator(it = 0:N), tofrom: test_lst[it])\n\t{\n\t\tfor(int i = 0; i < N; i++){\n\t\t\ttest_lst[i] = 2;\n\t\t}\n\t}\n\tfor (int i = 0; i < N; i++){\n\t\tsum += test_lst[i];\n\t}\n\tOMPVV_TEST_AND_SET(errors, (sum != 2*N));\n\treturn (errors);\n}\n\nint main(){\n\tint errors = 0;\n\tOMPVV_TEST_OFFLOADING;\n\tOMPVV_TEST_AND_SET_VERBOSE(errors,test_case() != 0);\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_defaultmap_present_aggregate.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===--- test_target_defaultmap_present_aggregate.c -------------------------===//\n//\n//  OpenMP API Version 5.1 Aug 2020\n//\n//  This test checks behavior of the defaultmap clause when the specified \n//  implicit-behavior is present. The variable-categories available for defaultmap\n//  are scalar, aggregate, and pointer. If implicit-behavior is present, each \n//  variable referenced in the construct in the category specified by \n//  variable-category is treated as if it had been listed in a map clause with the\n//  map-type of alloc and map-type-modifier of present.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_defaultmap_present_aggregate() {\n\n   int errors = 0;\n   int i;\n   int a[N];\n   struct test_struct {\n     int s; \n     int S[2];\n   };\n   \n   //Initialize aggregate array\n   for (i = 0; i < N; i++) {\n      a[i] = i;\n   }\n   \n   //Initialize struct and associated members\n   struct test_struct new_struct;\n   new_struct.s = 10; new_struct.S[0] = 100; new_struct.S[1] = 1000;\n   \n   \n   #pragma omp target data map(tofrom: a, new_struct)\n   {\n   #pragma omp target map(tofrom: errors) defaultmap(present: aggregate)\n   {  \n      for (i = 0; i < N; i++) {\n         if(a[i] != i){errors++;}\n         a[i] += 2;\n      }\n      \n      if(new_struct.s != 10 || new_struct.S[0] != 100 || new_struct.S[1] != 1000) {errors++;}\n      new_struct.s = 7; new_struct.S[0] = 70; new_struct.S[1] = 700;\n   }\n   }\n     \n   OMPVV_ERROR_IF(errors > 0, \"Values were not mapped to the device properly\");\n\n   for (i = 0; i < N; i++) {\n      OMPVV_TEST_AND_SET(errors, a[i] != 2+i);\n   }\n\n   OMPVV_TEST_AND_SET(errors, new_struct.s != 7 ||  new_struct.S[0] != 70 || new_struct.S[1] != 700);\n \n   return errors;\n}\n\nint main() {\n   int errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_defaultmap_present_aggregate() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n\n    \n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\ndouble cnykzsqsgp = 179;\nshort rpgpevecxd = 82;\nbyte tvhulfulem = 93;\nbyte rgcsnmwjrl = 104;\nint utydmrxkxf = 215;\nint qharkazabx = 130;\nshort lvbbxuaqfh = 24;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_update_from.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp map\" at position 919",
        "issue_id": 0,
        "original_code": "//===---- test_target_update_from.c -------------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks the target update motion clause 'from' by mapping an array \n// to the device with map-type 'to', changing the values of array on the device,\n// and finally using the update 'from' motion clause to assign the value of the \n// list item. Back on the host, measures are taken to ensure the value was properly\n// updated.  \n//===--------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define N 100\n\nint a[N];\nint b[N];\nint c[N];\n\n\n// Test for OpenMP 4.5 target update with to\nint main() {\n  int errors = 0, i = 0, change_flag = 0;\n\n  for (i = 0; i < N; i++) {\n    a[i] = 10;\n    b[i] = 2; \n  }\n\n  // We test for offloading\n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n\n\n#pragma omp target data map(to: a[:N], b[:N]) \n{\n  #pragma omp target\n  {\n    int j = 0;\n    for (j = 0; j < N; j++) {\n      b[j] = (a[j] + b[j]);// b = 12 \n    }\n  } // end target\n\n  #pragma omp target update from(b[:N]) // update b = 12 on host \n\n} //end target-data\n \n  // Checking values of b[N] \n  for (i = 0; i < N; i++) \n    OMPVV_TEST_AND_SET_VERBOSE(errors, (b[i] != 12)); \n\n  #pragma omp target \n  {\n    int j = 0;\n    for (j = 0; j < N; j++) {\n      c[j] = (2* b[j]);// c = 24 \n    }\n  } // end target\n\n  // Checking values of c[N] \n  for (i = 0; i < N; i++) \n    OMPVV_TEST_AND_SET_VERBOSE(errors, (c[i] != 24)); \n    \n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_update_from.c -------------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks the target update motion clause 'from' by mapping an array \n// to the device with map-type 'to', changing the values of array on the device,\n// and finally using the update 'from' motion clause to assign the value of the \n// list item. Back on the host, measures are taken to ensure the value was properly\n// updated.  \n//===--------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define N 100\n\nint a[N];\nint b[N];\nint c[N];\n\n\n// Test for OpenMP 4.5 target update with to\nint main() {\n  int errors = 0, i = 0, change_flag = 0;\n\n  for (i = 0; i < N; i++) {\n    a[i] = 10;\n    b[i] = 2; \n  }\n\n  // We test for offloading\n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n\n\n#pragma omp map data map(to: a[:N], b[:N]) \n{\n  #pragma omp target\n  {\n    int j = 0;\n    for (j = 0; j < N; j++) {\n      b[j] = (a[j] + b[j]);// b = 12 \n    }\n  } // end target\n\n  #pragma omp target update from(b[:N]) // update b = 12 on host \n\n} //end target-data\n \n  // Checking values of b[N] \n  for (i = 0; i < N; i++) \n    OMPVV_TEST_AND_SET_VERBOSE(errors, (b[i] != 12)); \n\n  #pragma omp target \n  {\n    int j = 0;\n    for (j = 0; j < N; j++) {\n      c[j] = (2* b[j]);// c = 24 \n    }\n  } // end target\n\n  // Checking values of c[N] \n  for (i = 0; i < N; i++) \n    OMPVV_TEST_AND_SET_VERBOSE(errors, (c[i] != 24)); \n    \n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_loop_reduction_min.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp parallel\" with directive \"#pragma omp cancel\" at position 773",
        "issue_id": 0,
        "original_code": "//===--- test_loop_reduction_min.c ------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the reduction clause on a loop directive, testing that the\n// variable in the reduction clause is properly reduced using the min\n// operator.\n//\n////===----------------------------------------------------------------------===//\n\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_min() {\n  int a[N];\n  int b[N];\n  int errors = 0;\n  int num_threads[N];\n  srand(1);\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = (int) rand() / (double) (RAND_MAX / 100);\n    b[x] = (int) rand() / (double) (RAND_MAX / 100);\n    num_threads[x] = -x;\n  }\n\n  int result = a[0] + b[0];\n\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST)\n  {\n#pragma omp loop reduction(min:result)\n    for (int x = 0; x < N; ++x) {\n      result = fmin(result, a[x] + b[x]);\n    }\n#pragma omp for\n    for (int x = 0; x < N; ++x) {\n      num_threads[x] = omp_get_num_threads();\n    }\n  }\n\n  int host_min = a[0] + b[0];\n\n  for (int x = 0; x < N; ++x) {\n    host_min = fmin(host_min, a[x] + b[x]);\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_threads[x - 1] != num_threads[x], \"Test reported differing numbers of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_threads[0] == 1, \"Test operated with one thread.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_threads[0] <= 0, \"Test reported invalid number of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, host_min != result);\n  OMPVV_ERROR_IF(host_min != result, \"Min from loop directive is %d but expected min is %d.\", result, host_min);\n\n  return errors;\n}\n\nint main() {\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_min() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n",
        "error_code": "//===--- test_loop_reduction_min.c ------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the reduction clause on a loop directive, testing that the\n// variable in the reduction clause is properly reduced using the min\n// operator.\n//\n////===----------------------------------------------------------------------===//\n\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_min() {\n  int a[N];\n  int b[N];\n  int errors = 0;\n  int num_threads[N];\n  srand(1);\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = (int) rand() / (double) (RAND_MAX / 100);\n    b[x] = (int) rand() / (double) (RAND_MAX / 100);\n    num_threads[x] = -x;\n  }\n\n  int result = a[0] + b[0];\n\n#pragma omp cancel num_threads(OMPVV_NUM_THREADS_HOST)\n  {\n#pragma omp loop reduction(min:result)\n    for (int x = 0; x < N; ++x) {\n      result = fmin(result, a[x] + b[x]);\n    }\n#pragma omp for\n    for (int x = 0; x < N; ++x) {\n      num_threads[x] = omp_get_num_threads();\n    }\n  }\n\n  int host_min = a[0] + b[0];\n\n  for (int x = 0; x < N; ++x) {\n    host_min = fmin(host_min, a[x] + b[x]);\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_threads[x - 1] != num_threads[x], \"Test reported differing numbers of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_threads[0] == 1, \"Test operated with one thread.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_threads[0] <= 0, \"Test reported invalid number of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, host_min != result);\n  OMPVV_ERROR_IF(host_min != result, \"Min from loop directive is %d but expected min is %d.\", result, host_min);\n\n  return errors;\n}\n\nint main() {\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_min() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_error_at_execution.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_error_at_execution() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 1000",
        "issue_id": 4,
        "original_code": "//===--- test_error_at_execution.c ----------------------------===//\n//\n//  OpenMP API Version 5.1 Aug 2021\n//\n//  Test uses error directive with at(execution) where if the error \n//  condition is reached during runtime, it will print an error message.\n//  If error message does not print, then the test has failed. \n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\nint errors, i;\n\nint test_error_at_execution() {\n    i = 0;\n    OMPVV_INFOMSG(\"If successful, test should print an \\\"error directive encountered\\\" message at the beginning of output\");\n    #pragma omp parallel\n    {\n        #pragma omp single\n        {\n            #pragma omp error at(execution) severity(warning)\n            i+=5;\n        }\n    }\n    OMPVV_TEST_AND_SET_VERBOSE(errors, i != 5);\n    OMPVV_ERROR_IF(errors > 0, \"Error directive cause execution error\");\n    return errors;\n}\n\nint main() {\n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_error_at_execution() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_error_at_execution.c ----------------------------===//\n//\n//  OpenMP API Version 5.1 Aug 2021\n//\n//  Test uses error directive with at(execution) where if the error \n//  condition is reached during runtime, it will print an error message.\n//  If error message does not print, then the test has failed. \n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\nint errors, i;\n\nint test_error_at_execution() {\n    i = 0;\n    OMPVV_INFOMSG(\"If successful, test should print an \\\"error directive encountered\\\" message at the beginning of output\");\n    #pragma omp parallel\n    {\n        #pragma omp single\n        {\n            #pragma omp error at(execution) severity(warning)\n            i+=5;\n        }\n    }\n    OMPVV_TEST_AND_SET_VERBOSE(errors, i != 5);\n    OMPVV_ERROR_IF(errors > 0, \"Error directive cause execution error\");\n    return errors;\n}\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_loop_collapse.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 264",
        "issue_id": 2,
        "original_code": "#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define DIM 32\n#define N (DIM*DIM)\n\n/**\n  This is a basic test to demonstrate collapse clause used\n  with \"omp target teams loop\".\n*/\nint main() {\n  int a[N], b[N], c[N];\n  int errors = 0;\n  // Data Inititalize\n  for (int i = 0; i < N; i++) {\n    a[i] = 2*i;  // Even\n    b[i] = 2*i + 1;  // Odd\n    c[i] = 0;\n  }\n  // Execute on target\n#pragma omp target teams loop map(to: a, b) map(from: c) collapse(2)\n  for (int i = 0; i < DIM; i++) {\n    for (int j = (i*DIM); j < (i*DIM + DIM); j++) {\n      c[j] = a[j] + b[j];\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, c[i] != a[i] + b[i]);\n  }\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define DIM 32\n#define N (DIM*DIM)\n\n/**\n  This is a basic test to demonstrate collapse clause used\n  with \"omp target teams loop\".\n*/\nint main() {\n  int a[N], b[N], c[N];\n  int errors = 0;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n  // Data Inititalize\n  for (int i = 0; i < N; i++) {\n    a[i] = 2*i;  // Even\n    b[i] = 2*i + 1;  // Odd\n    c[i] = 0;\n  }\n  // Execute on target\n#pragma omp target teams loop map(to: a, b) map(from: c) collapse(2)\n  for (int i = 0; i < DIM; i++) {\n    for (int j = (i*DIM); j < (i*DIM + DIM); j++) {\n      c[j] = a[j] + b[j];\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, c[i] != a[i] + b[i]);\n  }\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/gemv_target_reduction.cpp",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp map\" at position 1016",
        "issue_id": 0,
        "original_code": "//===-- gemv_target_reduction.cpp - GEMV with target and reduction ---------===!\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// Taken from the suggestions of the QMCPack team. Uses the combined construct\n// target teams distribute but creates a parallel region inside that uses the \n// reduction clause\n// \n//!===----------------------------------------------------------------------===!\n#include <chrono>\n#include <string>\n#include <cmath>\n#include \"ompvv.h\"\n#include \"omp.h\"\n\n#define N 8192\n\nclass Timer\n{\n  const std::chrono::time_point<std::chrono::system_clock> start;\n  const std::string name;\n\npublic:\n  Timer(const std::string& name_in): start(std::chrono::system_clock::now()), name(name_in) {};\n  ~Timer()\n  {\n    auto end = std::chrono::system_clock::now();\n    OMPVV_INFOMSG(\"Function %s takes %lf us \",name.c_str(), std::chrono::duration_cast<std::chrono::duration<double, std::micro>>(end - start).count());\n  }\n};\n\ntemplate <typename T>\nvoid gemv(int n, T alpha, const T*  A, const T*  V, T*  Vout)\n{\n  #pragma omp target teams distribute map(to:A[:n*n], V[:n]) map(from:Vout[:n])\n  for(int row=0; row<n; row++)\n  {\n    T sum = T(0);\n    const T *  A_row = A+row*n;\n    #pragma omp parallel for reduction(+:sum)\n    for(int col=0; col<n; col++) {\n      sum += A_row[col]*V[col];\n    }\n    Vout[row] = sum*alpha;\n  }\n}\n\ntemplate <class T>\nT* allocate(size_t n)\n{\n  T* ptr = new T[n];\n  std::fill_n(ptr, n, T(1));\n  #pragma omp target enter data map(to:ptr[:n])\n  return ptr;\n}\n\ntemplate <class T>\nvoid deallocate(T* ptr, size_t n)\n{\n  #pragma omp target exit data map(delete:ptr[:n])\n  delete[] ptr;\n}\n\nint main()\n{\n  OMPVV_TEST_OFFLOADING;\n  auto* A = allocate<float>(N*N);\n  auto* V = allocate<float>(N);\n  auto* Vout = allocate<float>(N);\n  int errors = 0;\n\n  {\n    Timer local(\"GEMV\");\n    gemv(N, 1.0f, A, V, Vout);\n  }\n\n  #pragma omp target update from(Vout[:N])\n  for(int i=0; i<N; i++)\n  {\n    OMPVV_TEST_AND_SET(errors, std::abs(Vout[i]-N) > 0.0001);\n    OMPVV_ERROR_IF(std::abs(Vout[i]-N) > 0.0001, \"Error for Vout[%d] = %f, Should be %d\", i, Vout[i], N);\n  }\n\n  deallocate(A, N*N);\n  deallocate(V, N);\n  deallocate(Vout, N);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===-- gemv_target_reduction.cpp - GEMV with target and reduction ---------===!\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// Taken from the suggestions of the QMCPack team. Uses the combined construct\n// target teams distribute but creates a parallel region inside that uses the \n// reduction clause\n// \n//!===----------------------------------------------------------------------===!\n#include <chrono>\n#include <string>\n#include <cmath>\n#include \"ompvv.h\"\n#include \"omp.h\"\n\n#define N 8192\n\nclass Timer\n{\n  const std::chrono::time_point<std::chrono::system_clock> start;\n  const std::string name;\n\npublic:\n  Timer(const std::string& name_in): start(std::chrono::system_clock::now()), name(name_in) {};\n  ~Timer()\n  {\n    auto end = std::chrono::system_clock::now();\n    OMPVV_INFOMSG(\"Function %s takes %lf us \",name.c_str(), std::chrono::duration_cast<std::chrono::duration<double, std::micro>>(end - start).count());\n  }\n};\n\ntemplate <typename T>\nvoid gemv(int n, T alpha, const T*  A, const T*  V, T*  Vout)\n{\n  #pragma omp map teams distribute map(to:A[:n*n], V[:n]) map(from:Vout[:n])\n  for(int row=0; row<n; row++)\n  {\n    T sum = T(0);\n    const T *  A_row = A+row*n;\n    #pragma omp parallel for reduction(+:sum)\n    for(int col=0; col<n; col++) {\n      sum += A_row[col]*V[col];\n    }\n    Vout[row] = sum*alpha;\n  }\n}\n\ntemplate <class T>\nT* allocate(size_t n)\n{\n  T* ptr = new T[n];\n  std::fill_n(ptr, n, T(1));\n  #pragma omp target enter data map(to:ptr[:n])\n  return ptr;\n}\n\ntemplate <class T>\nvoid deallocate(T* ptr, size_t n)\n{\n  #pragma omp target exit data map(delete:ptr[:n])\n  delete[] ptr;\n}\n\nint main()\n{\n  OMPVV_TEST_OFFLOADING;\n  auto* A = allocate<float>(N*N);\n  auto* V = allocate<float>(N);\n  auto* Vout = allocate<float>(N);\n  int errors = 0;\n\n  {\n    Timer local(\"GEMV\");\n    gemv(N, 1.0f, A, V, Vout);\n  }\n\n  #pragma omp target update from(Vout[:N])\n  for(int i=0; i<N; i++)\n  {\n    OMPVV_TEST_AND_SET(errors, std::abs(Vout[i]-N) > 0.0001);\n    OMPVV_ERROR_IF(std::abs(Vout[i]-N) > 0.0001, \"Error for Vout[%d] = %f, Should be %d\", i, Vout[i], N);\n  }\n\n  deallocate(A, N*N);\n  deallocate(V, N);\n  deallocate(Vout, N);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_loop_reduction_subtract_device.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp cancel\" at position 761",
        "issue_id": 0,
        "original_code": "//===--- test_loop_reduction_subtract_device.c --------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the reduction clause on a loop directive, testing that the\n// variable in the reduction clause is properly reduced using the subtract\n// operator. This test checks the above in a target context.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_subtraction() {\n  int a[N];\n  int b[N];\n  int total = 0;\n  int host_total = 0;\n  int errors = 0;\n  int num_threads[N];\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    num_threads[x] = -x;\n  }\n\n#pragma omp target parallel num_threads(OMPVV_NUM_THREADS_DEVICE) map(tofrom: total, a, b, num_threads)\n  {\n#pragma omp loop reduction(-:total)\n    for (int x = 0; x < N; ++x) {\n      total -= a[x] + b[x];\n    }\n#pragma omp for\n    for (int x = 0; x < N; ++x) {\n      num_threads[x] = omp_get_num_threads();\n    }\n  }\n\n  for (int x = 0; x < N; ++x) {\n    host_total -= a[x] + b[x];\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_threads[x - 1] != num_threads[x], \"Test reported differing numbers of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_threads[0] == 1, \"Test operated with one thread.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_threads[0] <= 0, \"Test reported invalid number of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, host_total != total);\n  OMPVV_ERROR_IF(host_total != total, \"Total from loop directive is %d but expected total is %d.\", total, host_total);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_subtraction() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n",
        "error_code": "//===--- test_loop_reduction_subtract_device.c --------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the reduction clause on a loop directive, testing that the\n// variable in the reduction clause is properly reduced using the subtract\n// operator. This test checks the above in a target context.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_subtraction() {\n  int a[N];\n  int b[N];\n  int total = 0;\n  int host_total = 0;\n  int errors = 0;\n  int num_threads[N];\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    num_threads[x] = -x;\n  }\n\n#pragma omp cancel parallel num_threads(OMPVV_NUM_THREADS_DEVICE) map(tofrom: total, a, b, num_threads)\n  {\n#pragma omp loop reduction(-:total)\n    for (int x = 0; x < N; ++x) {\n      total -= a[x] + b[x];\n    }\n#pragma omp for\n    for (int x = 0; x < N; ++x) {\n      num_threads[x] = omp_get_num_threads();\n    }\n  }\n\n  for (int x = 0; x < N; ++x) {\n    host_total -= a[x] + b[x];\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_threads[x - 1] != num_threads[x], \"Test reported differing numbers of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_threads[0] == 1, \"Test operated with one thread.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_threads[0] <= 0, \"Test reported invalid number of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, host_total != total);\n  OMPVV_ERROR_IF(host_total != total, \"Total from loop directive is %d but expected total is %d.\", total, host_total);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_subtraction() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_task_depend_iterator.cpp",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 2123",
        "issue_id": 2,
        "original_code": "//===-- test_task_depend_iterator.cpp - test of the iterator clause inside the task depend clause ----===//\n// \n// OpenMP API Version 5.0 Nov 2020\n// \n// This file is a test for the iterator modifier when used with the task depend\n// clause. This modifier should create an iterator that expand into multiple values\n// inside the clause they appear. In this particular test case the iterator expands into\n// several values creating several dependencies at the same time.\n//\n//===-------------------------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <thread>\n#include <vector>\n#include \"ompvv.h\"\n\nint test_task_depend_iterator() {\n  int ptr[] = {0, 4, 5, 6, 7, 8, 9, 10, 11}, cols[] = {1, 2, 3, 4, 5, 5, 6, 6, 7, 7, 8};\n  std::vector<int> threadOrder;\n  bool threadOrderError = false;\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST)\n  {\n#pragma omp single\n    {\n      for (int i = 0; i < 8; ++i) {\n        int pos = ptr[i], size = ptr[i + 1] - ptr[i];\n#pragma omp task depend(iterator(it = 0 : size), in : ptr[cols[pos + it]]) depend(out : ptr[i])\n        {\n#pragma omp critical\n          {\n            threadOrder.push_back(i);\n          } // end critical section\n        } // end task depend\n      }\n    } // end single\n  } // end parallel\n\n  std::vector<int>::iterator idx[8];\n  for (int i = 0; i < 8; ++i)\n    idx[i] = std::find (threadOrder.begin(), threadOrder.end(), i);\n  if (idx[0] != threadOrder.begin())\n    threadOrderError |= true;\n  if (idx[1] > idx[5] || idx[2] > idx[5])\n    threadOrderError |= true;\n  if (idx[3] > idx[6] || idx[4] > idx[6])\n    threadOrderError |= true;\n  if (idx[5] > idx[7] || idx[5] > idx[7])\n    threadOrderError |= true;\n\n  std::sort(threadOrder.begin(), threadOrder.end());\n  for(int i = 0; i < 8; ++i)\n    threadOrderError = (threadOrder[i] != i) || threadOrderError;\n  OMPVV_ERROR_IF(threadOrderError, \"The dependencies between tasks were not enforced in the correct order.\");\n  return threadOrderError ? 1 : 0;\n}\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_task_depend_iterator());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===-- test_task_depend_iterator.cpp - test of the iterator clause inside the task depend clause ----===//\n// \n// OpenMP API Version 5.0 Nov 2020\n// \n// This file is a test for the iterator modifier when used with the task depend\n// clause. This modifier should create an iterator that expand into multiple values\n// inside the clause they appear. In this particular test case the iterator expands into\n// several values creating several dependencies at the same time.\n//\n//===-------------------------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <algorithm>\n#include <cstdlib>\n#include <iostream>\n#include <thread>\n#include <vector>\n#include \"ompvv.h\"\n\nint test_task_depend_iterator() {\n  int ptr[] = {0, 4, 5, 6, 7, 8, 9, 10, 11}, cols[] = {1, 2, 3, 4, 5, 5, 6, 6, 7, 7, 8};\n  std::vector<int> threadOrder;\n  bool threadOrderError = false;\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST)\n  {\n#pragma omp single\n    {\n      for (int i = 0; i < 8; ++i) {\n        int pos = ptr[i], size = ptr[i + 1] - ptr[i];\n#pragma omp task depend(iterator(it = 0 : size), in : ptr[cols[pos + it]]) depend(out : ptr[i])\n        {\n#pragma omp critical\n          {\n            threadOrder.push_back(i);\n          } // end critical section\n        } // end task depend\n      }\n    } // end single\n  } // end parallel\n\n  std::vector<int>::iterator idx[8];\n  for (int i = 0; i < 8; ++i)\n    idx[i] = std::find (threadOrder.begin(), threadOrder.end(), i);\n  if (idx[0] != threadOrder.begin())\n    threadOrderError |= true;\n  if (idx[1] > idx[5] || idx[2] > idx[5])\n    threadOrderError |= true;\n  if (idx[3] > idx[6] || idx[4] > idx[6])\n    threadOrderError |= true;\n  if (idx[5] > idx[7] || idx[5] > idx[7])\n    threadOrderError |= true;\n\n  std::sort(threadOrder.begin(), threadOrder.end());\n  for(int i = 0; i < 8; ++i)\n    threadOrderError = (threadOrder[i] != i) || threadOrderError;\n  OMPVV_ERROR_IF(threadOrderError, \"The dependencies between tasks were not enforced in the correct order.\");\n  return threadOrderError ? 1 : 0;\n}\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_task_depend_iterator());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_default_firstprivate_parallel.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===--- test_default_firstprivate_parallel.c -----------------------------------------------===//\n//\n//  OpenMP API Version 5.1 Aug 2021\n//\n//  This test checks behavior of the default clause when the specified data-sharing-attribute  \n//  is firstprivate. The constructs allowed for a default clause are parallel, teams, task, and taskloop.\n//  This test utilizes the parallel construct, where firstprivate states that one ore more list items are\n//  private to the parallel task, and each of them are initialized with the value of the corresponding\n//  original item.\n//\n////===--------------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint errors, i;\n\nint test_default_firstprivate_parallel() {\n  int scalar_var = 5;\n  int arr[N];\n  int sum = 0;\n  for (int i=0; i<N; i++){\n\tarr[i] = i;\n\tsum += arr[i];\n  }\n  #pragma omp parallel default(firstprivate) num_threads(OMPVV_NUM_THREADS_HOST)\n  {\n  \tscalar_var += 10;\n  \tfor (int i=0; i<N; i++){\n\t\tarr[i] = i+2;\n  \t}\t\n  }\n  int newsum = 0;\n  int wrongsum = 0;\n  for(int i=0; i<N; i++){\n\tnewsum += arr[i];\n\twrongsum += i+2;\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_var != 5);\n  OMPVV_INFOMSG_IF(scalar_var == 0, \"Scalar was not initialized in parallel region & not updated\");\n  OMPVV_INFOMSG_IF(scalar_var == 15, \"Scalar was not firstprivate, changes made in parallel affected original copy\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, sum != newsum);\n  OMPVV_INFOMSG_IF(newsum == 0, \"Array was not initialized in parallel region properly\");\n  OMPVV_INFOMSG_IF(newsum == wrongsum, \"Array was not first private, changes made in parallel affected original copy\");\n  return errors;\n}\n\nint main() {\n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_default_firstprivate_parallel() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}           \n\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nlong wuqgukpiuq = 92;\nshort zyynkvjuck = 78;\nint yipbfqdtzn = 148;\nint cucfqsyrzp = 233;\nlong sbhoewaooa = 45;\nlong cxvoamhnjc = 134;\nint mxujfkxmeb = 50;\nint vkphpuwlwv = 185;\ndouble nqhdsdseun = 105;\nint ezctroxmyu = 158;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_depend_inout_omp_all_memory.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp declare\" at position 732",
        "issue_id": 0,
        "original_code": "//===------------ test_depend_inout_omp_all_memory.c --------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// This test checks that the special omp_all_memory locator keyword works\n// as intended. The test checks this by having two variables passed into the \n// target parallel region, depending on both values. If both variables are\n// properly passed through the tasks then it passes. If not, the test fails.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main() {\n\tint errors = 0;\n\tint x[N];\n  \tint y = 5;\n\n\tfor (int i = 0; i < N; i++) {\n\t\tx[i] = i;\n\t}\n\n\tOMPVV_TEST_OFFLOADING;\n\n\t#pragma omp target map(tofrom: errors) map(to: x, y)\n\t{\n\t\t#pragma omp parallel\n\t\t#pragma omp single\n\t\t{\n       \t\t\t#pragma omp task depend(out: x)\n       \t\t\t{\n         \t\t\tfor (int i = 0; i < N; i++) {\n        \t    \t\t\tx[i] += 1;\n       \t\t\t\t}\n        \t\t}\n        \t\t#pragma omp task depend(out: y)\n        \t\t{   \n          \t\t\ty += 5;\n        \t\t}\n\t      \t\t#pragma omp task depend(inout: omp_all_memory)\n\t      \t\t{\n          \t\t\tfor(int i = 0; i < N; i++) {\n            \t\t\t\tOMPVV_TEST_AND_SET(errors, x[i] != i + 1);\n          \t\t\t}\n\n          \t\t\tOMPVV_TEST_AND_SET(errors, y != 10 );\n\t      \t\t}\n        \t\t#pragma omp task depend(out: x)\n        \t\t{\n          \t\t\tfor (int i = 0; i < N; i++) {\n            \t\t\t\tx[i] += 1;\n          \t\t\t}\n        \t\t}\n        \t\t#pragma omp task depend(out: y)\n        \t\t{\n          \t\t\ty += 5;\n        \t\t}\n\t\t}\n\n      \t\tfor (int i = 0; i < N; i++) {\n        \t\tOMPVV_TEST_AND_SET(errors, x[i] != i + 2);\n      \t\t}\n\n      \t\tOMPVV_TEST_AND_SET(errors, y != 15);\n\t}\n\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===------------ test_depend_inout_omp_all_memory.c --------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// This test checks that the special omp_all_memory locator keyword works\n// as intended. The test checks this by having two variables passed into the \n// target parallel region, depending on both values. If both variables are\n// properly passed through the tasks then it passes. If not, the test fails.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main() {\n\tint errors = 0;\n\tint x[N];\n  \tint y = 5;\n\n\tfor (int i = 0; i < N; i++) {\n\t\tx[i] = i;\n\t}\n\n\tOMPVV_TEST_OFFLOADING;\n\n\t#pragma omp declare map(tofrom: errors) map(to: x, y)\n\t{\n\t\t#pragma omp parallel\n\t\t#pragma omp single\n\t\t{\n       \t\t\t#pragma omp task depend(out: x)\n       \t\t\t{\n         \t\t\tfor (int i = 0; i < N; i++) {\n        \t    \t\t\tx[i] += 1;\n       \t\t\t\t}\n        \t\t}\n        \t\t#pragma omp task depend(out: y)\n        \t\t{   \n          \t\t\ty += 5;\n        \t\t}\n\t      \t\t#pragma omp task depend(inout: omp_all_memory)\n\t      \t\t{\n          \t\t\tfor(int i = 0; i < N; i++) {\n            \t\t\t\tOMPVV_TEST_AND_SET(errors, x[i] != i + 1);\n          \t\t\t}\n\n          \t\t\tOMPVV_TEST_AND_SET(errors, y != 10 );\n\t      \t\t}\n        \t\t#pragma omp task depend(out: x)\n        \t\t{\n          \t\t\tfor (int i = 0; i < N; i++) {\n            \t\t\t\tx[i] += 1;\n          \t\t\t}\n        \t\t}\n        \t\t#pragma omp task depend(out: y)\n        \t\t{\n          \t\t\ty += 5;\n        \t\t}\n\t\t}\n\n      \t\tfor (int i = 0; i < N; i++) {\n        \t\tOMPVV_TEST_AND_SET(errors, x[i] != i + 2);\n      \t\t}\n\n      \t\tOMPVV_TEST_AND_SET(errors, y != 15);\n\t}\n\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_task_ThrdPrivate.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n      IfTstFailed++;\n  }\" at position 1357",
        "issue_id": 4,
        "original_code": "//===-- test_task_ThrdPrivate.c ------------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// Description\n// 1) The aim of the test case is to verify the functionality\n// of threadprivate construct when used under the influence of task construct\n// FuncABC() functions tests if thread 0 still has updated GlobalVar variable\n// while other threads observed GlobalVar still see 0\n// 2) In the main there is a check to verify GlobalVar is 0. This is because\n// what ever changes happen inside the task block are not reflected outside\n//===----------------------------------------------------------------------===//\n\n\n#include <stdio.h>\n#include <stdbool.h>\n#include <unistd.h>\n#include \"omp.h\"\n#include \"ompvv.h\"\n#define THREADS 64\n\n#define INIT_VAL 9999\n\n\nint IfTstFailed = 0;\n\nint GlobalVar;\n#pragma omp threadprivate(GlobalVar)\n\nvoid FuncABC() {\n  int ThrdId = omp_get_thread_num();\n\n  {\n    if (ThrdId == 0) {\n      if ((GlobalVar != INIT_VAL)) {\n        IfTstFailed++;\n      }\n    } else {\n      if (GlobalVar != 0) {\n        IfTstFailed++;\n      }\n    }\n  }\n}\n\n\nint main() {\n  int errors = 0;\n  omp_set_num_threads(THREADS);\n  GlobalVar = INIT_VAL;\n#pragma omp parallel\n  {\n    int ThrdId = omp_get_thread_num();\n#pragma omp task if(0)\n    {\n      FuncABC();\n      GlobalVar = ThrdId;\n    }\n  }\n\n  if (GlobalVar != 0) {\n      IfTstFailed++;\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (IfTstFailed != 0));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===-- test_task_ThrdPrivate.c ------------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// Description\n// 1) The aim of the test case is to verify the functionality\n// of threadprivate construct when used under the influence of task construct\n// FuncABC() functions tests if thread 0 still has updated GlobalVar variable\n// while other threads observed GlobalVar still see 0\n// 2) In the main there is a check to verify GlobalVar is 0. This is because\n// what ever changes happen inside the task block are not reflected outside\n//===----------------------------------------------------------------------===//\n\n\n#include <stdio.h>\n#include <stdbool.h>\n#include <unistd.h>\n#include \"omp.h\"\n#include \"ompvv.h\"\n#define THREADS 64\n\n#define INIT_VAL 9999\n\n\nint IfTstFailed = 0;\n\nint GlobalVar;\n#pragma omp threadprivate(GlobalVar)\n\nvoid FuncABC() {\n  int ThrdId = omp_get_thread_num();\n\n  {\n    if (ThrdId == 0) {\n      if ((GlobalVar != INIT_VAL)) {\n        IfTstFailed++;\n      }\n    } else {\n      if (GlobalVar != 0) {\n        IfTstFailed++;\n      }\n    }\n  }\n}\n\n\nint main() {\n  int errors = 0;\n  omp_set_num_threads(THREADS);\n  GlobalVar = INIT_VAL;\n#pragma omp parallel\n  {\n    int ThrdId = omp_get_thread_num();\n#pragma omp task if(0)\n    {\n      FuncABC();\n      GlobalVar = ThrdId;\n    }\n  }\n\n  if (GlobalVar != 0) \n  OMPVV_TEST_AND_SET_VERBOSE(errors, (IfTstFailed != 0));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_dist_schedule.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 2405",
        "issue_id": 2,
        "original_code": "//===------ test_target_teams_distribute_dist_schedule.c ------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks that the dist_schedule clause (which must have kind\n// static) correctly causes CHUNK_SIZE iterations to be split among the\n// number of teams the test is run with (in a round-robin fashion in order\n// of the team number) when a chunk size is given. The test also confirms\n// that when no chunk size is given, that each team receives no more than\n// one \"chunk\" of implementation-defined size.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n#define CHUNK_SIZE 64\n\nint test_dist_schedule() {\n  int errors = 0;\n  int num_teams;\n  int a[N];\n  int b[N];\n\n  for (int i = 0; i < N; ++i) {\n    a[i] = -1;\n    b[i] = -1;\n  }\n\n#pragma omp target teams distribute map(from: num_teams) map(tofrom: a[0:N]) dist_schedule(static, CHUNK_SIZE)\n  for (int i = 0; i < N; ++i) {\n    if (omp_get_team_num() == 0) {\n      num_teams = omp_get_num_teams();\n    }\n    a[i] = omp_get_team_num();\n  }\n\n  OMPVV_WARNING_IF(num_teams == 1, \"Cannot test dist_schedule(static, chunk_size) because num_teams was 1.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_teams < 1);\n\n  int counter = -1;\n  for (int i = 0; i < N; ++i) {\n    if (i % CHUNK_SIZE == 0) {\n      counter = (counter + 1) % num_teams;\n    }\n    OMPVV_TEST_AND_SET_VERBOSE(errors, a[i] != counter);\n    OMPVV_ERROR_IF(a[i] != counter, \"Loop iterations were not properly scheduled with specified chunk_size of %d.\", CHUNK_SIZE);\n  }\n\n  num_teams = -1;\n\n#pragma omp target teams distribute map(from: num_teams) map(tofrom: b[0:N]) dist_schedule(static)\n  for (int i = 0; i < N; ++i) {\n    if (omp_get_team_num() == 0) {\n      num_teams = omp_get_num_teams();\n    }\n    b[i] = omp_get_team_num();\n  }\n\n  OMPVV_WARNING_IF(num_teams == 1, \"Cannot test dist_schedule(static, chunk_size) because num_teams was 1.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_teams < 1);\n\n  counter = 1;\n\n  int err_cond = 0;\n  for (int i = 1; i < N; ++i) {\n    err_cond = a[i] < a[i - 1] || a[i] > (a[i - 1] + 1);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, err_cond);\n    OMPVV_ERROR_IF(err_cond, \"Loop iterations were not properly sheduled with unspecified chunk_size.\");\n    if (err_cond) {\n      break;\n    }\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_SHARED_ENVIRONMENT;\n\n  int errors = 0;\n\n  errors = test_dist_schedule();\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===------ test_target_teams_distribute_dist_schedule.c ------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks that the dist_schedule clause (which must have kind\n// static) correctly causes CHUNK_SIZE iterations to be split among the\n// number of teams the test is run with (in a round-robin fashion in order\n// of the team number) when a chunk size is given. The test also confirms\n// that when no chunk size is given, that each team receives no more than\n// one \"chunk\" of implementation-defined size.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n#define CHUNK_SIZE 64\n\nint test_dist_schedule() {\n  int errors = 0;\n  int num_teams;\n  int a[N];\n  int b[N];\n\n  for (int i = 0; i < N; ++i) {\n    a[i] = -1;\n    b[i] = -1;\n  }\n\n#pragma omp target teams distribute map(from: num_teams) map(tofrom: a[0:N]) dist_schedule(static, CHUNK_SIZE)\n  for (int i = 0; i < N; ++i) {\n    if (omp_get_team_num() == 0) {\n      num_teams = omp_get_num_teams();\n    }\n    a[i] = omp_get_team_num();\n  }\n\n  OMPVV_WARNING_IF(num_teams == 1, \"Cannot test dist_schedule(static, chunk_size) because num_teams was 1.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_teams < 1);\n\n  int counter = -1;\n  for (int i = 0; i < N; ++i) {\n    if (i % CHUNK_SIZE == 0) {\n      counter = (counter + 1) % num_teams;\n    }\n    OMPVV_TEST_AND_SET_VERBOSE(errors, a[i] != counter);\n    OMPVV_ERROR_IF(a[i] != counter, \"Loop iterations were not properly scheduled with specified chunk_size of %d.\", CHUNK_SIZE);\n  }\n\n  num_teams = -1;\n\n#pragma omp target teams distribute map(from: num_teams) map(tofrom: b[0:N]) dist_schedule(static)\n  for (int i = 0; i < N; ++i) {\n    if (omp_get_team_num() == 0) {\n      num_teams = omp_get_num_teams();\n    }\n    b[i] = omp_get_team_num();\n  }\n\n  OMPVV_WARNING_IF(num_teams == 1, \"Cannot test dist_schedule(static, chunk_size) because num_teams was 1.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_teams < 1);\n\n  counter = 1;\n\n  int err_cond = 0;\n  for (int i = 1; i < N; ++i) {\n    err_cond = a[i] < a[i - 1] || a[i] > (a[i - 1] + 1);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, err_cond);\n    OMPVV_ERROR_IF(err_cond, \"Loop iterations were not properly sheduled with unspecified chunk_size.\");\n    if (err_cond) {\n      break;\n    }\n  }\n\n  return errors;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_SHARED_ENVIRONMENT;\n\n  int errors = 0;\n\n  errors = test_dist_schedule();\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_master_taskloop_device.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 1523",
        "issue_id": 2,
        "original_code": "//===--- test_master_taskloop_device.c --------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the master taskloop directive in a parallel region. The\n// test performs simple operations on an int array which are then checked for\n// correctness. This test checks the above in a target region.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_master_taskloop_device() {\n  OMPVV_INFOMSG(\"test_master_taskloop_device\");\n  int errors = 0;\n  int num_threads = -1;\n  int x[N];\n  int y[N];\n  int z[N];\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 1;\n    y[i] = i + 1;\n    z[i] = 2*(i + 1);\n  }\n\n#pragma omp target parallel num_threads(OMPVV_NUM_THREADS_DEVICE) shared(x, y, z, num_threads) map(tofrom: x, y, z, num_threads)\n  {\n#pragma omp master taskloop\n    for (int i = 0; i < N; i++) {\n      x[i] += y[i]*z[i];\n    }\n    if (omp_get_thread_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != 1 + (y[i]*z[i]));\n  }\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of taskloop can't be guaranteed.\");\n  OMPVV_ERROR_IF(num_threads < 1, \"Test returned an invalid number of threads.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n\n  return errors;\n}\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_master_taskloop_device());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_master_taskloop_device.c --------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the master taskloop directive in a parallel region. The\n// test performs simple operations on an int array which are then checked for\n// correctness. This test checks the above in a target region.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_master_taskloop_device() {\n  OMPVV_INFOMSG(\"test_master_taskloop_device\");\n  int errors = 0;\n  int num_threads = -1;\n  int x[N];\n  int y[N];\n  int z[N];\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 1;\n    y[i] = i + 1;\n    z[i] = 2*(i + 1);\n  }\n\n#pragma omp target parallel num_threads(OMPVV_NUM_THREADS_DEVICE) shared(x, y, z, num_threads) map(tofrom: x, y, z, num_threads)\n  {\n#pragma omp master taskloop\n    for (int i = 0; i < N; i++) {\n      x[i] += y[i]*z[i];\n    }\n    if (omp_get_thread_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != 1 + (y[i]*z[i]));\n  }\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of taskloop can't be guaranteed.\");\n  OMPVV_ERROR_IF(num_threads < 1, \"Test returned an invalid number of threads.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n\n  return errors;\n}\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_master_taskloop_device());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_reduction_bitxor.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_bitxor() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\" at position 1650",
        "issue_id": 4,
        "original_code": "//===--- test_target_teams_distribute_reduction_bitxor.c----------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the reduction clause on a target teams distribute directive,\n// testing that the variable in the reduction clause is properly reduced using\n// the bitxor operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_bitxor() {\n  unsigned int a[N];\n  int errors = 0;\n  int num_teams[N];\n  srand(1);\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = (unsigned int) rand() / (double) (RAND_MAX / 2);\n    num_teams[x] = -x;\n  }\n\n  unsigned int b = 0;\n\n#pragma omp target teams distribute reduction(^:b) defaultmap(tofrom:scalar)\n  for (int x = 0; x < N; ++x) {\n    num_teams[x] = omp_get_num_teams();\n    b = (b ^ a[x]);\n  }\n\n  unsigned int host_b = 0;\n\n  for (int x = 0; x < N; ++x) {\n    host_b = (host_b ^ a[x]);\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_teams[x - 1] != num_teams[x], \"Kernel reported differing numbers of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_teams[0] == 1, \"Test operated with one team.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_teams[0] <= 0, \"Test reported invalid number of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, b != host_b);\n  OMPVV_ERROR_IF(host_b != b, \"Bit on device is %d but expected bit from host is %d.\", b, host_b);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_bitxor() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_reduction_bitxor.c----------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the reduction clause on a target teams distribute directive,\n// testing that the variable in the reduction clause is properly reduced using\n// the bitxor operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_bitxor() {\n  unsigned int a[N];\n  int errors = 0;\n  int num_teams[N];\n  srand(1);\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = (unsigned int) rand() / (double) (RAND_MAX / 2);\n    num_teams[x] = -x;\n  }\n\n  unsigned int b = 0;\n\n#pragma omp target teams distribute reduction(^:b) defaultmap(tofrom:scalar)\n  for (int x = 0; x < N; ++x) {\n    num_teams[x] = omp_get_num_teams();\n    b = (b ^ a[x]);\n  }\n\n  unsigned int host_b = 0;\n\n  for (int x = 0; x < N; ++x) {\n    host_b = (host_b ^ a[x]);\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_teams[x - 1] != num_teams[x], \"Kernel reported differing numbers of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_teams[0] == 1, \"Test operated with one team.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_teams[0] <= 0, \"Test reported invalid number of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, b != host_b);\n  OMPVV_ERROR_IF(host_b != b, \"Bit on device is %d but expected bit from host is %d.\", b, host_b);\n\n  return errors;\n}\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_requires_atomic_default_mem_order_seq_cst.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1272",
        "issue_id": 1,
        "original_code": "//===---test_requires_atomic_default_mem_order_seq_cst.c---------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks for support of the atomic_default_mem_order clause on the \n// requires directive. This clause determines the default memory behavior for\n// atomic constructs. These behaviors are seq_cst, acq_rel, and relaxed.\n// This test checks the seq_cst behavior, which is also the default.\n//\n// Adapted from 5.0 OpenMP example acquire_release.2.c\n////===----------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#pragma omp requires atomic_default_mem_order(seq_cst)\n\nint test_atomic_seq_cst() {\n  OMPVV_INFOMSG(\"test_atomic_seq_cst\");\n\n  int x = 0, y = 0;\n  int errors = 0;\n  omp_set_dynamic(0);\n  omp_set_num_threads(2);\n\n#pragma omp parallel\n   {\n      int thrd = omp_get_thread_num();\n       if (thrd == 0) {\n          x = 10;\n          #pragma omp atomic write \n          y = 1;\n       } else {\n          int tmp = 0;\n          while (tmp == 0) {\n            #pragma omp atomic read \n            tmp = y;\n          }\n          OMPVV_TEST_AND_SET_VERBOSE(errors, x != 10);\n       }\n   }\n   return errors;\n}\n\nint main() {\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_atomic_seq_cst());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---test_requires_atomic_default_mem_order_seq_cst.c---------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks for support of the atomic_default_mem_order clause on the \n// requires directive. This clause determines the default memory behavior for\n// atomic constructs. These behaviors are seq_cst, acq_rel, and relaxed.\n// This test checks the seq_cst behavior, which is also the default.\n//\n// Adapted from 5.0 OpenMP example acquire_release.2.c\n////===----------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#pragma omp requires atomic_default_mem_order(seq_cst)\n\nint test_atomic_seq_cst() {\n  OMPVV_INFOMSG(\"test_atomic_seq_cst\");\n\n  int x = 0, y = 0;\n  int errors = 0;\n  omp_set_dynamic(0);\n  omp_set_num_threads(2);\n\n#pragma omp parallel\n   {\n      int thrd = omp_get_thread_num();\n       if (thrd == 0) {\n          x = 10;\n          #pragma omp atomic write \n          y = 1;\n       } else {\n          int tmp = 0;\n          while (tmp == 0) {\n            #pragma omp atomic read \n            tmp = y;\n          }\n          OMPVV_TEST_AND_SET_VERBOSE(errors, x != 10);\n       }\n   }\n   return errors;\n}\n\nint main() \n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_atomic_seq_cst());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_enter_exit_data_map_global_array.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp single\" at position 817",
        "issue_id": 0,
        "original_code": "//===--- test_target_enter_exit_data_map_global_array.c ---------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test is in two parts. First, the test checks that mapping to on enter\n// followed by mapping from on exit works, by modifying the data on the\n// device. Then, the delete clause is tested by making sure that deleting\n// an array mapped to the device resets its reference count, meaning that\n// modifications made on the host are remapped back in when another map(to)\n// is encountered.\n//\n////===----------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <omp.h>\n\n#define N 10\n\nint A[N] = {0};\nint B[N] = {0};\n\nint test_tofrom() {\n  int errors = 0;\n\n  for (int i = 0; i < N; ++i) {\n    A[i] = 0;\n  }\n\n#pragma omp target enter data map(to: A)\n\n#pragma omp target\n  {\n    for (int i = 0; i < N; i++) {\n      A[i] = N;\n    }\n  }\n\n#pragma omp target exit data map(from: A)\n\n  for (int i = 0; i < N; ++i) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, A[i] != N);\n  }\n\n  return errors;\n}\n\nint test_delete() {\n  int errors = 0;\n\n  for (int i = 0; i < N; ++i) {\n    A[i] = N;\n  }\n\n#pragma omp target data map(tofrom: A) map(from: B)\n  {\n#pragma omp target exit data map(delete: A)\n    for (int i = 0; i < N; ++i) {\n      A[i] = 0;\n    }\n#pragma omp target map(to: A)   // if the delete does not work, this map will not happen.\n    {\n      for (int i = 0; i < N; ++i) {\n        B[i] = A[i];\n      }\n    }\n  }\n\n  for (int i = 0; i < N; ++i) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, B[i] != 0);\n  }\n\n  return errors;\n}\n\nint main () {\n  int errors = 0;\n\n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_SHARED_ENVIRONMENT;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_tofrom() != 0);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_delete() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_enter_exit_data_map_global_array.c ---------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test is in two parts. First, the test checks that mapping to on enter\n// followed by mapping from on exit works, by modifying the data on the\n// device. Then, the delete clause is tested by making sure that deleting\n// an array mapped to the device resets its reference count, meaning that\n// modifications made on the host are remapped back in when another map(to)\n// is encountered.\n//\n////===----------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <omp.h>\n\n#define N 10\n\nint A[N] = {0};\nint B[N] = {0};\n\nint test_tofrom() {\n  int errors = 0;\n\n  for (int i = 0; i < N; ++i) {\n    A[i] = 0;\n  }\n\n#pragma omp single enter data map(to: A)\n\n#pragma omp target\n  {\n    for (int i = 0; i < N; i++) {\n      A[i] = N;\n    }\n  }\n\n#pragma omp target exit data map(from: A)\n\n  for (int i = 0; i < N; ++i) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, A[i] != N);\n  }\n\n  return errors;\n}\n\nint test_delete() {\n  int errors = 0;\n\n  for (int i = 0; i < N; ++i) {\n    A[i] = N;\n  }\n\n#pragma omp target data map(tofrom: A) map(from: B)\n  {\n#pragma omp target exit data map(delete: A)\n    for (int i = 0; i < N; ++i) {\n      A[i] = 0;\n    }\n#pragma omp target map(to: A)   // if the delete does not work, this map will not happen.\n    {\n      for (int i = 0; i < N; ++i) {\n        B[i] = A[i];\n      }\n    }\n  }\n\n  for (int i = 0; i < N; ++i) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, B[i] != 0);\n  }\n\n  return errors;\n}\n\nint main () {\n  int errors = 0;\n\n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_SHARED_ENVIRONMENT;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_tofrom() != 0);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_delete() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_default_none.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===--- test_target_teams_distribute_default_none.c-------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This tests uses the default(none) clause on a target teams distribute test.\n// The test aims to validate that all values will not have default data sharing\n// attributes.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main() {\n  int is_offloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n  OMPVV_WARNING(\"Test only uses default(none) clause and does not guarantee that the default(none) is enforced.\");\n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int privatized;\n  int num_teams;\n  int share = 0;\n  int x;\n  int errors = 0;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    c[x] = 2*x;\n    d[x] = 0;\n  }\n\n#pragma omp target data map(from: d[0:N], num_teams) map(to: a[0:N], b[0:N], c[0:N])\n  {\n#pragma omp target teams distribute default(none) shared(a, b, c, d, num_teams) private(x, privatized) num_teams(OMPVV_NUM_TEAMS_DEVICE)\n    for (x = 0; x < N; ++x) {\n      privatized = 0;\n      for (int y = 0; y < a[x] + b[x]; ++y) {\n        privatized++;\n      }\n      d[x] = c[x] * privatized;\n      if (omp_get_team_num() == 0) {\n        num_teams = omp_get_num_teams();\n      }\n    }\n  }\n\n  OMPVV_WARNING_IF(num_teams == 1, \"The number of teams was 1. This is not a specification error but we could not guarantee parallelism of teams.\");\n\n  for (x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (d[x] != (1 + x)*2*x));\n    if (d[x] != (1 + x)*2*x) {\n      break;\n    }\n  }\n\n#pragma omp target data map(from: num_teams) map(to: b[0:N])\n  {\n#pragma omp target teams distribute default(none) private(x) shared(share, b, num_teams) defaultmap(tofrom:scalar) num_teams(OMPVV_NUM_TEAMS_DEVICE)\n    for (x = 0; x < N; ++x) {\n#pragma omp atomic update\n      share = share + b[x];\n      if (omp_get_team_num() == 0) {\n        num_teams = omp_get_num_teams();\n      }\n    }\n  }\n\n  OMPVV_WARNING_IF(num_teams == 1, \"The number of teams was 1. This is not a specification error but we could not guarantee parallelism of teams.\");\n\n  for (int x = 0; x < N; ++x) {\n    share = share - x;\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (share != 0));\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nint kcmchzizjt = 129;\nbyte cmdzcfjrpy = 30;\ndouble ufinohpurd = 207;\nfloat zdckntwfqg = 86;\nlong uywcuesvgk = 159;\nlong nzgvprzpfd = 160;\nint sedosotgwt = 51;\nfloat tqgmaqkero = 194;\nlong fsmqycfgyc = 40;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_nested_target_simd.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_simd());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 1612",
        "issue_id": 4,
        "original_code": "//===---- test_target_simd.c - Using simd directive inside of a terget region -===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// SIMD in OpenMP 4.5 does not have any API that allows us to confirm the creation \n// of SIMD lanes, nor the use of SIMD instructions in any architecture. Hence, our\n// tests are limited in that they check that the expected result is created, but\n// assume nothing in how they are mapped into a particular architecture\n//\n// This test creates a regular for loop and uses the SIMD directive inside \n// a target region then it checks that the values of the array are as expected\n//===--------------------------------------------------------------------------===//\n//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define ARRAY_SIZE 1024\n\nint test_target_simd() {\n  OMPVV_INFOMSG(\"test_target_simd\");\n  OMPVV_WARNING(\"This test cannot check if actual SIMD extensions at the hardware level\"\n                 \" were used, or of the generated code is different in any way\");\n\n  // Variable for errors counting\n  int errors = 0;\n\n  int a[ARRAY_SIZE];\n  int b[ARRAY_SIZE];\n  int c[ARRAY_SIZE];\n  int i;\n\n  // a and b array initialization\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      a[i] = 1;\n      b[i] = i;\n      c[i] = 2 * i;\n  }\n\n\n#pragma omp target map(to: b[0:ARRAY_SIZE], c[0:ARRAY_SIZE]) map(tofrom: a[0:ARRAY_SIZE])\n  {\n#pragma omp simd \n    for (i = 0; i < ARRAY_SIZE; ++i) {\n        a[i] += b[i] * c[i];\n    }\n  }\n\n\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      OMPVV_TEST_AND_SET(errors, (a[i] != 1 + (b[i] * c[i])));\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_simd());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_simd.c - Using simd directive inside of a terget region -===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// SIMD in OpenMP 4.5 does not have any API that allows us to confirm the creation \n// of SIMD lanes, nor the use of SIMD instructions in any architecture. Hence, our\n// tests are limited in that they check that the expected result is created, but\n// assume nothing in how they are mapped into a particular architecture\n//\n// This test creates a regular for loop and uses the SIMD directive inside \n// a target region then it checks that the values of the array are as expected\n//===--------------------------------------------------------------------------===//\n//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define ARRAY_SIZE 1024\n\nint test_target_simd() {\n  OMPVV_INFOMSG(\"test_target_simd\");\n  OMPVV_WARNING(\"This test cannot check if actual SIMD extensions at the hardware level\"\n                 \" were used, or of the generated code is different in any way\");\n\n  // Variable for errors counting\n  int errors = 0;\n\n  int a[ARRAY_SIZE];\n  int b[ARRAY_SIZE];\n  int c[ARRAY_SIZE];\n  int i;\n\n  // a and b array initialization\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      a[i] = 1;\n      b[i] = i;\n      c[i] = 2 * i;\n  }\n\n\n#pragma omp target map(to: b[0:ARRAY_SIZE], c[0:ARRAY_SIZE]) map(tofrom: a[0:ARRAY_SIZE])\n  {\n#pragma omp simd \n    for (i = 0; i < ARRAY_SIZE; ++i) {\n        a[i] += b[i] * c[i];\n    }\n  }\n\n\n  for (i = 0; i < ARRAY_SIZE; ++i) {\n      OMPVV_TEST_AND_SET(errors, (a[i] != 1 + (b[i] * c[i])));\n  }\n\n  return errors;\n}\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_data_if.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 6454",
        "issue_id": 1,
        "original_code": "//===---- test_target_data_if.c - check the if clause of target data ------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// The if clause determines if the section should be executed in the host or\n// the device. There are three things to test here:\n// (a) with offloading when 'if' clause evaluates to true then code\n// be executed on the device\n// (b) with offloading when 'if' clause evaluates to false then code should\n// be executed on the host\n// (c) without offloading all the code should be executed on the device\n// The if clause is evaluated on runtime which means that variables could\n// determine this behavior. We use a SIZE_THRESHOLD variable to check if we\n// should execute on the device or the host. Before starting the test we\n// sample offloading to see if it was enabled or not. If the code is executed\n// in the device, the result should be c[i] = a[i] + b[i] = i + 1.\n// If the code is executed on the host the result should be c[i] = -1\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define SIZE 1024\n#define SIZE_THRESHOLD 512\n\nint test_target_data_map_if_nested (int isOffloading){\n  int a[SIZE];\n  int b[SIZE];\n  int c[SIZE];\n  int map_size, i = 0, errors[2] = {0,0}, isHost = -1;\n\n  // a and b array initialization\n  for (i = 0; i < SIZE; i++) {\n    a[i] = 1;\n    b[i] = i;\n  }\n\n  // check multiple sizes.\n  for (map_size = 256; map_size <= SIZE; map_size += 256) {\n    // C initialization\n    for (i = 0; i < map_size; i++) {\n      c[i] = -1;\n    }\n#pragma omp target data if(map_size > SIZE_THRESHOLD) map(to: map_size)  \\\n        map(tofrom: c[0:map_size])                                       \\\n        map(to: a[0:map_size], b[0:map_size])\n    {\n#pragma omp target if(map_size > SIZE_THRESHOLD) map(tofrom: isHost) \\\n        map (alloc: a[0:map_size], b[0:map_size], c[0:map_size]) // avoid default mapping\n      {\n        isHost = omp_is_initial_device();\n        int alpha = (isHost ? 0 : 1);\n        int j = 0;\n        for (j = 0; j < map_size; j++) {\n          // c[j] is zero if executed in the host\n          // c[j] is 1+j if executed on the device\n          c[j] = alpha*(a[j] + b[j]);\n        }\n      } // end target\n    }//end-target data\n\n    // checking results\n    for (i = 0; i < map_size; i++) {\n      if (isOffloading && map_size > SIZE_THRESHOLD) {\n        // Should have executed on the device\n        // if offloading was used\n        // c[i] is zero if it was executed in the host\n        OMPVV_TEST_AND_SET(errors[0], (c[i] != i + 1)); //error when executed on the device\n      } else {\n        // Should have executed in the host\n        // with or without offloading\n        OMPVV_TEST_AND_SET(errors[1], (c[i] != 0));\n      } //end-else\n    }\n  } // end-for map_size\n\n  if (!errors[0] && !errors[1]) {\n    OMPVV_INFOMSG(\"Test nested if passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  } else if (errors[0]==0 && errors[1]!=0) {\n    OMPVV_ERROR(\"Test nested if failed on host with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n  } else if (errors[0]!=0 && errors[1]==0) {\n    OMPVV_ERROR(\"Test nested if failed on device with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n  } else if (errors[0]!=0 && errors[1]!=0) {\n    OMPVV_ERROR(\"Test nested if failed on host and device with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n  }\n\n  return errors[0] + errors[1];\n}\n\nint test_target_data_map_if_simple(int isOffloading){\n  int a[SIZE];\n  int b[SIZE];\n  int c[SIZE];\n  int map_size, i = 0, errors[3] = {0,0,0}, isHost = -1;\n\n  // check multiple sizes.\n  for (map_size = 256; map_size <= SIZE; map_size += 256) {\n    // a, b, and c array initialization\n    for (i = 0; i < SIZE; i++) {\n      a[i] = SIZE - i;\n      b[i] = i;\n      c[i] = -1;\n    }\n#pragma omp target data if(map_size > SIZE_THRESHOLD) map(to: map_size)  \\\n        map(tofrom: c[0:map_size])                             \\\n        map(to: a[0:map_size], b[0:map_size])\n    {\n#pragma omp target map(tofrom: isHost) \\\n        map (alloc: a[0:map_size], b[0:map_size], c[0:map_size]) // avoid default mapping\n      {\n        isHost = omp_is_initial_device();\n        int j = 0;\n        for (j = 0; j < map_size; j++) {\n          // This should be equal to SIZE, if target data\n          // mapped the arrays a and b, otherwise it is\n          // unknown but it is not used either\n          c[j] += (a[j] + b[j] + 1);\n          a[j] = -1; // changing memory content this should not affect original storage\n          b[j] = -1; // changing memory content\n        }\n      } // end target\n\n      // Check that the target region did not exec in the\n      // host as the if should only affect the target data\n      if (isOffloading) {\n        OMPVV_TEST_AND_SET_VERBOSE(errors[0], isHost);\n      }\n    }//end-target data\n\n    // checking results\n    for (i = 0; i < map_size; i++) {\n      if (map_size > SIZE_THRESHOLD || !isOffloading) {\n        // Should have executed in the device if offloading is enabled\n        // If offloading is not enabled or the system is a shared env\n        // between device and host, then the value will modify the original\n        // elements of c.\n        OMPVV_TEST_AND_SET(errors[1], (c[i] != SIZE)); //error when executed on the device\n      } else {\n        // Should have executed in the host\n        // with or without offloading\n        OMPVV_TEST_AND_SET(errors[2], (c[i] != -1));\n      } //end-else\n    }\n  } // end-for map_size\n\n  if (errors[0]) {\n    OMPVV_ERROR(\"Test did not offload to the device. 'If' clause might be affecting the target\"\n                \" offlading as well and it should not \")\n  }\n  if (!errors[0] && !errors[1] && !errors[2]) {\n    OMPVV_INFOMSG(\"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  } else if (errors[1]==0 && errors[2]!=0) {\n    OMPVV_ERROR(\"Test failed for if (false) with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n  } else if (errors[1]!=0 && errors[2]==0) {\n    OMPVV_ERROR(\"Test failed for if (true) with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n  } else if (errors[1]!=0 && errors[2]!=0) {\n    OMPVV_ERROR(\"Test failed for if(true) and if(false) with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n  }\n\n  return errors[0] + errors[1] + errors[2];\n}\n\n// Test for OpenMP 4.5 target data with if\nint main() {\n  int isOffloading = 0;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"Offloading is off, tests will be inconclusive. No way to tests if\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_data_map_if_nested(isOffloading) != 0);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_data_map_if_simple(isOffloading) != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_data_if.c - check the if clause of target data ------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// The if clause determines if the section should be executed in the host or\n// the device. There are three things to test here:\n// (a) with offloading when 'if' clause evaluates to true then code\n// be executed on the device\n// (b) with offloading when 'if' clause evaluates to false then code should\n// be executed on the host\n// (c) without offloading all the code should be executed on the device\n// The if clause is evaluated on runtime which means that variables could\n// determine this behavior. We use a SIZE_THRESHOLD variable to check if we\n// should execute on the device or the host. Before starting the test we\n// sample offloading to see if it was enabled or not. If the code is executed\n// in the device, the result should be c[i] = a[i] + b[i] = i + 1.\n// If the code is executed on the host the result should be c[i] = -1\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define SIZE 1024\n#define SIZE_THRESHOLD 512\n\nint test_target_data_map_if_nested (int isOffloading){\n  int a[SIZE];\n  int b[SIZE];\n  int c[SIZE];\n  int map_size, i = 0, errors[2] = {0,0}, isHost = -1;\n\n  // a and b array initialization\n  for (i = 0; i < SIZE; i++) {\n    a[i] = 1;\n    b[i] = i;\n  }\n\n  // check multiple sizes.\n  for (map_size = 256; map_size <= SIZE; map_size += 256) {\n    // C initialization\n    for (i = 0; i < map_size; i++) {\n      c[i] = -1;\n    }\n#pragma omp target data if(map_size > SIZE_THRESHOLD) map(to: map_size)  \\\n        map(tofrom: c[0:map_size])                                       \\\n        map(to: a[0:map_size], b[0:map_size])\n    {\n#pragma omp target if(map_size > SIZE_THRESHOLD) map(tofrom: isHost) \\\n        map (alloc: a[0:map_size], b[0:map_size], c[0:map_size]) // avoid default mapping\n      {\n        isHost = omp_is_initial_device();\n        int alpha = (isHost ? 0 : 1);\n        int j = 0;\n        for (j = 0; j < map_size; j++) {\n          // c[j] is zero if executed in the host\n          // c[j] is 1+j if executed on the device\n          c[j] = alpha*(a[j] + b[j]);\n        }\n      } // end target\n    }//end-target data\n\n    // checking results\n    for (i = 0; i < map_size; i++) {\n      if (isOffloading && map_size > SIZE_THRESHOLD) {\n        // Should have executed on the device\n        // if offloading was used\n        // c[i] is zero if it was executed in the host\n        OMPVV_TEST_AND_SET(errors[0], (c[i] != i + 1)); //error when executed on the device\n      } else {\n        // Should have executed in the host\n        // with or without offloading\n        OMPVV_TEST_AND_SET(errors[1], (c[i] != 0));\n      } //end-else\n    }\n  } // end-for map_size\n\n  if (!errors[0] && !errors[1]) {\n    OMPVV_INFOMSG(\"Test nested if passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  } else if (errors[0]==0 && errors[1]!=0) {\n    OMPVV_ERROR(\"Test nested if failed on host with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n  } else if (errors[0]!=0 && errors[1]==0) {\n    OMPVV_ERROR(\"Test nested if failed on device with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n  } else if (errors[0]!=0 && errors[1]!=0) {\n    OMPVV_ERROR(\"Test nested if failed on host and device with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n  }\n\n  return errors[0] + errors[1];\n}\n\nint test_target_data_map_if_simple(int isOffloading){\n  int a[SIZE];\n  int b[SIZE];\n  int c[SIZE];\n  int map_size, i = 0, errors[3] = {0,0,0}, isHost = -1;\n\n  // check multiple sizes.\n  for (map_size = 256; map_size <= SIZE; map_size += 256) {\n    // a, b, and c array initialization\n    for (i = 0; i < SIZE; i++) {\n      a[i] = SIZE - i;\n      b[i] = i;\n      c[i] = -1;\n    }\n#pragma omp target data if(map_size > SIZE_THRESHOLD) map(to: map_size)  \\\n        map(tofrom: c[0:map_size])                             \\\n        map(to: a[0:map_size], b[0:map_size])\n    {\n#pragma omp target map(tofrom: isHost) \\\n        map (alloc: a[0:map_size], b[0:map_size], c[0:map_size]) // avoid default mapping\n      {\n        isHost = omp_is_initial_device();\n        int j = 0;\n        for (j = 0; j < map_size; j++) {\n          // This should be equal to SIZE, if target data\n          // mapped the arrays a and b, otherwise it is\n          // unknown but it is not used either\n          c[j] += (a[j] + b[j] + 1);\n          a[j] = -1; // changing memory content this should not affect original storage\n          b[j] = -1; // changing memory content\n        }\n      } // end target\n\n      // Check that the target region did not exec in the\n      // host as the if should only affect the target data\n      if (isOffloading) {\n        OMPVV_TEST_AND_SET_VERBOSE(errors[0], isHost);\n      }\n    }//end-target data\n\n    // checking results\n    for (i = 0; i < map_size; i++) {\n      if (map_size > SIZE_THRESHOLD || !isOffloading) {\n        // Should have executed in the device if offloading is enabled\n        // If offloading is not enabled or the system is a shared env\n        // between device and host, then the value will modify the original\n        // elements of c.\n        OMPVV_TEST_AND_SET(errors[1], (c[i] != SIZE)); //error when executed on the device\n      } else {\n        // Should have executed in the host\n        // with or without offloading\n        OMPVV_TEST_AND_SET(errors[2], (c[i] != -1));\n      } //end-else\n    }\n  } // end-for map_size\n\n  if (errors[0]) {\n    OMPVV_ERROR(\"Test did not offload to the device. 'If' clause might be affecting the target\"\n                \" offlading as well and it should not \")\n  }\n  if (!errors[0] && !errors[1] && !errors[2]) {\n    OMPVV_INFOMSG(\"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  } else if (errors[1]==0 && errors[2]!=0) {\n    OMPVV_ERROR(\"Test failed for if (false) with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n  } else if (errors[1]!=0 && errors[2]==0) {\n    OMPVV_ERROR(\"Test failed for if (true) with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n  } else if (errors[1]!=0 && errors[2]!=0) {\n    OMPVV_ERROR(\"Test failed for if(true) and if(false) with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n  }\n\n  return errors[0] + errors[1] + errors[2];\n}\n\n// Test for OpenMP 4.5 target data with if\nint main() \n  int isOffloading = 0;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"Offloading is off, tests will be inconclusive. No way to tests if\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_data_map_if_nested(isOffloading) != 0);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_data_map_if_simple(isOffloading) != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_loop_reduction_or.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 2503",
        "issue_id": 1,
        "original_code": "//===--- test_loop_reduction_or.c -------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the reduction clause on a loop directive, testing that the\n// variable in the reduction clause is properly reduced using the or\n// operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n#define THRESHOLD 512\n\nint test_or() {\n  char a[N];\n  double true_margin = pow(exp(1), log(.5)/N);   // See the 'and' operator test for\n  int errors = 0;                                // an explanation of this math.\n  int num_threads[N];\n  int tested_true = 0;\n  int tested_false = 0;\n  int itr_count = 0;\n  srand(1);\n\n  while ((!tested_true || !tested_false) && (itr_count < THRESHOLD)) {\n    for (int x = 0; x < N; ++x) {\n      a[x] = rand() / (double)(RAND_MAX) > true_margin;\n      num_threads[x] = -x;\n    }\n\n    char result = 0;\n    char host_result = 0;\n\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST)\n    {\n#pragma omp loop reduction(||:result)\n      for (int x = 0; x < N; ++x) {\n        result = result || a[x];\n      }\n#pragma omp for\n      for (int x = 0; x < N; ++x) {\n        num_threads[x] = omp_get_num_threads();\n      }\n    }\n\n    for (int x = 0; x < N; ++x) {\n      host_result = host_result || a[x];\n    }\n\n    if (itr_count == 0) {\n      for (int x = 1; x < N; ++x) {\n        OMPVV_WARNING_IF(num_threads[x - 1] != num_threads[x], \"Test reported differing numbers of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n      }\n      OMPVV_WARNING_IF(num_threads[0] == 1, \"Test operated with one thread.  Reduction clause cannot be tested.\");\n      OMPVV_WARNING_IF(num_threads[0] <= 0, \"Test reported invalid number of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n    }\n\n    OMPVV_TEST_AND_SET_VERBOSE(errors, host_result != result);\n    OMPVV_ERROR_IF(host_result != result, \"Result from loop directive is %d but expected result is %d.\", result, host_result);\n\n    if (host_result) {\n      tested_true = 1;\n    } else {\n      tested_false = 1;\n    }\n\n    if (host_result != result) {\n      break;\n    }\n\n    itr_count++;\n  }\n\n  OMPVV_WARNING_IF(!tested_true, \"Did not test a case in which final result was true.\");\n  OMPVV_WARNING_IF(!tested_false, \"Did not test a case in which final result was false.\");\n\n  return errors;\n}\n\nint main() {\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_or() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n",
        "error_code": "//===--- test_loop_reduction_or.c -------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the reduction clause on a loop directive, testing that the\n// variable in the reduction clause is properly reduced using the or\n// operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n#define THRESHOLD 512\n\nint test_or() {\n  char a[N];\n  double true_margin = pow(exp(1), log(.5)/N);   // See the 'and' operator test for\n  int errors = 0;                                // an explanation of this math.\n  int num_threads[N];\n  int tested_true = 0;\n  int tested_false = 0;\n  int itr_count = 0;\n  srand(1);\n\n  while ((!tested_true || !tested_false) && (itr_count < THRESHOLD)) {\n    for (int x = 0; x < N; ++x) {\n      a[x] = rand() / (double)(RAND_MAX) > true_margin;\n      num_threads[x] = -x;\n    }\n\n    char result = 0;\n    char host_result = 0;\n\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST)\n    {\n#pragma omp loop reduction(||:result)\n      for (int x = 0; x < N; ++x) {\n        result = result || a[x];\n      }\n#pragma omp for\n      for (int x = 0; x < N; ++x) {\n        num_threads[x] = omp_get_num_threads();\n      }\n    }\n\n    for (int x = 0; x < N; ++x) {\n      host_result = host_result || a[x];\n    }\n\n    if (itr_count == 0) {\n      for (int x = 1; x < N; ++x) {\n        OMPVV_WARNING_IF(num_threads[x - 1] != num_threads[x], \"Test reported differing numbers of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n      }\n      OMPVV_WARNING_IF(num_threads[0] == 1, \"Test operated with one thread.  Reduction clause cannot be tested.\");\n      OMPVV_WARNING_IF(num_threads[0] <= 0, \"Test reported invalid number of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n    }\n\n    OMPVV_TEST_AND_SET_VERBOSE(errors, host_result != result);\n    OMPVV_ERROR_IF(host_result != result, \"Result from loop directive is %d but expected result is %d.\", result, host_result);\n\n    if (host_result) {\n      tested_true = 1;\n    } else {\n      tested_false = 1;\n    }\n\n    if (host_result != result) {\n      break;\n    }\n\n    itr_count++;\n  }\n\n  OMPVV_WARNING_IF(!tested_true, \"Did not test a case in which final result was true.\");\n  OMPVV_WARNING_IF(!tested_false, \"Did not test a case in which final result was false.\");\n\n  return errors;\n}\n\nint main() \n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_or() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_enter_exit_data_if.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp atomic\" at position 1790",
        "issue_id": 0,
        "original_code": "//===---- test_target_enter_exit_data_if.c --------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// The if clause determines if the section should be executed in the host or \n// the device. There are three things to test here: \n// (a) with offloading when 'if' clause evaluates to true then code\n// be executed on the device \n// (b) with offloading when 'if' clause evaluates to false then code should\n// be executed on the host\n// (c) without offloading all the code should be executed on the device\n// The if clause is evaluated on runtime which means that variables could\n// determine this behavior. We use a SIZE_THRESHOLD variable to check if we \n// should execute on the device or the host. Before starting the test we \n// sample offloading to see if it was enabled or not. If the code is executed\n// in the device, the result should be c[i] = a[i] + b[i] = i + 1. \n// If the code is executed on the host the result should be c[i] = -1\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define SIZE_THRESHOLD 512\n\nint main() {\n  int a[1024];\n  int b[1024];\n  int c[1024];\n  int size, i = 0, errors[2] = {0,0}, isOffloading = 0;\n\n  // a and b array initialization\n  for (i = 0; i < 1024; i++) {\n    a[i] = 1;\n    b[i] = i;\n  }\n\n  // We test for offloading\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n \n  OMPVV_WARNING_IF(!isOffloading, \"It is not possible to test conditional data transfers \"\n                 \"if the environment is shared or offloading is off. Not testing \"\n                 \"anything\"); \n\n  // check multiple sizes. \n  for (size = 256; size <= 1024; size += 256) {\n    // C initialization\n    for (i = 0; i < size; i++) {\n      c[i] = -1;\n    }\n#pragma omp target enter data if(size > SIZE_THRESHOLD) map(to: size) map(to: c[0:size])\n           \n#pragma omp target if(size > SIZE_THRESHOLD)  \\\n        map(to: a[0:size], b[0:size]) map(to: c[0:size]) //Mapping c again will not be required in OpenMP 4.5.\n\t\t\t\t\t\t\t\t\t     // Refer to https://gcc.gnu.org/bugzilla/show_bug.cgi?id=83295\n{\n        int isHost = -1;\n        isHost = omp_is_initial_device();\n        int alpha = (isHost ? 0 : 1);\n        int j = 0;\n        for (j = 0; j < size; j++) {\n          // c[j] is zero if executed in the host\n          // c[j] is 1+j if executed on the device\n          c[j] = alpha*(a[j] + b[j]);\n        }\n} // end target\n#pragma omp target exit data if(size > SIZE_THRESHOLD) map(from: c[0:size])\n\n    // checking results \n    for (i = 0; i < size; i++) {\n      if (isOffloading && size > SIZE_THRESHOLD) {\n        // Should have executed on the device\n        // if offloading was used\n        if (c[i] != i + 1) {\n          // c[i] is zero if it was executed in the host\n          errors[0] += 1;//error when executed on the device\n        }\n      } else {\n        // Should have executed in the host\n        // with or without offloading\n        if (c[i] != 0) {\n          errors[1] += 1;\n        }\n      } //end-else \n    }\n  } // end-for size\n\n  if (!errors[0] && !errors[1]) {\n    OMPVV_INFOMSG(\"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  } else if (errors[0]==0 && errors[1]!=0) {\n      OMPVV_ERROR(\"Test failed on host with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n    } else if (errors[0]!=0 && errors[1]==0) {\n        OMPVV_ERROR(\"Test failed on device with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n      } else if (errors[0]!=0 && errors[1]!=0) {\n              OMPVV_ERROR(\"Test failed on host and device with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n        }\n\n   OMPVV_REPORT_AND_RETURN((errors[0] && errors[1]));\n}\n",
        "error_code": "//===---- test_target_enter_exit_data_if.c --------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// The if clause determines if the section should be executed in the host or \n// the device. There are three things to test here: \n// (a) with offloading when 'if' clause evaluates to true then code\n// be executed on the device \n// (b) with offloading when 'if' clause evaluates to false then code should\n// be executed on the host\n// (c) without offloading all the code should be executed on the device\n// The if clause is evaluated on runtime which means that variables could\n// determine this behavior. We use a SIZE_THRESHOLD variable to check if we \n// should execute on the device or the host. Before starting the test we \n// sample offloading to see if it was enabled or not. If the code is executed\n// in the device, the result should be c[i] = a[i] + b[i] = i + 1. \n// If the code is executed on the host the result should be c[i] = -1\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define SIZE_THRESHOLD 512\n\nint main() {\n  int a[1024];\n  int b[1024];\n  int c[1024];\n  int size, i = 0, errors[2] = {0,0}, isOffloading = 0;\n\n  // a and b array initialization\n  for (i = 0; i < 1024; i++) {\n    a[i] = 1;\n    b[i] = i;\n  }\n\n  // We test for offloading\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n \n  OMPVV_WARNING_IF(!isOffloading, \"It is not possible to test conditional data transfers \"\n                 \"if the environment is shared or offloading is off. Not testing \"\n                 \"anything\"); \n\n  // check multiple sizes. \n  for (size = 256; size <= 1024; size += 256) {\n    // C initialization\n    for (i = 0; i < size; i++) {\n      c[i] = -1;\n    }\n#pragma omp atomic enter data if(size > SIZE_THRESHOLD) map(to: size) map(to: c[0:size])\n           \n#pragma omp target if(size > SIZE_THRESHOLD)  \\\n        map(to: a[0:size], b[0:size]) map(to: c[0:size]) //Mapping c again will not be required in OpenMP 4.5.\n\t\t\t\t\t\t\t\t\t     // Refer to https://gcc.gnu.org/bugzilla/show_bug.cgi?id=83295\n{\n        int isHost = -1;\n        isHost = omp_is_initial_device();\n        int alpha = (isHost ? 0 : 1);\n        int j = 0;\n        for (j = 0; j < size; j++) {\n          // c[j] is zero if executed in the host\n          // c[j] is 1+j if executed on the device\n          c[j] = alpha*(a[j] + b[j]);\n        }\n} // end target\n#pragma omp target exit data if(size > SIZE_THRESHOLD) map(from: c[0:size])\n\n    // checking results \n    for (i = 0; i < size; i++) {\n      if (isOffloading && size > SIZE_THRESHOLD) {\n        // Should have executed on the device\n        // if offloading was used\n        if (c[i] != i + 1) {\n          // c[i] is zero if it was executed in the host\n          errors[0] += 1;//error when executed on the device\n        }\n      } else {\n        // Should have executed in the host\n        // with or without offloading\n        if (c[i] != 0) {\n          errors[1] += 1;\n        }\n      } //end-else \n    }\n  } // end-for size\n\n  if (!errors[0] && !errors[1]) {\n    OMPVV_INFOMSG(\"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  } else if (errors[0]==0 && errors[1]!=0) {\n      OMPVV_ERROR(\"Test failed on host with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n    } else if (errors[0]!=0 && errors[1]==0) {\n        OMPVV_ERROR(\"Test failed on device with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n      } else if (errors[0]!=0 && errors[1]!=0) {\n              OMPVV_ERROR(\"Test failed on host and device with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n        }\n\n   OMPVV_REPORT_AND_RETURN((errors[0] && errors[1]));\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_task_in_reduction_dynamically_enclosed.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 1294",
        "issue_id": 2,
        "original_code": "//===--- test_task_in_reduction_dynamically_enclosed.c ----------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the task directive with the `in_reduction` reduction\n// participation clause. It performs simple array operations which are added\n// to a reduction variable in an explcit task with the in_reduction clause.\n// This checks the above in a case in which the in_reduction tasks are\n// nested in a function in the taskgroup. Thanks to Jakub Jelinek for\n// suggesting this test.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint sum = 0;\n\nvoid task_container(int i) {\n#pragma omp task in_reduction(+:sum)\n  sum += 1 + i;\n#pragma omp taskwait\n#pragma omp task in_reduction(+:sum)\n  sum += 1 + i*2;\n#pragma omp taskwait\n}\n\nint test_task_in_reduction_dynamically_enclosed() {\n  OMPVV_INFOMSG(\"test_task_in_reduction_dynamically_enclosed\");\n  int errors = 0;\n  int expect = 2;\n\n#pragma omp taskgroup task_reduction(+:sum)\n  task_container(0);\n#pragma omp taskloop reduction(+:sum)\n  for (int i = 0; i < N; i++) {\n    task_container(i);\n    sum += i;\n  }\n\n  for (int i = 0; i < N; i++) {\n    expect += 2 + 4*i;\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, sum != expect);\n\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_task_in_reduction_dynamically_enclosed());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_task_in_reduction_dynamically_enclosed.c ----------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the task directive with the `in_reduction` reduction\n// participation clause. It performs simple array operations which are added\n// to a reduction variable in an explcit task with the in_reduction clause.\n// This checks the above in a case in which the in_reduction tasks are\n// nested in a function in the taskgroup. Thanks to Jakub Jelinek for\n// suggesting this test.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint sum = 0;\n\nvoid task_container(int i) {\n#pragma omp task in_reduction(+:sum)\n  sum += 1 + i;\n#pragma omp taskwait\n#pragma omp task in_reduction(+:sum)\n  sum += 1 + i*2;\n#pragma omp taskwait\n}\n\nint test_task_in_reduction_dynamically_enclosed() {\n  OMPVV_INFOMSG(\"test_task_in_reduction_dynamically_enclosed\");\n  int errors = 0;\n  int expect = 2;\n\n#pragma omp taskgroup task_reduction(+:sum)\n  task_container(0);\n#pragma omp taskloop reduction(+:sum)\n  for (int i = 0; i < N; i++) {\n    task_container(i);\n    sum += i;\n  }\n\n  for (int i = 0; i < N; i++) {\n    expect += 2 + 4*i;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, sum != expect);\n\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_task_in_reduction_dynamically_enclosed());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_taskloop_simd_in_reduction.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1551",
        "issue_id": 1,
        "original_code": "//===--- test_taskloop_simd_in_reduction.c -----------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the taskloop simd directive with the `in_reduction`\n// reduction participation clause. It performs simple array operations which\n// are added to a reduction variable in a taskloop with the in_reduction\n// clause.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_taskloop_simd_in_reduction() {\n  OMPVV_INFOMSG(\"test_taskloop_simd_in_reduction\");\n  int errors = 0;\n  int num_threads = -1;\n  int y[N];\n  int z[N];\n  int sum = 0;\n  int expected_sum = 0;\n\n  for (int i = 0; i < N; i++) {\n    y[i] = i + 1;\n    z[i] = 2*(i + 1);\n  }\n\n#pragma omp parallel reduction(task, +: sum) num_threads(OMPVV_NUM_THREADS_HOST) shared(y, z, num_threads)\n  {\n#pragma omp master\n    {\n#pragma omp taskloop simd in_reduction(+: sum)\n      for (int i = 0; i < N; i++) {\n        sum += y[i]*z[i];\n      }\n      num_threads = omp_get_num_threads();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    expected_sum += y[i]*z[i];\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, sum != expected_sum);\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of taskloop can't be guaranteed.\");\n  OMPVV_ERROR_IF(num_threads < 1, \"Test returned an invalid number of threads.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n\n  return errors;\n}\n\n\nint main() {\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_taskloop_simd_in_reduction());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_taskloop_simd_in_reduction.c -----------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the taskloop simd directive with the `in_reduction`\n// reduction participation clause. It performs simple array operations which\n// are added to a reduction variable in a taskloop with the in_reduction\n// clause.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_taskloop_simd_in_reduction() {\n  OMPVV_INFOMSG(\"test_taskloop_simd_in_reduction\");\n  int errors = 0;\n  int num_threads = -1;\n  int y[N];\n  int z[N];\n  int sum = 0;\n  int expected_sum = 0;\n\n  for (int i = 0; i < N; i++) {\n    y[i] = i + 1;\n    z[i] = 2*(i + 1);\n  }\n\n#pragma omp parallel reduction(task, +: sum) num_threads(OMPVV_NUM_THREADS_HOST) shared(y, z, num_threads)\n  {\n#pragma omp master\n    {\n#pragma omp taskloop simd in_reduction(+: sum)\n      for (int i = 0; i < N; i++) {\n        sum += y[i]*z[i];\n      }\n      num_threads = omp_get_num_threads();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    expected_sum += y[i]*z[i];\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, sum != expected_sum);\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of taskloop can't be guaranteed.\");\n  OMPVV_ERROR_IF(num_threads < 1, \"Test returned an invalid number of threads.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n\n  return errors;\n}\n\n\nint main() \n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_taskloop_simd_in_reduction());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_aligned_calloc.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_aligned_calloc_on_device() != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 1805",
        "issue_id": 4,
        "original_code": "//===--------------------- test_target_aligned_calloc.c -------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// Tests the omp_aligned_calloc routine. Requests a memory allocation\n// aligned to the passed byte parameter. Starts by initializing some memory\n// in the omp_default_mem_space and then checks if this memory is aligned\n// and can be properly written to and read from. Checks on the device.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_aligned_calloc_on_device() {\n  int errors = 0;\n\n  #pragma omp target map(tofrom: errors) uses_allocators(omp_default_mem_alloc) \n  {\n    int *x;\n    int not_correct_array_values = 0;\n  \n    x = (int *)omp_aligned_calloc(64, N, N*sizeof(int), omp_default_mem_alloc);\n    \n    if (x == NULL) { \n      OMPVV_ERROR(\"omp_aligned_calloc returned null\"); \n      errors++;\n    } else {\n      OMPVV_TEST_AND_SET(errors, ((intptr_t)(x))%64 != 0);\n      OMPVV_ERROR_IF(((intptr_t)(x))%64 != 0, \" Condition ((intptr_t)(x))%%64 != 0 failed. The memory does not seem to be properly aligned.\");\n\n      #pragma omp parallel for simd simdlen(16) aligned(x: 64)\n      for (int i = 0; i < N; i++) {\n        x[i] = i;\n      }\n\n      #pragma omp parallel for simd simdlen(16) aligned(x: 64)\n      for (int i = 0; i < N; i++) {\n        if (x[i] != i) {\n          #pragma omp atomic write\n          not_correct_array_values = 1; \n        }\n      }\n\n      if (not_correct_array_values) {\n        OMPVV_ERROR(\"Values in the array did NOT match the expected values. Changes may not have persisted.\");\n        errors++;\n      }\n\n      omp_free(x, omp_default_mem_alloc);\n    }\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_aligned_calloc_on_device() != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n\n",
        "error_code": "//===--------------------- test_target_aligned_calloc.c -------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// Tests the omp_aligned_calloc routine. Requests a memory allocation\n// aligned to the passed byte parameter. Starts by initializing some memory\n// in the omp_default_mem_space and then checks if this memory is aligned\n// and can be properly written to and read from. Checks on the device.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_aligned_calloc_on_device() {\n  int errors = 0;\n\n  #pragma omp target map(tofrom: errors) uses_allocators(omp_default_mem_alloc) \n  {\n    int *x;\n    int not_correct_array_values = 0;\n  \n    x = (int *)omp_aligned_calloc(64, N, N*sizeof(int), omp_default_mem_alloc);\n    \n    if (x == NULL) { \n      OMPVV_ERROR(\"omp_aligned_calloc returned null\"); \n      errors++;\n    } else {\n      OMPVV_TEST_AND_SET(errors, ((intptr_t)(x))%64 != 0);\n      OMPVV_ERROR_IF(((intptr_t)(x))%64 != 0, \" Condition ((intptr_t)(x))%%64 != 0 failed. The memory does not seem to be properly aligned.\");\n\n      #pragma omp parallel for simd simdlen(16) aligned(x: 64)\n      for (int i = 0; i < N; i++) {\n        x[i] = i;\n      }\n\n      #pragma omp parallel for simd simdlen(16) aligned(x: 64)\n      for (int i = 0; i < N; i++) {\n        if (x[i] != i) {\n          #pragma omp atomic write\n          not_correct_array_values = 1; \n        }\n      }\n\n      if (not_correct_array_values) {\n        OMPVV_ERROR(\"Values in the array did NOT match the expected values. Changes may not have persisted.\");\n        errors++;\n      }\n\n      omp_free(x, omp_default_mem_alloc);\n    }\n  }\n\n  return errors;\n}\n\nint main() \n\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_loop_is_device_ptr.c",
        "correct": "n",
        "issue": "Removed memory allocation line \"omp_target_alloc(N * sizeof(int),\n                omp_get_default_device());\" at position 688",
        "issue_id": 0,
        "original_code": "//===-------------- test_target_teams_loop_is_device_ptr.c----------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n// The tests in this file tests 'teams loop' construct coupled with is_device_ptr\n// & map() clause\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n/**\n  This is a basic test to demonstrate is_device_ptr\n  clause with target teams loop construct.\n*/\nint testIsDevPtrBasic() {\n  int *a_h = NULL;\n  int *a_d = NULL;\n  int errors = 0;\n\n  a_h = (int *) malloc(N * sizeof(int));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, a_h == NULL);\n  a_d = (int *) omp_target_alloc(N * sizeof(int),\n                omp_get_default_device());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, a_d == NULL);\n\n#pragma omp target teams loop is_device_ptr(a_d) map(from: a_h[0:N])\n  for (int i = 0; i < N; ++i) {\n    a_d[i] = i;\n    a_h[i] = a_d[i];\n  }\n  // Validate\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, a_h[i] != i);\n  }\n  omp_target_free(a_d, omp_get_default_device());\n  free(a_h);\n  return errors;\n}\n\n/**\n  This is a basic test to demonstrate is_device_ptr\n  clause with 2 target teams blocks. The first block populates\n  data and the second block uses the data.\n*/\nint testIsDevPtrOn2DifferentTasks() {\n  int *a_h = NULL;\n  int *a_d = NULL;\n  int errors = 0;\n\n  a_h = (int *) malloc(N * sizeof(int));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, a_h == NULL);\n  a_d = (int *) omp_target_alloc(N * sizeof(int),\n                omp_get_default_device());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, a_d == NULL);\n\n#pragma omp target teams loop is_device_ptr(a_d)\n  for (int i = 0; i < N; ++i) {\n    a_d[i] = i;\n  }\n\n#pragma omp target teams loop is_device_ptr(a_d) map(from: a_h[0:N])\n  for (int i = 0; i < N; ++i) {\n    a_h[i] = a_d[i];\n  }\n  // Validate\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, a_h[i] != i);\n  }\n  omp_target_free(a_d, omp_get_default_device());\n  free(a_h);\n  return errors;\n}\n\n/**\n  This is a basic test to demonstrate is_device_ptr\n  clause with 2 target teams blocks using multiple device pointers.\n*/\nint testIsDevPtrOn2DifferentPointers() {\n  int *a_h = NULL;\n  int *a_d1 = NULL, *a_d2 = NULL;\n  int errors = 0;\n\n  a_h = (int *) malloc(N * sizeof(int));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, a_h == NULL);\n  a_d1 = (int *) omp_target_alloc(N * sizeof(int),\n                omp_get_default_device());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, a_d1 == NULL);\n  a_d2 = (int *) omp_target_alloc(N * sizeof(int),\n                omp_get_default_device());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, a_d2 == NULL);\n\n#pragma omp target teams loop is_device_ptr(a_d1, a_d2)\n  for (int i = 0; i < N; ++i) {\n    a_d1[i] = 2*i;\n    a_d2[i] = 2*i + 1;\n  }\n\n#pragma omp target teams loop is_device_ptr(a_d1, a_d2) map(from: a_h[0:N])\n  for (int i = 0; i < N; ++i) {\n    a_h[i] = a_d1[i] + a_d2[i];\n  }\n  // Validate\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, a_h[i] != (4*i + 1));\n  }\n  omp_target_free(a_d1, omp_get_default_device());\n  omp_target_free(a_d2, omp_get_default_device());\n  free(a_h);\n  return errors;\n}\n\nint main(void) {\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testIsDevPtrBasic());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testIsDevPtrOn2DifferentTasks());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testIsDevPtrOn2DifferentPointers());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===-------------- test_target_teams_loop_is_device_ptr.c----------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n// The tests in this file tests 'teams loop' construct coupled with is_device_ptr\n// & map() clause\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n/**\n  This is a basic test to demonstrate is_device_ptr\n  clause with target teams loop construct.\n*/\nint testIsDevPtrBasic() {\n  int *a_h = NULL;\n  int *a_d = NULL;\n  int errors = 0;\n\n  a_h = (int *) malloc(N * sizeof(int));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, a_h == NULL);\n  a_d = (int *) \n  OMPVV_TEST_AND_SET_VERBOSE(errors, a_d == NULL);\n\n#pragma omp target teams loop is_device_ptr(a_d) map(from: a_h[0:N])\n  for (int i = 0; i < N; ++i) {\n    a_d[i] = i;\n    a_h[i] = a_d[i];\n  }\n  // Validate\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, a_h[i] != i);\n  }\n  omp_target_free(a_d, omp_get_default_device());\n  free(a_h);\n  return errors;\n}\n\n/**\n  This is a basic test to demonstrate is_device_ptr\n  clause with 2 target teams blocks. The first block populates\n  data and the second block uses the data.\n*/\nint testIsDevPtrOn2DifferentTasks() {\n  int *a_h = NULL;\n  int *a_d = NULL;\n  int errors = 0;\n\n  a_h = (int *) malloc(N * sizeof(int));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, a_h == NULL);\n  a_d = (int *) omp_target_alloc(N * sizeof(int),\n                omp_get_default_device());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, a_d == NULL);\n\n#pragma omp target teams loop is_device_ptr(a_d)\n  for (int i = 0; i < N; ++i) {\n    a_d[i] = i;\n  }\n\n#pragma omp target teams loop is_device_ptr(a_d) map(from: a_h[0:N])\n  for (int i = 0; i < N; ++i) {\n    a_h[i] = a_d[i];\n  }\n  // Validate\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, a_h[i] != i);\n  }\n  omp_target_free(a_d, omp_get_default_device());\n  free(a_h);\n  return errors;\n}\n\n/**\n  This is a basic test to demonstrate is_device_ptr\n  clause with 2 target teams blocks using multiple device pointers.\n*/\nint testIsDevPtrOn2DifferentPointers() {\n  int *a_h = NULL;\n  int *a_d1 = NULL, *a_d2 = NULL;\n  int errors = 0;\n\n  a_h = (int *) malloc(N * sizeof(int));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, a_h == NULL);\n  a_d1 = (int *) omp_target_alloc(N * sizeof(int),\n                omp_get_default_device());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, a_d1 == NULL);\n  a_d2 = (int *) omp_target_alloc(N * sizeof(int),\n                omp_get_default_device());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, a_d2 == NULL);\n\n#pragma omp target teams loop is_device_ptr(a_d1, a_d2)\n  for (int i = 0; i < N; ++i) {\n    a_d1[i] = 2*i;\n    a_d2[i] = 2*i + 1;\n  }\n\n#pragma omp target teams loop is_device_ptr(a_d1, a_d2) map(from: a_h[0:N])\n  for (int i = 0; i < N; ++i) {\n    a_h[i] = a_d1[i] + a_d2[i];\n  }\n  // Validate\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, a_h[i] != (4*i + 1));\n  }\n  omp_target_free(a_d1, omp_get_default_device());\n  omp_target_free(a_d2, omp_get_default_device());\n  free(a_h);\n  return errors;\n}\n\nint main(void) {\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testIsDevPtrBasic());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testIsDevPtrOn2DifferentTasks());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testIsDevPtrOn2DifferentPointers());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_get_max_teams.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 2210",
        "issue_id": 2,
        "original_code": "//--------------- test_target_get_max_teams.c --------------------------------//\n// OpenMP API Version 5.1 Nov 2020\n// Pg. 669, line 29\n// ***************************\n// ROUTINE: omp_get_max_teams\n// ***************************\n// This test uses the omp_get_max_teams routine on the host and device (if\n// available) to check what the max teams capacity is for host and the current\n// device. If the routine returns 0, the nteams-var ICV is 0, thus it is not\n// treated as an upper bound and the behavior of the program is implementation\n// defined. If the routine were to return a negative integer, the same behavior\n// applies. If the routine returns a positive integer, the value of the ICV is\n// treated as an upperbound. If the value is a number greater than the maximum\n// capacity that the implementation supports, then the test will pass if the\n// number of teams is less than that value, but the value itself has no\n// functional purpose. The ICV is initialized to 0 per device. Thus, if\n// omp_get_num_teams returns a positive number as expected, the test will pass\n// when the ICV value is 0 or less than 0. In the case where the OMP_NUM_TEAMS\n// environmental variable is set to a positive integer, or the omp_set_num_teams\n// routine is given a positive integer as an argument, the test will pass if and\n// only if the omp_get_num_teams routine returns an integer that is less than or\n// equal to the positive ICV value.\n//----------------------------------------------------------------------------//\n#include \"ompvv.h\"\n#include <omp.h>\n\nint test_get_max_teams(int offload) {\n  int errors = 0;\n  int max_teams;\n  int num_teams = 0; // a value that is not possible for omp_get_num_teams()\n\n  #pragma omp target map(tofrom: max_teams) if(offload)\n  {\n    max_teams = omp_get_max_teams();\n  }\n  #pragma omp target map(tofrom : num_teams) if(offload)\n  {\n    #pragma omp teams \n    {\n      if (omp_get_team_num() == 0)\n        num_teams = omp_get_num_teams();\n    }\n  }\n\n  OMPVV_ERROR_IF(\n      max_teams > 0 && num_teams > max_teams,\n      \"Number of teams reported exceeded max number of teams (max no. > 0)\");\n  OMPVV_TEST_AND_SET(errors, max_teams > 0 && num_teams > max_teams);\n\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET(errors, test_get_max_teams(0) != 0);\n  OMPVV_REPORT(errors);\n  OMPVV_TEST_OFFLOADING;\n  OMPVV_TEST_AND_SET(errors, test_get_max_teams(1) != 0);\n  OMPVV_REPORT(errors);\n  OMPVV_RETURN(errors);\n  return errors;\n}\n",
        "error_code": "//--------------- test_target_get_max_teams.c --------------------------------//\n// OpenMP API Version 5.1 Nov 2020\n// Pg. 669, line 29\n// ***************************\n// ROUTINE: omp_get_max_teams\n// ***************************\n// This test uses the omp_get_max_teams routine on the host and device (if\n// available) to check what the max teams capacity is for host and the current\n// device. If the routine returns 0, the nteams-var ICV is 0, thus it is not\n// treated as an upper bound and the behavior of the program is implementation\n// defined. If the routine were to return a negative integer, the same behavior\n// applies. If the routine returns a positive integer, the value of the ICV is\n// treated as an upperbound. If the value is a number greater than the maximum\n// capacity that the implementation supports, then the test will pass if the\n// number of teams is less than that value, but the value itself has no\n// functional purpose. The ICV is initialized to 0 per device. Thus, if\n// omp_get_num_teams returns a positive number as expected, the test will pass\n// when the ICV value is 0 or less than 0. In the case where the OMP_NUM_TEAMS\n// environmental variable is set to a positive integer, or the omp_set_num_teams\n// routine is given a positive integer as an argument, the test will pass if and\n// only if the omp_get_num_teams routine returns an integer that is less than or\n// equal to the positive ICV value.\n//----------------------------------------------------------------------------//\n#include \"ompvv.h\"\n#include <omp.h>\n\nint test_get_max_teams(int offload) {\n  int errors = 0;\n  int max_teams;\n  int num_teams = 0; // a value that is not possible for omp_get_num_teams()\n\n  #pragma omp target map(tofrom: max_teams) if(offload)\n  {\n    max_teams = omp_get_max_teams();\n  }\n  #pragma omp target map(tofrom : num_teams) if(offload)\n  {\n    #pragma omp teams \n    {\n      if (omp_get_team_num() == 0)\n        num_teams = omp_get_num_teams();\n    }\n  }\n\n  OMPVV_ERROR_IF(\n      max_teams > 0 && num_teams > max_teams,\n      \"Number of teams reported exceeded max number of teams (max no. > 0)\");\n  OMPVV_TEST_AND_SET(errors, max_teams > 0 && num_teams > max_teams);\n\n  return errors;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n}\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET(errors, test_get_max_teams(0) != 0);\n  OMPVV_REPORT(errors);\n  OMPVV_TEST_OFFLOADING;\n  OMPVV_TEST_AND_SET(errors, test_get_max_teams(1) != 0);\n  OMPVV_REPORT(errors);\n  OMPVV_RETURN(errors);\n  return errors;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_simd_nontemporal.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1169",
        "issue_id": 1,
        "original_code": "//===--- test_target_simd_nontemporal.c -----------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//  \n// This test checks for support of the nontemporal clause on a target simd construct. \n// The nontemporal clause indicates that accesses to the storage location of list items\n// have low temporal locality across the iterations in which those storage \n// locations are accessed. \n//  \n////===--------------------------------------------------------------------------------===/\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1028\n#define STRIDE_LEN 100\nint test_simd_nontemporal() {\n   int errors = 0;\n   int i;\n   int a[N], b[N], c[N];\n\n   for (i = 0; i < N; i++) {\n      a[i] = 10; \n      b[i] = i;\n      c[i] = 2 * i;\n   }   \n\n   #pragma omp target simd nontemporal (a, b, c)\n      for (i = 0; i < N; i += STRIDE_LEN) {\n         a[i] = b[i] * c[i];\n      }   \n\n   for (i = 0; i < N; i++) {\n      if (i % STRIDE_LEN == 0) { \n         OMPVV_TEST_AND_SET(errors, a[i] != (b[i] * c[i]));\n      } else { \n\t OMPVV_TEST_AND_SET(errors, a[i] != 10);\n      }\n   }   \n\n   return errors;\n}\n\nint main () {\n   int errors = 0;\n\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_simd_nontemporal())\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_simd_nontemporal.c -----------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//  \n// This test checks for support of the nontemporal clause on a target simd construct. \n// The nontemporal clause indicates that accesses to the storage location of list items\n// have low temporal locality across the iterations in which those storage \n// locations are accessed. \n//  \n////===--------------------------------------------------------------------------------===/\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1028\n#define STRIDE_LEN 100\nint test_simd_nontemporal() {\n   int errors = 0;\n   int i;\n   int a[N], b[N], c[N];\n\n   for (i = 0; i < N; i++) {\n      a[i] = 10; \n      b[i] = i;\n      c[i] = 2 * i;\n   }   \n\n   #pragma omp target simd nontemporal (a, b, c)\n      for (i = 0; i < N; i += STRIDE_LEN) {\n         a[i] = b[i] * c[i];\n      }   \n\n   for (i = 0; i < N; i++) {\n      if (i % STRIDE_LEN == 0) { \n         OMPVV_TEST_AND_SET(errors, a[i] != (b[i] * c[i]));\n      } else { \n\t OMPVV_TEST_AND_SET(errors, a[i] != 10);\n      }\n   }   \n\n   return errors;\n}\n\nint main () \n   int errors = 0;\n\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_simd_nontemporal())\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_omp_aligned_alloc_host.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp parallel\" with directive \"#pragma omp teams\" at position 1057",
        "issue_id": 0,
        "original_code": "//===------ test_omp_aligned_alloc_host.c ------------------------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// Tests the omp_aligned_alloc routine properly requests a memory allocation\n// aligned to the passed byte parameter. Starts by initializing some memory\n// in the omp_default_mem_space and then checks if this memory is aligned\n// and can be properly written to and read from. Checks on host.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_omp_aligned_alloc_on_host() {\n  int errors = 0;\n  int *x;\n\n  omp_memspace_handle_t  memspace = omp_default_mem_space;\n  omp_alloctrait_t       traits[1] = {{omp_atk_alignment, 64}};\n  omp_allocator_handle_t alloc = omp_init_allocator(memspace,1,traits);\n\n  x = (int *)omp_aligned_alloc(64, N*sizeof(int), alloc);\n    \n  OMPVV_TEST_AND_SET_VERBOSE(errors, ((intptr_t)(x))%64 != 0);\n\n  int values_did_not_match_expected_changes = 0;\n\n  #pragma omp parallel for simd simdlen(16) aligned(x: 64)\n  for (int i = 0; i < N; i++) {\n    x[i] = i;\n  }\n\n  #pragma omp parallel for simd simdlen(16) aligned(x: 64)\n  for (int i = 0; i < N; i++) {\n    if (x[i] != i) {\n      values_did_not_match_expected_changes = 1;\n    }\n  }\n\n\n  if (values_did_not_match_expected_changes) {\n    OMPVV_ERROR(\"Array values did not match the expected values\");\n    errors++;\n  }\n\n  omp_free(x, alloc);\n  omp_destroy_allocator(alloc);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_omp_aligned_alloc_on_host() != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n\n",
        "error_code": "//===------ test_omp_aligned_alloc_host.c ------------------------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// Tests the omp_aligned_alloc routine properly requests a memory allocation\n// aligned to the passed byte parameter. Starts by initializing some memory\n// in the omp_default_mem_space and then checks if this memory is aligned\n// and can be properly written to and read from. Checks on host.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_omp_aligned_alloc_on_host() {\n  int errors = 0;\n  int *x;\n\n  omp_memspace_handle_t  memspace = omp_default_mem_space;\n  omp_alloctrait_t       traits[1] = {{omp_atk_alignment, 64}};\n  omp_allocator_handle_t alloc = omp_init_allocator(memspace,1,traits);\n\n  x = (int *)omp_aligned_alloc(64, N*sizeof(int), alloc);\n    \n  OMPVV_TEST_AND_SET_VERBOSE(errors, ((intptr_t)(x))%64 != 0);\n\n  int values_did_not_match_expected_changes = 0;\n\n  #pragma omp teams for simd simdlen(16) aligned(x: 64)\n  for (int i = 0; i < N; i++) {\n    x[i] = i;\n  }\n\n  #pragma omp parallel for simd simdlen(16) aligned(x: 64)\n  for (int i = 0; i < N; i++) {\n    if (x[i] != i) {\n      values_did_not_match_expected_changes = 1;\n    }\n  }\n\n\n  if (values_did_not_match_expected_changes) {\n    OMPVV_ERROR(\"Array values did not match the expected values\");\n    errors++;\n  }\n\n  omp_free(x, alloc);\n  omp_destroy_allocator(alloc);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_omp_aligned_alloc_on_host() != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_defaultmap_present.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_defaultmap_present() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 2111",
        "issue_id": 4,
        "original_code": "//===--- test_target_defaultmap_present.c -----------------------------------===//\n//\n//  OpenMP API Version 5.1 Aug 2020\n//\n//  This test checks behavior of the defaultmap clause when the specified \n//  implicit-behavior is present. The variable-categories available for defaultmap\n//  are scalar, aggregate, and pointer. If implicit-behavior is present, each \n//  variable referenced in the construct in the category specified by \n//  variable-category is treated as if it had been listed in a map clause with the\n//  map-type of alloc and map-type-modifier of present.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint errors, i;\n\nint test_defaultmap_present() {\n   \n   struct test_struct {\n     int s; \n     int S[N]; \n   }; \n\n   int scalar_var; // scalar \n   int A[N]; // aggregate \n   struct test_struct new_struct; // aggregate\n   int *ptr; // scalar, pointer \n   errors = 0;\n\n   scalar_var = 1; \n   A[0] = 0; A[50] = 50;\n   new_struct.s = 10; new_struct.S[0] = 10; new_struct.S[1] = 10;\n   ptr = &A[0]; \n   ptr[50] = 50; ptr[51] = 51;\n   \n   #pragma omp target enter data map(to: scalar_var, A, new_struct, ptr)\n   \n   #pragma omp target map(tofrom: errors) defaultmap(present)\n   {     \n      if(scalar_var != 1){errors++;}\n      if(A[0] != 0){errors++;}\n      if(A[50] != 50 || A[51] != 51){errors++;}\n      if(new_struct.s != 10){errors++;}\n      if(new_struct.S[0] != 10 || new_struct.S[1] != 10){errors++;}\n      \n      scalar_var = 7; \n      A[0] = 70; A[50] = 150;\n      new_struct.s = 110; new_struct.S[0] = 110; new_struct.S[1] = 110;\n      ptr = &A[0]; \n      ptr[50] = 150; ptr[51] = 151;\n   }\n   \n   OMPVV_TEST_AND_SET(errors, scalar_var == 7);\n   OMPVV_TEST_AND_SET(errors, A[0] == 70 || A[50] == 150 || A[51] == 151);\n   OMPVV_TEST_AND_SET(errors, new_struct.s == 110 || new_struct.S[0] == 110 || new_struct.S[1] == 110);\n\n   #pragma omp target exit data map(delete: scalar_var, A, new_struct, ptr)\n      \n   return errors;\n}\n\nint main() {\n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_defaultmap_present() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}           \n",
        "error_code": "//===--- test_target_defaultmap_present.c -----------------------------------===//\n//\n//  OpenMP API Version 5.1 Aug 2020\n//\n//  This test checks behavior of the defaultmap clause when the specified \n//  implicit-behavior is present. The variable-categories available for defaultmap\n//  are scalar, aggregate, and pointer. If implicit-behavior is present, each \n//  variable referenced in the construct in the category specified by \n//  variable-category is treated as if it had been listed in a map clause with the\n//  map-type of alloc and map-type-modifier of present.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint errors, i;\n\nint test_defaultmap_present() {\n   \n   struct test_struct {\n     int s; \n     int S[N]; \n   }; \n\n   int scalar_var; // scalar \n   int A[N]; // aggregate \n   struct test_struct new_struct; // aggregate\n   int *ptr; // scalar, pointer \n   errors = 0;\n\n   scalar_var = 1; \n   A[0] = 0; A[50] = 50;\n   new_struct.s = 10; new_struct.S[0] = 10; new_struct.S[1] = 10;\n   ptr = &A[0]; \n   ptr[50] = 50; ptr[51] = 51;\n   \n   #pragma omp target enter data map(to: scalar_var, A, new_struct, ptr)\n   \n   #pragma omp target map(tofrom: errors) defaultmap(present)\n   {     \n      if(scalar_var != 1){errors++;}\n      if(A[0] != 0){errors++;}\n      if(A[50] != 50 || A[51] != 51){errors++;}\n      if(new_struct.s != 10){errors++;}\n      if(new_struct.S[0] != 10 || new_struct.S[1] != 10){errors++;}\n      \n      scalar_var = 7; \n      A[0] = 70; A[50] = 150;\n      new_struct.s = 110; new_struct.S[0] = 110; new_struct.S[1] = 110;\n      ptr = &A[0]; \n      ptr[50] = 150; ptr[51] = 151;\n   }\n   \n   OMPVV_TEST_AND_SET(errors, scalar_var == 7);\n   OMPVV_TEST_AND_SET(errors, A[0] == 70 || A[50] == 150 || A[51] == 151);\n   OMPVV_TEST_AND_SET(errors, new_struct.s == 110 || new_struct.S[0] == 110 || new_struct.S[1] == 110);\n\n   #pragma omp target exit data map(delete: scalar_var, A, new_struct, ptr)\n      \n   return errors;\n}\n\nint main()            \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_begin_end_assumes_contains.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_begin_end_assumes() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 1262",
        "issue_id": 4,
        "original_code": "//===--- test_begin_end_assumes.c -------------------------------------------===//\n//\n//  OpenMP API Version 5.1 Aug 2021\n//\n//  Test for the \"begin_end\" version of assumes. Spec states that\n//  \"declaration-definition-seq\" goes between the begin & end assumes directives.\n//  In this test, the function declaration is listed between these w/ the \n//  contain(target parallel for) clause, telling the compiler that this \n//  directive will be used in this function.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\n#pragma omp begin assumes contains(target, parallel, for)\nint test_begin_end_assumes();\n#pragma omp end assumes\n\nint errors, i;\n\nint test_begin_end_assumes() {\n    int arr[N];\n    for(i = 0; i < N; i++){\n        arr[i] = i;\n    }\n\n    #pragma omp target map(tofrom: arr)\n    #pragma omp parallel num_threads(OMPVV_NUM_THREADS_DEVICE)\n    #pragma omp for\n    for(i = 0; i < N; i++){\n        arr[i] = arr[i]*2;\n    }\n    // Test that no issues were caused from using assumes directive\n    for(i = 0; i < N; i++){\n        OMPVV_TEST_AND_SET(errors, arr[i] != i*2);\n    }\n   return errors;\n}\nint main() {\n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_begin_end_assumes() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_begin_end_assumes.c -------------------------------------------===//\n//\n//  OpenMP API Version 5.1 Aug 2021\n//\n//  Test for the \"begin_end\" version of assumes. Spec states that\n//  \"declaration-definition-seq\" goes between the begin & end assumes directives.\n//  In this test, the function declaration is listed between these w/ the \n//  contain(target parallel for) clause, telling the compiler that this \n//  directive will be used in this function.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\n#pragma omp begin assumes contains(target, parallel, for)\nint test_begin_end_assumes();\n#pragma omp end assumes\n\nint errors, i;\n\nint test_begin_end_assumes() {\n    int arr[N];\n    for(i = 0; i < N; i++){\n        arr[i] = i;\n    }\n\n    #pragma omp target map(tofrom: arr)\n    #pragma omp parallel num_threads(OMPVV_NUM_THREADS_DEVICE)\n    #pragma omp for\n    for(i = 0; i < N; i++){\n        arr[i] = arr[i]*2;\n    }\n    // Test that no issues were caused from using assumes directive\n    for(i = 0; i < N; i++){\n        OMPVV_TEST_AND_SET(errors, arr[i] != i*2);\n    }\n   return errors;\n}\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/gemv_target.cpp",
        "correct": "n",
        "issue": "Removed opening bracket at position 1632",
        "issue_id": 1,
        "original_code": "//===-- gemv_target.cpp - General Matrix Vector Multiplication target -------===!\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// Taken from the suggestions of the QMCPack team. This test has a simple\n// target region that performs a GEMV\n//!===----------------------------------------------------------------------===!\n#include <chrono>\n#include <string>\n#include <cmath>\n#include \"ompvv.h\"\n#include \"omp.h\"\n\n#define N 8192\n\nclass Timer\n{\n  const std::chrono::time_point<std::chrono::system_clock> start;\n  const std::string name;\n\npublic:\n  Timer(const std::string& name_in): start(std::chrono::system_clock::now()), name(name_in) {};\n  ~Timer()\n  {\n    auto end = std::chrono::system_clock::now();\n    OMPVV_INFOMSG(\"Function %s takes %lf us \",name.c_str(), std::chrono::duration_cast<std::chrono::duration<double, std::micro>>(end - start).count());\n  }\n};\n\ntemplate <typename T>\nvoid gemv(int n, T alpha, const T*  A, const T*  V, T*  Vout)\n{\n  #pragma omp target map(to:A[:n*n], V[:n]) map(from:Vout[:n])\n  for(int row=0; row<n; row++)\n  {\n    T sum = T(0);\n    const T * A_row = A+row*n;\n    for(int col=0; col<n; col++) {\n      sum += A_row[col]*V[col];\n    }\n    Vout[row] = sum*alpha;\n  }\n}\n\ntemplate <class T>\nT* allocate(size_t n)\n{\n  T* ptr = new T[n];\n  std::fill_n(ptr, n, T(1));\n  return ptr;\n}\n\ntemplate <class T>\nvoid deallocate(T* ptr, size_t n)\n{\n  delete[] ptr;\n}\n\nint main()\n{\n  OMPVV_TEST_OFFLOADING;\n  auto* A = allocate<float>(N*N);\n  auto* V = allocate<float>(N);\n  auto* Vout = allocate<float>(N);\n  int errors = 0;\n\n  {\n    Timer local(\"GEMV\");\n    gemv(N, 1.0f, A, V, Vout);\n  }\n\n  for(int i=0; i<N; i++)\n  {\n    OMPVV_TEST_AND_SET(errors, std::abs(Vout[i]-N) > 0.0001);\n    OMPVV_ERROR_IF(std::abs(Vout[i]-N) > 0.0001, \"Error for Vout[%d] = %f, Should be %d\", i, Vout[i], N);\n  }\n\n  deallocate(A, N*N);\n  deallocate(V, N);\n  deallocate(Vout, N);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===-- gemv_target.cpp - General Matrix Vector Multiplication target -------===!\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// Taken from the suggestions of the QMCPack team. This test has a simple\n// target region that performs a GEMV\n//!===----------------------------------------------------------------------===!\n#include <chrono>\n#include <string>\n#include <cmath>\n#include \"ompvv.h\"\n#include \"omp.h\"\n\n#define N 8192\n\nclass Timer\n{\n  const std::chrono::time_point<std::chrono::system_clock> start;\n  const std::string name;\n\npublic:\n  Timer(const std::string& name_in): start(std::chrono::system_clock::now()), name(name_in) {};\n  ~Timer()\n  {\n    auto end = std::chrono::system_clock::now();\n    OMPVV_INFOMSG(\"Function %s takes %lf us \",name.c_str(), std::chrono::duration_cast<std::chrono::duration<double, std::micro>>(end - start).count());\n  }\n};\n\ntemplate <typename T>\nvoid gemv(int n, T alpha, const T*  A, const T*  V, T*  Vout)\n{\n  #pragma omp target map(to:A[:n*n], V[:n]) map(from:Vout[:n])\n  for(int row=0; row<n; row++)\n  {\n    T sum = T(0);\n    const T * A_row = A+row*n;\n    for(int col=0; col<n; col++) {\n      sum += A_row[col]*V[col];\n    }\n    Vout[row] = sum*alpha;\n  }\n}\n\ntemplate <class T>\nT* allocate(size_t n)\n{\n  T* ptr = new T[n];\n  std::fill_n(ptr, n, T(1));\n  return ptr;\n}\n\ntemplate <class T>\nvoid deallocate(T* ptr, size_t n)\n{\n  delete[] ptr;\n}\n\nint main()\n{\n  OMPVV_TEST_OFFLOADING;\n  auto* A = allocate<float>(N*N);\n  auto* V = allocate<float>(N);\n  auto* Vout = allocate<float>(N);\n  int errors = 0;\n\n  {\n    Timer local(\"GEMV\");\n    gemv(N, 1.0f, A, V, Vout);\n  }\n\n  for(int i=0; i<N; i++)\n  \n    OMPVV_TEST_AND_SET(errors, std::abs(Vout[i]-N) > 0.0001);\n    OMPVV_ERROR_IF(std::abs(Vout[i]-N) > 0.0001, \"Error for Vout[%d] = %f, Should be %d\", i, Vout[i], N);\n  }\n\n  deallocate(A, N*N);\n  deallocate(V, N);\n  deallocate(Vout, N);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_thread_limit.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1099",
        "issue_id": 1,
        "original_code": "//===--- test_target_teams_distribute_thread_limit.c--------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the thread_limit clause on a target teams distribute directive to\n// indicate a requested number of threads to execute the teams distribute region.\n// The specifications indicate that the number of threads that are given can be any\n// number that is equal to or less than the indicated value. \n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_target_teams_distribute_thread_limit(){\n  int num_threads = -9;\n  int errors = 0;\n  \n  \n  #pragma omp target teams distribute thread_limit(4) map(from: num_threads)\n    for (int x = 0; x < N; ++x) {\n      if (omp_get_team_num() == 0) {\n        #pragma omp parallel\n        {\n        if (omp_get_thread_num() == 0)\n          num_threads = omp_get_num_threads();\n        }\n      }\n    }\n    OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads > 4);\n\n  return errors;\n\n}\n\nint main(){\n  int errors = 0;\n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_thread_limit() != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n",
        "error_code": "//===--- test_target_teams_distribute_thread_limit.c--------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the thread_limit clause on a target teams distribute directive to\n// indicate a requested number of threads to execute the teams distribute region.\n// The specifications indicate that the number of threads that are given can be any\n// number that is equal to or less than the indicated value. \n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_target_teams_distribute_thread_limit(){\n  int num_threads = -9;\n  int errors = 0;\n  \n  \n  #pragma omp target teams distribute thread_limit(4) map(from: num_threads)\n    for (int x = 0; x < N; ++x) {\n      if (omp_get_team_num() == 0) {\n        #pragma omp parallel\n        {\n        if (omp_get_thread_num() == 0)\n          num_threads = omp_get_num_threads();\n        }\n      }\n    }\n    OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads > 4);\n\n  return errors;\n\n}\n\nint main()\n  int errors = 0;\n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_thread_limit() != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_allocate_allocator.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp allocate(x,y)\" with directive \"#pragma omp cancel\" at position 1457",
        "issue_id": 0,
        "original_code": "//===------ test_allocate_allocators.c ------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Tests the allocate directive with allocator clause, based on the OpenMP\n// 5.0 example for allocators. The allocator testing first creates\n// an allocator, with 64-byte alignment and the default memory space,\n// then checks that 64-byte alignment is correct and that the memory can\n// be written to in the parallel region. The tests checks that the values\n// were written correctly, and then frees the memory and deletes the\n// allocator.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_allocate_allocator() {\n  int errors = 0;\n\n  int n = N;\n  omp_memspace_handle_t x_memspace = omp_default_mem_space;\n  omp_alloctrait_t x_traits[1] = {{omp_atk_alignment, 64}};\n  omp_allocator_handle_t x_alloc = omp_init_allocator(x_memspace, 1, x_traits);\n  {\n    // x and y must be in an inner scope as their lifetime must not exceed the\n    // lifetime of the allocator associated with x_alloc; i.e. their lifetime\n    // must have ended before omp_destroy_allocator is called.\n    //\n    // The following two lines allocate the pointer 'x' itself\n    // (i.e. sizeof(void*) bytes) and 'y'. The omp_alloc allocates then\n    // space for the actual data stored in 'x'.\n    int* x, y[n];\n#pragma omp allocate(x,y) allocator(x_alloc)\n\n    x = (int *)omp_alloc(N * sizeof(int), x_alloc);\n\n    // OMPVV_TEST_AND_SET_VERBOSE diagnostic uses printf, which\n    // causes compiler warnigns for '% '. Hence:\n    OMPVV_TEST_AND_SET(errors, ((intptr_t) &x) % 64 != 0);\n    OMPVV_TEST_AND_SET(errors, ((intptr_t) &y) % 64 != 0);\n    OMPVV_TEST_AND_SET(errors, ((intptr_t) x) % 64 != 0);\n    OMPVV_ERROR_IF(((intptr_t) &x) % 64 != 0,\n                   \"Condition (intptr_t) &x) %% 64 != 0 failed\")\n    OMPVV_ERROR_IF(((intptr_t) &y) % 64 != 0,\n                   \"Condition (intptr_t) &y) %% 64 != 0 failed\")\n    OMPVV_ERROR_IF(((intptr_t) x) % 64 != 0,\n                   \"Condition (intptr_t) x) %% 64 != 0 failed\")\n\n#pragma omp parallel for simd simdlen(16) aligned(x, y: 64)\n    for (int i = 0; i < N; i++) {\n      x[i] = i;\n      y[i] = 3*i;\n    }\n\n    for (int i = 0; i < N; i++) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != i);\n      OMPVV_TEST_AND_SET_VERBOSE(errors, y[i] != 3*i);\n    }\n\n    omp_free(x, x_alloc);\n  }\n  omp_destroy_allocator(x_alloc);\n\n  return errors;\n}\n\nint main() {\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_allocate_allocator() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===------ test_allocate_allocators.c ------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Tests the allocate directive with allocator clause, based on the OpenMP\n// 5.0 example for allocators. The allocator testing first creates\n// an allocator, with 64-byte alignment and the default memory space,\n// then checks that 64-byte alignment is correct and that the memory can\n// be written to in the parallel region. The tests checks that the values\n// were written correctly, and then frees the memory and deletes the\n// allocator.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_allocate_allocator() {\n  int errors = 0;\n\n  int n = N;\n  omp_memspace_handle_t x_memspace = omp_default_mem_space;\n  omp_alloctrait_t x_traits[1] = {{omp_atk_alignment, 64}};\n  omp_allocator_handle_t x_alloc = omp_init_allocator(x_memspace, 1, x_traits);\n  {\n    // x and y must be in an inner scope as their lifetime must not exceed the\n    // lifetime of the allocator associated with x_alloc; i.e. their lifetime\n    // must have ended before omp_destroy_allocator is called.\n    //\n    // The following two lines allocate the pointer 'x' itself\n    // (i.e. sizeof(void*) bytes) and 'y'. The omp_alloc allocates then\n    // space for the actual data stored in 'x'.\n    int* x, y[n];\n#pragma omp cancel allocator(x_alloc)\n\n    x = (int *)omp_alloc(N * sizeof(int), x_alloc);\n\n    // OMPVV_TEST_AND_SET_VERBOSE diagnostic uses printf, which\n    // causes compiler warnigns for '% '. Hence:\n    OMPVV_TEST_AND_SET(errors, ((intptr_t) &x) % 64 != 0);\n    OMPVV_TEST_AND_SET(errors, ((intptr_t) &y) % 64 != 0);\n    OMPVV_TEST_AND_SET(errors, ((intptr_t) x) % 64 != 0);\n    OMPVV_ERROR_IF(((intptr_t) &x) % 64 != 0,\n                   \"Condition (intptr_t) &x) %% 64 != 0 failed\")\n    OMPVV_ERROR_IF(((intptr_t) &y) % 64 != 0,\n                   \"Condition (intptr_t) &y) %% 64 != 0 failed\")\n    OMPVV_ERROR_IF(((intptr_t) x) % 64 != 0,\n                   \"Condition (intptr_t) x) %% 64 != 0 failed\")\n\n#pragma omp parallel for simd simdlen(16) aligned(x, y: 64)\n    for (int i = 0; i < N; i++) {\n      x[i] = i;\n      y[i] = 3*i;\n    }\n\n    for (int i = 0; i < N; i++) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != i);\n      OMPVV_TEST_AND_SET_VERBOSE(errors, y[i] != 3*i);\n    }\n\n    omp_free(x, x_alloc);\n  }\n  omp_destroy_allocator(x_alloc);\n\n  return errors;\n}\n\nint main() {\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_allocate_allocator() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_requires_unified_shared_memory_stack_map.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 1557",
        "issue_id": 2,
        "original_code": "//===---test_requires_unified_shared_memory_stack_map.c ---------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Testing memory access from host and device to a variable allocated in the stack\n// The variable is accessed through a pointer to guarantee that there is no default\n// mapping tofrom: of the stack array\n//\n// Using the map of a pointer to test the mapping of the pointer from the host to \n// the device.\n//\n////===----------------------------------------------------------------------===//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp requires unified_shared_memory\n\nint unified_shared_memory_stack_map() {\n  OMPVV_INFOMSG(\"Unified shared memory testing - Array on stack\");\n  int errors = 0;\n  \n  int anArray[N];\n  int anArrayCopy[N];\n  int * aPtr = anArray;\n\n  for (int i = 0; i < N; i++) {\n    anArray[i] = i;\n    anArrayCopy[i] = 0;\n  }\n\n  // Test for writes to this variable from device\n#pragma omp target map(aPtr)\n  {\n    for (int i = 0; i < N; i++) {\n      aPtr[i] += 10;\n    }\n  }\n  // Modify again on the host\n  for (int i = 0; i < N; i++) {\n    aPtr[i] += 10;\n  }\n\n  // Test for reads to this variable from device\n#pragma omp target map(aPtr)\n  {\n    for (int i = 0; i < N; i++) {\n      anArrayCopy[i] = aPtr[i];\n    }\n  }\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArray[i] != i + 20);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArrayCopy[i] != i + 20);\n    if (errors) break;\n  }\n  return errors;\n}\n\nint main() {\n  int isOffloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"With no offloading, unified shared memory is guaranteed due to host execution\");\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, unified_shared_memory_stack_map());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---test_requires_unified_shared_memory_stack_map.c ---------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Testing memory access from host and device to a variable allocated in the stack\n// The variable is accessed through a pointer to guarantee that there is no default\n// mapping tofrom: of the stack array\n//\n// Using the map of a pointer to test the mapping of the pointer from the host to \n// the device.\n//\n////===----------------------------------------------------------------------===//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp requires unified_shared_memory\n\nint unified_shared_memory_stack_map() {\n  OMPVV_INFOMSG(\"Unified shared memory testing - Array on stack\");\n  int errors = 0;\n  \n  int anArray[N];\n  int anArrayCopy[N];\n  int * aPtr = anArray;\n\n  for (int i = 0; i < N; i++) {\n    anArray[i] = i;\n    anArrayCopy[i] = 0;\n  }\n\n  // Test for writes to this variable from device\n#pragma omp target map(aPtr)\n  {\n    for (int i = 0; i < N; i++) {\n      aPtr[i] += 10;\n    }\n  }\n  // Modify again on the host\n  for (int i = 0; i < N; i++) {\n    aPtr[i] += 10;\n  }\n\n  // Test for reads to this variable from device\n#pragma omp target map(aPtr)\n  {\n    for (int i = 0; i < N; i++) {\n      anArrayCopy[i] = aPtr[i];\n    }\n  }\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArray[i] != i + 20);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArrayCopy[i] != i + 20);\n    if (errors) break;\n  }\n  return errors;\n}\n\nint main() {\n  int isOffloading;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"With no offloading, unified shared memory is guaranteed due to host execution\");\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, unified_shared_memory_stack_map());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_firstprivate_device.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===------ test_target_firstprivate.c --------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Tests the target directive with parallel for + firstprivate clauses\n//\n//===------------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include \"omp.h\"\n#include \"ompvv.h\"\n\n#define ELMTS 1024*1024\n#define INIT_VAL 9999\n\n\nint Runtst(int gpu) {\n  int *A = (int*) malloc(sizeof(int) * ELMTS), errors = 0;\n  if (A == NULL) {\n    OMPVV_ERROR(\"Memory allocation failed\");\n    return 1;\n  }\n  for (int i = 0; i < ELMTS; ++i) {\n    A[i] = i;\n  }\n  int HostVar = INIT_VAL;\n#pragma omp target data map(tofrom: A[0:ELMTS], HostVar, errors) device(gpu)\n  {\n#pragma omp target parallel for firstprivate(HostVar) device(gpu)\n    for (int i = 0; i < ELMTS; ++i) {\n      if (HostVar == INIT_VAL) {\n        A[i] = A[i] + A[i];\n      } else {\n        A[i] = 0;\n      }\n      if (i == (ELMTS - 1)) {\n        HostVar++;\n      }\n    }\n    // The following check ensures that the HostVar is private\n    if (HostVar != INIT_VAL) {\n      errors++;\n    }\n  }\n\n  // Verification\n  // Also validate for gpu ordinal \n  for (int i = 0; i < ELMTS; ++i) {\n    if (A[i] != i+i) {\n      errors++;\n    }\n  }\n\n  free(A);\n  return errors;\n}\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int TotGpus = omp_get_num_devices();\n  int errors = 0;\n  for (int gpu = 0; gpu < TotGpus; ++gpu) {\n   OMPVV_TEST_AND_SET_VERBOSE(errors, (Runtst(gpu) != 0));\n  }\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\ndouble tvtzhkkrrc = 241;\nbyte uevdpnrwwv = 125;\nint ufxditjnuf = 183;\nfloat cajpvpjnty = 8;\nshort knfgsjrnpg = 200;\nlong vjqistuhqp = 106;\nfloat lapqufvauq = 34;\nint faaysuhtwo = 204;\nbyte fyytmzuyqy = 43;\nshort rnyutrbyyk = 190;\ndouble oczuemccin = 208;\nfloat ryqzcprbnm = 79;\nbyte uumdsagrql = 52;\nint zootxghtmu = 22;\nfloat xqycdrncex = 242;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_map_scalar_no_map_type_modifier.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp atomic\" at position 863",
        "issue_id": 0,
        "original_code": "//===--- test_target_map_scalar_no_map_type_modifier.c ----------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// When map-type-modifier (e.g. to, from and tofrom) is not specified, the \n// default behavior should be tofrom. This test checks if this is satisfied with\n// a simple integer value. An array is created an initialized to zero in the host\n// then changed in the device with a scalar value. An additional simple test \n// function also checks from behavior by changing scalar value on device.\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\" \n\n#define N 1000\n\nint test_scalar_to() {\n\n  int compute_array[N];\n  int asclr = 12, sum = 0, result = 0, errors = 0;\n  int i;\n\n  // Array initialization\n  for (i = 0; i < N; i++) \n    compute_array[i] = 0;\n\n#pragma omp target map(from: compute_array) map(asclr)\n  {\n  for (i = 0; i < N; i++)\n    compute_array[i] = i + asclr;\n \n  } // end target\n\n  for (i = 0; i < N; i++)\n    sum = sum + compute_array[i];    \n  \n  for (i = 0; i < N; i++)\n    result += i + asclr;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result!= sum);  \n\n  return errors;\n}\n\nint test_scalar_from() {\n\n  int new_scalar = 25;\n  int errors = 0;\n\n#pragma omp target map(new_scalar)\n  {\n  //Change scalar value on device\n  new_scalar = 27;\n\n  }\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, new_scalar!=27);\n  \n  return errors;\t\n}\n\nint main() {\n  \n  int errors = 0;\n\n  //Test Offloading\n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n  OMPVV_WARNING_IF(!is_offloading, \"This test in running on host, asclr is not copied over to the device\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_scalar_to());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_scalar_from());  \n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_map_scalar_no_map_type_modifier.c ----------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// When map-type-modifier (e.g. to, from and tofrom) is not specified, the \n// default behavior should be tofrom. This test checks if this is satisfied with\n// a simple integer value. An array is created an initialized to zero in the host\n// then changed in the device with a scalar value. An additional simple test \n// function also checks from behavior by changing scalar value on device.\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\" \n\n#define N 1000\n\nint test_scalar_to() {\n\n  int compute_array[N];\n  int asclr = 12, sum = 0, result = 0, errors = 0;\n  int i;\n\n  // Array initialization\n  for (i = 0; i < N; i++) \n    compute_array[i] = 0;\n\n#pragma omp atomic map(from: compute_array) map(asclr)\n  {\n  for (i = 0; i < N; i++)\n    compute_array[i] = i + asclr;\n \n  } // end target\n\n  for (i = 0; i < N; i++)\n    sum = sum + compute_array[i];    \n  \n  for (i = 0; i < N; i++)\n    result += i + asclr;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result!= sum);  \n\n  return errors;\n}\n\nint test_scalar_from() {\n\n  int new_scalar = 25;\n  int errors = 0;\n\n#pragma omp target map(new_scalar)\n  {\n  //Change scalar value on device\n  new_scalar = 27;\n\n  }\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, new_scalar!=27);\n  \n  return errors;\t\n}\n\nint main() {\n  \n  int errors = 0;\n\n  //Test Offloading\n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n  OMPVV_WARNING_IF(!is_offloading, \"This test in running on host, asclr is not copied over to the device\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_scalar_to());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_scalar_from());  \n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_requires_atomic_default_mem_order_acq_rel.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===---test_target_requires_atomic_default_mem_order_acq_rel.c--------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n// \n// This test checks for support of the atomic_default_mem_order clause on the \n// requires directive. This clause determines the default memory behavior for\n// atomic constructs. These behaviors are seq_cst, acq_rel, and relaxed.\n// This test checks the for acq_rel as the memory-order-clause.\n//\n////===----------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp requires atomic_default_mem_order(acq_rel)\n\nint test_target_requires_atomic_acq_rel() {\n  OMPVV_INFOMSG(\"test_target_requires_atomic_acq_rel\");\n\n  int x = 0, y = 0;\n  int errors = 0;\n      \n#pragma omp target parallel num_threads(2) map(tofrom: x, y, errors)\n   {\n       int thrd = omp_get_thread_num();\n       if (thrd == 0) {\n          x = 10;\n          #pragma omp atomic write \n          y = 1;\n       } else {\n          int tmp = 0;\n          while (tmp == 0) {\n            #pragma omp atomic read \n            tmp = y;\n          }\n          OMPVV_TEST_AND_SET(errors, x != 10);\n       }\n   }\n   OMPVV_ERROR_IF(errors > 0, \"Requires atomic_default_mem_order(acq_rel) test failed\");\n   return errors;\n}\n\nint main() {\n\n  int errors = 0;\n\n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_requires_atomic_acq_rel());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nshort uyrxycezts = 83;\ndouble kfpqjkkwzf = 151;\nint difwmaiwzg = 119;\nshort uyjocqmbdx = 18;\nbyte tyspbkhvhz = 131;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_parallel_master_device.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1465",
        "issue_id": 1,
        "original_code": "//===--- test_parallel_master_device.c --------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the parallel master directive in a target context. The\n// test performs simple operations on an int array which are then checked for\n// correctness.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_parallel_master_device() {\n  OMPVV_INFOMSG(\"test_parallel_master_device\");\n  int errors = 0;\n  int num_threads = -1;\n  int x[N];\n  int y[N];\n  int z[N];\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 1;\n    y[i] = i + 1;\n    z[i] = 2*(i + 1);\n  }\n\n#pragma omp target map(tofrom: x, num_threads) map(to: y, z)\n  {\n#pragma omp parallel master num_threads(OMPVV_NUM_THREADS_DEVICE) shared(x, y, z, num_threads)\n    {\n#pragma omp taskloop\n      for (int i = 0; i < N; i++) {\n        x[i] += y[i]*z[i];\n      }\n      num_threads = omp_get_num_threads();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != 1 + (y[i]*z[i]));\n  }\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of parallel master with taskloop can't be guaranteed.\");\n  OMPVV_ERROR_IF(num_threads < 1, \"Test returned an invalid number of threads.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n\n  return errors;\n}\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_parallel_master_device());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_parallel_master_device.c --------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the parallel master directive in a target context. The\n// test performs simple operations on an int array which are then checked for\n// correctness.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_parallel_master_device() {\n  OMPVV_INFOMSG(\"test_parallel_master_device\");\n  int errors = 0;\n  int num_threads = -1;\n  int x[N];\n  int y[N];\n  int z[N];\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 1;\n    y[i] = i + 1;\n    z[i] = 2*(i + 1);\n  }\n\n#pragma omp target map(tofrom: x, num_threads) map(to: y, z)\n  {\n#pragma omp parallel master num_threads(OMPVV_NUM_THREADS_DEVICE) shared(x, y, z, num_threads)\n    {\n#pragma omp taskloop\n      for (int i = 0; i < N; i++) {\n        x[i] += y[i]*z[i];\n      }\n      num_threads = omp_get_num_threads();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != 1 + (y[i]*z[i]));\n  }\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of parallel master with taskloop can't be guaranteed.\");\n  OMPVV_ERROR_IF(num_threads < 1, \"Test returned an invalid number of threads.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n\n  return errors;\n}\n\n\nint main() \n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_parallel_master_device());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_metadirective_nothing.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 858",
        "issue_id": 2,
        "original_code": "//===--------------------- test_metadirective_nothing.c ---------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n// \n// Test for nothing directive within metadirectives. Runs a variety of\n// metadirectives that check if the nothing directive is properly rendered.\n// Primarily tests based on the fact that no matter what 'when' clause is \n// rendered it should result in nothing, and thus no additional pragma should\n// be created. Thus, the threads should remain unchanged through this process\n// and the compiler should handle it properly. Handles both device and host\n// based tests.\n//\n////===---------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n#define THREAD_LIMIT 32\n\nint metadirectiveOnDevice() {\n   int errors = 0;\n   int A[N];\n   int thread_limit_target = THREAD_LIMIT;\n   int thread_limit_teams = 0;\n\n   for (int i = 0; i < N; i++) {\n      A[i] = 0;\n   }\n   #pragma omp target map(from: thread_limit_target) thread_limit(thread_limit_target)\n   {\n      thread_limit_target = omp_get_thread_limit();\n   }\n\n   #pragma omp target map(tofrom: A, thread_limit_teams) thread_limit(thread_limit_target)\n   {\n      // We expect at least one of these when conditons to eval to true, thus having the nothing directive utilized\n      #pragma omp metadirective \\\n         when( device={kind(nohost)}: nothing ) \\\n         when( device={arch(\"nvptx\")}: nothing) \\\n         when( implementation={vendor(amd)}: nothing ) \\\n         default( teams distribute parallel for thread_limit(thread_limit_target+1) )\n            for (int i = 0; i < N; i++) {\n               A[i] += omp_in_parallel();\n               if( i == 0 ) {\n                 thread_limit_teams = omp_get_thread_limit();\n               }\n            }\n   }\n\n   for (int i = 0; i < N; i++) {\n      OMPVV_TEST_AND_SET(errors, A[i] != 0);\n   }\n   OMPVV_TEST_AND_SET(errors, thread_limit_target != thread_limit_teams);\n\n   OMPVV_INFOMSG(\"Test ran with a number of available devices greater than 0\");\n   OMPVV_INFOMSG_IF(thread_limit_target == thread_limit_teams, \"Test recognized device was of arch/vendor/kind nvidia, amd, or nohost\");\n   OMPVV_WARNING_IF(A[0] == 1, \"Test could not recognize if device was of arch/vendor/kind nvidia, amd or, nohost, even though there are devices available.\");\n\n   return errors;\n}\n\nint metadirectiveOnHost() {\n  int errors = 0;\n  int A[N];\n  int thread_limit_initial = THREAD_LIMIT;\n  int thread_limit_teams = 0;\n\n  for (int i = 0; i < N; i++) {\n     A[i] = 0;\n  }\n\n  thread_limit_initial = omp_get_thread_limit();\n  // We expect all of these when statements to eval to false, causing body of code to run using 'nothing' as the default pragma\n  #pragma omp metadirective \\\n     when( device={kind(nohost)}: teams distribute parallel for thread_limit(thread_limit_initial+1) ) \\\n     when( device={arch(\"nvptx\")}: teams distribute parallel for thread_limit(thread_limit_initial+1) ) \\\n     when( implementation={vendor(amd)}: teams distribute parallel for thread_limit(thread_limit_initial+1) ) \\\n     default( nothing )\n        for (int i = 0; i < N; i++) {\n           A[i] += omp_in_parallel();\n           if( i == 0 ) {\n              thread_limit_teams = omp_get_thread_limit();\n           }\n        }\n\n  OMPVV_WARNING_IF(A[0] == 1, \"Even though no devices were available the test recognized kind/arch equal to nohost or nvptx or amd\");\n  \n  for (int i = 0; i < N; i++) {\n     OMPVV_TEST_AND_SET(errors, A[i] != 0);\n  }\n  OMPVV_TEST_AND_SET(errors, thread_limit_initial != thread_limit_teams);\n\n  return errors;\n} \n\nint main () {\n  int errors = 0;\n  OMPVV_TEST_OFFLOADING;\n\n  if (omp_get_num_devices() > 0) {\n    errors = metadirectiveOnDevice();\n  } else {\n    errors = metadirectiveOnHost();\n  }\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n  return 0;\n}\n",
        "error_code": "//===--------------------- test_metadirective_nothing.c ---------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n// \n// Test for nothing directive within metadirectives. Runs a variety of\n// metadirectives that check if the nothing directive is properly rendered.\n// Primarily tests based on the fact that no matter what 'when' clause is \n// rendered it should result in nothing, and thus no additional pragma should\n// be created. Thus, the threads should remain unchanged through this process\n// and the compiler should handle it properly. Handles both device and host\n// based tests.\n//\n////===---------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n#define THREAD_LIMIT 32\n\nint metadirectiveOnDevice() {\n   int errors = 0;\n   int A[N];yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n   int thread_limit_target = THREAD_LIMIT;\n   int thread_limit_teams = 0;\n\n   for (int i = 0; i < N; i++) {\n      A[i] = 0;\n   }\n   #pragma omp target map(from: thread_limit_target) thread_limit(thread_limit_target)\n   {\n      thread_limit_target = omp_get_thread_limit();\n   }\n\n   #pragma omp target map(tofrom: A, thread_limit_teams) thread_limit(thread_limit_target)\n   {\n      // We expect at least one of these when conditons to eval to true, thus having the nothing directive utilized\n      #pragma omp metadirective \\\n         when( device={kind(nohost)}: nothing ) \\\n         when( device={arch(\"nvptx\")}: nothing) \\\n         when( implementation={vendor(amd)}: nothing ) \\\n         default( teams distribute parallel for thread_limit(thread_limit_target+1) )\n            for (int i = 0; i < N; i++) {\n               A[i] += omp_in_parallel();\n               if( i == 0 ) {\n                 thread_limit_teams = omp_get_thread_limit();\n               }\n            }\n   }\n\n   for (int i = 0; i < N; i++) {\n      OMPVV_TEST_AND_SET(errors, A[i] != 0);\n   }\n   OMPVV_TEST_AND_SET(errors, thread_limit_target != thread_limit_teams);\n\n   OMPVV_INFOMSG(\"Test ran with a number of available devices greater than 0\");\n   OMPVV_INFOMSG_IF(thread_limit_target == thread_limit_teams, \"Test recognized device was of arch/vendor/kind nvidia, amd, or nohost\");\n   OMPVV_WARNING_IF(A[0] == 1, \"Test could not recognize if device was of arch/vendor/kind nvidia, amd or, nohost, even though there are devices available.\");\n\n   return errors;\n}\n\nint metadirectiveOnHost() {\n  int errors = 0;\n  int A[N];\n  int thread_limit_initial = THREAD_LIMIT;\n  int thread_limit_teams = 0;\n\n  for (int i = 0; i < N; i++) {\n     A[i] = 0;\n  }\n\n  thread_limit_initial = omp_get_thread_limit();\n  // We expect all of these when statements to eval to false, causing body of code to run using 'nothing' as the default pragma\n  #pragma omp metadirective \\\n     when( device={kind(nohost)}: teams distribute parallel for thread_limit(thread_limit_initial+1) ) \\\n     when( device={arch(\"nvptx\")}: teams distribute parallel for thread_limit(thread_limit_initial+1) ) \\\n     when( implementation={vendor(amd)}: teams distribute parallel for thread_limit(thread_limit_initial+1) ) \\\n     default( nothing )\n        for (int i = 0; i < N; i++) {\n           A[i] += omp_in_parallel();\n           if( i == 0 ) {\n              thread_limit_teams = omp_get_thread_limit();\n           }\n        }\n\n  OMPVV_WARNING_IF(A[0] == 1, \"Even though no devices were available the test recognized kind/arch equal to nohost or nvptx or amd\");\n  \n  for (int i = 0; i < N; i++) {\n     OMPVV_TEST_AND_SET(errors, A[i] != 0);\n  }\n  OMPVV_TEST_AND_SET(errors, thread_limit_initial != thread_limit_teams);\n\n  return errors;\n} \n\nint main () {\n  int errors = 0;\n  OMPVV_TEST_OFFLOADING;\n\n  if (omp_get_num_devices() > 0) {\n    errors = metadirectiveOnDevice();\n  } else {\n    errors = metadirectiveOnHost();\n  }\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n  return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_omp_target_offload_env_MANDATORY.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 490",
        "issue_id": 2,
        "original_code": "//===--- test_omp_target_offload_env_MANDATORY.c --------------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks for offloading behavior when OMP_TARGET_OFFLOAD is set to MANDATORY.\n//\n// See test_omp_target_offload_env_DEFAULT.c for details.\n//\n////===--------------------------------------------------------------------------------------------===//\n\n#define EXPECTED_POLICY MANDATORY\n\n#include \"test_omp_target_offload_env_DEFAULT.c\"\n",
        "error_code": "//===--- test_omp_target_offload_env_MANDATORY.c --------------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks for offloading behavior when OMP_TARGET_OFFLOAD is set to MANDATORY.\n//\n// See test_omp_target_offload_env_DEFAULT.c for details.\n//\n////===--------------------------------------------------------------------------------------------===//\n\n#define EXPECTED_POLICY MANDATORY\n\n#include \"test_omp_target_offload_env_DEFAULT.c\"\n;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_loop_reduction_bitor_device.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp parallel\" at position 1438",
        "issue_id": 0,
        "original_code": "//===--- test_loop_reduction_bitor_device.c ---------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the reduction clause on a loop directive, testing that the\n// variable in the reduction clause is properly reduced using the bitor\n// operator. This test checks the above in a target context.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n#define THRESHOLD 1024\n\nint test_bitor() {\n  int a[N];\n  // See the 'and' operator test for an exaplantion of this math.\n  double true_margin = pow(exp(1), log(.5)/N);\n  int errors = 0;\n  int num_threads[N];\n  int num_attempts = 0;\n  int have_true = 0, have_false = 0;\n  srand(1);\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = 0;\n  }\n  while ((!have_true || !have_false) && (num_attempts < THRESHOLD)) {\n    have_true = 0;\n    have_false = 0;\n    for (int x = 0; x < N; ++x) {\n      for (int y = 0; y < 16; ++y) {\n        if (rand() / (double) RAND_MAX > true_margin) {\n          a[x] += (1 << y);\n          have_true = 1;\n        } else {\n          have_false = 1;\n        }\n      }\n      num_threads[x] = -x;\n    }\n    num_attempts++;\n  }\n\n  OMPVV_WARNING_IF(!have_true, \"No true bits were generated to test\");\n  OMPVV_WARNING_IF(!have_false, \"No false bits were generated to test\");\n\n  unsigned int b = 0;\n\n#pragma omp target parallel num_threads(OMPVV_NUM_THREADS_DEVICE) map(tofrom: a, b, num_threads)\n  {\n#pragma omp loop reduction(|:b)\n    for (int x = 0; x < N; ++x) {\n      b = b | a[x];\n    }\n#pragma omp for\n    for (int x = 0; x < N; ++x) {\n      num_threads[x] = omp_get_num_threads();\n    }\n  }\n\n  unsigned int host_b = 0;\n\n  for (int x = 0; x < N; ++x) {\n    host_b = host_b | a[x];\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_threads[x - 1] != num_threads[x], \"Test reported differing numbers of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_threads[0] == 1, \"Test operated with one thread.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_threads[0] <= 0, \"Test reported invalid number of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, b != host_b);\n  OMPVV_ERROR_IF(host_b != b, \"Bit from loop directive is %d but expected bit is %d.\", b, host_b);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_bitor() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n",
        "error_code": "//===--- test_loop_reduction_bitor_device.c ---------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the reduction clause on a loop directive, testing that the\n// variable in the reduction clause is properly reduced using the bitor\n// operator. This test checks the above in a target context.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n#define THRESHOLD 1024\n\nint test_bitor() {\n  int a[N];\n  // See the 'and' operator test for an exaplantion of this math.\n  double true_margin = pow(exp(1), log(.5)/N);\n  int errors = 0;\n  int num_threads[N];\n  int num_attempts = 0;\n  int have_true = 0, have_false = 0;\n  srand(1);\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = 0;\n  }\n  while ((!have_true || !have_false) && (num_attempts < THRESHOLD)) {\n    have_true = 0;\n    have_false = 0;\n    for (int x = 0; x < N; ++x) {\n      for (int y = 0; y < 16; ++y) {\n        if (rand() / (double) RAND_MAX > true_margin) {\n          a[x] += (1 << y);\n          have_true = 1;\n        } else {\n          have_false = 1;\n        }\n      }\n      num_threads[x] = -x;\n    }\n    num_attempts++;\n  }\n\n  OMPVV_WARNING_IF(!have_true, \"No true bits were generated to test\");\n  OMPVV_WARNING_IF(!have_false, \"No false bits were generated to test\");\n\n  unsigned int b = 0;\n\n#pragma omp parallel parallel num_threads(OMPVV_NUM_THREADS_DEVICE) map(tofrom: a, b, num_threads)\n  {\n#pragma omp loop reduction(|:b)\n    for (int x = 0; x < N; ++x) {\n      b = b | a[x];\n    }\n#pragma omp for\n    for (int x = 0; x < N; ++x) {\n      num_threads[x] = omp_get_num_threads();\n    }\n  }\n\n  unsigned int host_b = 0;\n\n  for (int x = 0; x < N; ++x) {\n    host_b = host_b | a[x];\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_threads[x - 1] != num_threads[x], \"Test reported differing numbers of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_threads[0] == 1, \"Test operated with one thread.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_threads[0] <= 0, \"Test reported invalid number of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, b != host_b);\n  OMPVV_ERROR_IF(host_b != b, \"Bit from loop directive is %d but expected bit is %d.\", b, host_b);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_bitor() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_virtual_function_map.cpp",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 554",
        "issue_id": 2,
        "original_code": "//-----------test_map_virtual_function.cpp------------------\n//\n// OpenMP API Version 5.1 Mar 2023\n//\n//This test is designed to ensure that virtual functions \n//are correctly passed into a target region. The class base\n//should use the derived classes test function instead of \n//the virtual one declared in the base class\n//----------------------------------------------------------\n\n\n#include <iostream>\n#include <omp.h>\n#include \"ompvv.h\"\n\nusing namespace std;\n\n#pragma omp begin declare target\nclass base {\npublic:\n\tvirtual int test()\n\t{\n\t\treturn 1;\n\t}\n\n};\n#pragma omp end declare target\n\n#pragma omp begin declare target\nclass derived : public base {\n\tpublic: \n\t\tint test()\n\t\t{\n\t\t\treturn 2;\n\t\t}\n\n};\n#pragma omp end declare target\n\nint test_case(){\n    base *bptr;\n    derived d;\n    bptr = &d;\n    int test_val = 0;\n\n    #pragma omp target map(tofrom: test_val)\n    {\n\ttest_val = bptr->test();\n    }\n\treturn test_val;\n}\n\nint main(){\n\tint errors = 0;\n\tOMPVV_TEST_OFFLOADING;\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_case() != 2);\n\tOMPVV_REPORT_AND_RETURN(errors)\n\treturn errors;\n}\n",
        "error_code": "//-----------test_map_virtual_function.cpp------------------\n//\n// OpenMP API Version 5.1 Mar 2023\n//\n//This test is designed to ensure that virtual functions \n//are correctly passed into a target region. The class base\n//should use the derived classes test function instead of \n//the virtual one declared in the base class\n//----------------------------------------------------------\n\n\n#include <iostream>\n#include <omp.h>\n#include \"ompvv.h\"\n\nusing namespace std;\n\n#pragma omp begin declare target\nclass base {\npublic:\n\tvirtual int test()\n\t{\n\t\treturn 1;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n\t}\n\n};\n#pragma omp end declare target\n\n#pragma omp begin declare target\nclass derived : public base {\n\tpublic: \n\t\tint test()\n\t\t{\n\t\t\treturn 2;\n\t\t}\n\n};\n#pragma omp end declare target\n\nint test_case(){\n    base *bptr;\n    derived d;\n    bptr = &d;\n    int test_val = 0;\n\n    #pragma omp target map(tofrom: test_val)\n    {\n\ttest_val = bptr->test();\n    }\n\treturn test_val;\n}\n\nint main(){\n\tint errors = 0;\n\tOMPVV_TEST_OFFLOADING;\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_case() != 2);\n\tOMPVV_REPORT_AND_RETURN(errors)\n\treturn errors;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_loop_lastprivate.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_one_loop_level());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_two_loop_levels());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 2436",
        "issue_id": 4,
        "original_code": "//===--- test_loop_lastprivate.c ----------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the lastprivate clause with a loop directive. According to\n// specification, the list items on a lastprivate clause in this context may\n// only contain loop iteration variables of loops associated with the loop\n// directive. This test checks that the loop iteration variables associated\n// with a loop directive and a loop directive with collapse(2) have valid\n// values after the parallel region containing the loop.\n//\n////===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define SIZE 1024\n#define SIZE2 512\n\nint test_one_loop_level() {\n  int a[SIZE];\n  int b[SIZE];\n  int errors = 0;\n  int lp_errors = 0;\n  int x = 0;\n\n  for (x = 0; x < SIZE; ++x) {\n    a[x] = 1;\n    b[x] = x;\n  }\n\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST)\n  {\n#pragma omp loop lastprivate(x)\n    for (x = 0; x < SIZE; ++x) {\n      a[x] += b[x];\n    }\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(lp_errors, x != SIZE);\n  OMPVV_ERROR_IF(lp_errors, \"Loop iteration variable in loop construct ended with invalid value.\");\n\n  for (x = 0; x < SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, a[x] - b[x] != 1);\n  }\n\n  return errors + lp_errors;\n}\n\nint test_two_loop_levels() {\n  int a[SIZE][SIZE2];\n  int b[SIZE][SIZE2];\n  int errors = 0;\n  int lp_errors_x = 0;\n  int lp_errors_y = 0;\n  int x = 0;\n  int y = 0;\n\n  for (x = 0; x < SIZE; ++x) {\n    for (y = 0; y < SIZE2; ++y) {\n      a[x][y] = 1;\n      b[x][y] = x + y;\n    }\n  }\n\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST)\n  {\n#pragma omp loop lastprivate(x, y) collapse(2)\n    for (x = 0; x < SIZE; ++x) {\n      for (y = 0; y < SIZE2; ++y) {\n        a[x][y] += b[x][y];\n      }\n    }\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(lp_errors_x, x != SIZE);\n  OMPVV_TEST_AND_SET_VERBOSE(lp_errors_y, y != SIZE2);\n  OMPVV_ERROR_IF(lp_errors_x, \"Outer loop iteration variable in loop directive with collapse ended with invalid value.\");\n  OMPVV_ERROR_IF(lp_errors_y, \"Inner loop iteration variable in loop directive with collapse ended with invalid value.\");\n\n  for (x = 0; x < SIZE; ++x) {\n    for (y = 0; y < SIZE2; ++y) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, a[x][y] - b[x][y] != 1);\n    }\n  }\n\n  return errors + lp_errors_x + lp_errors_y;\n}\n\nint main() {\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_one_loop_level());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_two_loop_levels());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_loop_lastprivate.c ----------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the lastprivate clause with a loop directive. According to\n// specification, the list items on a lastprivate clause in this context may\n// only contain loop iteration variables of loops associated with the loop\n// directive. This test checks that the loop iteration variables associated\n// with a loop directive and a loop directive with collapse(2) have valid\n// values after the parallel region containing the loop.\n//\n////===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define SIZE 1024\n#define SIZE2 512\n\nint test_one_loop_level() {\n  int a[SIZE];\n  int b[SIZE];\n  int errors = 0;\n  int lp_errors = 0;\n  int x = 0;\n\n  for (x = 0; x < SIZE; ++x) {\n    a[x] = 1;\n    b[x] = x;\n  }\n\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST)\n  {\n#pragma omp loop lastprivate(x)\n    for (x = 0; x < SIZE; ++x) {\n      a[x] += b[x];\n    }\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(lp_errors, x != SIZE);\n  OMPVV_ERROR_IF(lp_errors, \"Loop iteration variable in loop construct ended with invalid value.\");\n\n  for (x = 0; x < SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, a[x] - b[x] != 1);\n  }\n\n  return errors + lp_errors;\n}\n\nint test_two_loop_levels() {\n  int a[SIZE][SIZE2];\n  int b[SIZE][SIZE2];\n  int errors = 0;\n  int lp_errors_x = 0;\n  int lp_errors_y = 0;\n  int x = 0;\n  int y = 0;\n\n  for (x = 0; x < SIZE; ++x) {\n    for (y = 0; y < SIZE2; ++y) {\n      a[x][y] = 1;\n      b[x][y] = x + y;\n    }\n  }\n\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST)\n  {\n#pragma omp loop lastprivate(x, y) collapse(2)\n    for (x = 0; x < SIZE; ++x) {\n      for (y = 0; y < SIZE2; ++y) {\n        a[x][y] += b[x][y];\n      }\n    }\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(lp_errors_x, x != SIZE);\n  OMPVV_TEST_AND_SET_VERBOSE(lp_errors_y, y != SIZE2);\n  OMPVV_ERROR_IF(lp_errors_x, \"Outer loop iteration variable in loop directive with collapse ended with invalid value.\");\n  OMPVV_ERROR_IF(lp_errors_y, \"Inner loop iteration variable in loop directive with collapse ended with invalid value.\");\n\n  for (x = 0; x < SIZE; ++x) {\n    for (y = 0; y < SIZE2; ++y) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, a[x][y] - b[x][y] != 1);\n    }\n  }\n\n  return errors + lp_errors_x + lp_errors_y;\n}\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/lsms_triangular_packing.cpp",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp single\" at position 3222",
        "issue_id": 0,
        "original_code": "/*\n * Copyright (C) 2014, The University of Texas at Austin\n * Copyright (C) 2014-2015, Michael Lehn\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *  - Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  - Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *  - Neither the name of The University of Texas at Austin nor the names\n *    of its contributors may be used to endorse or promote products\n *    derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n#include <complex>\n#include <cstdio>\n#include <omp.h>\n#include \"ompvv.h\"\n\nconst int MR = 16;\nconst int M = 256;\nconst int N = 256;\n\nstatic_assert(!(M % MR), \"Block size must be divisible by the matrix size\");\n\nnamespace ulmBLAS {\n\n/* Perform a triangular packing algorithm on an input matrix. Converting it to\n * a lower unit triangular matrix and packing column blocks of size MR x MR into\n * an auxilliary buffer.\n *\n *  _|--- MR ----|\n *  | 1   2  3  4  5  6  7  8       1   0  0  0  0  0  0  0\n * MR 9  10 11 12 13 14 15 16       9   1  0  0  0  0  0  0\n *  | 17 18 19 20 21 22 23 24       17 18  1  0  0  0  0  0\n *  - 25 26 27 28 29 30 31 32  -->  25 26 27  1  0  0  0  0\n *    33 34 35 36 37 38 39 40       33 34 35 36  1  0  0  0\n *    41 42 43 44 45 46 47 48       41 42 43 44 45  1  0  0\n *    49 50 51 52 53 54 55 56       49 50 51 52 53 54  1  0\n *    57 58 59 60 61 62 63 64       57 58 59 60 61 62 63  1\n *      \n *  Packed into a collection of MR by MR blocks stored column-major in memory\n *\n *  1  9 17 25      33 41 49 57      1 45 53 61  \n *  0  1 18 26  ... 34 42 50 58 ...  0  1 54 61  \n *  0  0  1 27      35 43 51 59      0  0  1 63  \n *  0  0  0  1      36 44 52 60      0  0  0  1\n *\n */\n\ntemplate <typename IndexType, typename TL, typename Buffer>\nvoid\ntrlspack(IndexType   mc,\n         bool        unit,\n         const TL    *L,\n         IndexType   incRowL,\n         IndexType   incColL,\n         Buffer      *p)\n{\n    OMPVV_INFOMSG(\"app_kernel_lsms_triangular_packing\");\n    IndexType mp = (mc+MR-1) / MR;\n\n// Collapsing the whole loop nest here causes errors\n#pragma omp target teams distribute parallel for collapse(4)\n    for (IndexType j=0; j<mp; ++j) {\n// Collapsing here is fine\n//#pragma omp target teams distribute parallel for collapse(3)\n        for (IndexType j0=0; j0<MR; ++j0) {\n            for (IndexType i=j; i<mp; ++i) {\n                for (IndexType i0=0; i0<MR; ++i0) {\n                    IndexType I  = i*MR+i0;\n                    IndexType J  = j*MR+j0;\n                    IndexType nu = (i+1)*i/2*MR*MR + j*MR*MR + j0*MR +i0;\n                    p[nu] = (I==J && unit)\n                            ? Buffer(1)\n                          : (I==J && !unit)\n                            ? Buffer(1) / L[I*(incRowL+incColL)]\n                          : (I>=mc || J>=mc)\n                            ? Buffer(0)\n                          : (I>J)\n                            ? L[I*incRowL+J*incColL]\n                          : Buffer(0);\n                }\n            }\n        }\n    }\n}\n\n} // namespace ulmBLAS\n\nint main() {\n    const bool unit = true;\n\n    double A[M*N];\n    double buffer[M*M + MR];\n\n    OMPVV_TEST_OFFLOADING;\n\n    for (int i = 0; i < M; i++) \n        for (int j = 0; j < N; j++) \n            A[i*N + j] = (i == j) ? 1.0 \n                       : (j >  i) ? 0.0\n                       : drand48()*2.0 - 1.0;\n\n#pragma omp target data           \\\n    map(to:A[0 : M*N])            \\\n    map(from:buffer[0 : M*M + MR])\n    {\n    ulmBLAS::trlspack(M, unit, A, N, 1, buffer);\n    }\n\n    double error_sum = 0.0;\n    int mp = (M + MR - 1) / MR;\n    for (int j = 0; j < mp; j++) {\n        for (int j0 = 0; j0 < MR; j0++) {\n            for (int i = j; i < mp; i++) {\n                for (int i0 = 0; i0 < MR; i0++) {\n                    int I  = i*MR+i0;\n                    int J  = j*MR+j0;\n                    int nu = (i+1)*i/2*MR*MR + j*MR*MR + j0*MR +i0;\n                    OMPVV_TEST_AND_SET(error_sum,buffer[nu] != A[I*N + J]);\n                }\n            }\n        }\n    }\n\n    OMPVV_REPORT_AND_RETURN(error_sum != 0.0);\n}\n\n",
        "error_code": "/*\n * Copyright (C) 2014, The University of Texas at Austin\n * Copyright (C) 2014-2015, Michael Lehn\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *  - Redistributions of source code must retain the above copyright\n *    notice, this list of conditions and the following disclaimer.\n *  - Redistributions in binary form must reproduce the above copyright\n *    notice, this list of conditions and the following disclaimer in the\n *    documentation and/or other materials provided with the distribution.\n *  - Neither the name of The University of Texas at Austin nor the names\n *    of its contributors may be used to endorse or promote products\n *    derived from this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n */\n\n#include <complex>\n#include <cstdio>\n#include <omp.h>\n#include \"ompvv.h\"\n\nconst int MR = 16;\nconst int M = 256;\nconst int N = 256;\n\nstatic_assert(!(M % MR), \"Block size must be divisible by the matrix size\");\n\nnamespace ulmBLAS {\n\n/* Perform a triangular packing algorithm on an input matrix. Converting it to\n * a lower unit triangular matrix and packing column blocks of size MR x MR into\n * an auxilliary buffer.\n *\n *  _|--- MR ----|\n *  | 1   2  3  4  5  6  7  8       1   0  0  0  0  0  0  0\n * MR 9  10 11 12 13 14 15 16       9   1  0  0  0  0  0  0\n *  | 17 18 19 20 21 22 23 24       17 18  1  0  0  0  0  0\n *  - 25 26 27 28 29 30 31 32  -->  25 26 27  1  0  0  0  0\n *    33 34 35 36 37 38 39 40       33 34 35 36  1  0  0  0\n *    41 42 43 44 45 46 47 48       41 42 43 44 45  1  0  0\n *    49 50 51 52 53 54 55 56       49 50 51 52 53 54  1  0\n *    57 58 59 60 61 62 63 64       57 58 59 60 61 62 63  1\n *      \n *  Packed into a collection of MR by MR blocks stored column-major in memory\n *\n *  1  9 17 25      33 41 49 57      1 45 53 61  \n *  0  1 18 26  ... 34 42 50 58 ...  0  1 54 61  \n *  0  0  1 27      35 43 51 59      0  0  1 63  \n *  0  0  0  1      36 44 52 60      0  0  0  1\n *\n */\n\ntemplate <typename IndexType, typename TL, typename Buffer>\nvoid\ntrlspack(IndexType   mc,\n         bool        unit,\n         const TL    *L,\n         IndexType   incRowL,\n         IndexType   incColL,\n         Buffer      *p)\n{\n    OMPVV_INFOMSG(\"app_kernel_lsms_triangular_packing\");\n    IndexType mp = (mc+MR-1) / MR;\n\n// Collapsing the whole loop nest here causes errors\n#pragma omp single teams distribute parallel for collapse(4)\n    for (IndexType j=0; j<mp; ++j) {\n// Collapsing here is fine\n//#pragma omp target teams distribute parallel for collapse(3)\n        for (IndexType j0=0; j0<MR; ++j0) {\n            for (IndexType i=j; i<mp; ++i) {\n                for (IndexType i0=0; i0<MR; ++i0) {\n                    IndexType I  = i*MR+i0;\n                    IndexType J  = j*MR+j0;\n                    IndexType nu = (i+1)*i/2*MR*MR + j*MR*MR + j0*MR +i0;\n                    p[nu] = (I==J && unit)\n                            ? Buffer(1)\n                          : (I==J && !unit)\n                            ? Buffer(1) / L[I*(incRowL+incColL)]\n                          : (I>=mc || J>=mc)\n                            ? Buffer(0)\n                          : (I>J)\n                            ? L[I*incRowL+J*incColL]\n                          : Buffer(0);\n                }\n            }\n        }\n    }\n}\n\n} // namespace ulmBLAS\n\nint main() {\n    const bool unit = true;\n\n    double A[M*N];\n    double buffer[M*M + MR];\n\n    OMPVV_TEST_OFFLOADING;\n\n    for (int i = 0; i < M; i++) \n        for (int j = 0; j < N; j++) \n            A[i*N + j] = (i == j) ? 1.0 \n                       : (j >  i) ? 0.0\n                       : drand48()*2.0 - 1.0;\n\n#pragma omp target data           \\\n    map(to:A[0 : M*N])            \\\n    map(from:buffer[0 : M*M + MR])\n    {\n    ulmBLAS::trlspack(M, unit, A, N, 1, buffer);\n    }\n\n    double error_sum = 0.0;\n    int mp = (M + MR - 1) / MR;\n    for (int j = 0; j < mp; j++) {\n        for (int j0 = 0; j0 < MR; j0++) {\n            for (int i = j; i < mp; i++) {\n                for (int i0 = 0; i0 < MR; i0++) {\n                    int I  = i*MR+i0;\n                    int J  = j*MR+j0;\n                    int nu = (i+1)*i/2*MR*MR + j*MR*MR + j0*MR +i0;\n                    OMPVV_TEST_AND_SET(error_sum,buffer[nu] != A[I*N + J]);\n                }\n            }\n        }\n    }\n\n    OMPVV_REPORT_AND_RETURN(error_sum != 0.0);\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_scope_nowait_construct.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//-------------test_scope_nowait_construct.c-------------//\n//\n//OpenMP API Version 5.1 Aug 2021\n//\n//Tests the behavior of the scope construct with nowait\n//specified. This test should remove the implied barrier\n//creatd by the scope construct when nowait is specified.\n//-------------------------------------------------------//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n#include <unistd.h>\n\n#define N 1024\n\nint test1[N];\nint test2[N];\n\n\nint test_scope_nowait(){\n\tint errors = 0;\n\tfor (int i = 0; i <N; i++){\n\t\ttest1[i] = 0;\n\t\ttest2[i] = 0;\n\t}\n\t#pragma omp parallel shared(test1, test2)\n\t{\n\t\t#pragma omp scope\n\t\t{\n\t\t\t#pragma omp for\n\t\t\tfor (int i = 0; i < N; i++){\n\t\t\t\ttest1[i] = 1;\n\t\t\t}\n\t\t}\n\t\t#pragma omp scope nowait\n\t\t{\n\t\t\t#pragma omp for\n\t\t\tfor (int i = 0; i < N; i++){\n\t\t\t\ttest2[i] = 1;\n\t\t\t}\n\t\t}\n\t}\n\tint sum1 = 0;\n\tint sum2 = 0;\n\tfor (int i = 0; i <N; i++){\n\t\tsum1 += test1[i];\n\t\tsum2 += test2[i];\n\t}\n\tint total = sum1 + sum2;\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, total != 2048);\n        OMPVV_INFOMSG_IF(sum1 != 1024, \"first function was not called\");\n\tOMPVV_INFOMSG_IF(sum2 != 1024, \"second function was not called\");\n\treturn errors;\n}\n\nint main(){\n\tint errors = 0;\n\tOMPVV_TEST_OFFLOADING;\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_scope_nowait() != 0);\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nint yewxvfffrp = 240;\ndouble cwwayowsbx = 248;\nint mylggxkdlw = 245;\nfloat nikabwaypx = 72;\nlong efhaohvvvy = 187;\nbyte ctwctcbupx = 213;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/reduction_separated_directives.cpp",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n      counts_reduction = counts_team;\n    }\" at position 1293",
        "issue_id": 4,
        "original_code": "//===---- reduction_separated_directives.cpp ------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks the behavior of a reduction clause with separated target teams\n// parallel for directives by comparing the results to those from atomic-protected\n// writes without a reduction. This test comes from the aomp development repo, see\n// https://github.com/ROCm-Developer-Tools/aomp/issues/51.\n//\n//===----------------------------------------------------------------------------------===//\n\n#include <cstdio>\n#include \"omp.h\"\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main()\n{\n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_SHARED_ENVIRONMENT;\n\n  int errors = 0;\n  int counts_atomic = 0;\n  int counts_reduction = 0;\n\n#pragma omp target teams map(from: counts_atomic)\n  {\n    int counts_team = 0;\n#pragma omp parallel\n    {\n#pragma omp for\n      for (int i = 0; i < N; ++i)\n#pragma omp atomic\n        counts_team += 1;\n    }\n    if (omp_get_team_num() == 0) {\n      counts_atomic = counts_team;\n    }\n  }\n\n#pragma omp target teams map(from: counts_reduction)\n  {\n    int counts_team = 0;\n#pragma omp parallel\n    {\n#pragma omp for reduction(+: counts_team)\n      for (int i = 0; i < N; ++i)\n        counts_team += 1;\n    }\n    if (omp_get_team_num() == 0) {\n      counts_reduction = counts_team;\n    }\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, counts_atomic != N);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, counts_reduction != N);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- reduction_separated_directives.cpp ------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks the behavior of a reduction clause with separated target teams\n// parallel for directives by comparing the results to those from atomic-protected\n// writes without a reduction. This test comes from the aomp development repo, see\n// https://github.com/ROCm-Developer-Tools/aomp/issues/51.\n//\n//===----------------------------------------------------------------------------------===//\n\n#include <cstdio>\n#include \"omp.h\"\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main()\n{\n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_SHARED_ENVIRONMENT;\n\n  int errors = 0;\n  int counts_atomic = 0;\n  int counts_reduction = 0;\n\n#pragma omp target teams map(from: counts_atomic)\n  {\n    int counts_team = 0;\n#pragma omp parallel\n    {\n#pragma omp for\n      for (int i = 0; i < N; ++i)\n#pragma omp atomic\n        counts_team += 1;\n    }\n    if (omp_get_team_num() == 0) {\n      counts_atomic = counts_team;\n    }\n  }\n\n#pragma omp target teams map(from: counts_reduction)\n  {\n    int counts_team = 0;\n#pragma omp parallel\n    {\n#pragma omp for reduction(+: counts_team)\n      for (int i = 0; i < N; ++i)\n        counts_team += 1;\n    }\n    if (omp_get_team_num() == 0) \n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, counts_atomic != N);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, counts_reduction != N);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_defaultmap_none.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp teams\" at position 1293",
        "issue_id": 0,
        "original_code": "//===--- test_target_defaultmap_none.c -----------------------------------------------------------===//\n//\n//  OpenMP API Version 5.0 Nov 2018\n//\n//  This test checks behavior of the defaultmap clause when the specified implicit-behavior  \n//  is none. The variable-categories avaiable for defaultmap are scalar, aggregate, and pointer.\n//  When defaultmap(none) is used alone without a variable-category, then none is the implicit-\n//  behavior for all variables referenced in the construct. Since none is used, the data mapping\n//  attributes must be specified somewhere else. In this case, they are specified using the map\n//  clause.\n//\n////===-------------------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint errors;\nint i;\n\nint test_defaultmap_with_none() {\n\n   struct test_struct {\n     int s;\n     int S[N];\n   };\n\n   int scalar; // scalar \n   int A[N]; // aggregate \n   struct test_struct new_struct; // aggregate variable -> structure\n   int *ptr; // scalar, pointer variable -> pointer\n\n   // initialize everything   \n   scalar = 1;\n   new_struct.s = 0;\n\n   for (i = 0; i < N; i++) {\n      A[i] = 0;\n      new_struct.S[i] = 0;\n   }\n\n   #pragma omp target defaultmap(none) map(tofrom: scalar, A, new_struct, ptr) \n   {\n      scalar = 17;    // Scalar variable, default is firstprivate\n      A[0] = 5; A[1] = 5; // Aggregate array, default is tofrom\n      new_struct.s = 10; new_struct.S[0] = 10; new_struct.S[1] = 10; // Aggregate structure, default is tofrom\n      ptr = &A[0]; ptr[50] = 50; ptr[51] = 51; // Pointer, default is private\n   }\n\n   OMPVV_TEST_AND_SET_VERBOSE(errors, scalar != 17); \n   OMPVV_TEST_AND_SET_VERBOSE(errors, A[0] != 5 || A[1] != 5); \n   OMPVV_TEST_AND_SET_VERBOSE(errors, A[50] != 50 || A[51] != 51);\n   OMPVV_TEST_AND_SET_VERBOSE(errors, new_struct.s != 10 || new_struct.S[0] != 10 || new_struct.S[1] != 10);\n   \n   #pragma omp target defaultmap(none) map(to: scalar, A, new_struct, ptr)\n   {\n      scalar += 10;\n      A[0] += 10; A[1] = 10;\n      new_struct.s += 10; new_struct.S[0] += 10; new_struct.S[1] += 10; // Aggregate structure, default is tofrom\n      ptr[50] += 10; ptr[51] += 10; // Pointer, default is private\n   }\n\n   OMPVV_TEST_AND_SET_VERBOSE(errors, scalar != 17); \n   OMPVV_TEST_AND_SET_VERBOSE(errors, A[0] != 5 || A[1] != 5); \n   OMPVV_TEST_AND_SET_VERBOSE(errors, A[50] != 50 || A[51] != 51);\n   OMPVV_TEST_AND_SET_VERBOSE(errors, new_struct.s != 10 || new_struct.S[0] != 10 || new_struct.S[1] != 10);\n\n   return errors;\n}\n\nint main() {\n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_defaultmap_with_none() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_defaultmap_none.c -----------------------------------------------------------===//\n//\n//  OpenMP API Version 5.0 Nov 2018\n//\n//  This test checks behavior of the defaultmap clause when the specified implicit-behavior  \n//  is none. The variable-categories avaiable for defaultmap are scalar, aggregate, and pointer.\n//  When defaultmap(none) is used alone without a variable-category, then none is the implicit-\n//  behavior for all variables referenced in the construct. Since none is used, the data mapping\n//  attributes must be specified somewhere else. In this case, they are specified using the map\n//  clause.\n//\n////===-------------------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint errors;\nint i;\n\nint test_defaultmap_with_none() {\n\n   struct test_struct {\n     int s;\n     int S[N];\n   };\n\n   int scalar; // scalar \n   int A[N]; // aggregate \n   struct test_struct new_struct; // aggregate variable -> structure\n   int *ptr; // scalar, pointer variable -> pointer\n\n   // initialize everything   \n   scalar = 1;\n   new_struct.s = 0;\n\n   for (i = 0; i < N; i++) {\n      A[i] = 0;\n      new_struct.S[i] = 0;\n   }\n\n   #pragma omp teams defaultmap(none) map(tofrom: scalar, A, new_struct, ptr) \n   {\n      scalar = 17;    // Scalar variable, default is firstprivate\n      A[0] = 5; A[1] = 5; // Aggregate array, default is tofrom\n      new_struct.s = 10; new_struct.S[0] = 10; new_struct.S[1] = 10; // Aggregate structure, default is tofrom\n      ptr = &A[0]; ptr[50] = 50; ptr[51] = 51; // Pointer, default is private\n   }\n\n   OMPVV_TEST_AND_SET_VERBOSE(errors, scalar != 17); \n   OMPVV_TEST_AND_SET_VERBOSE(errors, A[0] != 5 || A[1] != 5); \n   OMPVV_TEST_AND_SET_VERBOSE(errors, A[50] != 50 || A[51] != 51);\n   OMPVV_TEST_AND_SET_VERBOSE(errors, new_struct.s != 10 || new_struct.S[0] != 10 || new_struct.S[1] != 10);\n   \n   #pragma omp target defaultmap(none) map(to: scalar, A, new_struct, ptr)\n   {\n      scalar += 10;\n      A[0] += 10; A[1] = 10;\n      new_struct.s += 10; new_struct.S[0] += 10; new_struct.S[1] += 10; // Aggregate structure, default is tofrom\n      ptr[50] += 10; ptr[51] += 10; // Pointer, default is private\n   }\n\n   OMPVV_TEST_AND_SET_VERBOSE(errors, scalar != 17); \n   OMPVV_TEST_AND_SET_VERBOSE(errors, A[0] != 5 || A[1] != 5); \n   OMPVV_TEST_AND_SET_VERBOSE(errors, A[50] != 50 || A[51] != 51);\n   OMPVV_TEST_AND_SET_VERBOSE(errors, new_struct.s != 10 || new_struct.S[0] != 10 || new_struct.S[1] != 10);\n\n   return errors;\n}\n\nint main() {\n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_defaultmap_with_none() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_task_in_reduction.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 745",
        "issue_id": 2,
        "original_code": "//===--- test_task_in_reduction.c -------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the task directive with the `in_reduction` reduction\n// participation clause. It performs simple array operations which are added\n// to a reduction variable in an explcit task with the in_reduction clause.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_task_in_reduction() {\n  OMPVV_INFOMSG(\"test_task_in_reduction\");\n  int errors = 0;\n  int num_threads = -1;\n  int y[N];\n  int z[N];\n  int sum = 0;\n  int expected_sum = 0;\n\n  for (int i = 0; i < N; i++) {\n    y[i] = i + 1;\n    z[i] = 2*(i + 1);\n  }\n\n#pragma omp parallel reduction(task, +: sum) num_threads(OMPVV_NUM_THREADS_HOST) shared(y, z, num_threads)\n  {\n#pragma omp master\n    {\n#pragma omp task in_reduction(+: sum)\n      {\n        for (int i = 0; i < N; i++) {\n          sum += y[i]*z[i];\n        }\n      }\n      num_threads = omp_get_num_threads();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    expected_sum += y[i]*z[i];\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, sum != expected_sum);\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of taskloop can't be guaranteed.\");\n  OMPVV_ERROR_IF(num_threads < 1, \"Test returned an invalid number of threads.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n\n  return errors;\n}\n\n\nint main() {\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_task_in_reduction());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_task_in_reduction.c -------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the task directive with the `in_reduction` reduction\n// participation clause. It performs simple array operations which are added\n// to a reduction variable in an explcit task with the in_reduction clause.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_task_in_reduction() {\n  OMPVV_INFOMSG(\"test_task_in_reduction\");\n  int errors = 0;\n  int num_threads = -1;\n  int y[N];\n  int z[N];\n  int sum = 0;\n  int expected_sum = 0;\n\n  for (int i = 0;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1; i < N; i++) {\n    y[i] = i + 1;\n    z[i] = 2*(i + 1);\n  }\n\n#pragma omp parallel reduction(task, +: sum) num_threads(OMPVV_NUM_THREADS_HOST) shared(y, z, num_threads)\n  {\n#pragma omp master\n    {\n#pragma omp task in_reduction(+: sum)\n      {\n        for (int i = 0; i < N; i++) {\n          sum += y[i]*z[i];\n        }\n      }\n      num_threads = omp_get_num_threads();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    expected_sum += y[i]*z[i];\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, sum != expected_sum);\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of taskloop can't be guaranteed.\");\n  OMPVV_ERROR_IF(num_threads < 1, \"Test returned an invalid number of threads.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n\n  return errors;\n}\n\n\nint main() {\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_task_in_reduction());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_assumes_contains.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===--- test_assumes_contains.c --------------------------------------------===//\n//\n//  OpenMP API Version 5.1 Aug 2021\n//\n//  The purpose of this test in particular is to test the syntax listed as:\n//  #pragma omp assumes clause[ [ [ ,]clause]...]new-line.\n//\n//  The scope of the assumes directive is the \"the code executed and reached \n//  from the current compilation unit\". In this test, we use assumes \n//  contains(target parallel for) to tell the compiler that this directive\n//  will show up somewhere in our program, which it does.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\n#pragma omp assumes contains(target, parallel, for)\n\nint errors, i;\n\nint test_assumes_contains() {\n    int arr[N];\n    for(i = 0; i < N; i++){\n        arr[i] = i;\n    }\n\n    #pragma omp target map(tofrom: arr)\n    #pragma omp parallel num_threads(OMPVV_NUM_THREADS_DEVICE)\n    #pragma omp for\n    for(i = 0; i < N; i++){\n        arr[i] = arr[i]*2;\n    }\n    // Test that no issues were caused from using assumes directive\n    for(i = 0; i < N; i++){\n        OMPVV_TEST_AND_SET(errors, arr[i] != i*2);\n    }\n   return errors;\n}\n\nint main() {\n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_assumes_contains() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_loop_reduction_and.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_and() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\" at position 2712",
        "issue_id": 4,
        "original_code": "//===--- test_loop_reduction_and.c ------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the reduction clause on a loop directive, testing that the\n// variable in the reduction clause is properly reduced using the and\n// operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n#define THRESHOLD 512\n\nint test_and() {\n  char a[N];\n      // The below calculation is meant to ensure about half the arrays we will\n      // test will come out to true under the 'and' operator, and the rest false.\n      // For the and operator, a test array that comes out true requires every\n      // entry to be false, which is why this margin is so close to 100%.\n  double false_margin = pow(exp(1), log(.5)/N);\n  int errors = 0;\n  int num_threads[N];\n  int tested_true = 0;\n  int tested_false = 0;\n  int itr_count = 0;\n  srand(1);\n\n  while ((!tested_true || !tested_false) && (itr_count < THRESHOLD)) {\n    for (int x = 0; x < N; ++x) {\n      a[x] = (rand() / (double) (RAND_MAX) < false_margin);\n      num_threads[x] = -x;\n    }\n\n    char result = 1;\n    char host_result = 1;\n\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST)\n    {\n#pragma omp loop reduction(&&:result)\n      for (int x = 0; x < N; ++x) {\n        result = result && a[x];\n      }\n#pragma omp for\n      for (int x = 0; x < N; ++x) {\n        num_threads[x] = omp_get_num_threads();\n      }\n    }\n\n    for (int x = 0; x < N; ++x) {\n      host_result = host_result && a[x];\n    }\n\n    if (itr_count == 0) {\n      for (int x = 1; x < N; ++x) {\n        OMPVV_WARNING_IF(num_threads[x - 1] != num_threads[x], \"Test reported differing numbers of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n      }\n      OMPVV_WARNING_IF(num_threads[0] == 1, \"Test operated with one thread.  Reduction clause cannot be tested.\");\n      OMPVV_WARNING_IF(num_threads[0] <= 0, \"Test reported invalid number of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n    }\n\n    OMPVV_TEST_AND_SET_VERBOSE(errors, host_result != result);\n    OMPVV_ERROR_IF(host_result != result, \"Actual result is %d but expected result is %d.\", result, host_result);\n\n    if (host_result) {\n      tested_true = 1;\n    } else {\n      tested_false = 1;\n    }\n\n    if (host_result != result) {\n      break;\n    }\n\n    itr_count++;\n  }\n\n  OMPVV_WARNING_IF(!tested_true, \"Did not test a case in which final result was true.\");\n  OMPVV_WARNING_IF(!tested_false, \"Did not test a case in which final result was false.\");\n\n  return errors;\n}\n\nint main() {\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_and() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n",
        "error_code": "//===--- test_loop_reduction_and.c ------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the reduction clause on a loop directive, testing that the\n// variable in the reduction clause is properly reduced using the and\n// operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n#define THRESHOLD 512\n\nint test_and() {\n  char a[N];\n      // The below calculation is meant to ensure about half the arrays we will\n      // test will come out to true under the 'and' operator, and the rest false.\n      // For the and operator, a test array that comes out true requires every\n      // entry to be false, which is why this margin is so close to 100%.\n  double false_margin = pow(exp(1), log(.5)/N);\n  int errors = 0;\n  int num_threads[N];\n  int tested_true = 0;\n  int tested_false = 0;\n  int itr_count = 0;\n  srand(1);\n\n  while ((!tested_true || !tested_false) && (itr_count < THRESHOLD)) {\n    for (int x = 0; x < N; ++x) {\n      a[x] = (rand() / (double) (RAND_MAX) < false_margin);\n      num_threads[x] = -x;\n    }\n\n    char result = 1;\n    char host_result = 1;\n\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST)\n    {\n#pragma omp loop reduction(&&:result)\n      for (int x = 0; x < N; ++x) {\n        result = result && a[x];\n      }\n#pragma omp for\n      for (int x = 0; x < N; ++x) {\n        num_threads[x] = omp_get_num_threads();\n      }\n    }\n\n    for (int x = 0; x < N; ++x) {\n      host_result = host_result && a[x];\n    }\n\n    if (itr_count == 0) {\n      for (int x = 1; x < N; ++x) {\n        OMPVV_WARNING_IF(num_threads[x - 1] != num_threads[x], \"Test reported differing numbers of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n      }\n      OMPVV_WARNING_IF(num_threads[0] == 1, \"Test operated with one thread.  Reduction clause cannot be tested.\");\n      OMPVV_WARNING_IF(num_threads[0] <= 0, \"Test reported invalid number of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n    }\n\n    OMPVV_TEST_AND_SET_VERBOSE(errors, host_result != result);\n    OMPVV_ERROR_IF(host_result != result, \"Actual result is %d but expected result is %d.\", result, host_result);\n\n    if (host_result) {\n      tested_true = 1;\n    } else {\n      tested_false = 1;\n    }\n\n    if (host_result != result) {\n      break;\n    }\n\n    itr_count++;\n  }\n\n  OMPVV_WARNING_IF(!tested_true, \"Did not test a case in which final result was true.\");\n  OMPVV_WARNING_IF(!tested_false, \"Did not test a case in which final result was false.\");\n\n  return errors;\n}\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_error_message_at_compilation.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===--- test_error_message_at_compilation.c ----------------------------===//\n//\n//  OpenMP API Version 5.1 Aug 2021\n//\n//  Test uses error directive with message clause to print a message,\n//  if error condition is reached then \"runtime error!\" is printed,\n//  otherwise is simply used to print a message. \n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\nint errors, i;\n\nint test_error_message() {\n    i = 0;\n    OMPVV_INFOMSG(\"If successful, test should print an \\\"error message success\\\" at the beginning of the test\");\n    #pragma omp parallel\n    {\n        #pragma omp single\n        {\n            #pragma omp error severity(warning) at(compilation) message(\"error message success\")\n            i+=5;\n        }\n    }\n    OMPVV_TEST_AND_SET_VERBOSE(errors, i != 5);\n    OMPVV_ERROR_IF(errors > 0, \"Error directive caused execution error\");\n    return errors;\n}\n\nint main() {\n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_error_message() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nshort jpirltaqeh = 72;\nint wfotodnffd = 164;\nshort sesupkwelh = 233;\nint kkedbnahny = 196;\nbyte gpiopubwde = 244;\nint mbptgmqbtg = 90;\nint zvryyvjeam = 46;\ndouble lmtxvmwfoi = 99;\nshort mdfmxdnbqd = 176;\nlong ekffxmumxq = 248;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_loop_firstprivate.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n    OMPVV_TEST_AND_SET_VERBOSE(errors, b[i] != (2*i + 1));\n  }\" at position 519",
        "issue_id": 4,
        "original_code": "#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n/**\n  This is a basic test to demonstrate firstprivate clause used\n  with \"omp target teams loop\".\n*/\nint main() {\n  int a[N], b[N];\n  int errors = 0;\n  // Data Inititalize\n  for (int i = 0; i < N; i++) {\n    a[i] = 2*i;  // Even\n    b[i] = a[i];\n  }\n  // Execute on target\n#pragma omp target teams loop map(tofrom: b[0:N]) firstprivate(a)\n  for (int i = 0; i < N; i++) {\n    b[i] = a[i] + 1;\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, b[i] != (2*i + 1));\n  }\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n/**\n  This is a basic test to demonstrate firstprivate clause used\n  with \"omp target teams loop\".\n*/\nint main() {\n  int a[N], b[N];\n  int errors = 0;\n  // Data Inititalize\n  for (int i = 0; i < N; i++) {\n    a[i] = 2*i;  // Even\n    b[i] = a[i];\n  }\n  // Execute on target\n#pragma omp target teams loop map(tofrom: b[0:N]) firstprivate(a)\n  for (int i = 0; i < N; i++) {\n    b[i] = a[i] + 1;\n  }\n\n  for (int i = 0; i < N; i++) \n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_declare_variant_adjust_args.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n    OMPVV_TEST_OFFLOADING;\n    OMPVV_TEST_AND_SET_VERBOSE(errors, test_wrapper());\n    OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 2491",
        "issue_id": 4,
        "original_code": "//===---- test_declare_variant_adjust_args.c -----------------------------------------===//\n// \n// OpenMP API Version 5.1\n//\n// Uses declare variant directive with the adjust_args clause, which states that\n// \"For each adjust_args clause that is present on the selected variant the adjustment operation\n// specified by adjust-op will be applied to each of the arguments specified in the clause\n// before being passed to the selected variant.\" Clause also requires a\n// match(construct={dispatch}) clause to be specified, as listed in restrictions.\n//\n// Inspired by \"OpenMP 5.1 Features: The Dispatch Construct\" video:\n// https://www.youtube.com/watch?v=ruugaX95gIs\n// \n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint errors;\nint i = 0;\n\nvoid add_dispatch(int *arr);\n\n#pragma omp declare variant(add_dispatch) match(construct={dispatch}) adjust_args(need_device_ptr:arr)\nvoid add(int *arr){\n    for (int i = 0; i < N; i++){ // Base function adds 1 to array values\n        arr[i] = i+1;\n    }\n}\n\nvoid add_dispatch(int *arr){\n    if (arr == NULL){\n      return;\n    }\n    #pragma omp target parallel for\n    for (int i = 0; i < N; i++){\n        arr[i] = i+3; // Variant function adds 3 to array values\n    }\n}\n\nint test_wrapper() { \n    int *arr = (int*)malloc(sizeof(int)*N); // implicit map array \n    errors = 0;\n    add(arr);\n    for(i = 0; i < N; i++){\n        OMPVV_TEST_AND_SET_VERBOSE(errors, arr[i] != i+1);\n    } \n    OMPVV_ERROR_IF(errors > 0, \"Base function is not working properly\");\n\n    #pragma omp target enter data map(to:arr[0:N])\n    #pragma omp dispatch\n        add(arr);  \n        /* array should be converted to device ptr; i.e. spec states since it is not a device ptr, \"the argument\n        will be converted in the same manner that a use_device_ptr clause on a target data construct converts \n        its pointer list items into device pointers.\" */\n    \n    #pragma omp target parallel for map(tofrom: errors)\n    for(i = 0; i < N; i++){\n        if(arr[i] != i+3){\n            errors++;\n        }\n    }\n    #pragma omp target exit data map(delete:arr[0:N])\n    free(arr);\n    \n    OMPVV_INFOMSG_IF(errors > 0 || arr[0] == 1,\n                  \"Dispatch is either not working or was not considered\"\n                  \" by the implementation as part of the context selector.\");\n    return errors;\n}\n\nint main () {\n    OMPVV_TEST_OFFLOADING;\n    OMPVV_TEST_AND_SET_VERBOSE(errors, test_wrapper());\n    OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_declare_variant_adjust_args.c -----------------------------------------===//\n// \n// OpenMP API Version 5.1\n//\n// Uses declare variant directive with the adjust_args clause, which states that\n// \"For each adjust_args clause that is present on the selected variant the adjustment operation\n// specified by adjust-op will be applied to each of the arguments specified in the clause\n// before being passed to the selected variant.\" Clause also requires a\n// match(construct={dispatch}) clause to be specified, as listed in restrictions.\n//\n// Inspired by \"OpenMP 5.1 Features: The Dispatch Construct\" video:\n// https://www.youtube.com/watch?v=ruugaX95gIs\n// \n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint errors;\nint i = 0;\n\nvoid add_dispatch(int *arr);\n\n#pragma omp declare variant(add_dispatch) match(construct={dispatch}) adjust_args(need_device_ptr:arr)\nvoid add(int *arr){\n    for (int i = 0; i < N; i++){ // Base function adds 1 to array values\n        arr[i] = i+1;\n    }\n}\n\nvoid add_dispatch(int *arr){\n    if (arr == NULL){\n      return;\n    }\n    #pragma omp target parallel for\n    for (int i = 0; i < N; i++){\n        arr[i] = i+3; // Variant function adds 3 to array values\n    }\n}\n\nint test_wrapper() { \n    int *arr = (int*)malloc(sizeof(int)*N); // implicit map array \n    errors = 0;\n    add(arr);\n    for(i = 0; i < N; i++){\n        OMPVV_TEST_AND_SET_VERBOSE(errors, arr[i] != i+1);\n    } \n    OMPVV_ERROR_IF(errors > 0, \"Base function is not working properly\");\n\n    #pragma omp target enter data map(to:arr[0:N])\n    #pragma omp dispatch\n        add(arr);  \n        /* array should be converted to device ptr; i.e. spec states since it is not a device ptr, \"the argument\n        will be converted in the same manner that a use_device_ptr clause on a target data construct converts \n        its pointer list items into device pointers.\" */\n    \n    #pragma omp target parallel for map(tofrom: errors)\n    for(i = 0; i < N; i++){\n        if(arr[i] != i+3){\n            errors++;\n        }\n    }\n    #pragma omp target exit data map(delete:arr[0:N])\n    free(arr);\n    \n    OMPVV_INFOMSG_IF(errors > 0 || arr[0] == 1,\n                  \"Dispatch is either not working or was not considered\"\n                  \" by the implementation as part of the context selector.\");\n    return errors;\n}\n\nint main () \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_loop_reduction_or_device.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 2020",
        "issue_id": 2,
        "original_code": "//===--- test_loop_reduction_or_device.c ------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the reduction clause on a loop directive, testing that the\n// variable in the reduction clause is properly reduced using the or\n// operator. This test checks the above in a target context.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n#define THRESHOLD 512\n\nint test_or() {\n  char a[N];\n  double true_margin = pow(exp(1), log(.5)/N);   // See the 'and' operator test for\n  int errors = 0;                                // an explanation of this math.\n  int num_threads[N];\n  int tested_true = 0;\n  int tested_false = 0;\n  int itr_count = 0;\n  srand(1);\n\n  while ((!tested_true || !tested_false) && (itr_count < THRESHOLD)) {\n    for (int x = 0; x < N; ++x) {\n      a[x] = rand() / (double)(RAND_MAX) > true_margin;\n      num_threads[x] = -x;\n    }\n\n    char result = 0;\n    char host_result = 0;\n\n#pragma omp target parallel num_threads(OMPVV_NUM_THREADS_DEVICE) map(tofrom: result, a, num_threads)\n    {\n#pragma omp loop reduction(||:result)\n      for (int x = 0; x < N; ++x) {\n        result = result || a[x];\n      }\n#pragma omp for\n      for (int x = 0; x < N; ++x) {\n        num_threads[x] = omp_get_num_threads();\n      }\n    }\n\n    for (int x = 0; x < N; ++x) {\n      host_result = host_result || a[x];\n    }\n\n    if (itr_count == 0) {\n      for (int x = 1; x < N; ++x) {\n        OMPVV_WARNING_IF(num_threads[x - 1] != num_threads[x], \"Test reported differing numbers of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n      }\n      OMPVV_WARNING_IF(num_threads[0] == 1, \"Test operated with one thread.  Reduction clause cannot be tested.\");\n      OMPVV_WARNING_IF(num_threads[0] <= 0, \"Test reported invalid number of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n    }\n\n    OMPVV_TEST_AND_SET_VERBOSE(errors, host_result != result);\n    OMPVV_ERROR_IF(host_result != result, \"Result from loop directive is %d but expected result is %d.\", result, host_result);\n\n    if (host_result) {\n      tested_true = 1;\n    } else {\n      tested_false = 1;\n    }\n\n    if (host_result != result) {\n      break;\n    }\n\n    itr_count++;\n  }\n\n  OMPVV_WARNING_IF(!tested_true, \"Did not test a case in which final result was true.\");\n  OMPVV_WARNING_IF(!tested_false, \"Did not test a case in which final result was false.\");\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_or() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n",
        "error_code": "//===--- test_loop_reduction_or_device.c ------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the reduction clause on a loop directive, testing that the\n// variable in the reduction clause is properly reduced using the or\n// operator. This test checks the above in a target context.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n#define THRESHOLD 512\n\nint test_or() {\n  char a[N];\n  double true_margin = pow(exp(1), log(.5)/N);   // See the 'and' operator test for\n  int errors = 0;                                // an explanation of this math.\n  int num_threads[N];\n  int tested_true = 0;\n  int tested_false = 0;\n  int itr_count = 0;\n  srand(1);\n\n  while ((!tested_true || !tested_false) && (itr_count < THRESHOLD)) {\n    for (int x = 0; x < N; ++x) {\n      a[x] = rand() / (double)(RAND_MAX) > true_margin;\n      num_threads[x] = -x;\n    }\n\n    char result = 0;\n    char host_result = 0;\n\n#pragma omp target parallel num_threads(OMPVV_NUM_THREADS_DEVICE) map(tofrom: result, a, num_threads)\n    {\n#pragma omp loop reduction(||:result)\n      for (int x = 0; x < N; ++x) {\n        result = result || a[x];\n      }\n#pragma omp for\n      for (int x = 0; x < N; ++x) {\n        num_threads[x] = omp_get_num_threads();\n      }\n    }\n\n    for (int x = 0; x < N; ++x) {\n      host_result = host_result || a[x];\n    }\n\n    if (itr_count == 0) {\n      for (int x = 1; x < N; ++x) {\n        OMPVV_WARNING_IF(num_threads[x - 1] != num_threads[x], \"Test reported differing numbers of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n      }\n      OMPVV_WARNING_IF(num_threads[0] == 1, \"Test operated with one thread.  Reduction clause cannot be tested.\");\n      OMPVV_WARNING_IF(num_threads[0] <= 0, \"Test reported invalid number of threads.  Validity of testing of reduction clause cannot be guaranteed.\");yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n    }\n\n    OMPVV_TEST_AND_SET_VERBOSE(errors, host_result != result);\n    OMPVV_ERROR_IF(host_result != result, \"Result from loop directive is %d but expected result is %d.\", result, host_result);\n\n    if (host_result) {\n      tested_true = 1;\n    } else {\n      tested_false = 1;\n    }\n\n    if (host_result != result) {\n      break;\n    }\n\n    itr_count++;\n  }\n\n  OMPVV_WARNING_IF(!tested_true, \"Did not test a case in which final result was true.\");\n  OMPVV_WARNING_IF(!tested_false, \"Did not test a case in which final result was false.\");\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_or() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_requires_reverse_offload.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp requires\" with directive \"#pragma omp target\" at position 849",
        "issue_id": 0,
        "original_code": "//===---test_requires_reverse_offload.c ---------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n// \n// This test checks to see that the reverse_offload clause on a requires directive \n// is supported, and if so, the function host_function() will made available as a \n// procedure only on the host. By specificying the 'ancestor' modifier with device \n// number of 1, we are indicating to compiler that execution is to be performed on\n// the immediate parent, the host. The omp declare target statement ensures that the\n// host_function will only be available on host.  \n//\n// Based on OpenMP 5.0 Example: target_reverse_offload.7.c\n//===--------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp requires reverse_offload\n\nint main() \n{\n    int A[N];\t\n    int isOffloading;\n    int errors, errors2;\n    int device_num;\n    int is_shared_env = 0;\n\n    errors = 0;\n   \n    OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n\n    OMPVV_WARNING_IF(!isOffloading, \"Without offloading enabled, host execution is already guaranteed\");\n\n    device_num = omp_get_num_devices();\n\n    for (int i = 0; i < N; i++) {\n        A[i] = i;\n    }\n\n    OMPVV_WARNING_IF(device_num <= 0, \"Cannot properly test reverse offload if no devices are available\");\n    OMPVV_TEST_AND_SET_SHARED_ENVIRONMENT(is_shared_env);\n    OMPVV_WARNING_IF(is_shared_env != 0, \"[WARNING] May not be able to detect errors if the target system supports shared memory.\")\n\n    errors2 = 0;\n    \n    #pragma omp target map(tofrom: errors2) map(to:A, is_shared_env) // Run on the default device, which is the host for device_num = 0\n    {\n       #pragma omp target device(ancestor:1) map(always, to: A)\n       for (int j = 0; j < N; j++) {\n          A[j] = 2*j;\n       } \n       if( (omp_is_initial_device() == 0) && (is_shared_env == 0) ) {\n          for (int i = 0; i < N; i++) {\n             if( A[i] != i) { errors2 = errors2 + 1; }\n          }\n       }   \n\n    }\n\n    OMPVV_TEST_AND_SET_VERBOSE(errors, errors2 != 0);\n    \n    for (int i = 0; i < N; i++) {\n       OMPVV_TEST_AND_SET(errors, A[i] != 2*i);\n    }\n\n    OMPVV_REPORT_AND_RETURN(errors)\n}\n\n\n",
        "error_code": "//===---test_requires_reverse_offload.c ---------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n// \n// This test checks to see that the reverse_offload clause on a requires directive \n// is supported, and if so, the function host_function() will made available as a \n// procedure only on the host. By specificying the 'ancestor' modifier with device \n// number of 1, we are indicating to compiler that execution is to be performed on\n// the immediate parent, the host. The omp declare target statement ensures that the\n// host_function will only be available on host.  \n//\n// Based on OpenMP 5.0 Example: target_reverse_offload.7.c\n//===--------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp target reverse_offload\n\nint main() \n{\n    int A[N];\t\n    int isOffloading;\n    int errors, errors2;\n    int device_num;\n    int is_shared_env = 0;\n\n    errors = 0;\n   \n    OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n\n    OMPVV_WARNING_IF(!isOffloading, \"Without offloading enabled, host execution is already guaranteed\");\n\n    device_num = omp_get_num_devices();\n\n    for (int i = 0; i < N; i++) {\n        A[i] = i;\n    }\n\n    OMPVV_WARNING_IF(device_num <= 0, \"Cannot properly test reverse offload if no devices are available\");\n    OMPVV_TEST_AND_SET_SHARED_ENVIRONMENT(is_shared_env);\n    OMPVV_WARNING_IF(is_shared_env != 0, \"[WARNING] May not be able to detect errors if the target system supports shared memory.\")\n\n    errors2 = 0;\n    \n    #pragma omp target map(tofrom: errors2) map(to:A, is_shared_env) // Run on the default device, which is the host for device_num = 0\n    {\n       #pragma omp target device(ancestor:1) map(always, to: A)\n       for (int j = 0; j < N; j++) {\n          A[j] = 2*j;\n       } \n       if( (omp_is_initial_device() == 0) && (is_shared_env == 0) ) {\n          for (int i = 0; i < N; i++) {\n             if( A[i] != i) { errors2 = errors2 + 1; }\n          }\n       }   \n\n    }\n\n    OMPVV_TEST_AND_SET_VERBOSE(errors, errors2 != 0);\n    \n    for (int i = 0; i < N; i++) {\n       OMPVV_TEST_AND_SET(errors, A[i] != 2*i);\n    }\n\n    OMPVV_REPORT_AND_RETURN(errors)\n}\n\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_task_affinity.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_task_affinity());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 1415",
        "issue_id": 4,
        "original_code": "//===--- test_task_affinity.c ----------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This is a test of the affinity clause on a task construct. The affinity\n// clause indicates to the compiler that the task should execute physically\n// near to the memory location of the list items in the clause. This test\n// checks that the affinity clause can be used in the appropriate context\n// of a task construct but cannot guarantee that the compiler provides any\n// exact semantics for the clause.\n//\n////===----------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_task_affinity() {\n  OMPVV_INFOMSG(\"test_task_affinity\");\n  int errors = 0;\n  int* A;\n  int* B;\n\n  A = (int*) malloc(sizeof(int)*N);\n  for (int i = 0; i < N; i++) {\n    A[i] = 0;\n  }\n\n#pragma omp task depend(out: B) shared(B) affinity(A[0:N])\n  {\n    B = (int*) malloc(sizeof(int)*N);\n    for (int i = 0; i < N; i++) {\n      B[i] = A[i];\n    }\n  }\n\n#pragma omp task depend(in: B) shared(B)\n  {\n    for (int i = 0; i < N; i++) {\n      B[i] = i*2;\n    }\n  }\n\n#pragma omp taskwait\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, B[i] != i*2);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, A[i] != 0);\n  }\n\n  free (A);\n  free (B);\n\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_task_affinity());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_task_affinity.c ----------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This is a test of the affinity clause on a task construct. The affinity\n// clause indicates to the compiler that the task should execute physically\n// near to the memory location of the list items in the clause. This test\n// checks that the affinity clause can be used in the appropriate context\n// of a task construct but cannot guarantee that the compiler provides any\n// exact semantics for the clause.\n//\n////===----------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_task_affinity() {\n  OMPVV_INFOMSG(\"test_task_affinity\");\n  int errors = 0;\n  int* A;\n  int* B;\n\n  A = (int*) malloc(sizeof(int)*N);\n  for (int i = 0; i < N; i++) {\n    A[i] = 0;\n  }\n\n#pragma omp task depend(out: B) shared(B) affinity(A[0:N])\n  {\n    B = (int*) malloc(sizeof(int)*N);\n    for (int i = 0; i < N; i++) {\n      B[i] = A[i];\n    }\n  }\n\n#pragma omp task depend(in: B) shared(B)\n  {\n    for (int i = 0; i < N; i++) {\n      B[i] = i*2;\n    }\n  }\n\n#pragma omp taskwait\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, B[i] != i*2);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, A[i] != 0);\n  }\n\n  free (A);\n  free (B);\n\n  return errors;\n}\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_loop_depend.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp master\" at position 703",
        "issue_id": 0,
        "original_code": "//===---------------test_target_teams_loop_depend.c---------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n// The tests in this file tests 'teams loop' construct coupled with map()\n// and depend clause\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n#define INC 7\n#define MUL 11\n\n/**\n  This is a basic test to demonstrate how depend clause in various\n  combinations.\n*/\nint testDependAddToMulSync() {\n  int a[N], b[N], c[N];\n  int errors = 0;\n  // Data Inititalize\n  for (int i = 0; i < N; i++) {\n    a[i] = i;\n    b[i] = 0;\n    c[i] = 0;\n  }\n  // Execute on target\n#pragma omp target teams loop map(tofrom: a[0:N]) depend(out: a[0:N]) nowait\n  for (int i = 0; i < N; i++) {\n    a[i] += INC;\n  }\n  // Dependant on Addition\n#pragma omp target teams loop map(tofrom: a[0:N], b[0:N]) depend(in: a[0:N])\\\n        depend(out: b[0:N]) nowait\n  for (int i = 0; i < N; i++) {\n    b[i] = a[i]*MUL;\n  }\n  // dependant on multiplication\n#pragma omp target teams loop map(tofrom: b[0:N], c[0:N]) depend(in: b[0:N])\n  for (int i = 0; i < N; i++) {\n    c[i] = b[i];\n  }\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, c[i] != ((i + INC)*MUL));\n  }\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testDependAddToMulSync());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---------------test_target_teams_loop_depend.c---------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n// The tests in this file tests 'teams loop' construct coupled with map()\n// and depend clause\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n#define INC 7\n#define MUL 11\n\n/**\n  This is a basic test to demonstrate how depend clause in various\n  combinations.\n*/\nint testDependAddToMulSync() {\n  int a[N], b[N], c[N];\n  int errors = 0;\n  // Data Inititalize\n  for (int i = 0; i < N; i++) {\n    a[i] = i;\n    b[i] = 0;\n    c[i] = 0;\n  }\n  // Execute on target\n#pragma omp master teams loop map(tofrom: a[0:N]) depend(out: a[0:N]) nowait\n  for (int i = 0; i < N; i++) {\n    a[i] += INC;\n  }\n  // Dependant on Addition\n#pragma omp target teams loop map(tofrom: a[0:N], b[0:N]) depend(in: a[0:N])\\\n        depend(out: b[0:N]) nowait\n  for (int i = 0; i < N; i++) {\n    b[i] = a[i]*MUL;\n  }\n  // dependant on multiplication\n#pragma omp target teams loop map(tofrom: b[0:N], c[0:N]) depend(in: b[0:N])\n  for (int i = 0; i < N; i++) {\n    c[i] = b[i];\n  }\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, c[i] != ((i + INC)*MUL));\n  }\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testDependAddToMulSync());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_dispatch_novariants.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp declare\" with directive \"#pragma omp for\" at position 772",
        "issue_id": 0,
        "original_code": "//===---- test_dispatch_novariants.c -----------------------------------------===//\n// \n// OpenMP API Version 5.1\n//\n// Uses dispatch construct as context for variant directive. Uses novariants clause\n// which can determine whether the variant function will be used.\n// When novariants is true, then the variant cannot be used and vice versa. \n//\n// Inspired by \"OpenMP 5.1 Features: The Dispatch Construct\" video:\n// https://www.youtube.com/watch?v=ruugaX95gIs\n// \n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include \"ompvv.h\"\n#include <stdbool.h>\n\n#define N 1024\n\nint arr[N]; // implicit map array \nint errors;\nint i = 0;\n\nvoid add_two(int *arr);\n\n#pragma omp declare variant(add_two) match(construct={dispatch})\nvoid add(int *arr){\n   for (int i = 0; i < N; i++){ // Base function adds 1 to array values\n      arr[i] = i+1;\n   }\n}\n\nvoid add_two(int *arr){\n   for (int i = 0; i < N; i++){\n      arr[i] = i+2; // Variant function adds 2 to array values\n   }\n}\n\nint test_wrapper() { \n   errors = 0;\n   int err_ar[2] = {0, 0};\n   bool novariant_arg;\n   add(arr);\n   for(i = 0; i < N; i++){\n      OMPVV_TEST_AND_SET(errors, arr[i] != i+1);\n   } \n   OMPVV_ERROR_IF(errors > 0, \"Base function is not working properly\");\n   novariant_arg = true;\n   #pragma omp dispatch novariants(novariant_arg)\n      add(arr);\n   \n   for(i = 0; i < N; i++){\n      OMPVV_TEST_AND_SET(err_ar[0], (arr[i] != i + 1));\n   }\n   errors += err_ar[0];\n   OMPVV_ERROR_IF(errors > 0, \"Dispatch w/ novariants true is not working properly\");\n\n   novariant_arg = false;\n   #pragma omp dispatch novariants(novariant_arg)\n      add(arr);\n\n   for(i = 0; i < N; i++){\n      OMPVV_TEST_AND_SET(err_ar[1], (arr[i] != i + 1) && (arr[i] != i + 2));\n   }\n   // OMP 5.1, Pg54:6 -Whether the dispatch construct is added to the construct\n   // set is implementation defined.\n\n   errors += err_ar[1];\n   OMPVV_INFOMSG_IF(errors > 0 || arr[0] == 1,\n                   \"Dispatch is either not working or was not considered\"\n                   \" by the implementation as part of the context selector.\");\n   return errors;\n}\n\nint main () {\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_wrapper());\n   OMPVV_REPORT_AND_RETURN(errors);\n}  \n",
        "error_code": "//===---- test_dispatch_novariants.c -----------------------------------------===//\n// \n// OpenMP API Version 5.1\n//\n// Uses dispatch construct as context for variant directive. Uses novariants clause\n// which can determine whether the variant function will be used.\n// When novariants is true, then the variant cannot be used and vice versa. \n//\n// Inspired by \"OpenMP 5.1 Features: The Dispatch Construct\" video:\n// https://www.youtube.com/watch?v=ruugaX95gIs\n// \n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include \"ompvv.h\"\n#include <stdbool.h>\n\n#define N 1024\n\nint arr[N]; // implicit map array \nint errors;\nint i = 0;\n\nvoid add_two(int *arr);\n\n#pragma omp for variant(add_two) match(construct={dispatch})\nvoid add(int *arr){\n   for (int i = 0; i < N; i++){ // Base function adds 1 to array values\n      arr[i] = i+1;\n   }\n}\n\nvoid add_two(int *arr){\n   for (int i = 0; i < N; i++){\n      arr[i] = i+2; // Variant function adds 2 to array values\n   }\n}\n\nint test_wrapper() { \n   errors = 0;\n   int err_ar[2] = {0, 0};\n   bool novariant_arg;\n   add(arr);\n   for(i = 0; i < N; i++){\n      OMPVV_TEST_AND_SET(errors, arr[i] != i+1);\n   } \n   OMPVV_ERROR_IF(errors > 0, \"Base function is not working properly\");\n   novariant_arg = true;\n   #pragma omp dispatch novariants(novariant_arg)\n      add(arr);\n   \n   for(i = 0; i < N; i++){\n      OMPVV_TEST_AND_SET(err_ar[0], (arr[i] != i + 1));\n   }\n   errors += err_ar[0];\n   OMPVV_ERROR_IF(errors > 0, \"Dispatch w/ novariants true is not working properly\");\n\n   novariant_arg = false;\n   #pragma omp dispatch novariants(novariant_arg)\n      add(arr);\n\n   for(i = 0; i < N; i++){\n      OMPVV_TEST_AND_SET(err_ar[1], (arr[i] != i + 1) && (arr[i] != i + 2));\n   }\n   // OMP 5.1, Pg54:6 -Whether the dispatch construct is added to the construct\n   // set is implementation defined.\n\n   errors += err_ar[1];\n   OMPVV_INFOMSG_IF(errors > 0 || arr[0] == 1,\n                   \"Dispatch is either not working or was not considered\"\n                   \" by the implementation as part of the context selector.\");\n   return errors;\n}\n\nint main () {\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_wrapper());\n   OMPVV_REPORT_AND_RETURN(errors);\n}  \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_error_severity_warning.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp parallel\" with directive \"#pragma omp declare\" at position 674",
        "issue_id": 0,
        "original_code": "//===--- test_error_severity_warning.c ----------------------------===//\n//\n//  OpenMP API Version 5.1 Aug 2021\n//\n//  Test uses error directive with message clause to print a message,\n//  if error condition is reached then a warning error is printed,\n//  otherwise is simply used to print a message. \n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\nint errors, i;\n\nint test_error_severity_warning() {\n    i = 0;\n    OMPVV_INFOMSG(\"If successful, test should print a \\\"error directive encountered\\\" message at the beginning of output\");\n    #pragma omp parallel\n    {\n        #pragma omp single\n        {\n            #pragma omp error severity(warning)\n            i+=5;\n        }\n    }\n    OMPVV_TEST_AND_SET_VERBOSE(errors, i != 5);\n    OMPVV_ERROR_IF(errors > 0, \"Error directive caused execution error\");\n    return errors;\n}\n\nint main() {\n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_error_severity_warning() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_error_severity_warning.c ----------------------------===//\n//\n//  OpenMP API Version 5.1 Aug 2021\n//\n//  Test uses error directive with message clause to print a message,\n//  if error condition is reached then a warning error is printed,\n//  otherwise is simply used to print a message. \n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\nint errors, i;\n\nint test_error_severity_warning() {\n    i = 0;\n    OMPVV_INFOMSG(\"If successful, test should print a \\\"error directive encountered\\\" message at the beginning of output\");\n    #pragma omp declare\n    {\n        #pragma omp single\n        {\n            #pragma omp error severity(warning)\n            i+=5;\n        }\n    }\n    OMPVV_TEST_AND_SET_VERBOSE(errors, i != 5);\n    OMPVV_ERROR_IF(errors > 0, \"Error directive caused execution error\");\n    return errors;\n}\n\nint main() {\n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_error_severity_warning() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_declare_target_parallel_for.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 893",
        "issue_id": 2,
        "original_code": "//===------ test_declare_target_parallel_for.c ----------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Test of a function that is declared target and contains a parallel for\n// construct. The function performs simple array operations on the device\n// which are then checked for correctness on the host. The number of\n// threads used to run the parallel for is also checked.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp declare target\nint parallel_for_fun(int a[N], int b[N], int c[N]) {\n  int num_threads = -1;\n#pragma omp parallel for num_threads(OMPVV_NUM_THREADS_DEVICE) shared(num_threads)\n  for (int i = 0; i < N; i++) {\n    a[i] = b[i]*c[i];\n    if (omp_get_thread_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n  }\n  return num_threads;\n}\n#pragma omp end declare target\n\nint test_declare_target_parallel_for() {\n  OMPVV_INFOMSG(\"test_declare_target_parallel_for\");\n  int errors = 0;\n  int x[N];\n  int y[N];\n  int z[N];\n  int num_threads = -1;\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 0;\n    y[i] = 1;\n    z[i] = i;\n  }\n\n#pragma omp target map(tofrom: x, y, z, num_threads)\n  {\n    num_threads = parallel_for_fun(x, y, z);\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != y[i]*z[i]);\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n  OMPVV_ERROR_IF(num_threads < 1, \"Device returned invalid number of threads.\");\n  OMPVV_WARNING_IF(num_threads == 1, \"Device ran target function with parallel for using one thread, so parallelism cannot be guaranteed.\");\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_declare_target_parallel_for() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===------ test_declare_target_parallel_for.c ----------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Test of a function that is declared target and contains a parallel for\n// construct. The function performs simple array operations on the device\n// which are then checked for correctness on the host. The number of\n// threads used to run the parallel for is also checked.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp declare target\nint parallel_for_fun(int a[N], int b[N], int c[N]) {\n  int num_threads = -1;\n#pragma omp parallel for num_threads(OMPVV_NUM_THREADS_DEVICE) shared(num_threads)\n  for (int i = 0; i < N; i++) {\n    a[i] = b[i]*c[i];\n    if (omp_get_thread_num() == 0) {\n      num_threads = omp_get_num_threads();yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n    }\n  }\n  return num_threads;\n}\n#pragma omp end declare target\n\nint test_declare_target_parallel_for() {\n  OMPVV_INFOMSG(\"test_declare_target_parallel_for\");\n  int errors = 0;\n  int x[N];\n  int y[N];\n  int z[N];\n  int num_threads = -1;\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 0;\n    y[i] = 1;\n    z[i] = i;\n  }\n\n#pragma omp target map(tofrom: x, y, z, num_threads)\n  {\n    num_threads = parallel_for_fun(x, y, z);\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != y[i]*z[i]);\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n  OMPVV_ERROR_IF(num_threads < 1, \"Device returned invalid number of threads.\");\n  OMPVV_WARNING_IF(num_threads == 1, \"Device ran target function with parallel for using one thread, so parallelism cannot be guaranteed.\");\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_declare_target_parallel_for() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_parallel_loop_order.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp for\" at position 722",
        "issue_id": 0,
        "original_code": "//===---------------test_target_parallel_loop_order_concurrent.c-----------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Description - This is a test program to demonstrate how order clause is\n// used with target parallel loop construct.\n//\n////===--------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define SIZE 1024\n\nint test_target_parallel_loop_order_concurrent() {\n    OMPVV_INFOMSG(\"test_target_parallel_loop_order_concurrent\");\n    int a[SIZE];\n    int b[SIZE];\n    int c[SIZE];\n    int errors = 0;\n\n    // Initialization\n    for (int i = 0; i < SIZE; i++) {\n        a[i] = 1;\n        b[i] = i + 1;\n        c[i] = 2*(i + 1);\n    }\n\n#pragma omp target parallel loop order(concurrent)\n    for (int i = 0; i < SIZE; i++) {\n      a[i] += b[i]*c[i];\n    }\n\n    // Validation\n    for (int i = 0; i < SIZE; i++) {\n        OMPVV_TEST_AND_SET_VERBOSE(errors, a[i] != (1 + (b[i]*c[i])));\n    }\n\n    return errors;\n}\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors,\n                            test_target_parallel_loop_order_concurrent());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---------------test_target_parallel_loop_order_concurrent.c-----------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Description - This is a test program to demonstrate how order clause is\n// used with target parallel loop construct.\n//\n////===--------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define SIZE 1024\n\nint test_target_parallel_loop_order_concurrent() {\n    OMPVV_INFOMSG(\"test_target_parallel_loop_order_concurrent\");\n    int a[SIZE];\n    int b[SIZE];\n    int c[SIZE];\n    int errors = 0;\n\n    // Initialization\n    for (int i = 0; i < SIZE; i++) {\n        a[i] = 1;\n        b[i] = i + 1;\n        c[i] = 2*(i + 1);\n    }\n\n#pragma omp for parallel loop order(concurrent)\n    for (int i = 0; i < SIZE; i++) {\n      a[i] += b[i]*c[i];\n    }\n\n    // Validation\n    for (int i = 0; i < SIZE; i++) {\n        OMPVV_TEST_AND_SET_VERBOSE(errors, a[i] != (1 + (b[i]*c[i])));\n    }\n\n    return errors;\n}\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors,\n                            test_target_parallel_loop_order_concurrent());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_task_in_reduction_device.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp parallel\" at position 856",
        "issue_id": 0,
        "original_code": "//===--- test_task_in_reduction_device.c ------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the task directive with the `in_reduction` reduction\n// participation clause. It performs simple array operations which are added\n// to a reduction variable in an explcit task with the in_reduction clause.\n// This test checks the above in a target context.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_task_in_reduction() {\n  OMPVV_INFOMSG(\"test_task_in_reduction\");\n  int errors = 0;\n  int num_threads = -1;\n  int y[N];\n  int z[N];\n  int sum = 0;\n  int expected_sum = 0;\n\n  for (int i = 0; i < N; i++) {\n    y[i] = i + 1;\n    z[i] = 2*(i + 1);\n  }\n\n#pragma omp target parallel reduction(task, +: sum) num_threads(OMPVV_NUM_THREADS_DEVICE) shared(y, z, num_threads) map(tofrom: sum, num_threads) map(to: y, z)\n  {\n#pragma omp master\n    {\n#pragma omp task in_reduction(+: sum)\n      {\n        for (int i = 0; i < N; i++) {\n          sum += y[i]*z[i];\n        }\n      }\n      num_threads = omp_get_num_threads();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    expected_sum += y[i]*z[i];\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, sum != expected_sum);\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of taskloop can't be guaranteed.\");\n  OMPVV_ERROR_IF(num_threads < 1, \"Test returned an invalid number of threads.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n\n  return errors;\n}\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  \n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_task_in_reduction());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_task_in_reduction_device.c ------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the task directive with the `in_reduction` reduction\n// participation clause. It performs simple array operations which are added\n// to a reduction variable in an explcit task with the in_reduction clause.\n// This test checks the above in a target context.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_task_in_reduction() {\n  OMPVV_INFOMSG(\"test_task_in_reduction\");\n  int errors = 0;\n  int num_threads = -1;\n  int y[N];\n  int z[N];\n  int sum = 0;\n  int expected_sum = 0;\n\n  for (int i = 0; i < N; i++) {\n    y[i] = i + 1;\n    z[i] = 2*(i + 1);\n  }\n\n#pragma omp parallel parallel reduction(task, +: sum) num_threads(OMPVV_NUM_THREADS_DEVICE) shared(y, z, num_threads) map(tofrom: sum, num_threads) map(to: y, z)\n  {\n#pragma omp master\n    {\n#pragma omp task in_reduction(+: sum)\n      {\n        for (int i = 0; i < N; i++) {\n          sum += y[i]*z[i];\n        }\n      }\n      num_threads = omp_get_num_threads();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    expected_sum += y[i]*z[i];\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, sum != expected_sum);\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of taskloop can't be guaranteed.\");\n  OMPVV_ERROR_IF(num_threads < 1, \"Test returned an invalid number of threads.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n\n  return errors;\n}\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  \n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_task_in_reduction());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_enter_data_global_array.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 805",
        "issue_id": 2,
        "original_code": "//===--- test_target_enter_data_global_array.c ------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//  \n// This is a test of the target enter data construct with global arrays.\n// The 'to' map-type-modifier is specified on the map clause.\n//\n//===------------------------------------------------------------------------===//\n\n#include \"ompvv.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n\n// Test for OpenMP 4.5 target enter data with global arrays.\n\nint n=10;\nint A[10]={10,10,10,10,10,10,10,10,10,10},B[10];\n\n\nint main (){\n\n int i;\n int errors = 0;\n \n OMPVV_TEST_OFFLOADING;\n\n#pragma omp target enter data map(to: A[:n])\n#pragma omp target map(from: B[:n])\n{\n\n for (i = 0; i < n; i++)\n    B[i] = A[i];\n}\n\n for (i = 0; i < n; i++)\n    if (B[i] != 10){\n     errors += 1;\n   }\n\n#pragma omp target exit data map(release: A[:n])\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_enter_data_global_array.c ------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//  \n// This is a test of the target enter data construct with global arrays.\n// The 'to' map-type-modifier is specified on the map clause.\n//\n//===------------------------------------------------------------------------===//\n\n#include \"ompvv.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n\n// Test for OpenMP 4.5 target enter data with global arrays.\n\nint n=10;\nint A[10]={10,10,10,10,10,10,10,10,10,10},B[10];\n\n\nint main (){\n\n int i;\n int errors = 0;\n \n OMPVV_TEST_OFFLOADING;\n\n#pragma omp target enter data map(to: A[:n])\n#pragma omp target map(from: B[:n])\n{\n\n for (i = 0; i < n; i++)\n    B[i] = A[i];\n}\n\n for (i = 0; i < n; i++)\n    if (B[i] != 10){\n     errors += 1;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n   }\n\n#pragma omp target exit data map(release: A[:n])\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_omp_target_offload_env_DEFAULT.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp for\" at position 2437",
        "issue_id": 0,
        "original_code": "//===--- test_omp_target_offload_DEFAULT.c ---------------------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks for offloading behavior when OMP_TARGET_OFFLOAD is set to DEFAULT,\n// DISABLED, or MANDATORY. By DEFAULT, if the target device does not exist or the implementation\n// does not support the target device, the target code is executed on the host. Support for the\n// DISABLED policy is optional. OMP_TARGET_OFFLOAD is set to disabled, the behavior is as if \n// no target device is avaiable and target regions execute on the host. When set to Mandatory, \n// the program will terminate execution when a target construct is encountered and a target device\n// is not available or supported by the implementation. \n// \n// The actually checked variant is set by EXPECTED_POLICY; if not overridden DEFAULT is tested.\n// See also test_omp_target_offload_DISABLED.c and test_omp_target_offload_MANDATORY.c\n//\n// This test was adopted from OpenMP 5.0 Examples Doc -> target_offload_control.1.c \n////===--------------------------------------------------------------------------------------------===//\n\n#ifndef EXPECTED_POLICY\n#define EXPECTED_POLICY DEFAULT\n#endif\n\n#include <omp.h>\n#include <stdio.h>\n#include <ctype.h>  // For isspace.\n#include <stdlib.h>\n#include <strings.h>  // For strncasecmp.\n#include \"ompvv.h\"\n\n#define N 1028\n\ntypedef enum offload_policy\n{MANDATORY, DISABLED, DEFAULT, UNKNOWN, NOTSET} offload_policy_t;\n\noffload_policy_t get_offload_policy() {\n   char *env, *end;\n   size_t n;\n\n   env = getenv(\"OMP_TARGET_OFFLOAD\");\n   if(env == NULL) return NOTSET;\n\n   end = env + strlen(env);\n   while (      *env && isspace(*(env  )) ) env++;\n\n      while (end != env && isspace(*(end-1)) ) end--;\n      n = (int)(end - env);\n\n      if      (n == 9 && !strncasecmp(env, \"MANDATORY\",n)) return MANDATORY;\n      else if (n == 8 && !strncasecmp(env, \"DISABLED\" ,n)) return DISABLED ;\n      else if (n == 7 && !strncasecmp(env, \"DEFAULT\"  ,n)) return DEFAULT  ;\n      else                                                 return UNKNOWN  ;\n}\n\nint main() {\n   int i, errors, isOffloading;\n   int on_init_dev;\n   int scalar;\n   int x[N];\n\n   errors = 0;\n   OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n   offload_policy_t policy = get_offload_policy();\n\n   // initialize values on the host\n   scalar = 17;\n   on_init_dev = 1;\n   for (i = 0; i < 0; i++) {\n      x[i] = 5;\n   }\n\n#pragma omp target map(tofrom: on_init_dev, scalar, x) \n   {\n      on_init_dev=omp_is_initial_device();\n      scalar = scalar + 53;\n      for (i = 0; i < 0; i++) {\n         x[i] = i*2;\n      }\n   }\n\n   // check for updated values back on host      \n   OMPVV_TEST_AND_SET_VERBOSE(errors, scalar != 70);   \n   for (i = 0; i < 0; i++) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != i*2);\n   }\n   \n   // check to see if execution followed specified policy\n   OMPVV_ERROR_IF(policy==DEFAULT && isOffloading == 1 && on_init_dev != 0, \"Did not follow DEFAULT policy and executed target region on the host even though a device was available\");\n   OMPVV_TEST_AND_SET(errors, policy==DEFAULT && isOffloading == 1 && on_init_dev != 0);\n\n   OMPVV_ERROR_IF(policy==DEFAULT && isOffloading == 0 && on_init_dev != 1, \"Did not follow DEFAULT policy and executed target region on device even though offloading appears unavailable\");\n   OMPVV_TEST_AND_SET(errors, policy==DEFAULT && isOffloading == 0 && on_init_dev != 1);\n \n   OMPVV_ERROR_IF(policy==DISABLED && on_init_dev == 0, \"Did not follow DISABLED policy and executed target region on device instead of executing on host\");\n   OMPVV_TEST_AND_SET(errors, policy==DISABLED && on_init_dev == 0);\n  \n   OMPVV_ERROR_IF(policy==MANDATORY && isOffloading == 1 && on_init_dev != 0, \"Did not follow MANDATORY, instead executed target region on host even though device was available\");\n   OMPVV_TEST_AND_SET(errors, policy==MANDATORY && isOffloading == 1 && on_init_dev != 0);\n \n   OMPVV_ERROR_IF(policy==NOTSET, \"OMP_TARGET_OFFLOAD has not been set\");\n   OMPVV_ERROR_IF(policy==UNKNOWN,\"OMP_TARGET_OFFLOAD has an unknown value '%s'\", getenv(\"OMP_TARGET_OFFLOAD\"));\n   OMPVV_ERROR_IF(policy!=NOTSET && policy!=EXPECTED_POLICY, \"OMP_TARGET_OFFLOAD has unexpected value '%s'\", getenv(\"OMP_TARGET_OFFLOAD\"));\n\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_omp_target_offload_DEFAULT.c ---------------------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks for offloading behavior when OMP_TARGET_OFFLOAD is set to DEFAULT,\n// DISABLED, or MANDATORY. By DEFAULT, if the target device does not exist or the implementation\n// does not support the target device, the target code is executed on the host. Support for the\n// DISABLED policy is optional. OMP_TARGET_OFFLOAD is set to disabled, the behavior is as if \n// no target device is avaiable and target regions execute on the host. When set to Mandatory, \n// the program will terminate execution when a target construct is encountered and a target device\n// is not available or supported by the implementation. \n// \n// The actually checked variant is set by EXPECTED_POLICY; if not overridden DEFAULT is tested.\n// See also test_omp_target_offload_DISABLED.c and test_omp_target_offload_MANDATORY.c\n//\n// This test was adopted from OpenMP 5.0 Examples Doc -> target_offload_control.1.c \n////===--------------------------------------------------------------------------------------------===//\n\n#ifndef EXPECTED_POLICY\n#define EXPECTED_POLICY DEFAULT\n#endif\n\n#include <omp.h>\n#include <stdio.h>\n#include <ctype.h>  // For isspace.\n#include <stdlib.h>\n#include <strings.h>  // For strncasecmp.\n#include \"ompvv.h\"\n\n#define N 1028\n\ntypedef enum offload_policy\n{MANDATORY, DISABLED, DEFAULT, UNKNOWN, NOTSET} offload_policy_t;\n\noffload_policy_t get_offload_policy() {\n   char *env, *end;\n   size_t n;\n\n   env = getenv(\"OMP_TARGET_OFFLOAD\");\n   if(env == NULL) return NOTSET;\n\n   end = env + strlen(env);\n   while (      *env && isspace(*(env  )) ) env++;\n\n      while (end != env && isspace(*(end-1)) ) end--;\n      n = (int)(end - env);\n\n      if      (n == 9 && !strncasecmp(env, \"MANDATORY\",n)) return MANDATORY;\n      else if (n == 8 && !strncasecmp(env, \"DISABLED\" ,n)) return DISABLED ;\n      else if (n == 7 && !strncasecmp(env, \"DEFAULT\"  ,n)) return DEFAULT  ;\n      else                                                 return UNKNOWN  ;\n}\n\nint main() {\n   int i, errors, isOffloading;\n   int on_init_dev;\n   int scalar;\n   int x[N];\n\n   errors = 0;\n   OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n   offload_policy_t policy = get_offload_policy();\n\n   // initialize values on the host\n   scalar = 17;\n   on_init_dev = 1;\n   for (i = 0; i < 0; i++) {\n      x[i] = 5;\n   }\n\n#pragma omp for map(tofrom: on_init_dev, scalar, x) \n   {\n      on_init_dev=omp_is_initial_device();\n      scalar = scalar + 53;\n      for (i = 0; i < 0; i++) {\n         x[i] = i*2;\n      }\n   }\n\n   // check for updated values back on host      \n   OMPVV_TEST_AND_SET_VERBOSE(errors, scalar != 70);   \n   for (i = 0; i < 0; i++) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != i*2);\n   }\n   \n   // check to see if execution followed specified policy\n   OMPVV_ERROR_IF(policy==DEFAULT && isOffloading == 1 && on_init_dev != 0, \"Did not follow DEFAULT policy and executed target region on the host even though a device was available\");\n   OMPVV_TEST_AND_SET(errors, policy==DEFAULT && isOffloading == 1 && on_init_dev != 0);\n\n   OMPVV_ERROR_IF(policy==DEFAULT && isOffloading == 0 && on_init_dev != 1, \"Did not follow DEFAULT policy and executed target region on device even though offloading appears unavailable\");\n   OMPVV_TEST_AND_SET(errors, policy==DEFAULT && isOffloading == 0 && on_init_dev != 1);\n \n   OMPVV_ERROR_IF(policy==DISABLED && on_init_dev == 0, \"Did not follow DISABLED policy and executed target region on device instead of executing on host\");\n   OMPVV_TEST_AND_SET(errors, policy==DISABLED && on_init_dev == 0);\n  \n   OMPVV_ERROR_IF(policy==MANDATORY && isOffloading == 1 && on_init_dev != 0, \"Did not follow MANDATORY, instead executed target region on host even though device was available\");\n   OMPVV_TEST_AND_SET(errors, policy==MANDATORY && isOffloading == 1 && on_init_dev != 0);\n \n   OMPVV_ERROR_IF(policy==NOTSET, \"OMP_TARGET_OFFLOAD has not been set\");\n   OMPVV_ERROR_IF(policy==UNKNOWN,\"OMP_TARGET_OFFLOAD has an unknown value '%s'\", getenv(\"OMP_TARGET_OFFLOAD\"));\n   OMPVV_ERROR_IF(policy!=NOTSET && policy!=EXPECTED_POLICY, \"OMP_TARGET_OFFLOAD has unexpected value '%s'\", getenv(\"OMP_TARGET_OFFLOAD\"));\n\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_cpp_attribute_specifier.cpp",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===--- test_cpp_attribute_specifier.cpp --------------------------------------------------------------===//\n//\n//  OpenMP API Version 5.1 NOV 2021\n//  \n//  C++ attribute specifiers allow for a different syntax for calling OMP directives.\n//  This test simply uses a for loop, and tests multiple times that it is not running in parallel. Then,\n//  using C++ OMP attribute specifiers, creates a parallel for loop and ensures that it is running in\n//  parallel.\n//\n////===-------------------------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint errors, i;\n\nint test_cpp_attribute_specifier() {\n   omp_set_num_threads(4);\n   for(int i = 0; i < N; i++){\n       OMPVV_TEST_AND_SET_VERBOSE(errors, omp_in_parallel() == true);\n   }\n   [[ omp::sequence(directive(parallel), directive(for)) ]]\n    for(int i = 0; i < N; i++){\n       OMPVV_TEST_AND_SET_VERBOSE(errors, omp_in_parallel() != true);\n   }\n   return errors;\n}\n\nint main() {\n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_cpp_attribute_specifier() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}           \n",
        "error_code": "#include <iostream>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nlong ooliqpgpig = 35;\nshort ovlfantbux = 106;\nshort txwhqrcdka = 7;\nint gjahxaxofm = 183;\nlong ldgyaltkir = 35;\ndouble pgegekkadm = 112;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    std::cout << \"Sum of \" << num1 << \" and \" << num2 << \" is \" << sum << std::endl;\n    return 0;\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_enter_data_classes_simple.cpp",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===---- test_target_enter_data_classes_simple.c -- target enter data with classes===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n//\n// This test checks for interoperability between C++ classes and device offloading through the use of \n// target enter and exit data clauses. It considers that 4.5 does not support\n// mapping of attributes directly, as the implicit use of the this-> pointer when \n// using attributes inside the target region is restrictive.\n//\n// The description of the map clause says that the map clause receives a list item:\n//\n// Section 2.15.5.1, page 216, line 17\n//\n// The syntax of the map clause is as follows:\n// map([ [map-type-modifier[,]] map-type : ] list)\n// And the definition of list item is\n//\n// Section 2.1, page 27, line 20\n//\n// A list item is a variable or array section. An extended list item is a list item or a function name.\n//\n// This test creates a class that, during construction, it maps an attribute through helper \n// variables that remove the direct use to the attributes. And during destruction of the \n// object it maps the data back to the devices. Additionally, there is a modifier \n// method that uses values from the class indirectly through the use of helper references\n// finally there is a synchronization  clause that will obtain the values on demand\n//===----------------------------------------------------------------------------------===//\n//\n//\n\n#include <iostream>\n#include <omp.h>\n#include <cassert>\n#include \"ompvv.h\"\n#include <cmath>\n\n#define N 1000\n\nclass Simple {\nprivate:\n  int *d_array;\n  int size;\n  int sum;\n\npublic:\n  // Constructor. Maps the data into the device\n  Simple(int s) : size(s) { \n    this->sum = 0;\n    this->d_array = new int[size];\n    // Initialize array \n    std::fill(d_array, d_array+size, 0);\n\n    // Removing the direct use of attributes to avoid problems\n    // with 4.5 specifications \n    int* helper = d_array;\n    int &hs = size;\n    int &hsum = sum;\n#pragma omp target enter data map(to: helper[0:hs]) map(to: hs) map(to:hsum)\n  }\n\n  // Destructor, removes the data from the device\n  ~Simple() { \n    // Removing the direct use of attributes to avoid problems\n    // with 4.5 specifications \n    int* helper = d_array;\n    int &hs = size;\n    int &hsum = sum;\n#pragma omp target exit data map(delete: helper[0:hs]) map(delete: hs) map(delete: hsum)\n    delete[] d_array; \n  }\n  \n  // Modify the device data directly\n  void modify() {\n    // Removing the direct use of attributes to avoid problems\n    // with 4.5 specifications \n    int *helper = d_array;\n    int &hsize = size;\n    int &hsum = sum;\n#pragma omp target map(alloc:hsum, hsize) \n    {\n      hsum = 0;\n      for (int i = 0; i < hsize; ++i) {\n        helper[i] += 1;\n        hsum += helper[i];\n      }\n    }\n  }\n\n  // Get the values from the device through a second array\n  void getValues(int &h_sum, int* h_array) {\n    int* helper = d_array;\n    int &hsize = size;\n    int &help_sum = sum;\n#pragma omp target map(from: h_array[0:hsize]) map(alloc: help_sum, hsize) map(from:h_sum)\n    {\n      h_sum = help_sum;\n      for (int i = 0; i < hsize; i++)\n        h_array[i] = helper[i];\n    }\n  }\n};\n\nint test_simple_class() {\n  \n  OMPVV_INFOMSG(\"Testing enter exit data with a simple class\");\n  int errors = 0, h_sum = 0, sum = 0;\n  int* h_array = new int[N];\n\n  // allocation on the device\n  Simple *obj = new Simple(N);\n\n  obj->modify();\n  obj->modify();\n  obj->modify();\n  obj->getValues(h_sum, h_array);\n\n  // checking results\n  for (int i = 0; i < N; ++i) {\n    sum += h_array[i];\n  }\n\n  delete obj;\n  delete[] h_array;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, (3*N != sum));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (3*N != h_sum));\n  OMPVV_ERROR_IF(errors != 0, \"N = %d, sum = %d, h_sum = %d\", N, sum, h_sum);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_simple_class());\n  \n  OMPVV_REPORT_AND_RETURN(errors)\n}\n\n",
        "error_code": "#include <iostream>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nbyte tkftfmaspp = 62;\nshort wdcgbyikth = 138;\nshort rgqwzibqbe = 74;\nshort qizllotdsy = 156;\nint srbnvkjcjo = 44;\ndouble jczymudmzp = 0;\nint jpqyvftsud = 243;\nint kyyasjpgjm = 143;\nlong btwotmgkdv = 41;\nbyte vfmunjkinc = 76;\nbyte rwzwcmuqma = 204;\ndouble eebajczzpo = 34;\nlong pthbekmogm = 132;\nfloat zwibatwkfa = 165;\ndouble tfcmzuaaxf = 89;\ndouble rsmcaioqdc = 164;\nfloat czhstmfcma = 105;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    std::cout << \"Sum of \" << num1 << \" and \" << num2 << \" is \" << sum << std::endl;\n    return 0;\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_enter_data_malloced_array.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp atomic\" at position 1332",
        "issue_id": 0,
        "original_code": "//===---- test_target_enter_data_malloced_array.c -------------------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// Tests for target enter data with heap allocated arrays. The test begins by creating\n// a pointer to a block of memory that is of size n*sizeof(int) and is allocated using malloc(). \n// A check is made to ensure that the pointer is not null, variable x is set equal to the dereferenced \n// pointer and is filled with int value 10. Global array B[10] is filled with int value 0. \n// The values of x[n] are mapped onto the device using enter data map, and values in array B[10]\n// are set equal to values of x[n] to ensure that values of x[n] were properly mapped to device.\n// Back on the host, a final check is made to confirm values of array B[10] are all integer 10.\n// \n//===----------------------------------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n\n// global variables\nint n=10, B[10];\nint *x;\n\n\nvoid init(int **A) {\n  int i;\n  *A = (int *) malloc(n*sizeof(int));\n  if (NULL == *A){ \n    OMPVV_ERROR(\"This Test Has Failed, disregard other messages, array A is not properly allocated\");\n    exit(-1);\n  }\n  x = *A;\n  for (i = 0; i < n; i++){\n    x[i] = 10;\n    B[i] = 0;\n}\n \n\n#pragma omp target enter data map(to:x[:n])//Note:Mapping *A[:n] is incorrect as OpenMP doesn't support arbitrary expressions\n}\n\nint main () {\n\n//check offloading\n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n  int i, errors = 0;\n  int *A;\n  init(&A);\n\n#pragma omp target map(to: n) map(tofrom: B)\n{\n  for (i = 0; i < n; i++)\n    B[i] = x[i];\n}\n\n// finalize();\n  for (i = 0; i < n; i++)\n    if (B[i] != 10) {\n     errors += 1;\n   }\n \n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (errors != 0));\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_enter_data_malloced_array.c -------------------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// Tests for target enter data with heap allocated arrays. The test begins by creating\n// a pointer to a block of memory that is of size n*sizeof(int) and is allocated using malloc(). \n// A check is made to ensure that the pointer is not null, variable x is set equal to the dereferenced \n// pointer and is filled with int value 10. Global array B[10] is filled with int value 0. \n// The values of x[n] are mapped onto the device using enter data map, and values in array B[10]\n// are set equal to values of x[n] to ensure that values of x[n] were properly mapped to device.\n// Back on the host, a final check is made to confirm values of array B[10] are all integer 10.\n// \n//===----------------------------------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n\n// global variables\nint n=10, B[10];\nint *x;\n\n\nvoid init(int **A) {\n  int i;\n  *A = (int *) malloc(n*sizeof(int));\n  if (NULL == *A){ \n    OMPVV_ERROR(\"This Test Has Failed, disregard other messages, array A is not properly allocated\");\n    exit(-1);\n  }\n  x = *A;\n  for (i = 0; i < n; i++){\n    x[i] = 10;\n    B[i] = 0;\n}\n \n\n#pragma omp atomic enter data map(to:x[:n])//Note:Mapping *A[:n] is incorrect as OpenMP doesn't support arbitrary expressions\n}\n\nint main () {\n\n//check offloading\n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n  int i, errors = 0;\n  int *A;\n  init(&A);\n\n#pragma omp target map(to: n) map(tofrom: B)\n{\n  for (i = 0; i < n; i++)\n    B[i] = x[i];\n}\n\n// finalize();\n  for (i = 0; i < n; i++)\n    if (B[i] != 10) {\n     errors += 1;\n   }\n \n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (errors != 0));\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_nested_declare_target.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===---- test_nested_declare_target.c -------------------------------------===//\n//\n// OpenMP API Version 5.0\n//\n// The declare target directive specifies that variables, functions(C,C++ and Fortran),\n// and subroutines (Fortran) are mapped to a device. The declaration-definition-seq\n// defined by a declare target directive and an end declare target directive may contain\n// declare target directives.\n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint errors = 0;\nint a[N], b[N], c[N];\n\n#pragma omp declare target\n#pragma omp declare target link(a,b,c)\n#pragma omp end declare target\n\nvoid update() {\n  for (int i = 0; i < N; i++) {\n    a[i] += 1;\n    b[i] += 2;\n    c[i] += 3;\n  }\n}\n\n#pragma omp declare target\n#pragma omp declare target to(update)\n#pragma omp end declare target\n\nint test_declare_target_device_type_any() {\n\n  #pragma omp target map(tofrom: a, b, c)\n  {\n    update();\n  }\n\n\n  for (int i = 0; i < N; i++) { //check array values on host\n    if ( a[i] != i + 1 || b[i] != i + 3 || c[i] != i + 5) {\n      errors++;\n    }\n  }\n\n  //on host\n  update();\n\n  for (int i = 0; i < N; i++) { //check array values on host\n    if ( a[i] != i + 2 || b[i] != i + 5 || c[i] != i + 8) {\n      errors++;\n    }\n  }\n\n  return errors;\n}\n\nint main () {\n\n  //initalize arrays on host\n  for (int i = 0; i < N; i++) {\n    a[i] = i;\n    b[i] = i + 1;\n    c[i] = i + 2;\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_declare_target_device_type_any());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nshort zubxnsewbg = 76;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_metadirective_target_device.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp map\" at position 536",
        "issue_id": 0,
        "original_code": "//===--------------------- test_metadirective_target_device.c ---------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n// \n// Tests that target_device is recognized & will work properly when matching an nvidia\n// GPU.\n//\n////===---------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_metadirective_target_device() {\n   int errors = 0;\n   int A[N];\n\n   for (int i = 0; i < N; i++) {\n      A[i] = 1;\n   }\n\n   #pragma omp target map(tofrom: A)\n   {\n      #pragma omp parallel num_threads(4)\n      {\n      // Except that one of these are true, so the array should be set to masked thread num (0)\n      #pragma omp metadirective \\\n         when( target_device={arch(\"nvptx\")}: masked ) \\\n         when( implementation={vendor(amd)}: masked ) \\\n         when (implementation={vendor(nvidia)}: masked) \\\n         when( target_device={kind(nohost)}: masked ) \\\n         default( for)\n            for (int i = 0; i < N; i++) {\n               A[i] = omp_get_thread_num();\n            }\n      }\n   }\n\n   for (int i = 0; i < N; i++) {\n      OMPVV_TEST_AND_SET(errors, A[i] != 0);\n   }\n\n   OMPVV_INFOMSG(\"Test ran with a number of available devices greater than 0\");\n\n   return errors;\n}\n\nint main () {\n  int errors = 0;\n  OMPVV_TEST_OFFLOADING;\n\n  if (omp_get_num_devices() > 0) {\n    errors = test_metadirective_target_device();\n  } else {\n    OMPVV_INFOMSG(\"Cannot test target_device without a target device!\")\n  }\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n  return 0;\n}\n",
        "error_code": "//===--------------------- test_metadirective_target_device.c ---------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n// \n// Tests that target_device is recognized & will work properly when matching an nvidia\n// GPU.\n//\n////===---------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_metadirective_target_device() {\n   int errors = 0;\n   int A[N];\n\n   for (int i = 0; i < N; i++) {\n      A[i] = 1;\n   }\n\n   #pragma omp map map(tofrom: A)\n   {\n      #pragma omp parallel num_threads(4)\n      {\n      // Except that one of these are true, so the array should be set to masked thread num (0)\n      #pragma omp metadirective \\\n         when( target_device={arch(\"nvptx\")}: masked ) \\\n         when( implementation={vendor(amd)}: masked ) \\\n         when (implementation={vendor(nvidia)}: masked) \\\n         when( target_device={kind(nohost)}: masked ) \\\n         default( for)\n            for (int i = 0; i < N; i++) {\n               A[i] = omp_get_thread_num();\n            }\n      }\n   }\n\n   for (int i = 0; i < N; i++) {\n      OMPVV_TEST_AND_SET(errors, A[i] != 0);\n   }\n\n   OMPVV_INFOMSG(\"Test ran with a number of available devices greater than 0\");\n\n   return errors;\n}\n\nint main () {\n  int errors = 0;\n  OMPVV_TEST_OFFLOADING;\n\n  if (omp_get_num_devices() > 0) {\n    errors = test_metadirective_target_device();\n  } else {\n    OMPVV_INFOMSG(\"Cannot test target_device without a target device!\")\n  }\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n  return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_task_affinity_device.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  int errors = 0;\n  \n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_task_affinity());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 1654",
        "issue_id": 4,
        "original_code": "//===--- test_task_affinity_device.c ----------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This is a test of the affinity clause on a task construct. The affinity\n// clause indicates to the compiler that the task should execute physically\n// near to the memory location of the list items in the clause. This test\n// checks that the affinity clause can be used in the appropriate context\n// of a task construct but cannot guarantee that the compiler provides any\n// exact semantics for the clause. This test checks the above in a target\n// offload context.\n//\n////===----------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_task_affinity() {\n  OMPVV_INFOMSG(\"test_task_affinity_device\");\n  int errors = 0;\n  int* A;\n  int* B;\n\n  A = (int*) malloc(sizeof(int)*N);\n  B = (int*) malloc(sizeof(int)*N);\n\n  for (int i = 0; i < N; i++) {\n    A[i] = i;\n    B[i] = 0;\n  }\n\n#pragma omp target enter data map(to: A[0:N])\n\n#pragma omp target data use_device_ptr(A)\n{\n#pragma omp target defaultmap(none) is_device_ptr(A) map(tofrom: B[0:N]) \n {\n#pragma omp task depend(out: B) shared(B) affinity(A[0:N])\n   {\n     for (int i = 0; i < N; i++) {\n       B[i] = 2 * A[i];\n     }\n   }\n\n#pragma omp task depend(in: B) shared(B) affinity(A[0:N])\n   {\n     for (int i = 0; i < N; i++) {\n       B[i] += A[i];\n     }\n   }\n\n#pragma omp taskwait\n }\n}\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, B[i] != i*3);\n  }\n\n  free(A);\n  free(B);\n\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  \n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_task_affinity());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_task_affinity_device.c ----------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This is a test of the affinity clause on a task construct. The affinity\n// clause indicates to the compiler that the task should execute physically\n// near to the memory location of the list items in the clause. This test\n// checks that the affinity clause can be used in the appropriate context\n// of a task construct but cannot guarantee that the compiler provides any\n// exact semantics for the clause. This test checks the above in a target\n// offload context.\n//\n////===----------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_task_affinity() {\n  OMPVV_INFOMSG(\"test_task_affinity_device\");\n  int errors = 0;\n  int* A;\n  int* B;\n\n  A = (int*) malloc(sizeof(int)*N);\n  B = (int*) malloc(sizeof(int)*N);\n\n  for (int i = 0; i < N; i++) {\n    A[i] = i;\n    B[i] = 0;\n  }\n\n#pragma omp target enter data map(to: A[0:N])\n\n#pragma omp target data use_device_ptr(A)\n{\n#pragma omp target defaultmap(none) is_device_ptr(A) map(tofrom: B[0:N]) \n {\n#pragma omp task depend(out: B) shared(B) affinity(A[0:N])\n   {\n     for (int i = 0; i < N; i++) {\n       B[i] = 2 * A[i];\n     }\n   }\n\n#pragma omp task depend(in: B) shared(B) affinity(A[0:N])\n   {\n     for (int i = 0; i < N; i++) {\n       B[i] += A[i];\n     }\n   }\n\n#pragma omp taskwait\n }\n}\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, B[i] != i*3);\n  }\n\n  free(A);\n  free(B);\n\n  return errors;\n}\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_VirDestr.cpp",
        "correct": "n",
        "issue": "Removed opening bracket at position 1153",
        "issue_id": 1,
        "original_code": "//===--  test_target_VirDestr.cpp-------------------------------------===//\n//\n// OpenMP API Version 5.2\n//\n// Description\n// This test case tests the working of the following aspects:\n// 1) Working of \"requires unified_shared_memory\"\n// 2) Testing virtual destructor on gpu\n//===----------------------------------------------------------------------===//\n\n\n#include <iostream>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1024*512\n\n#pragma omp requires unified_shared_memory\nclass base {\n  int *x = nullptr;\n  public:\n    static int StatVar;\n    static void SetStatVal() {\n      StatVar = 999;\n    }\n    base() {\n      x = new int[N];\n      for (int i = 0; i < N; ++i) {\n        x[i] = 10;\n      }\n    }\n    virtual ~base() {\n      delete[] x;\n    }\n};\n\nint base::StatVar = 0;\nclass derived: public base {\n  int *y = nullptr;\n  public:\n    derived() {\n      y = new int[N];\n      for (int i = 0; i < N; ++i) {\n        y[i] = 20;\n      }\n    }\n    ~derived() {\n      delete[] y;\n      StatVar = 999;\n    }\n};\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n#pragma omp target\n    {\n      derived *d = new derived();\n      base *b = d;\n      delete b;\n    }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (base::StatVar != 999));\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--  test_target_VirDestr.cpp-------------------------------------===//\n//\n// OpenMP API Version 5.2\n//\n// Description\n// This test case tests the working of the following aspects:\n// 1) Working of \"requires unified_shared_memory\"\n// 2) Testing virtual destructor on gpu\n//===----------------------------------------------------------------------===//\n\n\n#include <iostream>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1024*512\n\n#pragma omp requires unified_shared_memory\nclass base {\n  int *x = nullptr;\n  public:\n    static int StatVar;\n    static void SetStatVal() {\n      StatVar = 999;\n    }\n    base() {\n      x = new int[N];\n      for (int i = 0; i < N; ++i) {\n        x[i] = 10;\n      }\n    }\n    virtual ~base() {\n      delete[] x;\n    }\n};\n\nint base::StatVar = 0;\nclass derived: public base {\n  int *y = nullptr;\n  public:\n    derived() {\n      y = new int[N];\n      for (int i = 0; i < N; ++i) {\n        y[i] = 20;\n      }\n    }\n    ~derived() {\n      delete[] y;\n      StatVar = 999;\n    }\n};\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n#pragma omp target\n    \n      derived *d = new derived();\n      base *b = d;\n      delete b;\n    }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (base::StatVar != 999));\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_in_reduction.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n      *sum += 1; \n   }\" at position 1661",
        "issue_id": 4,
        "original_code": "//===--- test_target_in_reduction.c -----------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks task reductions for a target task resulting from a target\n// construct with the 'in_reduction' clause.\n//\n////===----------------------------------------------------------------------===//\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1028\n\nvoid compute_on_device(int *);\nvoid compute_on_host(int *);\n\n#pragma omp declare target to (compute_on_device)\n\nint main ()\n{\n   int i, host_reduction_sum = 0, device_reduction_sum = 0;\n   int sum = 0, errors = 0;\n\n   OMPVV_TEST_OFFLOADING;\n\n   \n   #pragma omp parallel master\n   #pragma omp taskgroup task_reduction(+:sum)\n   {\n      #pragma omp target in_reduction(+:sum)\n         compute_on_device(&sum);\n     \n      #pragma omp task in_reduction(+:sum)\n         compute_on_host(&sum);\n   }\n   \n   for (i = 0; i < N; i++) {\n      device_reduction_sum += 2;\n      host_reduction_sum += 1; \n   }\n  \n   OMPVV_TEST_AND_SET_VERBOSE(errors, sum != (device_reduction_sum + host_reduction_sum));\n\n   OMPVV_TEST_AND_SET_VERBOSE(errors, sum == device_reduction_sum);\n   OMPVV_ERROR_IF(sum == device_reduction_sum, \"Host task did not participate in the reduction\");\n\n   OMPVV_TEST_AND_SET_VERBOSE(errors, sum == host_reduction_sum);\n   OMPVV_ERROR_IF(sum == host_reduction_sum, \"Target task did not participate in the reduction\");\n\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n\nvoid compute_on_device(int *sum) \n{\n   int i;\n   for (i = 0; i < N; i++) {\n      *sum += 2; \n   }\n}\n\nvoid compute_on_host(int *sum) \n{\n   int i;\n   for (i = 0; i < N; i++) {\n      *sum += 1; \n   }\n}\n",
        "error_code": "//===--- test_target_in_reduction.c -----------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks task reductions for a target task resulting from a target\n// construct with the 'in_reduction' clause.\n//\n////===----------------------------------------------------------------------===//\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1028\n\nvoid compute_on_device(int *);\nvoid compute_on_host(int *);\n\n#pragma omp declare target to (compute_on_device)\n\nint main ()\n{\n   int i, host_reduction_sum = 0, device_reduction_sum = 0;\n   int sum = 0, errors = 0;\n\n   OMPVV_TEST_OFFLOADING;\n\n   \n   #pragma omp parallel master\n   #pragma omp taskgroup task_reduction(+:sum)\n   {\n      #pragma omp target in_reduction(+:sum)\n         compute_on_device(&sum);\n     \n      #pragma omp task in_reduction(+:sum)\n         compute_on_host(&sum);\n   }\n   \n   for (i = 0; i < N; i++) {\n      device_reduction_sum += 2;\n      host_reduction_sum += 1; \n   }\n  \n   OMPVV_TEST_AND_SET_VERBOSE(errors, sum != (device_reduction_sum + host_reduction_sum));\n\n   OMPVV_TEST_AND_SET_VERBOSE(errors, sum == device_reduction_sum);\n   OMPVV_ERROR_IF(sum == device_reduction_sum, \"Host task did not participate in the reduction\");\n\n   OMPVV_TEST_AND_SET_VERBOSE(errors, sum == host_reduction_sum);\n   OMPVV_ERROR_IF(sum == host_reduction_sum, \"Target task did not participate in the reduction\");\n\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n\nvoid compute_on_device(int *sum) \n{\n   int i;\n   for (i = 0; i < N; i++) {\n      *sum += 2; \n   }\n}\n\nvoid compute_on_host(int *sum) \n{\n   int i;\n   for (i = 0; i < N; i++) \n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_has_device_addr.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1676",
        "issue_id": 1,
        "original_code": "//===--- test_target_has_device_addr.c --------------------------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// This test verifies the 'has_device_addr' feature added to the target construct.\n// We tested this by mapping a scalar & array to the device\n// and ensuring that the address does not change when using\n// has_device_addr on another target region.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n//test by mapping to device use 'target map' construct\nint test_target_has_device_addr() {\n  OMPVV_INFOMSG(\"test_target_has_device_addr\");\n  int errors = 0;\n  int x = 10;\n  int arr[N];\n  for(int i=0;i<N;i++){\n    arr[i] = i;\n  }\n  int *first_scalar_device_addr;\n  int *first_arr_device_addr;\n  #pragma omp target enter data map(to: x, arr)\n  #pragma omp target map(from: first_scalar_device_addr, first_arr_device_addr) map(to: x, arr)\n  {\n    first_scalar_device_addr = &x;\n    first_arr_device_addr = &arr[0];\n  }\n  int *second_scalar_device_addr, *second_arr_device_addr;\n  //check addresses are same on device region\n  #pragma omp target data use_device_addr(x, arr)\n  #pragma omp target map(from:second_scalar_device_addr, second_arr_device_addr) has_device_addr(x, arr) \n  {\n    second_scalar_device_addr = &x;\n    second_arr_device_addr = &arr[0];\n  }\n  #pragma omp target exit data map(release: x, arr)\n  OMPVV_TEST_AND_SET(errors, first_scalar_device_addr != second_scalar_device_addr);\n  OMPVV_TEST_AND_SET(errors, first_arr_device_addr != second_arr_device_addr);\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_has_device_addr());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_has_device_addr.c --------------------------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// This test verifies the 'has_device_addr' feature added to the target construct.\n// We tested this by mapping a scalar & array to the device\n// and ensuring that the address does not change when using\n// has_device_addr on another target region.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n//test by mapping to device use 'target map' construct\nint test_target_has_device_addr() {\n  OMPVV_INFOMSG(\"test_target_has_device_addr\");\n  int errors = 0;\n  int x = 10;\n  int arr[N];\n  for(int i=0;i<N;i++){\n    arr[i] = i;\n  }\n  int *first_scalar_device_addr;\n  int *first_arr_device_addr;\n  #pragma omp target enter data map(to: x, arr)\n  #pragma omp target map(from: first_scalar_device_addr, first_arr_device_addr) map(to: x, arr)\n  {\n    first_scalar_device_addr = &x;\n    first_arr_device_addr = &arr[0];\n  }\n  int *second_scalar_device_addr, *second_arr_device_addr;\n  //check addresses are same on device region\n  #pragma omp target data use_device_addr(x, arr)\n  #pragma omp target map(from:second_scalar_device_addr, second_arr_device_addr) has_device_addr(x, arr) \n  {\n    second_scalar_device_addr = &x;\n    second_arr_device_addr = &arr[0];\n  }\n  #pragma omp target exit data map(release: x, arr)\n  OMPVV_TEST_AND_SET(errors, first_scalar_device_addr != second_scalar_device_addr);\n  OMPVV_TEST_AND_SET(errors, first_arr_device_addr != second_arr_device_addr);\n  return errors;\n}\n\nint main() \n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_has_device_addr());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_parallel_for_simd_atomic.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 735",
        "issue_id": 2,
        "original_code": "//===--- test_parallel_for_simd_atomic.c ------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks that the atomic construct can be used within the parallel\n// for simd construct to avoid a race condition in updating a shared\n// variable, whose value is checked after updating.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_parallel_for_simd_atomic() {\n  OMPVV_INFOMSG(\"test_parallel_for_simd_atomic\");\n  int errors = 0, x = 0;\n\n#pragma omp parallel for simd shared(x) num_threads(OMPVV_NUM_THREADS_HOST)\n  for (int i = 0; i < N; i++) {\n#pragma omp atomic update\n    x += 1;\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, x != N);\n\n  return errors;\n}\n\n\nint main() {\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_parallel_for_simd_atomic());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_parallel_for_simd_atomic.c ------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks that the atomic construct can be used within the parallel\n// for simd construct to avoid a race condition in updating a shared\n// variable, whose value is checked after updating.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_parallel_for_simd_atomic() {\n  OMPVV_INFOMSG(\"test_parallel_for_simd_atomic\");\n  int errors = 0, x = 0;\n\n#pragma omp parallel for simd shared(x) num_threads(OMPVV_NUM_THREADS_HOST)\n  for (int i = 0; i < N;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1; i++) {\n#pragma omp atomic update\n    x += 1;\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, x != N);\n\n  return errors;\n}\n\n\nint main() {\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_parallel_for_simd_atomic());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_data_use_device_addr.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp teams\" at position 929",
        "issue_id": 0,
        "original_code": "//===-- test_target_data_use_device_addr.c --------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This file is a test for the use_device_addr when used with the map\n// clause with target data directive. This test uses a scalar and an array\n// of size N which values are modified on the  device and tested in the\n// host. List items that appear in a use_device_addr clause have the address\n// of the corresponding object in the device data environment inside the\n// construct. This test also tests that address conversions of\n// use_device_addr clauses will occur as if performed after all variables\n// are mapped according to those map clauses.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n\nint main() {\n  int errors = 0;\n  int device_data = 14, host_data=0;\n\n  OMPVV_TEST_OFFLOADING;\n\n#pragma omp target data map(to: device_data)\n  {\n    int *dev_ptr;\n#pragma omp target data use_device_addr(device_data)\n    {\n      dev_ptr = &device_data;\n    }\n#pragma omp target map(to:device_data) map(tofrom: errors) map(from: host_data) is_device_ptr(dev_ptr)\n    {\n      if(&device_data != dev_ptr) {\n        errors++;\n      }\n    } // end target\n\n#pragma omp target map(from: host_data) is_device_ptr(dev_ptr)\n    {\n      host_data = *dev_ptr;\n    }\n\n  } // end target data\n\n\n  // checking results\n  OMPVV_TEST_AND_SET(errors, host_data != 14);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===-- test_target_data_use_device_addr.c --------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This file is a test for the use_device_addr when used with the map\n// clause with target data directive. This test uses a scalar and an array\n// of size N which values are modified on the  device and tested in the\n// host. List items that appear in a use_device_addr clause have the address\n// of the corresponding object in the device data environment inside the\n// construct. This test also tests that address conversions of\n// use_device_addr clauses will occur as if performed after all variables\n// are mapped according to those map clauses.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n\nint main() {\n  int errors = 0;\n  int device_data = 14, host_data=0;\n\n  OMPVV_TEST_OFFLOADING;\n\n#pragma omp teams data map(to: device_data)\n  {\n    int *dev_ptr;\n#pragma omp target data use_device_addr(device_data)\n    {\n      dev_ptr = &device_data;\n    }\n#pragma omp target map(to:device_data) map(tofrom: errors) map(from: host_data) is_device_ptr(dev_ptr)\n    {\n      if(&device_data != dev_ptr) {\n        errors++;\n      }\n    } // end target\n\n#pragma omp target map(from: host_data) is_device_ptr(dev_ptr)\n    {\n      host_data = *dev_ptr;\n    }\n\n  } // end target data\n\n\n  // checking results\n  OMPVV_TEST_AND_SET(errors, host_data != 14);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_requires_unified_shared_memory_heap.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===---test_requires_unified_shared_memory_heap.c --------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n// \n// This test checks for unified shared memory of an array that is allocated on \n// the heap and that is accessed from host and device with the same pointer.\n//\n// It uses the default mapping of pointers to access the array.\n//\n////===----------------------------------------------------------------------===//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp requires unified_shared_memory\n\nint unified_shared_memory_heap() {\n  OMPVV_INFOMSG(\"Unified shared memory testing - Array on heap\");\n  int errors = 0;\n  \n  int *anArray;\n  int anArrayCopy[N];\n\n  anArray = (int*)malloc(sizeof(int)*N);\n\n  for (int i = 0; i < N; i++) {\n    anArray[i] = i;\n    anArrayCopy[i] = 0;\n  }\n  // Modify in the device\n#pragma omp target \n  {\n    for (int i = 0; i < N; i++) {\n      anArray[i] += 10;\n    }\n  }\n  // Modify again on the host\n  for (int i = 0; i < N; i++) {\n    anArray[i] += 10;\n  }\n\n  // Get the value the device is seeing\n#pragma omp target \n  {\n    for (int i = 0; i < N; i++) {\n      anArrayCopy[i] = anArray[i];\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArray[i] != i + 20);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArrayCopy[i] != i + 20);\n    if (errors) break;\n  }\n\n  free(anArray);\n  return errors;\n}\nint main() {\n  int isOffloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"With no offloading, unified shared memory is guaranteed due to host execution\");\n  int errors = 0;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, unified_shared_memory_heap());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nbyte wwdwfhfcfz = 146;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_scope_firstprivate_construct.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//--------------- test_scope_firstprivate_construct.c -----------------------------//\n//\n// OpenMP API Version 5.2 Nov 2021 \n//\n// This test checks that the scope firstprivate construct clause is properly working.\n// The test itself passes a test integer into the scope pragma and ensures that\n// all changes made to it are not kept outside of the scope region.\n//----------------------------------------------------------------------------//\n\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\nint test_scope(){\n\tint errors = 0;\n\tint test_int = 1;\n\t#pragma omp target parallel map(tofrom: errors) \n\t{\n\t\t#pragma omp scope firstprivate(test_int)\n\t\t{\n\t\t\ttest_int += 1;\n\t\t\tOMPVV_TEST_AND_SET(errors,test_int != 2);\n\t\t}\n\t}\n\tOMPVV_ERROR_IF(errors, \"firstprivate int is not updating correctly\");\n\tOMPVV_TEST_AND_SET_VERBOSE(errors,test_int != 1);\n\tOMPVV_INFOMSG_IF(test_int == 2, \"test int was not firstprivate\");\n\treturn errors;\n}\n\nint main(){\n\tint errors = 0;\n\tOMPVV_TEST_OFFLOADING;\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_scope() != 0);\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nlong tigacezqaw = 82;\ndouble vnyvxgfqfi = 78;\nfloat qwllghgswl = 142;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_loop_allocate.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp single\" at position 834",
        "issue_id": 0,
        "original_code": "//===-------------- test_target_teams_loop_allocate.c---------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n// The tests in this file tests 'teams loop' construct coupled with map()\n// clause in combination with different allocator types\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n/**\n  This is a basic test to demonstrate how allocate can be used with\n  target teams loop construct. Allocate clause is used to allocate a local\n  variable of size int.\n*/\nint testTargetTeamsAllocateCl() {\n  int a[N], b[N], c[N], local = 0;\n  int errors = 0;\n  // Data Inititalize\n  for (int i = 0; i < N; i++) {\n    a[i] = 2*i;  // Even\n    b[i] = 2*i + 1;  // Odd\n    c[i] = 0;\n  }\n  // Execute on target\n#pragma omp target teams loop map(to: a[0:N], b[0:N]) map(from: c[0:N]) \\\n        uses_allocators(omp_low_lat_mem_alloc) \\\n        allocate(omp_low_lat_mem_alloc: local) firstprivate(local)\n  for (int i = 0; i < N; i++) {\n    local = a[i] + b[i];\n    c[i] = local;\n  }\n  // Validate\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, c[i] != a[i] + b[i]);\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, local != 0);\n  return errors;\n}\n\n/**\n  This is a basic test to demonstrate use of allocate clause with\n  omp_default_mem_alloc allocator to allocate an array.\n*/\nint testTargetTeamsAllocateArrayDefaultAlloc() {\n  int a[N], b[N], c[N], local[N];\n  int errors = 0;\n  // Data Inititalize\n  for (int i = 0; i < N; i++) {\n    a[i] = 2*i;  // Even\n    b[i] = 2*i + 1;  // Odd\n    local[i] = 0;\n  }\n  // Execute on target\n#pragma omp target teams loop map(to: a[0:N], b[0:N]) map(from: c[0:N])\\\n        uses_allocators(omp_default_mem_alloc)\\\n        allocate(omp_default_mem_alloc: local) firstprivate(local)\n  for (int i = 0; i < N; i++) {\n    local[i] = a[i] + b[i];\n    c[i] = local[i];\n  }\n  // Validate\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, c[i] != a[i] + b[i]);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, local[i] != 0);\n  }\n  return errors;\n}\n\n/**\n  This is a basic test to demonstrate use of allocate clause with\n  omp_large_cap_mem_alloc allocator to allocate an array.\n*/\nint testTargetTeamsAllocateArrayLargeCapAlloc() {\n  int a[N], b[N], c[N], local[N];\n  int errors = 0;\n  // Data Inititalize\n  for (int i = 0; i < N; i++) {\n    a[i] = 2*i;  // Even\n    b[i] = 2*i + 1;  // Odd\n    local[i] = 0;\n  }\n  // Execute on target\n#pragma omp target teams loop map(to: a[0:N], b[0:N]) map(from: c[0:N])\\\n        uses_allocators(omp_large_cap_mem_alloc)\\\n        allocate(omp_large_cap_mem_alloc: local) firstprivate(local)\n  for (int i = 0; i < N; i++) {\n    local[i] = a[i] + b[i];\n    c[i] = local[i];\n  }\n  // Validate\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, c[i] != a[i] + b[i]);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, local[i] != 0);\n  }\n  return errors;\n}\n\n/**\n  This is a basic test to demonstrate use of allocate clause with\n  omp_const_mem_alloc allocator to allocate an variable.\n*/\nint testTargetTeamsAllocateConstAlloc() {\n  int a[N], b[N];\n  const int local = 3;\n  int errors = 0;\n  // Data Inititalize\n  for (int i = 0; i < N; i++) {\n    a[i] = 2*i;  // Even\n    b[i] = 0;  // Odd\n  }\n  // Execute on target\n#pragma omp target teams loop map(to: a[0:N]) map(from: b[0:N])\\\n        firstprivate(local) uses_allocators(omp_const_mem_alloc)\\\n         allocate(omp_const_mem_alloc: local)\n  for (int i = 0; i < N; i++) {\n    b[i] = a[i] + local;\n  }\n  // Validate\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, b[i] != a[i] + local);\n  }\n  return errors;\n}\n\n/**\n  This is a basic test to demonstrate use of allocate clause with\n  omp_high_bw_mem_alloc allocator to allocate an array.\n*/\nint testTargetTeamsAllocateArrayHighBWAlloc() {\n  int a[N], b[N], c[N], local[N];\n  int errors = 0;\n  // Data Inititalize\n  for (int i = 0; i < N; i++) {\n    a[i] = 2*i;  // Even\n    b[i] = 2*i + 1;  // Odd\n    local[i] = 0;\n  }\n  // Execute on target\n#pragma omp target teams loop map(to: a[0:N], b[0:N]) map(from: c[0:N])\\\n        uses_allocators(omp_high_bw_mem_alloc)\\\n        allocate(omp_high_bw_mem_alloc: local) firstprivate(local)\n  for (int i = 0; i < N; i++) {\n    local[i] = a[i] + b[i];\n    c[i] = local[i];\n  }\n  // Validate\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, c[i] != a[i] + b[i]);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, local[i] != 0);\n  }\n  return errors;\n}\n\n/**\n  This is a basic test to demonstrate use of allocate clause with\n  omp_low_lat_mem_alloc allocator to allocate an array.\n*/\nint testTargetTeamsAllocateArrayLowLatAlloc() {\n  int a[N], b[N], c[N], local[N];\n  int errors = 0;\n  // Data Inititalize\n  for (int i = 0; i < N; i++) {\n    a[i] = 2*i;  // Even\n    b[i] = 2*i + 1;  // Odd\n    local[i] = 0;\n  }\n  // Execute on target\n#pragma omp target teams loop map(to: a[0:N], b[0:N]) map(from: c[0:N])\\\n        uses_allocators(omp_low_lat_mem_alloc)\\\n        allocate(omp_low_lat_mem_alloc: local) firstprivate(local)\n  for (int i = 0; i < N; i++) {\n    local[i] = a[i] + b[i];\n    c[i] = local[i];\n  }\n  // Validate\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, c[i] != a[i] + b[i]);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, local[i] != 0);\n  }\n  return errors;\n}\n\n/**\n  This is a basic test to demonstrate use of allocate clause with\n  omp_cgroup_mem_alloc allocator to allocate an array.\n*/\nint testTargetTeamsAllocateArrayCGroupAlloc() {\n  int a[N], b[N], c[N], local[N];\n  int errors = 0;\n  // Data Inititalize\n  for (int i = 0; i < N; i++) {\n    a[i] = 2*i;  // Even\n    b[i] = 2*i + 1;  // Odd\n    local[i] = 0;\n  }\n  // Execute on target\n#pragma omp target teams loop map(to: a[0:N], b[0:N]) map(from: c[0:N])\\\n        uses_allocators(omp_cgroup_mem_alloc)\\\n        allocate(omp_cgroup_mem_alloc: local) firstprivate(local)\n  for (int i = 0; i < N; i++) {\n    local[i] = a[i] + b[i];\n    c[i] = local[i];\n  }\n  // Validate\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, c[i] != a[i] + b[i]);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, local[i] != 0);\n  }\n  return errors;\n}\n\n/**\n  This is a basic test to demonstrate use of allocate clause with\n  omp_pteam_mem_alloc allocator to allocate an array.\n*/\nint testTargetTeamsAllocateArrayPTeamAlloc() {\n  int a[N], b[N], c[N], local[N];\n  int errors = 0;\n  // Data Inititalize\n  for (int i = 0; i < N; i++) {\n    a[i] = 2*i;  // Even\n    b[i] = 2*i + 1;  // Odd\n    local[i] = 0;\n  }\n  // Execute on target\n#pragma omp target teams loop map(to: a[0:N], b[0:N]) map(from: c[0:N])\\\n        uses_allocators(omp_pteam_mem_alloc)\\\n        allocate(omp_pteam_mem_alloc: local) firstprivate(local)\n  for (int i = 0; i < N; i++) {\n    local[i] = a[i] + b[i];\n    c[i] = local[i];\n  }\n  // Validate\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, c[i] != a[i] + b[i]);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, local[i] != 0);\n  }\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  \n  OMPVV_TEST_OFFLOADING;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTargetTeamsAllocateCl());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTargetTeamsAllocateArrayDefaultAlloc());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTargetTeamsAllocateArrayLargeCapAlloc());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTargetTeamsAllocateConstAlloc());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTargetTeamsAllocateArrayHighBWAlloc());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTargetTeamsAllocateArrayLowLatAlloc());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTargetTeamsAllocateArrayCGroupAlloc());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTargetTeamsAllocateArrayPTeamAlloc());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===-------------- test_target_teams_loop_allocate.c---------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n// The tests in this file tests 'teams loop' construct coupled with map()\n// clause in combination with different allocator types\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n/**\n  This is a basic test to demonstrate how allocate can be used with\n  target teams loop construct. Allocate clause is used to allocate a local\n  variable of size int.\n*/\nint testTargetTeamsAllocateCl() {\n  int a[N], b[N], c[N], local = 0;\n  int errors = 0;\n  // Data Inititalize\n  for (int i = 0; i < N; i++) {\n    a[i] = 2*i;  // Even\n    b[i] = 2*i + 1;  // Odd\n    c[i] = 0;\n  }\n  // Execute on target\n#pragma omp single teams loop map(to: a[0:N], b[0:N]) map(from: c[0:N]) \\\n        uses_allocators(omp_low_lat_mem_alloc) \\\n        allocate(omp_low_lat_mem_alloc: local) firstprivate(local)\n  for (int i = 0; i < N; i++) {\n    local = a[i] + b[i];\n    c[i] = local;\n  }\n  // Validate\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, c[i] != a[i] + b[i]);\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, local != 0);\n  return errors;\n}\n\n/**\n  This is a basic test to demonstrate use of allocate clause with\n  omp_default_mem_alloc allocator to allocate an array.\n*/\nint testTargetTeamsAllocateArrayDefaultAlloc() {\n  int a[N], b[N], c[N], local[N];\n  int errors = 0;\n  // Data Inititalize\n  for (int i = 0; i < N; i++) {\n    a[i] = 2*i;  // Even\n    b[i] = 2*i + 1;  // Odd\n    local[i] = 0;\n  }\n  // Execute on target\n#pragma omp target teams loop map(to: a[0:N], b[0:N]) map(from: c[0:N])\\\n        uses_allocators(omp_default_mem_alloc)\\\n        allocate(omp_default_mem_alloc: local) firstprivate(local)\n  for (int i = 0; i < N; i++) {\n    local[i] = a[i] + b[i];\n    c[i] = local[i];\n  }\n  // Validate\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, c[i] != a[i] + b[i]);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, local[i] != 0);\n  }\n  return errors;\n}\n\n/**\n  This is a basic test to demonstrate use of allocate clause with\n  omp_large_cap_mem_alloc allocator to allocate an array.\n*/\nint testTargetTeamsAllocateArrayLargeCapAlloc() {\n  int a[N], b[N], c[N], local[N];\n  int errors = 0;\n  // Data Inititalize\n  for (int i = 0; i < N; i++) {\n    a[i] = 2*i;  // Even\n    b[i] = 2*i + 1;  // Odd\n    local[i] = 0;\n  }\n  // Execute on target\n#pragma omp target teams loop map(to: a[0:N], b[0:N]) map(from: c[0:N])\\\n        uses_allocators(omp_large_cap_mem_alloc)\\\n        allocate(omp_large_cap_mem_alloc: local) firstprivate(local)\n  for (int i = 0; i < N; i++) {\n    local[i] = a[i] + b[i];\n    c[i] = local[i];\n  }\n  // Validate\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, c[i] != a[i] + b[i]);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, local[i] != 0);\n  }\n  return errors;\n}\n\n/**\n  This is a basic test to demonstrate use of allocate clause with\n  omp_const_mem_alloc allocator to allocate an variable.\n*/\nint testTargetTeamsAllocateConstAlloc() {\n  int a[N], b[N];\n  const int local = 3;\n  int errors = 0;\n  // Data Inititalize\n  for (int i = 0; i < N; i++) {\n    a[i] = 2*i;  // Even\n    b[i] = 0;  // Odd\n  }\n  // Execute on target\n#pragma omp target teams loop map(to: a[0:N]) map(from: b[0:N])\\\n        firstprivate(local) uses_allocators(omp_const_mem_alloc)\\\n         allocate(omp_const_mem_alloc: local)\n  for (int i = 0; i < N; i++) {\n    b[i] = a[i] + local;\n  }\n  // Validate\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, b[i] != a[i] + local);\n  }\n  return errors;\n}\n\n/**\n  This is a basic test to demonstrate use of allocate clause with\n  omp_high_bw_mem_alloc allocator to allocate an array.\n*/\nint testTargetTeamsAllocateArrayHighBWAlloc() {\n  int a[N], b[N], c[N], local[N];\n  int errors = 0;\n  // Data Inititalize\n  for (int i = 0; i < N; i++) {\n    a[i] = 2*i;  // Even\n    b[i] = 2*i + 1;  // Odd\n    local[i] = 0;\n  }\n  // Execute on target\n#pragma omp target teams loop map(to: a[0:N], b[0:N]) map(from: c[0:N])\\\n        uses_allocators(omp_high_bw_mem_alloc)\\\n        allocate(omp_high_bw_mem_alloc: local) firstprivate(local)\n  for (int i = 0; i < N; i++) {\n    local[i] = a[i] + b[i];\n    c[i] = local[i];\n  }\n  // Validate\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, c[i] != a[i] + b[i]);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, local[i] != 0);\n  }\n  return errors;\n}\n\n/**\n  This is a basic test to demonstrate use of allocate clause with\n  omp_low_lat_mem_alloc allocator to allocate an array.\n*/\nint testTargetTeamsAllocateArrayLowLatAlloc() {\n  int a[N], b[N], c[N], local[N];\n  int errors = 0;\n  // Data Inititalize\n  for (int i = 0; i < N; i++) {\n    a[i] = 2*i;  // Even\n    b[i] = 2*i + 1;  // Odd\n    local[i] = 0;\n  }\n  // Execute on target\n#pragma omp target teams loop map(to: a[0:N], b[0:N]) map(from: c[0:N])\\\n        uses_allocators(omp_low_lat_mem_alloc)\\\n        allocate(omp_low_lat_mem_alloc: local) firstprivate(local)\n  for (int i = 0; i < N; i++) {\n    local[i] = a[i] + b[i];\n    c[i] = local[i];\n  }\n  // Validate\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, c[i] != a[i] + b[i]);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, local[i] != 0);\n  }\n  return errors;\n}\n\n/**\n  This is a basic test to demonstrate use of allocate clause with\n  omp_cgroup_mem_alloc allocator to allocate an array.\n*/\nint testTargetTeamsAllocateArrayCGroupAlloc() {\n  int a[N], b[N], c[N], local[N];\n  int errors = 0;\n  // Data Inititalize\n  for (int i = 0; i < N; i++) {\n    a[i] = 2*i;  // Even\n    b[i] = 2*i + 1;  // Odd\n    local[i] = 0;\n  }\n  // Execute on target\n#pragma omp target teams loop map(to: a[0:N], b[0:N]) map(from: c[0:N])\\\n        uses_allocators(omp_cgroup_mem_alloc)\\\n        allocate(omp_cgroup_mem_alloc: local) firstprivate(local)\n  for (int i = 0; i < N; i++) {\n    local[i] = a[i] + b[i];\n    c[i] = local[i];\n  }\n  // Validate\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, c[i] != a[i] + b[i]);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, local[i] != 0);\n  }\n  return errors;\n}\n\n/**\n  This is a basic test to demonstrate use of allocate clause with\n  omp_pteam_mem_alloc allocator to allocate an array.\n*/\nint testTargetTeamsAllocateArrayPTeamAlloc() {\n  int a[N], b[N], c[N], local[N];\n  int errors = 0;\n  // Data Inititalize\n  for (int i = 0; i < N; i++) {\n    a[i] = 2*i;  // Even\n    b[i] = 2*i + 1;  // Odd\n    local[i] = 0;\n  }\n  // Execute on target\n#pragma omp target teams loop map(to: a[0:N], b[0:N]) map(from: c[0:N])\\\n        uses_allocators(omp_pteam_mem_alloc)\\\n        allocate(omp_pteam_mem_alloc: local) firstprivate(local)\n  for (int i = 0; i < N; i++) {\n    local[i] = a[i] + b[i];\n    c[i] = local[i];\n  }\n  // Validate\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, c[i] != a[i] + b[i]);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, local[i] != 0);\n  }\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  \n  OMPVV_TEST_OFFLOADING;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTargetTeamsAllocateCl());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTargetTeamsAllocateArrayDefaultAlloc());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTargetTeamsAllocateArrayLargeCapAlloc());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTargetTeamsAllocateConstAlloc());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTargetTeamsAllocateArrayHighBWAlloc());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTargetTeamsAllocateArrayLowLatAlloc());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTargetTeamsAllocateArrayCGroupAlloc());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTargetTeamsAllocateArrayPTeamAlloc());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_loop_reduction.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTargetTeamsReduction());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 707",
        "issue_id": 4,
        "original_code": "#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n/**\n  This is a basic test to demonstrate how reduction clause is used\n  with target teams loop construct.\n*/\nint testTargetTeamsReduction() {\n  int a[N], total = 0;\n  int errors = 0;\n  // Data Inititalize\n  for (int i = 0; i < N; i++) {\n    a[i] = i;\n  }\n  // Execute on target\n#pragma omp target teams loop map(to: a[0:N]) map(tofrom: total) reduction(+:total)\n  for (int i = 0; i < N; i++) {\n    total = total + a[i];\n  }\n  // Validate\n  int sum_host = 0;\n  for (int i = 0; i < N; i++) {\n    sum_host = sum_host + a[i];\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, total != sum_host);\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTargetTeamsReduction());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n/**\n  This is a basic test to demonstrate how reduction clause is used\n  with target teams loop construct.\n*/\nint testTargetTeamsReduction() {\n  int a[N], total = 0;\n  int errors = 0;\n  // Data Inititalize\n  for (int i = 0; i < N; i++) {\n    a[i] = i;\n  }\n  // Execute on target\n#pragma omp target teams loop map(to: a[0:N]) map(tofrom: total) reduction(+:total)\n  for (int i = 0; i < N; i++) {\n    total = total + a[i];\n  }\n  // Validate\n  int sum_host = 0;\n  for (int i = 0; i < N; i++) {\n    sum_host = sum_host + a[i];\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, total != sum_host);\n  return errors;\n}\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_data_map_classes.cpp",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===---- test_target_data_map_classes.cpp -----------------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// This test checks the mapping of c++ objects on both the stack and heap. The 'new'\n// operater is utilized in the case where memory allocation is on heap. Objects are first \n// initalized on the host and then mapped to device. Inside the target region, the object's \n// array data member, which was also mapped to device, is modified through the device array\n// pointer. After target region, we swap back to the host array pointer to verify that the \n// host array was properly updated.\n//\n//===-------------------------------------------------------------------------------------===//\n\n#include <iostream>\n#include <omp.h>\n#include \"ompvv.h\"\n\nusing namespace std;\n\n#define N 1000\n\nclass A {\n\npublic:\n  // breaks encapsulation\n  int *h_array;\n  int size;\n  int sum;\n\n  A(int *array, const int s) : h_array(array), size(s) { sum = 0; }\n\n  // TODO: Add virtual once supported \n  ~A() { h_array = NULL; }\n};\n\n// Test for OpenMP 4.5 target data mapping objects in the heap\nint test_map_tofrom_class_heap() {\n\n  OMPVV_INFOMSG(\"test_map_tofrom_class_heap\");\n\n  int sum = 0, errors = 0;\n\n  int *array = new int[N];\n  A *obj = new A(array, N);\n\n  // mapping an object + array: it is shallow copy thus \n  // pointers are not translated automatically\n#pragma omp target data map(from: array[0:N]) map(tofrom: obj[0:1])\n  {\n#pragma omp target\n    {\n      // assign device array ptr to device obj \n      int *tmp_h_array = obj->h_array;\n      obj->h_array = array;\n      int tmp = 0;\n      for (int i = 0; i < N; ++i) {\n        obj->h_array[i] = 1;\n        tmp += 1;\n      }\n      // swap array device ptr to host ptr \n      obj->h_array = tmp_h_array;\n\n      obj->sum = tmp;\n    } // end target\n  } // end target data\n\n  // checking results \n  for (int i = 0; i < N; ++i)\n    sum += obj->h_array[i];\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (N != sum) || (N != obj->sum));\n\n  delete obj;\n  delete[] array;\n\n  return errors;\n}\n\n// Test for OpenMP 4.5 target data mapping objects on the stack\nint test_map_tofrom_class_stack() {\n\n  OMPVV_INFOMSG(\"test_map_tofrom_class_stack\");\n\n  int sum = 0, errors = 0;\n\n  int array[N];\n  A obj(array, N);\n\n  // mapping an object + array: it is shallow copy thus \n  // pointers are not translated automatically\n#pragma omp target data map(from: array[0:N]) map(tofrom: obj)\n  {\n#pragma omp target\n    {\n      // assign device array ptr to device obj \n      int *tmp_h_array = obj.h_array;\n      obj.h_array = array;\n      int tmp = 0;\n      for (int i = 0; i < N; ++i) {\n        obj.h_array[i] = 1;\n        tmp += 1;\n      }\n      // swap array device ptr to host ptr \n      obj.h_array = tmp_h_array;\n\n      obj.sum = tmp;\n    } // end target\n  } // end target data\n\n  // checking results \n  for (int i = 0; i < N; ++i)\n    sum += obj.h_array[i];\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (N != sum) || (N != obj.sum));\n\n  return errors;\n}\n\nint main() {\n\n  int errors = 0;\n  \n  OMPVV_TEST_OFFLOADING;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_tofrom_class_heap());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_tofrom_class_stack());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <iostream>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nshort stqvrslcwu = 10;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    std::cout << \"Sum of \" << num1 << \" and \" << num2 << \" is \" << sum << std::endl;\n    return 0;\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_loop_lastprivate_device.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===--- test_loop_lastprivate_device.c ---------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the lastprivate clause with a loop directive. According to\n// specification, the list items on a lastprivate clause in this context may\n// only contain loop iteration variables of loops associated with the loop\n// directive. This test checks that the loop iteration variables associated\n// with a loop directive and a loop directive with collapse(2) have valid\n// values after the parallel region containing the loop. This test checks the\n// above in a target context.\n//\n////===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define SIZE 1024\n#define SIZE2 512\n\nint test_one_loop_level() {\n  int a[SIZE];\n  int b[SIZE];\n  int errors = 0;\n  int lp_errors = 0;\n  int x = 0;\n\n  for (x = 0; x < SIZE; ++x) {\n    a[x] = 1;\n    b[x] = x;\n  }\n\n#pragma omp target parallel num_threads(OMPVV_NUM_THREADS_DEVICE) map(tofrom: a, b, x)\n  {\n#pragma omp loop lastprivate(x)\n    for (x = 0; x < SIZE; ++x) {\n      a[x] += b[x];\n    }\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(lp_errors, x != SIZE);\n  OMPVV_ERROR_IF(lp_errors, \"Loop iteration variable in loop construct ended with invalid value.\");\n\n  for (x = 0; x < SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, a[x] - b[x] != 1);\n  }\n\n  return errors + lp_errors;\n}\n\nint test_two_loop_levels() {\n  int a[SIZE][SIZE2];\n  int b[SIZE][SIZE2];\n  int errors = 0;\n  int lp_errors_x = 0;\n  int lp_errors_y = 0;\n  int x = 0;\n  int y = 0;\n\n  for (x = 0; x < SIZE; ++x) {\n    for (y = 0; y < SIZE2; ++y) {\n      a[x][y] = 1;\n      b[x][y] = x + y;\n    }\n  }\n\n#pragma omp target parallel num_threads(OMPVV_NUM_THREADS_DEVICE) map(tofrom: a, b, x, y)\n  {\n#pragma omp loop lastprivate(x, y) collapse(2)\n    for (x = 0; x < SIZE; ++x) {\n      for (y = 0; y < SIZE2; ++y) {\n        a[x][y] += b[x][y];\n      }\n    }\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(lp_errors_x, x != SIZE);\n  OMPVV_TEST_AND_SET_VERBOSE(lp_errors_y, y != SIZE2);\n  OMPVV_ERROR_IF(lp_errors_x, \"Outer loop iteration variable in loop directive with collapse ended with invalid value.\");\n  OMPVV_ERROR_IF(lp_errors_y, \"Inner loop iteration variable in loop directive with collapse ended with invalid value.\");\n\n  for (x = 0; x < SIZE; ++x) {\n    for (y = 0; y < SIZE2; ++y) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, a[x][y] - b[x][y] != 1);\n    }\n  }\n\n  return errors + lp_errors_x + lp_errors_y;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_one_loop_level());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_two_loop_levels());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nlong shyoczgthm = 62;\nint gzrvcxhque = 179;\nshort kejzmwiwxv = 161;\nbyte hgipipeygi = 220;\ndouble muzyzyhfpz = 227;\nlong zumnmwnkyy = 24;\nfloat dszyzmtiny = 71;\nint oqmjglhzhx = 142;\ndouble vzvppyngyu = 6;\nshort oqgbznqhdf = 2;\nfloat ubiubgvycx = 112;\nbyte wcendwazgv = 141;\ndouble fwoirvrogb = 161;\nfloat mqmwgktwsn = 141;\ndouble laslcmjtym = 216;\nfloat osckzkxrth = 253;\nint ekzyjciocu = 165;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_taskloop_simd_order_reproducible_device.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 1103",
        "issue_id": 2,
        "original_code": "//===------------ test_target_taskloop_simd_order_reproducible_device.c ------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// This test checks that the order(reproducible:concurrent) clause is properly handled.\n// Leverages the previous array item to determine if the same threads executed\n// in the same order over the array. If both arrays match the test passes, \n// if not it fails as the reproducible clause failed.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 24\n\nint main() {\n\tint errors = 0;\n\tint x[N];\n\tint y[N];\n\n\tfor (int i = 0; i < N; i++) {\n\t\tx[i] = i;\n\t\ty[i] = i;\n\t}\n\n\tOMPVV_TEST_OFFLOADING;\n\n\t#pragma omp target map(tofrom: x,y)\n\t{\n\t\t#pragma omp parallel\n\t\t{\n\t\t   #pragma omp single\n\t\t   #pragma omp taskloop simd order(reproducible:concurrent)\n\t\t      for (int i = 0; i < N; i++) {\n\t\t\t x[i] = x[i] + 2;\t\n\t\t      }\n\n\t\t   #pragma omp single\n\t\t   #pragma omp taskloop simd order(reproducible:concurrent)\n\t\t      for (int i = 0; i < N; i++) {\n\t\t\ty[i] = x[i] + 2;\n\t\t      }\n\t\t}\n\n\t}\n\n\tfor (int i = 0; i < N; i++) {\n    \t\tOMPVV_TEST_AND_SET(errors, y[i] != i + 4);\n\t}\n\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===------------ test_target_taskloop_simd_order_reproducible_device.c ------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// This test checks that the order(reproducible:concurrent) clause is properly handled.\n// Leverages the previous array item to determine if the same threads executed\n// in the same order over the array. If both arrays match the test passes, \n// if not it fails as the reproducible clause failed.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 24\n\nint main() {\n\tint errors = 0;\n\tint x[N];\n\tint y[N];\n\n\tfor (int i = 0; i < N; i++) {\n\t\tx[i] = i;\n\t\ty[i] = i;\n\t}\n\n\tOMPVV_TEST_OFFLOADING;\n\n\t#pragma omp target map(tofrom: x,y)\n\t{\n\t\t#pragma omp parallel\n\t\t{\n\t\t   #pragma omp single\n\t\t   #pragma omp taskloop simd order(reproducible:concurrent)\n\t\t      for (int i = 0; i < N; i++) {\n\t\t\t x[i] = x[i] + 2;\t\n\t\t      }\n\n\t\t   #pragma omp single\n\t\t   #pragma omp taskloop simd order(reproducible:concurrent)\n\t\t      for (int i = 0; i < N; i++) {\n\t\t\ty[i] = x[i] + 2;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n\t\t      }\n\t\t}\n\n\t}\n\n\tfor (int i = 0; i < N; i++) {\n    \t\tOMPVV_TEST_AND_SET(errors, y[i] != i + 4);\n\t}\n\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_parallel_is_dev_ptr.c",
        "correct": "n",
        "issue": "Removed memory allocation line \"omp_target_alloc(sizeof(int) * N, gpu);\" at position 449",
        "issue_id": 0,
        "original_code": "//===------test_target_is_dev_ptr.c--------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Tests the target directive with parallel for + is_device_ptr + device clauses\n//\n//===------------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include \"omp.h\"\n#include \"ompvv.h\"\n\n#define N 1024\n\nint Runtst(int gpu) {\n  int *Hst_A = (int*)malloc(sizeof(int) * N);\n  int *Dev_B = (int*)omp_target_alloc(sizeof(int) * N, gpu);\n  int errors = 0;\n  for (int i = 0; i < N; ++i) {\n    Hst_A[i] = i;\n  }\n\n#pragma omp target data map(tofrom: Hst_A[0:N]) device(gpu)\n  {\n#pragma omp target parallel for  is_device_ptr(Dev_B) device(gpu)\n    for (int i = 0; i < N; ++i) {\n      Dev_B[i] = Hst_A[i] * Hst_A[i];\n      Hst_A[i] = Dev_B[i];\n    }\n  }\n\n  // Verification\n \n  for (int i = 0; i < N; ++i) {\n    if (Hst_A[i] != i*i) {\n      errors++;\n    }\n  }\n\n  free(Hst_A);\n  omp_target_free(Dev_B, gpu);\n  return errors;\n}\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int TotGpus = omp_get_num_devices();\n  int errors = 0;\n  for (int gpu = 0; gpu < TotGpus; ++gpu) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (Runtst(gpu) != 0));\n  }\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===------test_target_is_dev_ptr.c--------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Tests the target directive with parallel for + is_device_ptr + device clauses\n//\n//===------------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include \"omp.h\"\n#include \"ompvv.h\"\n\n#define N 1024\n\nint Runtst(int gpu) {\n  int *Hst_A = (int*)malloc(sizeof(int) * N);\n  int *Dev_B = (int*)\n  int errors = 0;\n  for (int i = 0; i < N; ++i) {\n    Hst_A[i] = i;\n  }\n\n#pragma omp target data map(tofrom: Hst_A[0:N]) device(gpu)\n  {\n#pragma omp target parallel for  is_device_ptr(Dev_B) device(gpu)\n    for (int i = 0; i < N; ++i) {\n      Dev_B[i] = Hst_A[i] * Hst_A[i];\n      Hst_A[i] = Dev_B[i];\n    }\n  }\n\n  // Verification\n \n  for (int i = 0; i < N; ++i) {\n    if (Hst_A[i] != i*i) {\n      errors++;\n    }\n  }\n\n  free(Hst_A);\n  omp_target_free(Dev_B, gpu);\n  return errors;\n}\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int TotGpus = omp_get_num_devices();\n  int errors = 0;\n  for (int gpu = 0; gpu < TotGpus; ++gpu) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (Runtst(gpu) != 0));\n  }\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_taskloop_shared.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp single\" at position 573",
        "issue_id": 0,
        "original_code": "//===--test_target_taskloop_shared.c ----------------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// Test uses a value within a taskloop & an atomic construct to update the value of\n// s_val. The shared clause ensures that the s_val will be shared between threads,\n// and therefore should be equal to N After the taskloop region.\n//\n////===--------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint taskloop_shared() {\n\n  int errors = 0;\n  int s_val=0;\n\n  #pragma omp target map(tofrom: s_val)\n  {\n    #pragma omp parallel\n    {\n      #pragma omp single\n      #pragma omp taskloop shared(s_val)\n      for (int i = 0; i < N; ++i){\n        #pragma omp atomic update\n        ++s_val; \n      }\n    }\n  }\n  OMPVV_ERROR_IF(s_val != N, \"Value of s_val should be %i, received %i\", N, s_val);\n  OMPVV_TEST_AND_SET(errors, s_val != N);\n  return errors;\n}\n\nint main() {\n    int errors = 0;\n    OMPVV_TEST_OFFLOADING;\n    OMPVV_TEST_AND_SET(errors, taskloop_shared());\n    OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--test_target_taskloop_shared.c ----------------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// Test uses a value within a taskloop & an atomic construct to update the value of\n// s_val. The shared clause ensures that the s_val will be shared between threads,\n// and therefore should be equal to N After the taskloop region.\n//\n////===--------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint taskloop_shared() {\n\n  int errors = 0;\n  int s_val=0;\n\n  #pragma omp single map(tofrom: s_val)\n  {\n    #pragma omp parallel\n    {\n      #pragma omp single\n      #pragma omp taskloop shared(s_val)\n      for (int i = 0; i < N; ++i){\n        #pragma omp atomic update\n        ++s_val; \n      }\n    }\n  }\n  OMPVV_ERROR_IF(s_val != N, \"Value of s_val should be %i, received %i\", N, s_val);\n  OMPVV_TEST_AND_SET(errors, s_val != N);\n  return errors;\n}\n\nint main() {\n    int errors = 0;\n    OMPVV_TEST_OFFLOADING;\n    OMPVV_TEST_AND_SET(errors, taskloop_shared());\n    OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_map_array_default.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp master\" at position 618",
        "issue_id": 0,
        "original_code": "//===--test_target_map_array_default.c - test default behavior of array map--===//\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// Whenever a map-type-modifier is not specified in the map clause, the symbol\n// is mapped as a tofrom. This test make sure this is satisfied\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nint main() {\n  int compute_array[N];\n  int sum = 0, result = 0, errors = 0;\n  int i;\n  \n  OMPVV_TEST_OFFLOADING;\n\n  // Array initialization\n  for (i=0; i<N; i++) \n    compute_array[i] = 10;\n\n#pragma omp target map(compute_array)\n  {\n    for (i = 0; i < N; i++)\n      compute_array[i] += i;\n   \n  } // End target\n\n  for (i = 0; i < N; i++)\n    sum = sum + compute_array[i];\n  \n  for (i = 0; i < N; i++)\n    result += 10 + i;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != sum);\n\n  OMPVV_REPORT_AND_RETURN(errors)\n}\n",
        "error_code": "//===--test_target_map_array_default.c - test default behavior of array map--===//\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// Whenever a map-type-modifier is not specified in the map clause, the symbol\n// is mapped as a tofrom. This test make sure this is satisfied\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nint main() {\n  int compute_array[N];\n  int sum = 0, result = 0, errors = 0;\n  int i;\n  \n  OMPVV_TEST_OFFLOADING;\n\n  // Array initialization\n  for (i=0; i<N; i++) \n    compute_array[i] = 10;\n\n#pragma omp master map(compute_array)\n  {\n    for (i = 0; i < N; i++)\n      compute_array[i] += i;\n   \n  } // End target\n\n  for (i = 0; i < N; i++)\n    sum = sum + compute_array[i];\n  \n  for (i = 0; i < N; i++)\n    result += 10 + i;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != sum);\n\n  OMPVV_REPORT_AND_RETURN(errors)\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_is_accessible.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n\tint errors = 0;\n\tOMPVV_TEST_OFFLOADING;\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, check_device() != 0);\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\" at position 1565",
        "issue_id": 4,
        "original_code": "//--------------- test_target_is_accessible.c---------------------//\n//\n// OpenMP API Version 5.1 Aug 2020\n//\n// This test checks that the omp_target_is_accessible device routine.\n// In this test the output of the target_is_accessible call should return\n// true because the storage indicated by the first and second arguements\n// is accessible by the targeted device. This test is closely adapdted\n// from the 5.1 OpenMP example sheet.\n//-----------------------------------------------------------------------//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\nint check_device(){\n\tint errors = 0;\n\tint isSharedMemory = 0;\n\tint check_test = 2;\n\tconst int N = 100;\n\tconst int buf_size = sizeof(int) * N;\n\tconst int dev = omp_get_default_device();\n\t\n\t/*Assumes that on shared-memory systems, no copy is done*/\n\t#pragma omp target map(to: isSharedMemory)\n\t\tisSharedMemory = 1;\n\n\tint *ptr = (int *) malloc(buf_size);\n\n\tcheck_test = omp_target_is_accessible(ptr, buf_size, dev);\n\t\n\tif(check_test)\n\t\t{\n\t\t#pragma omp target firstprivate(ptr)\n\t\t\tfor (int i=0; i<N; i++)\n\t\t\t\tptr[i] = 5*i;\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tOMPVV_TEST_AND_SET(errors, ptr[i] != 5*i);\n\t\t}\n\n\tfree(ptr);\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, check_test != isSharedMemory);\n\tOMPVV_INFOMSG_IF(check_test == 1, \"Omp_target_is_accessible returning true\");\n\tOMPVV_INFOMSG_IF(check_test == 0, \"Omp_target_is_accessible returning false\");\n\tOMPVV_ERROR_IF(check_test == 2, \"omp_target_is_accessible did not return true or false\");\n\treturn errors;\n}\n\nint main(){\n\tint errors = 0;\n\tOMPVV_TEST_OFFLOADING;\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, check_device() != 0);\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//--------------- test_target_is_accessible.c---------------------//\n//\n// OpenMP API Version 5.1 Aug 2020\n//\n// This test checks that the omp_target_is_accessible device routine.\n// In this test the output of the target_is_accessible call should return\n// true because the storage indicated by the first and second arguements\n// is accessible by the targeted device. This test is closely adapdted\n// from the 5.1 OpenMP example sheet.\n//-----------------------------------------------------------------------//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\nint check_device(){\n\tint errors = 0;\n\tint isSharedMemory = 0;\n\tint check_test = 2;\n\tconst int N = 100;\n\tconst int buf_size = sizeof(int) * N;\n\tconst int dev = omp_get_default_device();\n\t\n\t/*Assumes that on shared-memory systems, no copy is done*/\n\t#pragma omp target map(to: isSharedMemory)\n\t\tisSharedMemory = 1;\n\n\tint *ptr = (int *) malloc(buf_size);\n\n\tcheck_test = omp_target_is_accessible(ptr, buf_size, dev);\n\t\n\tif(check_test)\n\t\t{\n\t\t#pragma omp target firstprivate(ptr)\n\t\t\tfor (int i=0; i<N; i++)\n\t\t\t\tptr[i] = 5*i;\n\t\tfor (int i = 0; i < N; i++)\n\t\t\tOMPVV_TEST_AND_SET(errors, ptr[i] != 5*i);\n\t\t}\n\n\tfree(ptr);\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, check_test != isSharedMemory);\n\tOMPVV_INFOMSG_IF(check_test == 1, \"Omp_target_is_accessible returning true\");\n\tOMPVV_INFOMSG_IF(check_test == 0, \"Omp_target_is_accessible returning false\");\n\tOMPVV_ERROR_IF(check_test == 2, \"omp_target_is_accessible did not return true or false\");\n\treturn errors;\n}\n\nint main()\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_atomic_num_hint.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp parallel\" with directive \"#pragma omp map\" at position 655",
        "issue_id": 0,
        "original_code": "//===--- test_atomic_num_hint.c -------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n//  This test checks if atomic hints passed by enum value\n//  are accepted by the compiler. If the sync hint is not\n//  yet defined in the specification, it defaults to \n//  omp_sync_hint_none (0x0). \n////===--------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_atomic_with_used_enum_value() {\n  OMPVV_INFOMSG(\"test_atomic_with_used_enum_value\");\n  int errors = 0, x = 0, num_threads = -1;\n\n#pragma omp parallel num_threads(2) default(shared)\n  {\n    if (omp_get_thread_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n#pragma omp atomic hint(0X4) // corrosponds to omp_sync_hint_nonspeculative\n    x++;\n  }\n\n  OMPVV_ERROR_IF(num_threads < 0, \"Test ran with invalid number of teams (less than zero)\");\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so the results are not conclusive\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, x != num_threads);\n\n  return errors;\n}\n\nint test_atomic_with_unused_enum_value() {\n  OMPVV_INFOMSG(\"test_atomic_with_unused_enum_value\");\n  int errors = 0, x = 0, num_threads = -1;\n\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST) default(shared)\n  {\n    if (omp_get_thread_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n#pragma omp atomic hint(0X1024) //As of OMP Spec 5.0 only values till 0x8 have been taken\n    x++;\n  }\n\n  OMPVV_ERROR_IF(num_threads < 0, \"Test ran with invalid number of teams (less than zero)\");\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so the results are not conclusive\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, x != num_threads);\n\n  return errors;\n}\n\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_atomic_with_used_enum_value());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_atomic_with_unused_enum_value());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_atomic_num_hint.c -------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n//  This test checks if atomic hints passed by enum value\n//  are accepted by the compiler. If the sync hint is not\n//  yet defined in the specification, it defaults to \n//  omp_sync_hint_none (0x0). \n////===--------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_atomic_with_used_enum_value() {\n  OMPVV_INFOMSG(\"test_atomic_with_used_enum_value\");\n  int errors = 0, x = 0, num_threads = -1;\n\n#pragma omp map num_threads(2) default(shared)\n  {\n    if (omp_get_thread_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n#pragma omp atomic hint(0X4) // corrosponds to omp_sync_hint_nonspeculative\n    x++;\n  }\n\n  OMPVV_ERROR_IF(num_threads < 0, \"Test ran with invalid number of teams (less than zero)\");\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so the results are not conclusive\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, x != num_threads);\n\n  return errors;\n}\n\nint test_atomic_with_unused_enum_value() {\n  OMPVV_INFOMSG(\"test_atomic_with_unused_enum_value\");\n  int errors = 0, x = 0, num_threads = -1;\n\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST) default(shared)\n  {\n    if (omp_get_thread_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n#pragma omp atomic hint(0X1024) //As of OMP Spec 5.0 only values till 0x8 have been taken\n    x++;\n  }\n\n  OMPVV_ERROR_IF(num_threads < 0, \"Test ran with invalid number of teams (less than zero)\");\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so the results are not conclusive\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, x != num_threads);\n\n  return errors;\n}\n\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_atomic_with_used_enum_value());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_atomic_with_unused_enum_value());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_omp_display_env.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 553",
        "issue_id": 1,
        "original_code": "//===-- test_omp_display_env.c --------------------------------------------===//\n//\n// OpenMP API Version 5.1 Aug 2021\n//\n// Tests the behavior of omp_display_env. This test should print out the OpenMP\n// version number and the initial values of the ICV's associated with the\n// environment variables\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\nint test_omp_display_env(){\n\tomp_display_env(1);\n\treturn 0;\n}\n\nint main(){\n\tOMPVV_REPORT_AND_RETURN(test_omp_display_env());\n}\n",
        "error_code": "//===-- test_omp_display_env.c --------------------------------------------===//\n//\n// OpenMP API Version 5.1 Aug 2021\n//\n// Tests the behavior of omp_display_env. This test should print out the OpenMP\n// version number and the initial values of the ICV's associated with the\n// environment variables\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\nint test_omp_display_env(){\n\tomp_display_env(1);\n\treturn 0;\n}\n\nint main()\n\tOMPVV_REPORT_AND_RETURN(test_omp_display_env());\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_requires_unified_shared_memory_static_map.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1538",
        "issue_id": 1,
        "original_code": "//===---test_requires_unified_shared_memory_static_map.c --------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// We request the use of unified_shared_memory in this program.\n// Checking for static arrays. The array is global and then accessed through \n// a pointer from the host and the device.\n//\n// We use the map clause on the pointer, with zero length array, to use the host\n// pointer on the device.\n////===----------------------------------------------------------------------===//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp requires unified_shared_memory\n\n// STATIC ARRAY \nint anArray[N];\n\nint unified_shared_memory_static_map() {\n  OMPVV_INFOMSG(\"Unified shared memory testing - Static Array\");\n  int errors = 0;\n  \n  int anArrayCopy[N];\n  int * aPtr = anArray;\n\n  for (int i = 0; i < N; i++) {\n    anArray[i] = i;\n    anArrayCopy[i] = 0;\n  }\n\n  // Test for writes to this varriable from device\n#pragma omp target map(aPtr)\n  {\n    for (int i = 0; i < N; i++) {\n      aPtr[i] += 10;\n    }\n  }\n  // Modify again on the host\n  for (int i = 0; i < N; i++) {\n    aPtr[i] += 10;\n  }\n\n  // Test for reads to this variable from device\n#pragma omp target map(aPtr)\n  {\n    for (int i = 0; i < N; i++) {\n      anArrayCopy[i] = aPtr[i];\n    }\n  }\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArray[i] != i + 20);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArrayCopy[i] != i + 20);\n    if (errors) break;\n  }\n  return errors;\n}\n\nint main() {\n  int isOffloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"With no offloading, unified shared memory is guaranteed due to host execution\");\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, unified_shared_memory_static_map());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---test_requires_unified_shared_memory_static_map.c --------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// We request the use of unified_shared_memory in this program.\n// Checking for static arrays. The array is global and then accessed through \n// a pointer from the host and the device.\n//\n// We use the map clause on the pointer, with zero length array, to use the host\n// pointer on the device.\n////===----------------------------------------------------------------------===//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp requires unified_shared_memory\n\n// STATIC ARRAY \nint anArray[N];\n\nint unified_shared_memory_static_map() {\n  OMPVV_INFOMSG(\"Unified shared memory testing - Static Array\");\n  int errors = 0;\n  \n  int anArrayCopy[N];\n  int * aPtr = anArray;\n\n  for (int i = 0; i < N; i++) {\n    anArray[i] = i;\n    anArrayCopy[i] = 0;\n  }\n\n  // Test for writes to this varriable from device\n#pragma omp target map(aPtr)\n  {\n    for (int i = 0; i < N; i++) {\n      aPtr[i] += 10;\n    }\n  }\n  // Modify again on the host\n  for (int i = 0; i < N; i++) {\n    aPtr[i] += 10;\n  }\n\n  // Test for reads to this variable from device\n#pragma omp target map(aPtr)\n  {\n    for (int i = 0; i < N; i++) {\n      anArrayCopy[i] = aPtr[i];\n    }\n  }\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArray[i] != i + 20);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArrayCopy[i] != i + 20);\n    if (errors) break;\n  }\n  return errors;\n}\n\nint main() \n  int isOffloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"With no offloading, unified shared memory is guaranteed due to host execution\");\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, unified_shared_memory_static_map());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_teams_set_num_teams.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp teams\" with directive \"#pragma omp cancel\" at position 924",
        "issue_id": 0,
        "original_code": "//===--------------------- test_teams_set_num_teams.c ----------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// This test uses the omp_set_num_teams utility to set the default number of\n// teams allocated for team clauses. The test runs teams and checks to see if\n// the number allocated is correct and reflective of the new default set. It\n// then checks to see if an explicitly stated num_teams clause overrides\n// the omp_set_num_teams properly.\n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\nint main() {\n\n\n\tint errors = 0; \n\tint num_teams = 0;\n\tomp_set_num_teams(8);\n        \t\n\tnum_teams = omp_get_max_teams();             \n\t\n\tOMPVV_ERROR_IF(num_teams != 8, \"Upper bound of the number of teams is not the number set by omp_set_num_teams()\");\n\tOMPVV_TEST_AND_SET(errors, num_teams != 8);\n\n\t#pragma omp teams \n\t{\n\t\tif (omp_get_team_num() == 0 ) {\n\t\t\tnum_teams = omp_get_num_teams();\n\t\t}\n\t}\n\tOMPVV_ERROR_IF(num_teams > 8, \"Incorrect number of teams detected when num_teams clause was not specified\");\t\n\tOMPVV_TEST_AND_SET(errors, num_teams > 8);\n\n\t#pragma omp teams num_teams(OMPVV_NUM_TEAMS_HOST)\n\t{\n\t\tif (omp_get_team_num() == 0 ) {\n\t\t\tnum_teams = omp_get_num_teams();\n\t\t}\n\t}\n\tOMPVV_ERROR_IF(num_teams != OMPVV_NUM_TEAMS_HOST, \"The number of teams was not overriden by the num_teams clause\");\t\n\tOMPVV_TEST_AND_SET(errors, num_teams != OMPVV_NUM_TEAMS_HOST);\n\n\t\n\t\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--------------------- test_teams_set_num_teams.c ----------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// This test uses the omp_set_num_teams utility to set the default number of\n// teams allocated for team clauses. The test runs teams and checks to see if\n// the number allocated is correct and reflective of the new default set. It\n// then checks to see if an explicitly stated num_teams clause overrides\n// the omp_set_num_teams properly.\n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\nint main() {\n\n\n\tint errors = 0; \n\tint num_teams = 0;\n\tomp_set_num_teams(8);\n        \t\n\tnum_teams = omp_get_max_teams();             \n\t\n\tOMPVV_ERROR_IF(num_teams != 8, \"Upper bound of the number of teams is not the number set by omp_set_num_teams()\");\n\tOMPVV_TEST_AND_SET(errors, num_teams != 8);\n\n\t#pragma omp cancel \n\t{\n\t\tif (omp_get_team_num() == 0 ) {\n\t\t\tnum_teams = omp_get_num_teams();\n\t\t}\n\t}\n\tOMPVV_ERROR_IF(num_teams > 8, \"Incorrect number of teams detected when num_teams clause was not specified\");\t\n\tOMPVV_TEST_AND_SET(errors, num_teams > 8);\n\n\t#pragma omp teams num_teams(OMPVV_NUM_TEAMS_HOST)\n\t{\n\t\tif (omp_get_team_num() == 0 ) {\n\t\t\tnum_teams = omp_get_num_teams();\n\t\t}\n\t}\n\tOMPVV_ERROR_IF(num_teams != OMPVV_NUM_TEAMS_HOST, \"The number of teams was not overriden by the num_teams clause\");\t\n\tOMPVV_TEST_AND_SET(errors, num_teams != OMPVV_NUM_TEAMS_HOST);\n\n\t\n\t\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_update_mapper_from_discontiguous.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1382",
        "issue_id": 1,
        "original_code": "//===--- test_target_update_mapper_from_discontiguous.c -----------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test seeks to ensure that target update with motion-clause \"from\" can properly\n// map data from the device by specifying a user-defined mapper. Additionally, the test\n// checks a new addition to target update in OpenMP 5.0 that states \"List items in the\n// to or from clauses may include array sections with stride expressions.\" \n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\ntypedef struct{\n  int len;\n  int *data;\n} T;\n\nint errors = 0;\n\n#pragma omp declare mapper(custom: T v) map(to: v, v.len, v.data[0:v.len])\n\nint target_update_from_mapper() {\n  \n  T s;\n  \n  s.len = N;\n  s.data = (int *)calloc(N,sizeof(int));\n  \n  \n   #pragma omp target data map(mapper(custom), to:s) \n  { \n    #pragma omp target\n    { \n      for (int i = 0; i < s.len; i++) {\n        s.data[i] = i;\n      }\n    }//end target\n  \n  #pragma omp target update from(s.data[:N/2:2]) //only update even array elements\n  }//end-target-data \n\n  for (int i =0; i < s.len; i++) {\n    if(i%2){\n      OMPVV_TEST_AND_SET(errors, s.data[i] != 0);\n    }\n    else{\n      OMPVV_TEST_AND_SET(errors, s.data[i] != i);\n    }\n  }\n\n  return errors;\n}\n\nint main() {\n\n  OMPVV_TEST_OFFLOADING;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, target_update_from_mapper());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_update_mapper_from_discontiguous.c -----------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test seeks to ensure that target update with motion-clause \"from\" can properly\n// map data from the device by specifying a user-defined mapper. Additionally, the test\n// checks a new addition to target update in OpenMP 5.0 that states \"List items in the\n// to or from clauses may include array sections with stride expressions.\" \n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\ntypedef struct{\n  int len;\n  int *data;\n} T;\n\nint errors = 0;\n\n#pragma omp declare mapper(custom: T v) map(to: v, v.len, v.data[0:v.len])\n\nint target_update_from_mapper() {\n  \n  T s;\n  \n  s.len = N;\n  s.data = (int *)calloc(N,sizeof(int));\n  \n  \n   #pragma omp target data map(mapper(custom), to:s) \n  { \n    #pragma omp target\n    { \n      for (int i = 0; i < s.len; i++) {\n        s.data[i] = i;\n      }\n    }//end target\n  \n  #pragma omp target update from(s.data[:N/2:2]) //only update even array elements\n  }//end-target-data \n\n  for (int i =0; i < s.len; i++) {\n    if(i%2){\n      OMPVV_TEST_AND_SET(errors, s.data[i] != 0);\n    }\n    else{\n      OMPVV_TEST_AND_SET(errors, s.data[i] != i);\n    }\n  }\n\n  return errors;\n}\n\nint main() \n\n  OMPVV_TEST_OFFLOADING;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, target_update_from_mapper());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_memcpy_rect_async_no_obj.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 2753",
        "issue_id": 2,
        "original_code": "//===--- test_target_memcpy_rect_async_no_obj.c ----------------------------===//\n//\n//  OpenMP API Version 5.1 Nov 2020\n//\n//  Inspired from OpenMP 5.1 Examples Doc, 5.16.4 & 8.9\n//  This test utilizes the omp_target_memcpy_rect_async construct to\n//  allocate 2D memory on the device asynchronously. The construct\n//  uses '0' for 'depobj_count', so that the clause is not dependent\n//  and memory is therefore copied synchronously.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 5\n#define M 10\n\nint errors, i, j;\n\nint test_target_memcpy_async_depobj() {\n\n    const size_t volume[2] = {5, 10};\n    const size_t offsets[2] = {0, 0};\n    const size_t dimensions[2] = {N, M};\n\n    int h, t;\n    errors = 0;\n    h = omp_get_initial_device();\n    t = omp_get_default_device();\n\n    double hostRect[N][M]; // 5x10 2D array\n    double *devRect = (double *)omp_target_alloc(sizeof(double)*N*M, t);\n\n    OMPVV_TEST_AND_SET_VERBOSE(errors, devRect == NULL);\n\n    for(i = 0; i < N; i++){             //each index is set to number of their row\n        for (j = 0; j < M; j++){\n            hostRect[i][j] = i + j;\n        }\n    }\n\n    /* copy to device memory */\n    omp_target_memcpy_rect_async(devRect, hostRect, \n                                sizeof(double), 2, \n                                volume, //5 by 10\n                                offsets,    offsets,\n                                dimensions, dimensions,\n                                t,          h,\n                                0,          NULL);  // no dependent objects, 'depobj_list' i.e. NULL is ignored\n\n    #pragma omp taskwait\n    #pragma omp target is_device_ptr(devRect) device(t)\n    {\n        for(i = 0; i < N; i++){\n            for (j = 0; j < M; j++){\n                devRect[i*M + j] = devRect[i*M + j]*2; // initialize data\n            }\n        }\n    }\n\n    /* copy to host memory */\n    omp_target_memcpy_rect_async(hostRect, devRect,\n                                sizeof(double), 2,\n                                volume, //5 by 10\n                                offsets,          offsets,\n                                dimensions, dimensions,\n                                h,          t,\n                                0,          NULL);\n\n    #pragma omp taskwait\n    for(i = 0; i < N; i++){\n        for(j = 0; j < M; j++){\n            OMPVV_TEST_AND_SET(errors, hostRect[i][j]!=(i+j)*2);\n        }\n    }\n    // free resources\n    omp_target_free(devRect, t);\n    return errors;\n}\n\nint main() {\n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_memcpy_async_depobj() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_memcpy_rect_async_no_obj.c ----------------------------===//\n//\n//  OpenMP API Version 5.1 Nov 2020\n//\n//  Inspired from OpenMP 5.1 Examples Doc, 5.16.4 & 8.9\n//  This test utilizes the omp_target_memcpy_rect_async construct to\n//  allocate 2D memory on the device asynchronously. The construct\n//  uses '0' for 'depobj_count', so that the clause is not dependent\n//  and memory is therefore copied synchronously.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 5\n#define M 10\n\nint errors, i, j;\n\nint test_target_memcpy_async_depobj() {\n\n    const size_t volume[2] = {5, 10};\n    const size_t offsets[2] = {0, 0};\n    const size_t dimensions[2] = {N, M};\n\n    int h, t;\n    errors = 0;\n    h = omp_get_initial_device();\n    t = omp_get_default_device();\n\n    double hostRect[N][M]; // 5x10 2D array\n    double *devRect = (double *)omp_target_alloc(sizeof(double)*N*M, t);\n\n    OMPVV_TEST_AND_SET_VERBOSE(errors, devRect == NULL);\n\n    for(i = 0; i < N; i++){             //each index is set to number of their row\n        for (j = 0; j < M; j++){\n            hostRect[i][j] = i + j;\n        }\n    }\n\n    /* copy to device memory */\n    omp_target_memcpy_rect_async(devRect, hostRect, \n                                sizeof(double), 2, \n                                volume, //5 by 10\n                                offsets,    offsets,\n                                dimensions, dimensions,\n                                t,          h,\n                                0,          NULL);  // no dependent objects, 'depobj_list' i.e. NULL is ignored\n\n    #pragma omp taskwait\n    #pragma omp target is_device_ptr(devRect) device(t)\n    {\n        for(i = 0; i < N; i++){\n            for (j = 0; j < M; j++){\n                devRect[i*M + j] = devRect[i*M + j]*2; // initialize data\n            }\n        }\n    }\n\n    /* copy to host memory */\n    omp_target_memcpy_rect_async(hostRect, devRect,\n                                sizeof(double), 2,\n                                volume, //5 by 10\n                                offsets,          offsets,\n                                dimensions, dimensions,\n                                h,          t,\n                                0,          NULL);\n\n    #pragma omp taskwait\n    for(i = 0; i < N; i++){\n        for(j = 0; j < M; j++){\n            OMPVV_TEST_AND_SET(errors, hostRect[i][j]!=(i+j)*2);\n        }\n    }\n    // free resources\n    omp_target_free(devRect, t);\n    return errors;\n}\n\nint main() {\n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_memcpy_async_depobj() != 0);yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_depend_unused_data.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===--- test_target_teams_distribute_depend_unused_data.c-------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks if out-out dependency works even if the data in the list\n// is unused by either task. Both tasks are given the nowait clause to allow\n// for the possibility that they will be incorrectly run out of order. If the\n// two target teams ditribute loops run out of order, the test fails.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_target_teams_distribute_depend_unused_data() {\n  int isOffloading = 0;\n  int errors = 0;\n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int random_data[1];\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n    b[x] = 2 * x;\n    c[x] = 0;\n    d[x] = 0;\n  }\n\n#pragma omp target data map(to: a[0:N], b[0:N]) map(alloc: c[0:N], random_data[0:1]) map(from: d[0:N])\n  {\n#pragma omp target teams distribute nowait depend(out: random_data) map(alloc: a[0:N], b[0:N], c[0:N])\n    for (int x = 0; x < N; ++x) {\n      c[x] = a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(out: random_data) map(alloc: b[0:N], c[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n      d[x] = c[x] + b[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n      OMPVV_ERROR_IF(d[x] != 5*x, \"Test of depend clause using array sections did not pass with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n      OMPVV_TEST_AND_SET_VERBOSE(errors, d[x] != 5*x);\n      if (d[x] != 5*x) {\n        break;\n      }\n  }\n\n  return errors;\n}\n\n\nint main() {\n  int errors = 0;\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  errors += test_target_teams_distribute_depend_unused_data();\n  OMPVV_INFOMSG_IF(errors != 0, \"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nshort tompxajzep = 226;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_defaultmap_present_scalar.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===--- test_target_defaultmap_present_scalar.c ----------------------------===//\n//\n//  OpenMP API Version 5.1 Aug 2020\n//\n//  This test checks behavior of the defaultmap clause when the specified \n//  implicit-behavior is present. The variable-categories available for defaultmap\n//  are scalar, aggregate, and pointer. If implicit-behavior is present, each \n//  variable referenced in the construct in the category specified by \n//  variable-category is treated as if it had been listed in a map clause with the\n//  map-type of alloc and map-type-modifier of present.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint errors;\n\nint test_defaultmap_present_scalar() {\n\n   int scalar_var; \n   float float_var;\n   double double_var;\n   int is_shared_env;\n\n   errors = 0;\n   is_shared_env = 0;\n   scalar_var = 1;\n   float_var = 10.7f;\n   double_var = 12.22;\n\n   OMPVV_TEST_AND_SET_SHARED_ENVIRONMENT(is_shared_env);\n   OMPVV_WARNING_IF(is_shared_env != 0, \"[WARNING] may not be able to detect errors if the target system supports shared memory.\");\n\n   #pragma omp target enter data map(to: scalar_var, float_var, double_var)\n   #pragma omp target map(tofrom: errors) defaultmap(present: scalar)\n   {\n      if(scalar_var != 1){errors++;}\n      if(float_var != 10.7f){errors++;}\n      if(double_var != 12.22){errors++;}\n\n      scalar_var = 7;\n      float_var = 20.1f;\n      double_var = 55.55;\n   }\n   #pragma omp target exit data map(delete: scalar_var, float_var, double_var)\n\n   OMPVV_ERROR_IF(errors > 0, \"Values were not mapped to the device properly\");\n\n   if( is_shared_env == 0 ) {\n      OMPVV_TEST_AND_SET(errors, scalar_var == 7);\n      OMPVV_TEST_AND_SET(errors, float_var == 20.1f);\n      OMPVV_TEST_AND_SET(errors, double_var == 55.55);\n   }\n\n   return errors;\n}\n\nint main() {\n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_defaultmap_present_scalar() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nbyte mwaidokwbp = 142;\nlong fnuwrgnzkc = 152;\nbyte nmztzesuir = 154;\nlong euzubqyzqi = 101;\nshort wlbaghtqot = 254;\nfloat chkgmvhbut = 220;\nbyte qcpybvgpmd = 156;\nbyte sznbkxlhgc = 17;\nint bdyfspgobi = 9;\nfloat ukiifrgoud = 48;\nlong qeqbupccla = 136;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_simd_if.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp simd\" with directive \"#pragma omp atomic\" at position 895",
        "issue_id": 0,
        "original_code": "//===--- test_simd_if.c ---------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This is a test of the simd construct with an 'if' clause specified.\n// When the statement in the 'if' clause evaluates to true, \n// the preferred number of iterations secified in the simdlen clause \n// will run concurrently. When the 'if' clause evaluates to be false,\n// the number of iterations that will execute concurrently is one.\n//\n////===--------------------------------------------------------------===//\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <omp.h> \n#include \"ompvv.h\" \n\n#define N 1024\n\nint test_simd_if () {\n   int errors = 0;\n   int i;\n   int b[N], c[N];\n\n   struct new_struct {\n      int a[N];\n   };\n\n   struct new_struct struct_t;\n   \n   for (i = 0; i < N; i++ ) {\n      struct_t.a[i] = i;\n      b[i] = i + 5;\n      c[i] = 0;\n   }\n\n   int k = N;\n\n   #pragma omp simd simdlen(64) if(k == N) // simdlen specifies # of concurrent iterations\n      for (i = 0; i < N; i++) {\n         c[i] = struct_t.a[i] * b[i];\n      }\n\n   for (i = 0; i < N; i++) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, c[i] != (struct_t.a[i] * b[i]));\n   }\n\n   #pragma omp simd simdlen(64) if(k != N) \n      for (i = 0; i < N; i++) {\n         c[i] = struct_t.a[i] * 2 * b[i];\n      }\n\n   for (i = 0; i < N; i++) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, c[i] != (struct_t.a[i] * 2 * b[i]));\n   }\n\n   return errors;\n}\n\n\nint main () { \n   int errors = 0;\n   \n   OMPVV_WARNING(\"Vectorization resulting from the construct cannot be guaranteed\"); \n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_simd_if());\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_simd_if.c ---------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This is a test of the simd construct with an 'if' clause specified.\n// When the statement in the 'if' clause evaluates to true, \n// the preferred number of iterations secified in the simdlen clause \n// will run concurrently. When the 'if' clause evaluates to be false,\n// the number of iterations that will execute concurrently is one.\n//\n////===--------------------------------------------------------------===//\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <omp.h> \n#include \"ompvv.h\" \n\n#define N 1024\n\nint test_simd_if () {\n   int errors = 0;\n   int i;\n   int b[N], c[N];\n\n   struct new_struct {\n      int a[N];\n   };\n\n   struct new_struct struct_t;\n   \n   for (i = 0; i < N; i++ ) {\n      struct_t.a[i] = i;\n      b[i] = i + 5;\n      c[i] = 0;\n   }\n\n   int k = N;\n\n   #pragma omp atomic simdlen(64) if(k == N) // simdlen specifies # of concurrent iterations\n      for (i = 0; i < N; i++) {\n         c[i] = struct_t.a[i] * b[i];\n      }\n\n   for (i = 0; i < N; i++) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, c[i] != (struct_t.a[i] * b[i]));\n   }\n\n   #pragma omp simd simdlen(64) if(k != N) \n      for (i = 0; i < N; i++) {\n         c[i] = struct_t.a[i] * 2 * b[i];\n      }\n\n   for (i = 0; i < N; i++) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, c[i] != (struct_t.a[i] * 2 * b[i]));\n   }\n\n   return errors;\n}\n\n\nint main () { \n   int errors = 0;\n   \n   OMPVV_WARNING(\"Vectorization resulting from the construct cannot be guaranteed\"); \n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_simd_if());\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_reduction_bitor.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp single\" at position 1355",
        "issue_id": 0,
        "original_code": "//===--- test_target_teams_distribute_reduction_bitor.c----------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the reduction clause on a target teams distribute directive,\n// testing that the variable in the reduction clause is properly reduced using\n// the bitor operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n#define THRESHOLD 1024\n\nint test_bitor() {\n  int a[N];\n  // See the 'and' operator test for an exaplantion of this math.\n  double true_margin = pow(exp(1), log(.5)/N);\n  int errors = 0;\n  int num_teams[N];\n  int num_attempts = 0;\n  int have_true = 0, have_false = 0;\n  srand(1);\n\n  while ((!have_true || !have_false) && (num_attempts < THRESHOLD)) {\n    have_true = 0;\n    have_false = 0;\n    for (int x = 0; x < N; ++x) {\n      for (int y = 0; y < 16; ++y) {\n        if (rand() / (double) RAND_MAX > true_margin) {\n          a[x] += (1 << y);\n          have_true = 1;\n        } else {\n          have_false = 1;\n        }\n      }\n      num_teams[x] = -x;\n    }\n    num_attempts++;\n  }\n\n  OMPVV_WARNING_IF(!have_true, \"No true bits were generated to test\");\n  OMPVV_WARNING_IF(!have_false, \"No false bits were generated to test\");\n\n  unsigned int b = 0;\n\n#pragma omp target teams distribute reduction(|:b) defaultmap(tofrom:scalar)\n  for (int x = 0; x < N; ++x) {\n    num_teams[x] = omp_get_num_teams();\n    b = b | a[x];\n  }\n\n  unsigned int host_b = 0;\n\n  for (int x = 0; x < N; ++x) {\n    host_b = host_b | a[x];\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_teams[x - 1] != num_teams[x], \"Kernel reported differing numbers of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_teams[0] == 1, \"Test operated with one team.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_teams[0] <= 0, \"Test reported invalid number of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, b != host_b);\n  OMPVV_ERROR_IF(host_b != b, \"Bit on device is %d but expected bit from host is %d.\", b, host_b);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_bitor() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_reduction_bitor.c----------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the reduction clause on a target teams distribute directive,\n// testing that the variable in the reduction clause is properly reduced using\n// the bitor operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n#define THRESHOLD 1024\n\nint test_bitor() {\n  int a[N];\n  // See the 'and' operator test for an exaplantion of this math.\n  double true_margin = pow(exp(1), log(.5)/N);\n  int errors = 0;\n  int num_teams[N];\n  int num_attempts = 0;\n  int have_true = 0, have_false = 0;\n  srand(1);\n\n  while ((!have_true || !have_false) && (num_attempts < THRESHOLD)) {\n    have_true = 0;\n    have_false = 0;\n    for (int x = 0; x < N; ++x) {\n      for (int y = 0; y < 16; ++y) {\n        if (rand() / (double) RAND_MAX > true_margin) {\n          a[x] += (1 << y);\n          have_true = 1;\n        } else {\n          have_false = 1;\n        }\n      }\n      num_teams[x] = -x;\n    }\n    num_attempts++;\n  }\n\n  OMPVV_WARNING_IF(!have_true, \"No true bits were generated to test\");\n  OMPVV_WARNING_IF(!have_false, \"No false bits were generated to test\");\n\n  unsigned int b = 0;\n\n#pragma omp single teams distribute reduction(|:b) defaultmap(tofrom:scalar)\n  for (int x = 0; x < N; ++x) {\n    num_teams[x] = omp_get_num_teams();\n    b = b | a[x];\n  }\n\n  unsigned int host_b = 0;\n\n  for (int x = 0; x < N; ++x) {\n    host_b = host_b | a[x];\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_teams[x - 1] != num_teams[x], \"Kernel reported differing numbers of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_teams[0] == 1, \"Test operated with one team.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_teams[0] <= 0, \"Test reported invalid number of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, b != host_b);\n  OMPVV_ERROR_IF(host_b != b, \"Bit on device is %d but expected bit from host is %d.\", b, host_b);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_bitor() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_loop_order_unconstrained.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 680",
        "issue_id": 2,
        "original_code": "//===------------ test_loop_for_order_unconstrained.c -----------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// This test checks that the order(unconstrained:concurrent) clause is \n// properly handled. Since with unconstrained the values can be executed in any\n// order this test simply checks that the correct values have been calculated\n// for the array. In other words, that all iterations finish regardless of order.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main() {\n\tint errors = 0;\n\tint x[N];\n\n\tfor (int i = 0; i < N; i++) {\n\t\tx[i] = i;\n\t}\n\n\tOMPVV_TEST_OFFLOADING;\n\n\t#pragma omp target map(tofrom: x)\n\t{\n\t\t#pragma omp parallel loop order(unconstrained:concurrent) \n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tx[i] = x[i] + 2;\t\n\t\t}\n\t}\n\n\tfor (int i = 0; i < N; i++) {\n    \t\tOMPVV_TEST_AND_SET(errors, x[i] != i + 2);\n\t}\n\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===------------ test_loop_for_order_unconstrained.c -----------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// This test checks that the order(unconstrained:concurrent) clause is \n// properly handled. Since with unconstrained the values can be executed in any\n// order this test simply checks that the correct values have been calculated\n// for the array. In other words, that all iterations finish regardless of order.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main() {\n\tint errors = 0;\n\tint x[N];\n\n\tfor (int i = 0; i < N;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1; i++) {\n\t\tx[i] = i;\n\t}\n\n\tOMPVV_TEST_OFFLOADING;\n\n\t#pragma omp target map(tofrom: x)\n\t{\n\t\t#pragma omp parallel loop order(unconstrained:concurrent) \n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tx[i] = x[i] + 2;\t\n\t\t}\n\t}\n\n\tfor (int i = 0; i < N; i++) {\n    \t\tOMPVV_TEST_AND_SET(errors, x[i] != i + 2);\n\t}\n\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_data_map_devices.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_set_default_dev());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_device());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 3230",
        "issue_id": 4,
        "original_code": "//===--- test_target_data_map_devices.c--- target data map to multiple dev--===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n//  This test checks for data mapping on multiple devices when using the target\n//  data directive. It makes sure that data mapping is happening on each device\n//  through the use of omp_set_default_device as well as the device() clause\n//\n//  Since OpenMP 4.5 does not have an API call to obtain the current device, \n//  this test does not guarantee that the execution devices are different. \n//  \n//  Last modified by Jose M Monsalve Diaz, December 25, 2019\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\n// Test for OpenMP 4.5 target data to multiple devices using API\nint test_map_set_default_dev() {\n  OMPVV_INFOMSG(\"test_set_default_device\");\n\n  // Get number of devices\n  int num_dev = omp_get_num_devices();\n  OMPVV_INFOMSG(\"num_devices: %d\", num_dev);\n\n  int def_dev = omp_get_default_device();\n  OMPVV_INFOMSG(\"initial device: %d\", omp_get_initial_device());\n  OMPVV_INFOMSG(\"default device: %d\", def_dev);\n\n  // Allocate num_devices + 1 to avoid zero-sized VLA if num_devices == 0\n  int sum[num_dev+1], errors = 0;\n  int* h_matrix = (int*) malloc(num_dev * N * sizeof(int));\n\n  for (int dev = 0; dev < num_dev; ++dev) {\n    omp_set_default_device(dev);\n#pragma omp target data map(from: h_matrix[dev*N:N])\n    {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, dev != omp_get_default_device());\n#pragma omp target map(alloc: h_matrix[dev*N:N])\n      {\n        for (int i = 0; i < N; ++i)\n          h_matrix[dev*N + i] = dev;\n      } // end target\n    } // end target data\n  }\n\n  // checking results \n  for (int dev = 0; dev < num_dev; ++dev) {\n    sum[dev] = h_matrix[dev*N + 0];\n    for (int i = 1; i < N; ++i)\n      sum[dev] += h_matrix[dev*N + i];\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (dev * N != sum[dev]));\n  }\n\n  omp_set_default_device(def_dev);\n  free(h_matrix);\n  return errors;\n}\n\n// Test for OpenMP 4.5 target data to multiple devices using directives\nint test_map_device() {\n\n  OMPVV_INFOMSG(\"test_map_device\");\n\n  // Get number of devices \n  int num_dev = omp_get_num_devices();\n  OMPVV_INFOMSG(\"num_devices: %d\", num_dev);\n\n  OMPVV_INFOMSG(\"initial device: %d\", omp_get_initial_device());\n  OMPVV_INFOMSG(\"default device: %d\", omp_get_default_device());\n\n  // Allocate num_devices + 1 to avoid zero-sized VLA if num_devices == 0\n  int sum[num_dev+1], errors = 0;\n  int* h_matrix = (int*) malloc(num_dev * N * sizeof(int));\n\n  for (int dev = 0; dev < num_dev; ++dev) {\n#pragma omp target data map(from: h_matrix[dev*N:N]) device(dev)\n    {\n#pragma omp target map(alloc: h_matrix[dev*N:N]) device(dev)\n      {\n        for (int i = 0; i < N; ++i)\n          h_matrix[dev*N + i] = dev;\n      } // end target\n    } // end target data\n  }\n\n  // checking results \n  errors = 0;\n  for (int dev = 0; dev < num_dev; ++dev) {\n    sum[dev] = h_matrix[dev*N + 0];\n    for (int i = 1; i < N; ++i)\n      sum[dev] += h_matrix[dev*N + i];\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (dev * N != sum[dev]));\n  }\n\n  free(h_matrix);\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_set_default_dev());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_map_device());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_data_map_devices.c--- target data map to multiple dev--===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n//  This test checks for data mapping on multiple devices when using the target\n//  data directive. It makes sure that data mapping is happening on each device\n//  through the use of omp_set_default_device as well as the device() clause\n//\n//  Since OpenMP 4.5 does not have an API call to obtain the current device, \n//  this test does not guarantee that the execution devices are different. \n//  \n//  Last modified by Jose M Monsalve Diaz, December 25, 2019\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\n// Test for OpenMP 4.5 target data to multiple devices using API\nint test_map_set_default_dev() {\n  OMPVV_INFOMSG(\"test_set_default_device\");\n\n  // Get number of devices\n  int num_dev = omp_get_num_devices();\n  OMPVV_INFOMSG(\"num_devices: %d\", num_dev);\n\n  int def_dev = omp_get_default_device();\n  OMPVV_INFOMSG(\"initial device: %d\", omp_get_initial_device());\n  OMPVV_INFOMSG(\"default device: %d\", def_dev);\n\n  // Allocate num_devices + 1 to avoid zero-sized VLA if num_devices == 0\n  int sum[num_dev+1], errors = 0;\n  int* h_matrix = (int*) malloc(num_dev * N * sizeof(int));\n\n  for (int dev = 0; dev < num_dev; ++dev) {\n    omp_set_default_device(dev);\n#pragma omp target data map(from: h_matrix[dev*N:N])\n    {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, dev != omp_get_default_device());\n#pragma omp target map(alloc: h_matrix[dev*N:N])\n      {\n        for (int i = 0; i < N; ++i)\n          h_matrix[dev*N + i] = dev;\n      } // end target\n    } // end target data\n  }\n\n  // checking results \n  for (int dev = 0; dev < num_dev; ++dev) {\n    sum[dev] = h_matrix[dev*N + 0];\n    for (int i = 1; i < N; ++i)\n      sum[dev] += h_matrix[dev*N + i];\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (dev * N != sum[dev]));\n  }\n\n  omp_set_default_device(def_dev);\n  free(h_matrix);\n  return errors;\n}\n\n// Test for OpenMP 4.5 target data to multiple devices using directives\nint test_map_device() {\n\n  OMPVV_INFOMSG(\"test_map_device\");\n\n  // Get number of devices \n  int num_dev = omp_get_num_devices();\n  OMPVV_INFOMSG(\"num_devices: %d\", num_dev);\n\n  OMPVV_INFOMSG(\"initial device: %d\", omp_get_initial_device());\n  OMPVV_INFOMSG(\"default device: %d\", omp_get_default_device());\n\n  // Allocate num_devices + 1 to avoid zero-sized VLA if num_devices == 0\n  int sum[num_dev+1], errors = 0;\n  int* h_matrix = (int*) malloc(num_dev * N * sizeof(int));\n\n  for (int dev = 0; dev < num_dev; ++dev) {\n#pragma omp target data map(from: h_matrix[dev*N:N]) device(dev)\n    {\n#pragma omp target map(alloc: h_matrix[dev*N:N]) device(dev)\n      {\n        for (int i = 0; i < N; ++i)\n          h_matrix[dev*N + i] = dev;\n      } // end target\n    } // end target data\n  }\n\n  // checking results \n  errors = 0;\n  for (int dev = 0; dev < num_dev; ++dev) {\n    sum[dev] = h_matrix[dev*N + 0];\n    for (int i = 1; i < N; ++i)\n      sum[dev] += h_matrix[dev*N + i];\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (dev * N != sum[dev]));\n  }\n\n  free(h_matrix);\n  return errors;\n}\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_loop_device.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 623",
        "issue_id": 1,
        "original_code": "#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n/**\n  This is a basic test to demonstrate device clause used\n  with \"omp target teams loop\".\n*/\nint main() {\n  int a[N];\n  int errors = 0, total_dev = 0;\n  // Data Inititalize\n  for (int i = 0; i < N; i++) {\n    a[i] = 0;  // Set to 0th device\n  }\n  total_dev = omp_get_num_devices();\n  for (int dev_num = 0; dev_num < total_dev; dev_num++) {\n  // Execute on target\n  #pragma omp target teams loop map(tofrom: a[0:N]) device(dev_num)\n    for (int i = 0; i < N; i++) {\n      a[i] = a[i] + 1;\n    }\n  }\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, a[i] != total_dev);\n  }\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n/**\n  This is a basic test to demonstrate device clause used\n  with \"omp target teams loop\".\n*/\nint main() {\n  int a[N];\n  int errors = 0, total_dev = 0;\n  // Data Inititalize\n  for (int i = 0; i < N; i++) {\n    a[i] = 0;  // Set to 0th device\n  }\n  total_dev = omp_get_num_devices();\n  for (int dev_num = 0; dev_num < total_dev; dev_num++) {\n  // Execute on target\n  #pragma omp target teams loop map(tofrom: a[0:N]) device(dev_num)\n    for (int i = 0; i < N; i++) {\n      a[i] = a[i] + 1;\n    }\n  }\n  for (int i = 0; i < N; i++) \n    OMPVV_TEST_AND_SET_VERBOSE(errors, a[i] != total_dev);\n  }\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_assume_no_parallelism.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===--- test_assume_no_parallelism.c ---------------------------------------===//\n//\n//  OpenMP API Version 5.1 Aug 2021\n//\n//  Using assume no_parallelism, the compiler can be optimized as it knows that a\n//  structured block does not contain any parallelism.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint errors, i;\n\nint test_assume_no_parallelism() {\n    int x;\n    int arr[N];\n    #pragma omp assume no_parallelism\n    {\n        x = omp_get_thread_num(); // OMP runtime routine; should be 0\n        for(i = 0; i < N; i++){\n            arr[i] = i + x;\n        }\n    }\n    #pragma omp target parallel for map(tofrom: arr)\n    for(i = 0; i < N; i++){\n        arr[i] = arr[i]*2;\n    }\n    // Test that no issues were caused from using assume directive\n    for(i = 0; i < N; i++){\n        OMPVV_TEST_AND_SET(errors, arr[i] != (i+x)*2);\n    }\n    return errors;\n}\n\nint main() {\n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_assume_no_parallelism() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nfloat oaoadbefza = 161;\nlong fathpbdeax = 46;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_loop_reduction_multiply.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===--- test_loop_reduction_multiply.c -------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the reduction clause on a loop directive, testing that the\n// variable in the reduction clause is properly reduced using the multiply\n// operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_multiply() {\n  int a[N];\n  int errors = 0;\n  int num_threads[N];\n  srand(1);\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = 1 + (int) rand() / (double) RAND_MAX;\n    num_threads[x] = -x;\n  }\n\n  int result = 1;\n  int host_result;\n\n  for (int x = 0; x < N; x = x + 16) {\n    result = 1;\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST)\n    {\n#pragma omp loop reduction(*:result)\n      for (int y = 0; y < 16; ++y) {\n        result *= a[x + y];\n      }\n#pragma omp for\n      for (int y = 0; y < 16; ++y) {\n        num_threads[x + y] = omp_get_num_threads();\n      }\n    }\n    host_result = 1;\n    for (int y = 0; y < 16; ++y) {\n      host_result *= a[x + y];\n    }\n    OMPVV_TEST_AND_SET_VERBOSE(errors, host_result != result);\n    OMPVV_INFOMSG_IF(host_result != result, \"Loop directive result is %d and expected result is %d.\", result, host_result);\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_threads[x - 1] != num_threads[x], \"Test reported differing numbers of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_threads[0] == 1, \"Test operated with one thread.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_threads[0] <= 0, \"Test reported invalid number of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  return errors;\n}\n\nint main() {\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_multiply() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nshort qgipmodwtu = 129;\nbyte iomavgtiaa = 58;\nint mczwdbgrrm = 92;\nlong vfvlfxaaux = 11;\nfloat nbsupqbjsx = 99;\nfloat nsflgdzpyd = 24;\nlong jravufajcn = 205;\nlong bldbomhass = 176;\nint ihxlmkhbnp = 99;\nbyte ylsmehxvuu = 97;\nint xxoqoigbtu = 169;\nbyte wnitlypeki = 225;\nlong ydezhqpqfd = 69;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_loop_defaultmap.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 3061",
        "issue_id": 2,
        "original_code": "//===----------------- test_target_teams_loop_defaultmap.c-----------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n// The tests in this file tests 'teams loop' construct coupled with defaultmap()\n// clause.\n// all the tests target the device offload using target construct\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n/**\n  This is a basic test to demonstrate defaultmap(tofrom)\n  clause with target teams loop construct.\n*/\nint testDefaultMapToFrom() {\n  int errors = 0;\n  int device_data[N], host_data[N];\n  for (int i = 0; i < N; i++) {\n    device_data[i] = i;\n    host_data[i] = 0;\n  }\n#pragma omp target teams loop defaultmap(tofrom)\n  for (int i = 0; i < N; i++) {\n    host_data[i] += device_data[i];\n    device_data[i] = 2*i;\n  }\n  // checking results\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, host_data[i] != i);\n    OMPVV_TEST_AND_SET(errors, device_data[i] != 2*i);\n  }\n  return errors;\n}\n\n/**\n  This is a basic test to demonstrate defaultmap(from)\n  clause with target teams loop construct.\n*/\nint testDefaultMapFrom() {\n  int errors = 0;\n  int device_data[N], host_data[N];\n  for (int i = 0; i < N; i++) {\n    device_data[i] = i;\n    host_data[i] = 0;\n  }\n#pragma omp target teams loop defaultmap(from)\n  for (int i = 0; i < N; i++) {\n    host_data[i] = i;\n  }\n  // checking results\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, host_data[i] != i);\n  }\n  return errors;\n}\n\n/**\n  This is a basic test to demonstrate defaultmap(to)\n  clause with target teams loop construct.\n*/\nint testDefaultMapTo() {\n  int errors = 0;\n  int device_data[N], host_data[N];\n  for (int i = 0; i < N; i++) {\n    device_data[i] = i;\n    host_data[i] = 0;\n  }\n#pragma omp target teams loop defaultmap(to) map(tofrom: host_data)\n  for (int i = 0; i < N; i++) {\n    host_data[i] += device_data[i];\n  }\n  // checking results\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, host_data[i] != i);\n  }\n  return errors;\n}\n\n/**\n  This is a basic test to demonstrate defaultmap(default)\n  clause with target teams loop construct.\n*/\nint testDefaultMapDefault() {\n  int errors = 0;\n  int device_data[N], host_data[N];\n  for (int i = 0; i < N; i++) {\n    device_data[i] = i;\n    host_data[i] = 0;\n  }\n#pragma omp target teams loop defaultmap(default)\n  for (int i = 0; i < N; i++) {\n    host_data[i] += device_data[i];\n    device_data[i] = 2*i;\n  }\n  // checking results\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, host_data[i] != i);\n    OMPVV_TEST_AND_SET(errors, device_data[i] != 2*i);\n  }\n  return errors;\n}\n\n/**\n  This is a basic test to demonstrate defaultmap(firstprivate)\n  clause with target teams loop construct.\n*/\nint testDefaultMapFirstPrivate() {\n  int errors = 0;\n  int device_data[N], host_data[N];\n  for (int i = 0; i < N; i++) {\n    device_data[i] = i;\n    host_data[i] = 0;\n  }\n#pragma omp target teams loop defaultmap(firstprivate)\n  for (int i = 0; i < N; i++) {\n    host_data[i] = device_data[i];\n  }\n  // checking results\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, host_data[i] != 0);\n  }\n  return errors;\n}\n\n/**\n  This is a basic test to demonstrate defaultmap(tofrom:aggregate)\n  clause with target teams loop construct.\n*/\nint testDefaultMapToFromAggr() {\n  int errors = 0;\n  int device_data[N], host_data[N];\n  for (int i = 0; i < N; i++) {\n    device_data[i] = i;\n    host_data[i] = 0;\n  }\n#pragma omp target teams loop defaultmap(tofrom:aggregate) map(tofrom: host_data)\n  for (int i = 0; i < N; i++) {\n    host_data[i] += device_data[i];\n    device_data[i] = 2*i;\n  }\n  // checking results\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, host_data[i] != i);\n    OMPVV_TEST_AND_SET(errors, device_data[i] != 2*i);\n  }\n  return errors;\n}\n\n/**\n  This is a basic test to demonstrate defaultmap(tofrom:scalar)\n  clause with target teams loop construct.\n*/\nint testDefaultMapToFromScalar() {\n  int errors = 0;\n  int x = 0;\n#pragma omp target teams loop defaultmap(tofrom:scalar) reduction(+:x)\n  for (int i = 0; i < N; i++) {\n    x += i;\n  }\n  // checking results\n  OMPVV_TEST_AND_SET(errors, x != (N*(N-1)/2));\n  return errors;\n}\n\n/**\n  This is a basic test to demonstrate defaultmap(tofrom:aggregate)\n  clause with target teams loop construct using structure.\n*/\nint testDefaultMapToFromAggrStr() {\n  int errors = 0;\n  struct dataS {\n    int device_data[N];\n    int host_data[N];\n  } dataObjS;\n  for (int i = 0; i < N; i++) {\n    dataObjS.device_data[i] = i;\n    dataObjS.host_data[i] = 0;\n  }\n#pragma omp target teams loop defaultmap(tofrom:aggregate)\n  for (int i = 0; i < N; i++) {\n    dataObjS.host_data[i] = dataObjS.device_data[i];\n  }\n  // checking results\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, dataObjS.host_data[i] != i);\n  }\n  return errors;\n}\n\n/**\n  This is a basic test to demonstrate defaultmap(tofrom:pointer)\n  clause with target teams loop construct.\n*/\nint testDefaultMapToFromPtr() {\n  int errors = 0;\n  int *ptr[N];\n#pragma omp target teams loop defaultmap(tofrom:pointer)\n  for (int i = 0; i < N; i++) {\n    ptr[i] = (int*)0xefefefef;\n  }\n  // checking results\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, ptr[i] != ((int*)0xefefefef));\n  }\n  return errors;\n}\n\n/**\n  This is a basic test to demonstrate defaultmap(alloc)\n  clause with target teams loop construct.\n*/\nint testDefaultMapAlloc() {\n  int errors = 0;\n  int device_data[N], host_data[N];\n  for (int i = 0; i < N; i++) {\n    device_data[i] = i;\n    host_data[i] = 0;\n  }\n#pragma omp target teams loop defaultmap(alloc) map(to: device_data[0:N])\n  for (int i = 0; i < N; i++) {\n    host_data[i] = device_data[i];\n  }\n  // checking results to verify host_data is unchanged\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, host_data[i] != 0);\n  }\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testDefaultMapToFrom());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testDefaultMapFrom());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testDefaultMapTo());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testDefaultMapDefault());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testDefaultMapFirstPrivate());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testDefaultMapToFromAggr());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testDefaultMapToFromScalar());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testDefaultMapToFromAggrStr());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testDefaultMapToFromPtr());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testDefaultMapAlloc());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===----------------- test_target_teams_loop_defaultmap.c-----------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n// The tests in this file tests 'teams loop' construct coupled with defaultmap()\n// clause.\n// all the tests target the device offload using target construct\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n/**\n  This is a basic test to demonstrate defaultmap(tofrom)\n  clause with target teams loop construct.\n*/\nint testDefaultMapToFrom() {\n  int errors = 0;\n  int device_data[N], host_data[N];\n  for (int i = 0; i < N; i++) {\n    device_data[i] = i;\n    host_data[i] = 0;\n  }\n#pragma omp target teams loop defaultmap(tofrom)\n  for (int i = 0; i < N; i++) {\n    host_data[i] += device_data[i];\n    device_data[i] = 2*i;\n  }\n  // checking results\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, host_data[i] != i);\n    OMPVV_TEST_AND_SET(errors, device_data[i] != 2*i);\n  }\n  return errors;\n}\n\n/**\n  This is a basic test to demonstrate defaultmap(from)\n  clause with target teams loop construct.\n*/\nint testDefaultMapFrom() {\n  int errors = 0;\n  int device_data[N], host_data[N];\n  for (int i = 0; i < N; i++) {\n    device_data[i] = i;\n    host_data[i] = 0;\n  }\n#pragma omp target teams loop defaultmap(from)\n  for (int i = 0; i < N; i++) {\n    host_data[i] = i;\n  }\n  // checking results\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, host_data[i] != i);\n  }\n  return errors;\n}\n\n/**\n  This is a basic test to demonstrate defaultmap(to)\n  clause with target teams loop construct.\n*/\nint testDefaultMapTo() {\n  int errors = 0;\n  int device_data[N], host_data[N];\n  for (int i = 0; i < N; i++) {\n    device_data[i] = i;\n    host_data[i] = 0;\n  }\n#pragma omp target teams loop defaultmap(to) map(tofrom: host_data)\n  for (int i = 0; i < N; i++) {\n    host_data[i] += device_data[i];\n  }\n  // checking results\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, host_data[i] != i);\n  }\n  return errors;\n}\n\n/**\n  This is a basic test to demonstrate defaultmap(default)\n  clause with target teams loop construct.\n*/\nint testDefaultMapDefault() {\n  int errors = 0;\n  int device_data[N], host_data[N];\n  for (int i = 0; i < N; i++) {\n    device_data[i] = i;\n    host_data[i] = 0;\n  }\n#pragma omp target teams loop defaultmap(default)\n  for (int i = 0; i < N; i++) {\n    host_data[i] += device_data[i];\n    device_data[i] = 2*i;\n  }\n  // checking results\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, host_data[i] != i);\n    OMPVV_TEST_AND_SET(errors, device_data[i] != 2*i);\n  }\n  return errors;\n}\n\n/**\n  This is a basic test to demonstrate defaultmap(firstprivate)\n  clause with target teams loop construct.\n*/\nint testDefaultMapFirstPrivate() {\n  int errors = 0;\n  int device_data[N], host_data[N];\n  for (int i = 0; i < N; i++) {\n    device_data[i] = i;\n    host_data[i] = 0;\n  }\n#pragma omp target teams loop defaultmap(firstprivate)\n  for (int i = 0; i < N;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1; i++) {\n    host_data[i] = device_data[i];\n  }\n  // checking results\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, host_data[i] != 0);\n  }\n  return errors;\n}\n\n/**\n  This is a basic test to demonstrate defaultmap(tofrom:aggregate)\n  clause with target teams loop construct.\n*/\nint testDefaultMapToFromAggr() {\n  int errors = 0;\n  int device_data[N], host_data[N];\n  for (int i = 0; i < N; i++) {\n    device_data[i] = i;\n    host_data[i] = 0;\n  }\n#pragma omp target teams loop defaultmap(tofrom:aggregate) map(tofrom: host_data)\n  for (int i = 0; i < N; i++) {\n    host_data[i] += device_data[i];\n    device_data[i] = 2*i;\n  }\n  // checking results\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, host_data[i] != i);\n    OMPVV_TEST_AND_SET(errors, device_data[i] != 2*i);\n  }\n  return errors;\n}\n\n/**\n  This is a basic test to demonstrate defaultmap(tofrom:scalar)\n  clause with target teams loop construct.\n*/\nint testDefaultMapToFromScalar() {\n  int errors = 0;\n  int x = 0;\n#pragma omp target teams loop defaultmap(tofrom:scalar) reduction(+:x)\n  for (int i = 0; i < N; i++) {\n    x += i;\n  }\n  // checking results\n  OMPVV_TEST_AND_SET(errors, x != (N*(N-1)/2));\n  return errors;\n}\n\n/**\n  This is a basic test to demonstrate defaultmap(tofrom:aggregate)\n  clause with target teams loop construct using structure.\n*/\nint testDefaultMapToFromAggrStr() {\n  int errors = 0;\n  struct dataS {\n    int device_data[N];\n    int host_data[N];\n  } dataObjS;\n  for (int i = 0; i < N; i++) {\n    dataObjS.device_data[i] = i;\n    dataObjS.host_data[i] = 0;\n  }\n#pragma omp target teams loop defaultmap(tofrom:aggregate)\n  for (int i = 0; i < N; i++) {\n    dataObjS.host_data[i] = dataObjS.device_data[i];\n  }\n  // checking results\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, dataObjS.host_data[i] != i);\n  }\n  return errors;\n}\n\n/**\n  This is a basic test to demonstrate defaultmap(tofrom:pointer)\n  clause with target teams loop construct.\n*/\nint testDefaultMapToFromPtr() {\n  int errors = 0;\n  int *ptr[N];\n#pragma omp target teams loop defaultmap(tofrom:pointer)\n  for (int i = 0; i < N; i++) {\n    ptr[i] = (int*)0xefefefef;\n  }\n  // checking results\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, ptr[i] != ((int*)0xefefefef));\n  }\n  return errors;\n}\n\n/**\n  This is a basic test to demonstrate defaultmap(alloc)\n  clause with target teams loop construct.\n*/\nint testDefaultMapAlloc() {\n  int errors = 0;\n  int device_data[N], host_data[N];\n  for (int i = 0; i < N; i++) {\n    device_data[i] = i;\n    host_data[i] = 0;\n  }\n#pragma omp target teams loop defaultmap(alloc) map(to: device_data[0:N])\n  for (int i = 0; i < N; i++) {\n    host_data[i] = device_data[i];\n  }\n  // checking results to verify host_data is unchanged\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET(errors, host_data[i] != 0);\n  }\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testDefaultMapToFrom());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testDefaultMapFrom());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testDefaultMapTo());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testDefaultMapDefault());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testDefaultMapFirstPrivate());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testDefaultMapToFromAggr());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testDefaultMapToFromScalar());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testDefaultMapToFromAggrStr());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testDefaultMapToFromPtr());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testDefaultMapAlloc());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_taskloop_private.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 1186",
        "issue_id": 2,
        "original_code": "//---------------------------------------- test_taskloop_private.c -----------------------------------------//\n//\n// OpenMP API Version 4.5 August 2015\n//\n// This test checks the taskloop directive with the 'private' clause specified.\n// The 'taskloop' construct parallels loops with independent iterations by creating tasks.\n// It allows for efficient parallel execution of loop iterations by distributing them among multiple threads. \n// The 'private' clause ensures that each task should have private copies. \n//----------------------------------------------------------------------------------------------------------//\n\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define NUM_THREADS 100\n#define NUM_TASKS 5\n\nint test_taskloop_private() {\n\n   int errors = 0;\n\n   int private_var;\n   int shared_var_sum = 0;\n\n   #pragma omp parallel num_threads(NUM_THREADS)\n   {\n\t    #pragma omp single\n   \t    {\n\t\t    #pragma omp taskloop private(private_var)\n            for(int i = 0; i < NUM_TASKS; i++)\n\t\t    {\n            \tint sum = 0;\n\t    \t\tfor(private_var = 0; private_var < 5; private_var++)\n\t    \t\t\tsum += private_var;\n\n\t\t\t    #pragma omp atomic\n\t    \t\tshared_var_sum += sum;\n\t \t    }\n   \t    }\n   }\n\n   //check if the value of shared_var_sum is equal to (NUM_TASKS * 10)\n   OMPVV_TEST_AND_SET_VERBOSE(errors, shared_var_sum != (NUM_TASKS * 10));\n\n   return errors;\n}\n\n\nint main() {\n  \n  int errors = 0;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, (test_taskloop_private()) != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n\n  return 0;\n}\n\n",
        "error_code": "//---------------------------------------- test_taskloop_private.c -----------------------------------------//\n//\n// OpenMP API Version 4.5 August 2015\n//\n// This test checks the taskloop directive with the 'private' clause specified.\n// The 'taskloop' construct parallels loops with independent iterations by creating tasks.\n// It allows for efficient parallel execution of loop iterations by distributing them among multiple threads. \n// The 'private' clause ensures that each task should have private copies. \n//----------------------------------------------------------------------------------------------------------//\n\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define NUM_THREADS 100\n#define NUM_TASKS 5\n\nint test_taskloop_private() {\n\n   int errors = 0;\n\n   int private_var;\n   int shared_var_sum = 0;\n\n   #pragma omp parallel num_threads(NUM_THREADS)\n   {\n\t    #pragma omp single\n   \t    {\n\t\t    #pragma omp taskloop private(private_var)\n            for(int i = 0; i < NUM_TASKS; i++)\n\t\t    {\n            \tint sum = 0;\n\t    \t\tfor(private_var = 0; private_var < 5; private_var++)\n\t    \t\t\tsum += private_var;\n\n\t\t\t    #pragma omp atomic\n\t    \t\tshared_var_sum += sum;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n\t \t    }\n   \t    }\n   }\n\n   //check if the value of shared_var_sum is equal to (NUM_TASKS * 10)\n   OMPVV_TEST_AND_SET_VERBOSE(errors, shared_var_sum != (NUM_TASKS * 10));\n\n   return errors;\n}\n\n\nint main() {\n  \n  int errors = 0;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, (test_taskloop_private()) != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n\n  return 0;\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_uses_allocators_large_cap.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 628",
        "issue_id": 2,
        "original_code": "//===--- test_target_uses_allocators_large_cap.c ---------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// The tests checks the uses_allocators clause with omp_large_cap_mem_alloc. \n// The variable allaocated in the target region is modified and used to compute \n// result on device. Result is copied back to the host and checked with computed \n// value on host.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_uses_allocators_large_cap() {\n  int errors = 0;\n  int x = 0;\n  int device_result = 0;\n  int result = 0;\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      result += j + i ;\n    }\n  }\n\n#pragma omp target uses_allocators(omp_large_cap_mem_alloc) allocate(omp_large_cap_mem_alloc: x) firstprivate(x) map(from: device_result)\n{\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      x += j + i;\n    }\n  }\n    device_result = x;\n}\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != device_result);\n\n  return errors;\n}\n\nint main() {\n\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_uses_allocators_large_cap() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n",
        "error_code": "//===--- test_target_uses_allocators_large_cap.c ---------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// The tests checks the uses_allocators clause with omp_large_cap_mem_alloc. \n// The variable allaocated in the target region is modified and used to compute \n// result on device. Result is copied back to the host and checked with computed \n// value on host.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_uses_allocators_large_cap() {\n  int errors = 0;\n  int x = 0;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n  int device_result = 0;\n  int result = 0;\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      result += j + i ;\n    }\n  }\n\n#pragma omp target uses_allocators(omp_large_cap_mem_alloc) allocate(omp_large_cap_mem_alloc: x) firstprivate(x) map(from: device_result)\n{\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      x += j + i;\n    }\n  }\n    device_result = x;\n}\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != device_result);\n\n  return errors;\n}\n\nint main() {\n\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_uses_allocators_large_cap() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_depend_in_in.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp declare\" at position 829",
        "issue_id": 0,
        "original_code": "//===--- test_target_teams_distribute_depend_in_in.c-------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks if two depend(in) tasks are independent by trying to\n// create a asynchronous behavior. If no asynchronicity can be shown, then\n// the test gives only a warning, since this is still complaint. This test\n// will fail if invalid values are written.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_target_teams_distribute_depend_in_in() {\n  int isOffloading = 0;\n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int async_found = 0;\n  int errors = 0;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n    b[x] = 2*x;\n    c[x] = 0;\n    d[x] = 0;\n  }\n\n#pragma omp target data map(to: a[0:N], b[0:N]) map(tofrom: c[0:N], d[0:N])\n  {\n#pragma omp target teams distribute nowait depend(in:d) map(alloc: a[0:N], b[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n#pragma omp atomic\n      d[x] += a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(in:d) map(alloc: a[0:N], b[0:N], c[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n#pragma omp atomic\n      c[x] += 2*(a[x] + b[x]) + d[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, c[x] != 6*x && c[x] != 9*x);\n    OMPVV_ERROR_IF(errors, \"Found invalid results, cannot show independence between depend clauses on disjoint array sections.\");\n    if (errors) {\n      break;\n    }\n    if (c[x] == 6*x) {\n      async_found = 1;\n    }\n  }\n\n  OMPVV_INFOMSG_IF(!errors && async_found, \"Found asynchronous behavior between depend clauses on disjoint array sections.\");\n  OMPVV_WARNING_IF(!errors && !async_found, \"Constructs ran in sequence, could not show lack of dependence since nowait had no effect.\");\n\n  return errors;\n}\nint main() {\n  int errors = 0;\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  errors += test_target_teams_distribute_depend_in_in();\n  OMPVV_INFOMSG_IF(errors != 0, \"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_depend_in_in.c-------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks if two depend(in) tasks are independent by trying to\n// create a asynchronous behavior. If no asynchronicity can be shown, then\n// the test gives only a warning, since this is still complaint. This test\n// will fail if invalid values are written.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_target_teams_distribute_depend_in_in() {\n  int isOffloading = 0;\n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int async_found = 0;\n  int errors = 0;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n    b[x] = 2*x;\n    c[x] = 0;\n    d[x] = 0;\n  }\n\n#pragma omp declare data map(to: a[0:N], b[0:N]) map(tofrom: c[0:N], d[0:N])\n  {\n#pragma omp target teams distribute nowait depend(in:d) map(alloc: a[0:N], b[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n#pragma omp atomic\n      d[x] += a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(in:d) map(alloc: a[0:N], b[0:N], c[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n#pragma omp atomic\n      c[x] += 2*(a[x] + b[x]) + d[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, c[x] != 6*x && c[x] != 9*x);\n    OMPVV_ERROR_IF(errors, \"Found invalid results, cannot show independence between depend clauses on disjoint array sections.\");\n    if (errors) {\n      break;\n    }\n    if (c[x] == 6*x) {\n      async_found = 1;\n    }\n  }\n\n  OMPVV_INFOMSG_IF(!errors && async_found, \"Found asynchronous behavior between depend clauses on disjoint array sections.\");\n  OMPVV_WARNING_IF(!errors && !async_found, \"Constructs ran in sequence, could not show lack of dependence since nowait had no effect.\");\n\n  return errors;\n}\nint main() {\n  int errors = 0;\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  errors += test_target_teams_distribute_depend_in_in();\n  OMPVV_INFOMSG_IF(errors != 0, \"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_VirFunc.cpp",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 618",
        "issue_id": 2,
        "original_code": "//===-- test_target_VirFunc.cpp -------------------------------------===//\n//\n// OpenMP API Version 5.2\n//\n// Description\n// This test case tests the working of the following aspects:\n// 1) Working of \"requires unified_shared_memory\"\n// 2) Testing pure virtual function on gpu\n//===----------------------------------------------------------------------===//\n\n#include <iostream>\n#include <omp.h>\n#include \"ompvv.h\"\n\n\n#pragma omp requires unified_shared_memory\n\nclass Base {\n  protected:\n    int x;\n  public:\n    virtual int GetX() = 0;\n    Base(int val) {\n      x = val;\n    }\n};\n\nclass Derived: public Base {\n  int y;\n  public:\n    Derived(int m, int n):Base(m) {\n      y = n;\n    }\n    int GetX() {\n      return x;\n    }\n};\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int *Val = nullptr, errors = 0;\n  Val = reinterpret_cast<int *>(omp_target_alloc(sizeof(int), 0));\n#pragma omp target\n  {\n    Derived Dobj(1, 2);\n    *Val = Dobj.GetX();\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (*Val != 1));\n  // Val value\n  *Val = 0;\n  // object creation using pointer of base class\n#pragma omp target\n  {\n    Base *ptr = new Derived(10, 20);\n    *Val = ptr->GetX();\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (*Val != 10));\n  omp_target_free(Val, 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===-- test_target_VirFunc.cpp -------------------------------------===//\n//\n// OpenMP API Version 5.2\n//\n// Description\n// This test case tests the working of the following aspects:\n// 1) Working of \"requires unified_shared_memory\"\n// 2) Testing pure virtual function on gpu\n//===----------------------------------------------------------------------===//\n\n#include <iostream>\n#include <omp.h>\n#include \"ompvv.h\"\n\n\n#pragma omp requires unified_shared_memory\n\nclass Base {\n  protected:\n    int x;\n  public:\n    virtual int GetX() = 0;\n    Base(int val) {\n      x = val;\n    }\n};\n\nclass Derived: public Base {\n  int y;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n  public:\n    Derived(int m, int n):Base(m) {\n      y = n;\n    }\n    int GetX() {\n      return x;\n    }\n};\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int *Val = nullptr, errors = 0;\n  Val = reinterpret_cast<int *>(omp_target_alloc(sizeof(int), 0));\n#pragma omp target\n  {\n    Derived Dobj(1, 2);\n    *Val = Dobj.GetX();\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (*Val != 1));\n  // Val value\n  *Val = 0;\n  // object creation using pointer of base class\n#pragma omp target\n  {\n    Base *ptr = new Derived(10, 20);\n    *Val = ptr->GetX();\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (*Val != 10));\n  omp_target_free(Val, 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_defaultmap_present_pointer.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===--- test_target_defaultmap_present_pointer.c ---------------------------===//\n//\n//  OpenMP API Version 5.1 Aug 2020\n//\n//  This test checks behavior of the defaultmap clause when the specified \n//  implicit-behavior is present. The variable-categories available for defaultmap\n//  are scalar, aggregate, and pointer. If implicit-behavior is present, each \n//  variable referenced in the construct in the category specified by \n//  variable-category is treated as if it had been listed in a map clause with the\n//  map-type of alloc and map-type-modifier of present.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_defaultmap_present_pointer() {\n   \n   int errors = 0;\n   int i;\n   \n   int *ptr;\n   int A[N];\n   \n   for (i = 0; i < N; i++) {\n      A[i] = i;\n   }\n   \n   \n   #pragma omp target enter data map(to: ptr)\n   #pragma omp target map(tofrom: errors) defaultmap(present: pointer)\n   {  \n      ptr = &A[0];\n      for (i = 0; i < N; i++) {\n         if (ptr[i] != i) {\n           errors++;\n         }\n         ptr[i] = 2+i;\n      }\n   }\n   #pragma omp target exit data map(delete: ptr)\n   \n   OMPVV_ERROR_IF(errors > 0, \"Values were not mapped to the device properly\");\n   \n   for (i = 0; i < N; i++) {\n      OMPVV_TEST_AND_SET(errors, A[i] != 2+i);\n   }\n\n   return errors;\n}\n\nint main() {\n   int errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_defaultmap_present_pointer() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nbyte etjltyjzcn = 161;\nbyte pynntpbeza = 122;\nlong vjeomfhlqp = 196;\nlong natqxgxduu = 241;\ndouble oqjsevsvrs = 94;\nshort mkndksvqjt = 2;\nint zkoijkxcuf = 220;\ndouble tjkodrpjhd = 35;\nshort zsyqzgvraq = 16;\nshort agufnjttmq = 1;\nlong vhzuwzkhtn = 119;\nint jerhmrzvce = 80;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_reduction_multiply.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp cancel\" at position 792",
        "issue_id": 0,
        "original_code": "//===--- test_target_teams_distribute_reduction_multiply.c-------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the reduction clause on a target teams distribute directive,\n// testing that the variable in the reduction clause is properly reduced using\n// the multiply operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_multiply() {\n  int a[N];\n  int errors = 0;\n  int num_teams[N];\n  srand(1);\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = 1 + (int) rand() / (double) RAND_MAX;\n    num_teams[x] = -x;\n  }\n\n  int result = 1;\n  int host_result;\n\n  for (int x = 0; x < N; x = x + 16) {\n    result = 1;\n#pragma omp target teams distribute reduction(*:result) defaultmap(tofrom:scalar)\n    for (int y = 0; y < 16; ++y) {\n      result *= a[x + y];\n      num_teams[x + y] = omp_get_num_teams();\n    }\n    host_result = 1;\n    for (int y = 0; y < 16; ++y) {\n      host_result *= a[x + y];\n    }\n    OMPVV_TEST_AND_SET_VERBOSE(errors, host_result != result);\n    OMPVV_INFOMSG_IF(host_result != result, \"Device result is %d and host result is %d.\", result, host_result);\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_teams[x - 1] != num_teams[x], \"Kernel reported differing numbers of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_teams[0] == 1, \"Test operated with one team.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_teams[0] <= 0, \"Test reported invalid number of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_multiply() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_reduction_multiply.c-------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the reduction clause on a target teams distribute directive,\n// testing that the variable in the reduction clause is properly reduced using\n// the multiply operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_multiply() {\n  int a[N];\n  int errors = 0;\n  int num_teams[N];\n  srand(1);\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = 1 + (int) rand() / (double) RAND_MAX;\n    num_teams[x] = -x;\n  }\n\n  int result = 1;\n  int host_result;\n\n  for (int x = 0; x < N; x = x + 16) {\n    result = 1;\n#pragma omp cancel teams distribute reduction(*:result) defaultmap(tofrom:scalar)\n    for (int y = 0; y < 16; ++y) {\n      result *= a[x + y];\n      num_teams[x + y] = omp_get_num_teams();\n    }\n    host_result = 1;\n    for (int y = 0; y < 16; ++y) {\n      host_result *= a[x + y];\n    }\n    OMPVV_TEST_AND_SET_VERBOSE(errors, host_result != result);\n    OMPVV_INFOMSG_IF(host_result != result, \"Device result is %d and host result is %d.\", result, host_result);\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_teams[x - 1] != num_teams[x], \"Kernel reported differing numbers of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_teams[0] == 1, \"Test operated with one team.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_teams[0] <= 0, \"Test reported invalid number of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_multiply() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_nowait.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1958",
        "issue_id": 1,
        "original_code": "//===--- test_target_teams_distribute_nowait.c-------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the nowait clause on a target teams distribute directive and\n// uses a barrier to resyncronize the target regions.  Since we can't be sure\n// that operations will be asyncronous, we can only raise a warning if they are\n// not executed asynchronously.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n#define N_TASKS 16\n#define ITERATIONS 1024\n\nint main() {\n  OMPVV_WARNING(\"This test does not throw an error if tasks fail to execute asynchronously, as this is still correct behavior. If execution is not asynchronous, we will throw a warning.\");\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  int64_t work_storage[N_TASKS][N];\n  int order[N_TASKS];  // Each position marks the order in which that task executed\n  int errors = 0;\n  int ticket[1] = {0};\n\n\n#pragma omp target enter data map(to: ticket[0:1], order[0:N_TASKS])\n\n  for (int i = 0; i < N_TASKS; ++i) {\n#pragma omp target teams distribute map(alloc: work_storage[i][0:N], ticket[0:1]) nowait\n    for (int j = 0; j < N; ++j) {\n      work_storage[i][j] = 0;\n      for (int k = 0; k < N*(N_TASKS - i); ++k) { // Creates skewed work distribution\n\twork_storage[i][j] += k*i*j;              // This value will not be verified\n      }\n      int my_ticket = 0;\n#pragma omp atomic capture\n      my_ticket = ticket[0]++;\n      order[i] = my_ticket;\n    }\n  }\n#pragma omp taskwait\n\n#pragma omp target exit data map(from:ticket[0:1], order[0:N_TASKS])\n\n  if (ticket[0] != N_TASKS*N) {\n    OMPVV_ERROR(\"The test registered a different number of target regions than were spawned\");\n    errors = 1;\n  }\n\n  int was_async = 0;\n  for (int i = 1; i < N_TASKS; ++i) {\n    if (order[i] <= order[i - 1]) {\n      was_async = 1;\n      break;\n    }\n  }\n\n  OMPVV_WARNING_IF(!was_async, \"We could not detect asynchronous behavior between target regions\");\n  OMPVV_INFOMSG_IF(was_async, \"Asynchronous behavior detected, this suggests nowait had an effect\");\n  \n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_nowait.c-------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the nowait clause on a target teams distribute directive and\n// uses a barrier to resyncronize the target regions.  Since we can't be sure\n// that operations will be asyncronous, we can only raise a warning if they are\n// not executed asynchronously.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n#define N_TASKS 16\n#define ITERATIONS 1024\n\nint main() {\n  OMPVV_WARNING(\"This test does not throw an error if tasks fail to execute asynchronously, as this is still correct behavior. If execution is not asynchronous, we will throw a warning.\");\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  int64_t work_storage[N_TASKS][N];\n  int order[N_TASKS];  // Each position marks the order in which that task executed\n  int errors = 0;\n  int ticket[1] = {0};\n\n\n#pragma omp target enter data map(to: ticket[0:1], order[0:N_TASKS])\n\n  for (int i = 0; i < N_TASKS; ++i) {\n#pragma omp target teams distribute map(alloc: work_storage[i][0:N], ticket[0:1]) nowait\n    for (int j = 0; j < N; ++j) {\n      work_storage[i][j] = 0;\n      for (int k = 0; k < N*(N_TASKS - i); ++k) { // Creates skewed work distribution\n\twork_storage[i][j] += k*i*j;              // This value will not be verified\n      }\n      int my_ticket = 0;\n#pragma omp atomic capture\n      my_ticket = ticket[0]++;\n      order[i] = my_ticket;\n    }\n  }\n#pragma omp taskwait\n\n#pragma omp target exit data map(from:ticket[0:1], order[0:N_TASKS])\n\n  if (ticket[0] != N_TASKS*N) {\n    OMPVV_ERROR(\"The test registered a different number of target regions than were spawned\");\n    errors = 1;\n  }\n\n  int was_async = 0;\n  for (int i = 1; i < N_TASKS; ++i) {\n    if (order[i] <= order[i - 1]) \n      was_async = 1;\n      break;\n    }\n  }\n\n  OMPVV_WARNING_IF(!was_async, \"We could not detect asynchronous behavior between target regions\");\n  OMPVV_INFOMSG_IF(was_async, \"Asynchronous behavior detected, this suggests nowait had an effect\");\n  \n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_loop_private_device.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp parallel\" at position 1042",
        "issue_id": 0,
        "original_code": "//===--- test_loop_private_device.c -----------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the private clause on a loop directive to indicate that the\n// variable in the private clause should be made private to each thread\n// executing the loop region.  The test then operates on the privatized\n// variable in such a way that would most likely cause competing operations\n// if the variable is not privatized.  If the computation completes without\n// errors, we assume that the privatization occured. This test checks the\n// above in a target context.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define SIZE 1024\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int a[SIZE];\n  int b[SIZE];\n  int c[SIZE];\n  int d[SIZE];\n  int privatized;\n  int errors = 0;\n  int num_threads = -1;\n\n  for (int x = 0; x < SIZE; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    c[x] = 2*x;\n    d[x] = 0;\n  }\n\n#pragma omp target parallel num_threads(OMPVV_NUM_THREADS_DEVICE) map(tofrom: a, b, c, d, num_threads)\n  {\n#pragma omp loop private(privatized)\n    for (int x = 0; x < SIZE; ++x) {\n      privatized = 0;\n      for (int y = 0; y < a[x] + b[x]; ++y) {\n        privatized++;\n      }\n      d[x] = c[x] * privatized;\n    }\n    if (omp_get_thread_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n  }\n\n  for (int x = 0; x < SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, d[x] != (1 + x)*2*x);\n    if (d[x] != (1 + x)*2*x) {\n      break;\n    }\n  }\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread. Results of private test are inconclusive.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_loop_private_device.c -----------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the private clause on a loop directive to indicate that the\n// variable in the private clause should be made private to each thread\n// executing the loop region.  The test then operates on the privatized\n// variable in such a way that would most likely cause competing operations\n// if the variable is not privatized.  If the computation completes without\n// errors, we assume that the privatization occured. This test checks the\n// above in a target context.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define SIZE 1024\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int a[SIZE];\n  int b[SIZE];\n  int c[SIZE];\n  int d[SIZE];\n  int privatized;\n  int errors = 0;\n  int num_threads = -1;\n\n  for (int x = 0; x < SIZE; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    c[x] = 2*x;\n    d[x] = 0;\n  }\n\n#pragma omp parallel parallel num_threads(OMPVV_NUM_THREADS_DEVICE) map(tofrom: a, b, c, d, num_threads)\n  {\n#pragma omp loop private(privatized)\n    for (int x = 0; x < SIZE; ++x) {\n      privatized = 0;\n      for (int y = 0; y < a[x] + b[x]; ++y) {\n        privatized++;\n      }\n      d[x] = c[x] * privatized;\n    }\n    if (omp_get_thread_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n  }\n\n  for (int x = 0; x < SIZE; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, d[x] != (1 + x)*2*x);\n    if (d[x] != (1 + x)*2*x) {\n      break;\n    }\n  }\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread. Results of private test are inconclusive.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_teams_region_routines.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp teams\" with directive \"#pragma omp master\" at position 1710",
        "issue_id": 0,
        "original_code": "//===------------ test_teams_region_routines.c ----------------------------===//\n//\n// OpenMP API Version 5.1 Aug 2021\n//\n// Test Teams Region Routines added to 5.1. \n//\n// omp_set_num_teams           (Section 3.4.3)\n//    * Sets nteams-var ICV of the current task\n//\n// omp_get_max_teams           (Section 3.4.4)\n//    * Returns the value of the nteams-var ICV of the current task\n//\n// omp_set_teams_thread_limit  (Section 3.4.5)\n//    * Sets the value of the teams-thread-limit-var ICV \n//\n// omp_get_teams_thread_limit  (Section 3.4.6)\n//    * Returns the value of the teams-thread-limit-var ICV\n//\n// The test sets the ICV variables and reads their values\n// Furthermore, it checks that the number of teams and threads created were correct\n//\n//===----------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n\nint test_teams_region_routines()\n{\n  int num_teams[OMPVV_NUM_TEAMS_DEVICE];\n  int num_threads[OMPVV_NUM_TEAMS_DEVICE];\n  int errors[2] = {0,0};\n\n\n  for (int x = 0; x < OMPVV_NUM_TEAMS_DEVICE; ++x) {\n    num_teams[x] = -99;\n  }\n\n  for (int x = 0; x < OMPVV_NUM_THREADS_DEVICE; ++x) {\n    num_threads[x] = -99;\n  }\n\n  //sets runtime test\n  omp_set_num_teams(OMPVV_NUM_TEAMS_DEVICE);\n  omp_set_teams_thread_limit(OMPVV_NUM_THREADS_DEVICE);\n\n  //team error if the max teams doesn't get the set value\n  OMPVV_TEST_AND_SET_VERBOSE(errors[0], omp_get_max_teams() != OMPVV_NUM_TEAMS_DEVICE);\n\n  //thread error if the max teams doesn't get the set value\n  OMPVV_TEST_AND_SET_VERBOSE(errors[1], omp_get_teams_thread_limit() != OMPVV_NUM_THREADS_DEVICE);\n\n  // The test check if the correct team and thread numbers were created\n  \n  #pragma omp teams \n  {\n    num_teams[omp_get_team_num()] = omp_get_num_teams();\n    #pragma omp parallel masked\n      num_threads[omp_get_team_num()]= omp_get_num_threads();\n  }\n\n\n  OMPVV_ERROR_IF(num_teams[0] != OMPVV_NUM_TEAMS_DEVICE, \"Test ran with invalid number of teams.\");\n\n  OMPVV_ERROR_IF(num_threads[0] != OMPVV_NUM_THREADS_DEVICE, \"Test returned an invalid number of threads.\");\n\n\n  for (int x = 0; x < OMPVV_NUM_TEAMS_DEVICE; ++x) {\n    if (num_teams[x] != num_teams[0]) {\n      errors[0]++;\n    }\n    if (num_threads[x] != num_threads[0]) {\n      errors[1]++;\n    }\n  }\n  \n  OMPVV_INFOMSG_IF(!(errors[0] + errors[1]), \"Test passed with %d teams and %d threads per team.\", num_teams[0], num_threads[0]);\n\n  return errors[0] + errors[1];\n}\n\n\nint main() {\n\n  int errors = 0;\n\n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors,  test_teams_region_routines()!= 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n\n",
        "error_code": "//===------------ test_teams_region_routines.c ----------------------------===//\n//\n// OpenMP API Version 5.1 Aug 2021\n//\n// Test Teams Region Routines added to 5.1. \n//\n// omp_set_num_teams           (Section 3.4.3)\n//    * Sets nteams-var ICV of the current task\n//\n// omp_get_max_teams           (Section 3.4.4)\n//    * Returns the value of the nteams-var ICV of the current task\n//\n// omp_set_teams_thread_limit  (Section 3.4.5)\n//    * Sets the value of the teams-thread-limit-var ICV \n//\n// omp_get_teams_thread_limit  (Section 3.4.6)\n//    * Returns the value of the teams-thread-limit-var ICV\n//\n// The test sets the ICV variables and reads their values\n// Furthermore, it checks that the number of teams and threads created were correct\n//\n//===----------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n\nint test_teams_region_routines()\n{\n  int num_teams[OMPVV_NUM_TEAMS_DEVICE];\n  int num_threads[OMPVV_NUM_TEAMS_DEVICE];\n  int errors[2] = {0,0};\n\n\n  for (int x = 0; x < OMPVV_NUM_TEAMS_DEVICE; ++x) {\n    num_teams[x] = -99;\n  }\n\n  for (int x = 0; x < OMPVV_NUM_THREADS_DEVICE; ++x) {\n    num_threads[x] = -99;\n  }\n\n  //sets runtime test\n  omp_set_num_teams(OMPVV_NUM_TEAMS_DEVICE);\n  omp_set_teams_thread_limit(OMPVV_NUM_THREADS_DEVICE);\n\n  //team error if the max teams doesn't get the set value\n  OMPVV_TEST_AND_SET_VERBOSE(errors[0], omp_get_max_teams() != OMPVV_NUM_TEAMS_DEVICE);\n\n  //thread error if the max teams doesn't get the set value\n  OMPVV_TEST_AND_SET_VERBOSE(errors[1], omp_get_teams_thread_limit() != OMPVV_NUM_THREADS_DEVICE);\n\n  // The test check if the correct team and thread numbers were created\n  \n  #pragma omp master \n  {\n    num_teams[omp_get_team_num()] = omp_get_num_teams();\n    #pragma omp parallel masked\n      num_threads[omp_get_team_num()]= omp_get_num_threads();\n  }\n\n\n  OMPVV_ERROR_IF(num_teams[0] != OMPVV_NUM_TEAMS_DEVICE, \"Test ran with invalid number of teams.\");\n\n  OMPVV_ERROR_IF(num_threads[0] != OMPVV_NUM_THREADS_DEVICE, \"Test returned an invalid number of threads.\");\n\n\n  for (int x = 0; x < OMPVV_NUM_TEAMS_DEVICE; ++x) {\n    if (num_teams[x] != num_teams[0]) {\n      errors[0]++;\n    }\n    if (num_threads[x] != num_threads[0]) {\n      errors[1]++;\n    }\n  }\n  \n  OMPVV_INFOMSG_IF(!(errors[0] + errors[1]), \"Test passed with %d teams and %d threads per team.\", num_teams[0], num_threads[0]);\n\n  return errors[0] + errors[1];\n}\n\n\nint main() {\n\n  int errors = 0;\n\n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors,  test_teams_region_routines()!= 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_loop_reduction_bitxor_device.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp declare\" at position 771",
        "issue_id": 0,
        "original_code": "//===--- test_loop_reduction_bitxor_device.c --------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the reduction clause on a loop directive, testing that the\n// variable in the reduction clause is properly reduced using the bitxor\n// operator. This test checks the above in a target context.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_bitxor() {\n  unsigned int a[N];\n  int errors = 0;\n  int num_threads[N];\n  srand(1);\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = (unsigned int) rand() / (double) (RAND_MAX / 2);\n    num_threads[x] = -x;\n  }\n\n  unsigned int b = 0;\n\n#pragma omp target parallel num_threads(OMPVV_NUM_THREADS_DEVICE) map(tofrom: a, b, num_threads)\n  {\n#pragma omp loop reduction(^:b)\n    for (int x = 0; x < N; ++x) {\n      b = (b ^ a[x]);\n    }\n#pragma omp for\n    for (int x = 0; x < N; ++x) {\n      num_threads[x] = omp_get_num_threads();\n    }\n  }\n\n  unsigned int host_b = 0;\n\n  for (int x = 0; x < N; ++x) {\n    host_b = (host_b ^ a[x]);\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_threads[x - 1] != num_threads[x], \"Test reported differing numbers of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_threads[0] == 1, \"Test operated with one thread.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_threads[0] <= 0, \"Test reported invalid number of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, b != host_b);\n  OMPVV_ERROR_IF(host_b != b, \"Bit in loop is %d but expected bit is %d.\", b, host_b);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_bitxor() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n",
        "error_code": "//===--- test_loop_reduction_bitxor_device.c --------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the reduction clause on a loop directive, testing that the\n// variable in the reduction clause is properly reduced using the bitxor\n// operator. This test checks the above in a target context.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_bitxor() {\n  unsigned int a[N];\n  int errors = 0;\n  int num_threads[N];\n  srand(1);\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = (unsigned int) rand() / (double) (RAND_MAX / 2);\n    num_threads[x] = -x;\n  }\n\n  unsigned int b = 0;\n\n#pragma omp declare parallel num_threads(OMPVV_NUM_THREADS_DEVICE) map(tofrom: a, b, num_threads)\n  {\n#pragma omp loop reduction(^:b)\n    for (int x = 0; x < N; ++x) {\n      b = (b ^ a[x]);\n    }\n#pragma omp for\n    for (int x = 0; x < N; ++x) {\n      num_threads[x] = omp_get_num_threads();\n    }\n  }\n\n  unsigned int host_b = 0;\n\n  for (int x = 0; x < N; ++x) {\n    host_b = (host_b ^ a[x]);\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_threads[x - 1] != num_threads[x], \"Test reported differing numbers of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_threads[0] == 1, \"Test operated with one thread.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_threads[0] <= 0, \"Test reported invalid number of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, b != host_b);\n  OMPVV_ERROR_IF(host_b != b, \"Bit in loop is %d but expected bit is %d.\", b, host_b);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_bitxor() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1435",
        "issue_id": 1,
        "original_code": "//===--- test_target_teams_distribute.c--------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the target teams distribute directive and tests to validate\n// that computation inside the region executes properly.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main() {\n  int a[N];\n  int b[N];\n  int num_teams[N];\n  int errors = 0;\n  int is_offloading;\n\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n  OMPVV_TEST_SHARED_ENVIRONMENT\n\n  // a and b array initialization\n  for (int x = 0; x < N; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    num_teams[x] = -1;\n  }\n\n#pragma omp target teams distribute map(tofrom: a[0:N], num_teams[0:N]) map(to: b[0:N])\n  for (int x = 0; x < N; ++x) {\n    num_teams[x] = omp_get_num_teams();\n    a[x] += b[x];\n  }\n\n  if (num_teams[0] == 1) {\n    OMPVV_WARNING(\"Test operated with one team.  Parallelism of teams distribute can't be guaranteed.\");\n  } else if (num_teams[0] < 1) {\n    OMPVV_ERROR(\"omp_get_num_teams() reported a value below one.\");\n  }\n\n  for (int x = 1; x < N; ++x) {\n    if (num_teams[x] != num_teams[x - 1]) {\n      OMPVV_ERROR(\"Test reported an inconsistent number of teams between loop iterations.\");\n      errors++;\n    }\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (a[x] != 1 + b[x]));\n    if (a[x] != 1 + b[x]){\n      errors++;\n      break;\n    }\n  }\n\n  OMPVV_INFOMSG_IF(!errors, \"Test passed with %d teams.\", num_teams[0]);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute.c--------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the target teams distribute directive and tests to validate\n// that computation inside the region executes properly.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main() {\n  int a[N];\n  int b[N];\n  int num_teams[N];\n  int errors = 0;\n  int is_offloading;\n\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n  OMPVV_TEST_SHARED_ENVIRONMENT\n\n  // a and b array initialization\n  for (int x = 0; x < N; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    num_teams[x] = -1;\n  }\n\n#pragma omp target teams distribute map(tofrom: a[0:N], num_teams[0:N]) map(to: b[0:N])\n  for (int x = 0; x < N; ++x) {\n    num_teams[x] = omp_get_num_teams();\n    a[x] += b[x];\n  }\n\n  if (num_teams[0] == 1) {\n    OMPVV_WARNING(\"Test operated with one team.  Parallelism of teams distribute can't be guaranteed.\");\n  } else if (num_teams[0] < 1) {\n    OMPVV_ERROR(\"omp_get_num_teams() reported a value below one.\");\n  }\n\n  for (int x = 1; x < N; ++x) {\n    if (num_teams[x] != num_teams[x - 1]) {\n      OMPVV_ERROR(\"Test reported an inconsistent number of teams between loop iterations.\");\n      errors++;\n    }\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (a[x] != 1 + b[x]));\n    if (a[x] != 1 + b[x])\n      errors++;\n      break;\n    }\n  }\n\n  OMPVV_INFOMSG_IF(!errors, \"Test passed with %d teams.\", num_teams[0]);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_declare_target_device_type_nohost1.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp declare\" with directive \"#pragma omp parallel\" at position 732",
        "issue_id": 0,
        "original_code": "//===---- test_declare_target_device_type_nohost1.c  ----------------------------------===//\n// \n// OpenMP API Version 5.0 \n//\n// If a device_type clause is present on the declare target directive, then its argument \n// determines which versions are made available. If device_type(nohost) is present \n// only a device version of the procedure is made available. In case of fallback host version \n// required. The host version of the function is specified via declare variant.\n// \n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 10\nint errors = 0;\n\nvoid fun();\nvoid host_function();\n\n#pragma omp declare target to(fun) device_type(nohost)\n\n#pragma omp declare target\nint a[N], b[N], c[N];  \nint i = 0, dev=-9;\n#pragma omp end declare target\n\n#pragma omp declare variant(host_function) match(device={kind(host)})\nvoid fun(){\n  for (i = 0; i < N; i++) {\n    a[i] += 1;\n    b[i] += 2;\n    c[i] += 3;\n  }\n} \n\nvoid host_function() {\n  for (i = 0; i < N; i++) {\n    a[i] += 5;\n    b[i] += 5;\n    c[i] += 5;\n  }\n}\n\nint test_declare_target_device_type_nohost() { \n\n  fun(); //should call host_function()\n\n  #pragma omp target update to(a,b,c)\n\n  #pragma omp target  \n  {\n    fun(); //Will call fun() on device OR host_function() in case of fall-back\n    dev = omp_get_device_num();\n  }\n\n  #pragma omp target update from (a,b,c,dev)\n  \n  if (dev != omp_get_initial_device()) {\n    for (i = 0; i < N; i++) { //check array values on host\n      if ( a[i] != 6 || b[i] != 7 || c[i] != 8 ) {\n        errors++;\n      }\n    }\n  } else {\n    OMPVV_WARNING(\"Default device is the host device. Test ran on the host.\");\n    for (i = 0; i < N; i++) { //check array values on host\n      if ( a[i] != 10 || b[i] != 10 || c[i] != 10 ) {\n        errors++;\n      }\n    }\n  }\n  \n  return errors;\n}\n\nint main () {\n\n  OMPVV_TEST_OFFLOADING;\n  \n  //initalize arrays on host\n  for (i = 0; i < N; i++) {\n    a[i] = 0;\n    b[i] = 0;\n    c[i] = 0;\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_declare_target_device_type_nohost());\n  OMPVV_REPORT_AND_RETURN(errors);\n}  \n",
        "error_code": "//===---- test_declare_target_device_type_nohost1.c  ----------------------------------===//\n// \n// OpenMP API Version 5.0 \n//\n// If a device_type clause is present on the declare target directive, then its argument \n// determines which versions are made available. If device_type(nohost) is present \n// only a device version of the procedure is made available. In case of fallback host version \n// required. The host version of the function is specified via declare variant.\n// \n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 10\nint errors = 0;\n\nvoid fun();\nvoid host_function();\n\n#pragma omp parallel target to(fun) device_type(nohost)\n\n#pragma omp declare target\nint a[N], b[N], c[N];  \nint i = 0, dev=-9;\n#pragma omp end declare target\n\n#pragma omp declare variant(host_function) match(device={kind(host)})\nvoid fun(){\n  for (i = 0; i < N; i++) {\n    a[i] += 1;\n    b[i] += 2;\n    c[i] += 3;\n  }\n} \n\nvoid host_function() {\n  for (i = 0; i < N; i++) {\n    a[i] += 5;\n    b[i] += 5;\n    c[i] += 5;\n  }\n}\n\nint test_declare_target_device_type_nohost() { \n\n  fun(); //should call host_function()\n\n  #pragma omp target update to(a,b,c)\n\n  #pragma omp target  \n  {\n    fun(); //Will call fun() on device OR host_function() in case of fall-back\n    dev = omp_get_device_num();\n  }\n\n  #pragma omp target update from (a,b,c,dev)\n  \n  if (dev != omp_get_initial_device()) {\n    for (i = 0; i < N; i++) { //check array values on host\n      if ( a[i] != 6 || b[i] != 7 || c[i] != 8 ) {\n        errors++;\n      }\n    }\n  } else {\n    OMPVV_WARNING(\"Default device is the host device. Test ran on the host.\");\n    for (i = 0; i < N; i++) { //check array values on host\n      if ( a[i] != 10 || b[i] != 10 || c[i] != 10 ) {\n        errors++;\n      }\n    }\n  }\n  \n  return errors;\n}\n\nint main () {\n\n  OMPVV_TEST_OFFLOADING;\n  \n  //initalize arrays on host\n  for (i = 0; i < N; i++) {\n    a[i] = 0;\n    b[i] = 0;\n    c[i] = 0;\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_declare_target_device_type_nohost());\n  OMPVV_REPORT_AND_RETURN(errors);\n}  \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_parallel_master_taskloop_device.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp cancel\" at position 799",
        "issue_id": 0,
        "original_code": "//===--- test_parallel_master_taskloop_device.c ------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the parallel master taskloop directive. The test performs\n// simple operations on an int array which are then checked for correctness.\n// This test checks the construct in a target context.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_parallel_master_taskloop_device() {\n  OMPVV_INFOMSG(\"test_parallel_master_taskloop_device\");\n  int errors = 0;\n  int num_threads = -1;\n  int x[N];\n  int y[N];\n  int z[N];\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 1;\n    y[i] = i + 1;\n    z[i] = 2*(i + 1);\n  }\n\n#pragma omp target map(tofrom: x, y, z, num_threads)\n  {\n#pragma omp parallel master taskloop num_threads(OMPVV_NUM_THREADS_DEVICE) shared(x, y, z, num_threads)\n    for (int i = 0; i < N; i++) {\n      x[i] += y[i]*z[i];\n      if (i == 0) {\n        num_threads = omp_get_num_threads();\n      }\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != 1 + (y[i]*z[i]));\n  }\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of taskloop can't be guaranteed.\");\n  OMPVV_ERROR_IF(num_threads < 1, \"Test returned an invalid number of threads.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n\n  return errors;\n}\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_parallel_master_taskloop_device());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_parallel_master_taskloop_device.c ------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the parallel master taskloop directive. The test performs\n// simple operations on an int array which are then checked for correctness.\n// This test checks the construct in a target context.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_parallel_master_taskloop_device() {\n  OMPVV_INFOMSG(\"test_parallel_master_taskloop_device\");\n  int errors = 0;\n  int num_threads = -1;\n  int x[N];\n  int y[N];\n  int z[N];\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 1;\n    y[i] = i + 1;\n    z[i] = 2*(i + 1);\n  }\n\n#pragma omp cancel map(tofrom: x, y, z, num_threads)\n  {\n#pragma omp parallel master taskloop num_threads(OMPVV_NUM_THREADS_DEVICE) shared(x, y, z, num_threads)\n    for (int i = 0; i < N; i++) {\n      x[i] += y[i]*z[i];\n      if (i == 0) {\n        num_threads = omp_get_num_threads();\n      }\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != 1 + (y[i]*z[i]));\n  }\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of taskloop can't be guaranteed.\");\n  OMPVV_ERROR_IF(num_threads < 1, \"Test returned an invalid number of threads.\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads < 1);\n\n  return errors;\n}\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_parallel_master_taskloop_device());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_task_final.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp parallel\" with directive \"#pragma omp declare\" at position 1365",
        "issue_id": 0,
        "original_code": "//===-- test_task_final.c ------------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// Description:\n// testTaskWithFinalSimple():\n// This test demonstrates the use of final clause with tasks.\n// In this test we prove that omp_in_final() returns true\n// when the task is final else returns false.\n//\n//testNestedTaskWithFinalSimple()\n//This test demonstrates that all nested tasks under a final task\n// are also final tasks.\n//\n//testTaskWithFinalAdvanced()\n//This test demonstrates the use of final clause with tasks.\n// In this test we prove that if a task is declared as final,\n// then all subsequent tasks generated by this task will undeferred\n// tasks. Hence they all will be executed in the same thread as\n// parent task and each child task will be executed in order.\n\n//===----------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n// defines\n#define INC 5\n#define MUL 7\n#define DIV 3\n#define DEC 11\n#define INITVAL 10\n\nint testTaskWithFinalSimple(int numThreads, int isFinal) {\n  int errors = 0;\n  int ret = 0;\n  int *A = (int*) (malloc(numThreads*sizeof(int)));\n  assert(A != NULL);\n  omp_set_num_threads(numThreads);\n  // Initialize the arrays\n  for (int i = 0; i < numThreads; i++) {\n    A[i] = -1;\n  }\n#pragma omp parallel\n  {\n    int id = omp_get_thread_num();\n  // undeferred\n#pragma omp task final(isFinal)\n    {\n      A[id] = omp_in_final();\n    }\n  }\n  for (int i = 0; i < numThreads; i++) {\n    if ((isFinal == 1) && (A[i] == 0)) {\n      ret = -1;\n      break;\n    } else if ((isFinal == 0) && (A[i] != 0)) {\n      ret = -1;\n      break;\n    }\n  }\n  free(A);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, ret != 0);\n  return errors;\n}\n\nint testNestedTaskWithFinalSimple(int numThreads) {\n  int errors = 0;\n  int ret = 0;\n  int *A = (int*) (malloc(numThreads*sizeof(int)));\n  assert(A != NULL);\n  omp_set_num_threads(numThreads);\n  // Initialize the arrays\n  for (int i = 0; i < numThreads; i++) {\n    A[i] = 0;\n  }\n#pragma omp parallel\n  {\n    int id = omp_get_thread_num();\n  // undeferred\n#pragma omp task final(1)\n    {\n#pragma omp task shared(id)\n      {\n        A[id] = omp_in_final();\n      }\n    }\n  }\n  for (int i = 0; i < numThreads; i++) {\n    if (A[i] == 0) {\n      ret = -1;\n      break;\n    }\n  }\n  free(A);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, ret != 0);\n  return errors;\n}\n\nint testTaskWithFinalAdvanced(int numThreads) {\n  int errors = 0;\n  int ret = 0;\n  int *A = (int*) (malloc(numThreads*sizeof(int)));\n  assert(A != NULL);\n  int *B = (int*) (malloc(numThreads*sizeof(int)));\n  assert(B != NULL);\n  omp_set_num_threads(numThreads);\n  // Initialize the arrays\n  for (int i = 0; i < numThreads; i++) {\n    A[i] = 0;\n    B[i] = INITVAL;\n  }\n#pragma omp parallel\n  {\n    int id = omp_get_thread_num();\n#pragma omp task final(1)\n    {\n      int first_final_task_thrdid = omp_get_thread_num();\n      int first_1stchld_task_thrdid = 0, first_2ndchld_task_thrdid = 0,\n      first_3rdchld_task_thrdid = 0, root_id = id;\n#pragma omp task shared(first_1stchld_task_thrdid, root_id)\n        {\n          first_1stchld_task_thrdid = omp_get_thread_num();\n          B[root_id] += INC;\n#pragma omp task shared(root_id)\n          {\n            B[root_id] /= DIV;\n          }\n        }\n#pragma omp task shared(first_2ndchld_task_thrdid, root_id)\n        {\n          first_2ndchld_task_thrdid = omp_get_thread_num();\n          B[root_id] *= MUL;\n        }\n#pragma omp task shared(first_3rdchld_task_thrdid, root_id)\n        {\n          first_3rdchld_task_thrdid = omp_get_thread_num();\n          B[root_id] -= DEC;\n        }\n        if ((first_final_task_thrdid == first_1stchld_task_thrdid) &&\n           (first_final_task_thrdid == first_2ndchld_task_thrdid) &&\n           (first_final_task_thrdid == first_3rdchld_task_thrdid)) {\n          A[root_id] = 1;\n        }\n    }\n  }\n  for (int i = 0; i < numThreads; i++) {\n    if ((A[i] != 1) || (B[i] != (((INITVAL + INC)/DIV)*MUL - DEC))) {\n      ret = 1;\n      break;\n    }    \n  }\n  free(B);\n  free(A);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, ret != 0);\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testNestedTaskWithFinalSimple(4));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testNestedTaskWithFinalSimple(8));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testNestedTaskWithFinalSimple(16));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testNestedTaskWithFinalSimple(32));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testNestedTaskWithFinalSimple(64));\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(4, 1));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(8, 1));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(16, 1));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(32, 1));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(64, 1));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(4, 0));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(8, 0));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(16, 0));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(32, 0));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(64, 0));\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalAdvanced(4));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalAdvanced(8));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalAdvanced(16));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalAdvanced(32));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalAdvanced(64));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===-- test_task_final.c ------------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// Description:\n// testTaskWithFinalSimple():\n// This test demonstrates the use of final clause with tasks.\n// In this test we prove that omp_in_final() returns true\n// when the task is final else returns false.\n//\n//testNestedTaskWithFinalSimple()\n//This test demonstrates that all nested tasks under a final task\n// are also final tasks.\n//\n//testTaskWithFinalAdvanced()\n//This test demonstrates the use of final clause with tasks.\n// In this test we prove that if a task is declared as final,\n// then all subsequent tasks generated by this task will undeferred\n// tasks. Hence they all will be executed in the same thread as\n// parent task and each child task will be executed in order.\n\n//===----------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n// defines\n#define INC 5\n#define MUL 7\n#define DIV 3\n#define DEC 11\n#define INITVAL 10\n\nint testTaskWithFinalSimple(int numThreads, int isFinal) {\n  int errors = 0;\n  int ret = 0;\n  int *A = (int*) (malloc(numThreads*sizeof(int)));\n  assert(A != NULL);\n  omp_set_num_threads(numThreads);\n  // Initialize the arrays\n  for (int i = 0; i < numThreads; i++) {\n    A[i] = -1;\n  }\n#pragma omp declare\n  {\n    int id = omp_get_thread_num();\n  // undeferred\n#pragma omp task final(isFinal)\n    {\n      A[id] = omp_in_final();\n    }\n  }\n  for (int i = 0; i < numThreads; i++) {\n    if ((isFinal == 1) && (A[i] == 0)) {\n      ret = -1;\n      break;\n    } else if ((isFinal == 0) && (A[i] != 0)) {\n      ret = -1;\n      break;\n    }\n  }\n  free(A);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, ret != 0);\n  return errors;\n}\n\nint testNestedTaskWithFinalSimple(int numThreads) {\n  int errors = 0;\n  int ret = 0;\n  int *A = (int*) (malloc(numThreads*sizeof(int)));\n  assert(A != NULL);\n  omp_set_num_threads(numThreads);\n  // Initialize the arrays\n  for (int i = 0; i < numThreads; i++) {\n    A[i] = 0;\n  }\n#pragma omp parallel\n  {\n    int id = omp_get_thread_num();\n  // undeferred\n#pragma omp task final(1)\n    {\n#pragma omp task shared(id)\n      {\n        A[id] = omp_in_final();\n      }\n    }\n  }\n  for (int i = 0; i < numThreads; i++) {\n    if (A[i] == 0) {\n      ret = -1;\n      break;\n    }\n  }\n  free(A);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, ret != 0);\n  return errors;\n}\n\nint testTaskWithFinalAdvanced(int numThreads) {\n  int errors = 0;\n  int ret = 0;\n  int *A = (int*) (malloc(numThreads*sizeof(int)));\n  assert(A != NULL);\n  int *B = (int*) (malloc(numThreads*sizeof(int)));\n  assert(B != NULL);\n  omp_set_num_threads(numThreads);\n  // Initialize the arrays\n  for (int i = 0; i < numThreads; i++) {\n    A[i] = 0;\n    B[i] = INITVAL;\n  }\n#pragma omp parallel\n  {\n    int id = omp_get_thread_num();\n#pragma omp task final(1)\n    {\n      int first_final_task_thrdid = omp_get_thread_num();\n      int first_1stchld_task_thrdid = 0, first_2ndchld_task_thrdid = 0,\n      first_3rdchld_task_thrdid = 0, root_id = id;\n#pragma omp task shared(first_1stchld_task_thrdid, root_id)\n        {\n          first_1stchld_task_thrdid = omp_get_thread_num();\n          B[root_id] += INC;\n#pragma omp task shared(root_id)\n          {\n            B[root_id] /= DIV;\n          }\n        }\n#pragma omp task shared(first_2ndchld_task_thrdid, root_id)\n        {\n          first_2ndchld_task_thrdid = omp_get_thread_num();\n          B[root_id] *= MUL;\n        }\n#pragma omp task shared(first_3rdchld_task_thrdid, root_id)\n        {\n          first_3rdchld_task_thrdid = omp_get_thread_num();\n          B[root_id] -= DEC;\n        }\n        if ((first_final_task_thrdid == first_1stchld_task_thrdid) &&\n           (first_final_task_thrdid == first_2ndchld_task_thrdid) &&\n           (first_final_task_thrdid == first_3rdchld_task_thrdid)) {\n          A[root_id] = 1;\n        }\n    }\n  }\n  for (int i = 0; i < numThreads; i++) {\n    if ((A[i] != 1) || (B[i] != (((INITVAL + INC)/DIV)*MUL - DEC))) {\n      ret = 1;\n      break;\n    }    \n  }\n  free(B);\n  free(A);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, ret != 0);\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testNestedTaskWithFinalSimple(4));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testNestedTaskWithFinalSimple(8));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testNestedTaskWithFinalSimple(16));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testNestedTaskWithFinalSimple(32));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testNestedTaskWithFinalSimple(64));\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(4, 1));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(8, 1));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(16, 1));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(32, 1));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(64, 1));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(4, 0));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(8, 0));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(16, 0));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(32, 0));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalSimple(64, 0));\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalAdvanced(4));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalAdvanced(8));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalAdvanced(16));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalAdvanced(32));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithFinalAdvanced(64));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_reduction_add.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp single\" at position 708",
        "issue_id": 0,
        "original_code": "//===--- test_target_teams_distribute_reduction_add.c-------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the reduction clause on a target teams distribute directive,\n// testing that the variable in the reduction clause is properly reduced using\n// the add operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_add() {\n  int a[N];\n  int b[N];\n  int total = 0;\n  int host_total = 0;\n  int errors = 0;\n  int num_teams[N];\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    num_teams[x] = -1;\n  }\n\n#pragma omp target teams distribute reduction(+:total) defaultmap(tofrom:scalar)\n  for (int x = 0; x < N; ++x) {\n    num_teams[x] = omp_get_num_teams();\n    total += a[x] + b[x];\n  }\n\n  for (int x = 0; x < N; ++x) {\n    host_total += a[x] + b[x];\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_teams[x - 1] != num_teams[x], \"Kernel reported differing numbers of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_teams[0] == 1, \"Test operated with one team.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_teams[0] <= 0, \"Test reported invalid number of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, host_total != total);\n  OMPVV_ERROR_IF(host_total != total, \"Total on device is %d but expected total from host is %d.\", total, host_total);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_add() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_reduction_add.c-------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the reduction clause on a target teams distribute directive,\n// testing that the variable in the reduction clause is properly reduced using\n// the add operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_add() {\n  int a[N];\n  int b[N];\n  int total = 0;\n  int host_total = 0;\n  int errors = 0;\n  int num_teams[N];\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    num_teams[x] = -1;\n  }\n\n#pragma omp single teams distribute reduction(+:total) defaultmap(tofrom:scalar)\n  for (int x = 0; x < N; ++x) {\n    num_teams[x] = omp_get_num_teams();\n    total += a[x] + b[x];\n  }\n\n  for (int x = 0; x < N; ++x) {\n    host_total += a[x] + b[x];\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_teams[x - 1] != num_teams[x], \"Kernel reported differing numbers of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_teams[0] == 1, \"Test operated with one team.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_teams[0] <= 0, \"Test reported invalid number of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, host_total != total);\n  OMPVV_ERROR_IF(host_total != total, \"Total on device is %d but expected total from host is %d.\", total, host_total);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_add() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_atomic_hint.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===--- test_atomic_hint.c -------------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_atomic_hint_uncontended() {\n  OMPVV_INFOMSG(\"test_atomic_hint_uncontended\");\n  int errors = 0, x = 0, num_threads = -1;\n\n#pragma omp parallel num_threads(2) default(shared)\n  {\n    if (omp_get_thread_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n#pragma omp atomic hint(omp_sync_hint_uncontended)\n    x++;\n  }\n\n  OMPVV_ERROR_IF(num_threads < 0, \"Test ran with invalid number of teams (less than zero)\");\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so the results are not conclusive\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, x != num_threads);\n\n  return errors;\n}\n\nint test_atomic_hint_contended_nonspec() {\n  OMPVV_INFOMSG(\"test_atomic_hint_contended_nonspec\");\n  int errors = 0, x = 0, num_threads = -1;\n\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST) default(shared)\n  {\n    if (omp_get_thread_num() == 0) {\n      num_threads = omp_get_num_threads();\n    }\n#pragma omp atomic hint(omp_sync_hint_contended+omp_sync_hint_nonspeculative)\n    x++;\n  }\n\n  OMPVV_ERROR_IF(num_threads < 0, \"Test ran with invalid number of teams (less than zero)\");\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so the results are not conclusive\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, x != num_threads);\n\n  return errors;\n}\n\nint test_atomic_hint_speculative() {\n  OMPVV_INFOMSG(\"test_atomic_hint_speculative\");\n  int errors = 0, num_threads = -1;\n  int a[N];\n\n  for (int i = 0; i < N; i++) {\n    a[i] = 1;\n  }\n\n#pragma omp parallel for num_threads(OMPVV_NUM_THREADS_HOST) default(shared)\n  for (int i = 0; i < N; i++) {\n    if (i == 0) {\n      num_threads = omp_get_num_threads();\n#pragma omp atomic hint(omp_sync_hint_speculative)\n      a[1] += 1;\n    }\n#pragma omp atomic hint(omp_sync_hint_speculative)\n    a[i] += i;\n  }\n\n  OMPVV_ERROR_IF(num_threads < 0, \"Test ran with invalid number of teams (less than zero)\");\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so the results are not conclusive\");\n\n\n  for (int i = 0; i < N; i++) {\n    if (i == 1) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, a[i] != 3);\n    } else {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, a[i] != i + 1);\n    }\n  }\n\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_atomic_hint_uncontended());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_atomic_hint_contended_nonspec());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_atomic_hint_speculative());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nfloat wcddiczlra = 193;\nshort diqklxugrj = 237;\nfloat iluxbqwqbd = 195;\ndouble nnonlkupfv = 45;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_requires_unified_shared_memory_heap_is_device_ptr.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp requires\" with directive \"#pragma omp cancel\" at position 540",
        "issue_id": 0,
        "original_code": "//===---test_requires_unified_shared_memory_heap_is_device_ptr.c -----------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n// \n// This test Checks for unified shared memory of an array that is allocated on \n// the heap and that is accessed from host and device with the same pointer\n//\n// To guarantee the use of the device pointer, we use the is_device_ptr clause\n//\n////===----------------------------------------------------------------------===//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp requires unified_shared_memory\n\nint unified_shared_memory_heap() {\n  OMPVV_INFOMSG(\"Unified shared memory testing - Array on heap\");\n  int errors = 0;\n  \n  int *anArray;\n  int anArrayCopy[N];\n\n  anArray = (int*)malloc(sizeof(int)*N);\n  if( anArray == NULL ) {\n     OMPVV_ERROR(\"Memory was not properly allocated\");\n     OMPVV_RETURN(1);\n  }\n\n  for (int i = 0; i < N; i++) {\n    anArray[i] = i;\n    anArrayCopy[i] = 0;\n  }\n  // Modify in the device\n#pragma omp target is_device_ptr(anArray)\n  {\n    for (int i = 0; i < N; i++) {\n      anArray[i] += 10;\n    }\n  }\n  // Modify again on the host\n  for (int i = 0; i < N; i++) {\n    anArray[i] += 10;\n  }\n\n  // Get the value the device is seeing\n#pragma omp target is_device_ptr(anArray)\n  {\n    for (int i = 0; i < N; i++) {\n      anArrayCopy[i] = anArray[i];\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArray[i] != i + 20);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArrayCopy[i] != i + 20);\n    if (errors) break;\n  }\n\n  free(anArray);\n  return errors;\n}\nint main() {\n  int isOffloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"With no offloading, unified shared memory is guaranteed due to host execution\");\n  int errors = 0;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, unified_shared_memory_heap());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---test_requires_unified_shared_memory_heap_is_device_ptr.c -----------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n// \n// This test Checks for unified shared memory of an array that is allocated on \n// the heap and that is accessed from host and device with the same pointer\n//\n// To guarantee the use of the device pointer, we use the is_device_ptr clause\n//\n////===----------------------------------------------------------------------===//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp cancel unified_shared_memory\n\nint unified_shared_memory_heap() {\n  OMPVV_INFOMSG(\"Unified shared memory testing - Array on heap\");\n  int errors = 0;\n  \n  int *anArray;\n  int anArrayCopy[N];\n\n  anArray = (int*)malloc(sizeof(int)*N);\n  if( anArray == NULL ) {\n     OMPVV_ERROR(\"Memory was not properly allocated\");\n     OMPVV_RETURN(1);\n  }\n\n  for (int i = 0; i < N; i++) {\n    anArray[i] = i;\n    anArrayCopy[i] = 0;\n  }\n  // Modify in the device\n#pragma omp target is_device_ptr(anArray)\n  {\n    for (int i = 0; i < N; i++) {\n      anArray[i] += 10;\n    }\n  }\n  // Modify again on the host\n  for (int i = 0; i < N; i++) {\n    anArray[i] += 10;\n  }\n\n  // Get the value the device is seeing\n#pragma omp target is_device_ptr(anArray)\n  {\n    for (int i = 0; i < N; i++) {\n      anArrayCopy[i] = anArray[i];\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArray[i] != i + 20);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArrayCopy[i] != i + 20);\n    if (errors) break;\n  }\n\n  free(anArray);\n  return errors;\n}\nint main() {\n  int isOffloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"With no offloading, unified shared memory is guaranteed due to host execution\");\n  int errors = 0;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, unified_shared_memory_heap());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_uses_allocators_high_bw.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp map\" at position 770",
        "issue_id": 0,
        "original_code": "//===--- test_target_uses_allocators_high_bw.c ---------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// The tests checks the uses_allocators clause with omp_high_bw_mem_alloc.\n// The variable allaocated in the target is modified and used to compute result\n// on device. Result is copied back to the host  and checked with computed value\n// on host.\n//\n//===---------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_uses_allocators_high_bw() {\n  int errors = 0;\n  int x = 0;\n  int device_result = 0;\n  int result = 0;\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      result += j + i ;\n    }\n  }\n\n#pragma omp target uses_allocators(omp_high_bw_mem_alloc) allocate(omp_high_bw_mem_alloc: x) firstprivate(x) map(from: device_result)\n{\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        x += j + i;\n      }\n    }\n    device_result = x;\n}\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != device_result);\n\n  return errors;\n}\n\nint main() {\n\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_uses_allocators_high_bw() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n",
        "error_code": "//===--- test_target_uses_allocators_high_bw.c ---------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// The tests checks the uses_allocators clause with omp_high_bw_mem_alloc.\n// The variable allaocated in the target is modified and used to compute result\n// on device. Result is copied back to the host  and checked with computed value\n// on host.\n//\n//===---------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_uses_allocators_high_bw() {\n  int errors = 0;\n  int x = 0;\n  int device_result = 0;\n  int result = 0;\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      result += j + i ;\n    }\n  }\n\n#pragma omp map uses_allocators(omp_high_bw_mem_alloc) allocate(omp_high_bw_mem_alloc: x) firstprivate(x) map(from: device_result)\n{\n    for (int i = 0; i < N; i++) {\n      for (int j = 0; j < N; j++) {\n        x += j + i;\n      }\n    }\n    device_result = x;\n}\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != device_result);\n\n  return errors;\n}\n\nint main() {\n\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n  \n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_uses_allocators_high_bw() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_tile.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp tile\" with directive \"#pragma omp map\" at position 1399",
        "issue_id": 0,
        "original_code": "//===--- test_tile.c --------------------------------------------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// This test checks the tile directive with required sizes clause. The tile\n// directive reorganizes `n` of the nested loops into `2n` tiled loops\n// according to the sizes provided in the sizes clause, where `n` is the\n// number of sizes provided in the sizes clause. The nested loops under a\n// tile directive must be perfectly nested and rectangular, and there must be\n// at least `n` of them. The loop tiles are iterated over in lexographic\n// order, and two iterations may be reordered by an implementation if at\n// least one of them is from a partial tile and if thier logical iteration\n// vectors do not have a product order relation. Thus, this test checks that\n// a completely-tiled loop nest is tiled in the correct order, but only\n// checks results correctness for a tiling with some partial tiles.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 8\n\nint test_tile_complete() {\n  OMPVV_INFOMSG(\"test_tile_complete\");\n  int errors = 0;\n  int result[N][N];\n  int expected[N][N];\n  int time = 0;\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      result[i][j] = 0;\n      expected[i][j] = 0;\n    }\n  }\n\n#pragma omp tile sizes(4, 4)\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      result[i][j] = time++;\n    }\n  }\n\n  time = 0;\n\n  for (int i1 = 0; i1 < N; i1 += 4) {\n    for (int j1 = 0; j1 < N; j1 += 4) {\n      for (int i2 = i1; i2 < i1 + 4; i2 += 1) {\n        for (int j2 = j1; j2 < j1 + 4; j2 += 1) {\n          expected[i2][j2] = time++;\n        }\n      }\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      OMPVV_TEST_AND_SET(errors, result[i][j] != expected[i][j]);\n    }\n  }\n\n  return errors;\n}\n\nint test_tile_partial() {\n  OMPVV_INFOMSG(\"test_tile_partial\");\n  int errors = 0;\n  int result[N][N];\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      result[i][j] = 1;\n    }\n  }\n\n#pragma omp tile sizes(3, 3)\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      result[i][j] += i*j;\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, result[i][j] != 1 + i*j);\n    }\n  }\n\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_tile_complete());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_tile_partial());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_tile.c --------------------------------------------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// This test checks the tile directive with required sizes clause. The tile\n// directive reorganizes `n` of the nested loops into `2n` tiled loops\n// according to the sizes provided in the sizes clause, where `n` is the\n// number of sizes provided in the sizes clause. The nested loops under a\n// tile directive must be perfectly nested and rectangular, and there must be\n// at least `n` of them. The loop tiles are iterated over in lexographic\n// order, and two iterations may be reordered by an implementation if at\n// least one of them is from a partial tile and if thier logical iteration\n// vectors do not have a product order relation. Thus, this test checks that\n// a completely-tiled loop nest is tiled in the correct order, but only\n// checks results correctness for a tiling with some partial tiles.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 8\n\nint test_tile_complete() {\n  OMPVV_INFOMSG(\"test_tile_complete\");\n  int errors = 0;\n  int result[N][N];\n  int expected[N][N];\n  int time = 0;\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      result[i][j] = 0;\n      expected[i][j] = 0;\n    }\n  }\n\n#pragma omp map sizes(4, 4)\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      result[i][j] = time++;\n    }\n  }\n\n  time = 0;\n\n  for (int i1 = 0; i1 < N; i1 += 4) {\n    for (int j1 = 0; j1 < N; j1 += 4) {\n      for (int i2 = i1; i2 < i1 + 4; i2 += 1) {\n        for (int j2 = j1; j2 < j1 + 4; j2 += 1) {\n          expected[i2][j2] = time++;\n        }\n      }\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      OMPVV_TEST_AND_SET(errors, result[i][j] != expected[i][j]);\n    }\n  }\n\n  return errors;\n}\n\nint test_tile_partial() {\n  OMPVV_INFOMSG(\"test_tile_partial\");\n  int errors = 0;\n  int result[N][N];\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      result[i][j] = 1;\n    }\n  }\n\n#pragma omp tile sizes(3, 3)\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      result[i][j] += i*j;\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, result[i][j] != 1 + i*j);\n    }\n  }\n\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_tile_complete());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_tile_partial());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_depend_disjoint_section.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp atomic\" at position 877",
        "issue_id": 0,
        "original_code": "//===--- test_target_teams_distribute_depend_disjoint_section.c--------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks the out-out dependency of two tasks when the array\n// sections in the depend lists are disjoint (non-overlapping). If no\n// asynchronous behavior can be shown, then the test gives only a warning,\n// since this is still complaint. This test will fail if invalid values\n// are written.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_target_teams_distribute_depend_disjoint_section() {\n  int isOffloading = 0;\n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int async_found = 0;\n  int errors = 0;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n    b[x] = 2*x;\n    c[x] = 0;\n    d[x] = 0;\n  }\n\n#pragma omp target data map(to: a[0:N], b[0:N]) map(tofrom: c[0:N], d[0:N])\n  {\n#pragma omp target teams distribute nowait depend(out: c[0:N/2]) map(alloc: a[0:N], b[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n#pragma omp atomic\n      d[x] += a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(out: c[N/2:N/2]) map(alloc: a[0:N], b[0:N], c[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n#pragma omp atomic\n      c[x] += 2*(a[x] + b[x]) + d[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, c[x] != 6*x && c[x] != 9*x);\n    OMPVV_ERROR_IF(errors, \"Found invalid results, cannot show independence between depend clauses on disjoint array sections.\");\n    if (errors) {\n      break;\n    }\n    if (c[x] == 6*x) {\n      async_found = 1;\n    }\n  }\n\n  OMPVV_INFOMSG_IF(!errors && async_found, \"Found asynchronous behavior between depend clauses on disjoint array sections.\");\n  OMPVV_WARNING_IF(!errors && !async_found, \"Constructs ran in sequence, could not show lack of dependence since nowait had no effect.\");\n\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  errors += test_target_teams_distribute_depend_disjoint_section();\n  OMPVV_INFOMSG_IF(errors != 0, \"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_depend_disjoint_section.c--------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks the out-out dependency of two tasks when the array\n// sections in the depend lists are disjoint (non-overlapping). If no\n// asynchronous behavior can be shown, then the test gives only a warning,\n// since this is still complaint. This test will fail if invalid values\n// are written.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_target_teams_distribute_depend_disjoint_section() {\n  int isOffloading = 0;\n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int async_found = 0;\n  int errors = 0;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n    b[x] = 2*x;\n    c[x] = 0;\n    d[x] = 0;\n  }\n\n#pragma omp atomic data map(to: a[0:N], b[0:N]) map(tofrom: c[0:N], d[0:N])\n  {\n#pragma omp target teams distribute nowait depend(out: c[0:N/2]) map(alloc: a[0:N], b[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n#pragma omp atomic\n      d[x] += a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(out: c[N/2:N/2]) map(alloc: a[0:N], b[0:N], c[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n#pragma omp atomic\n      c[x] += 2*(a[x] + b[x]) + d[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, c[x] != 6*x && c[x] != 9*x);\n    OMPVV_ERROR_IF(errors, \"Found invalid results, cannot show independence between depend clauses on disjoint array sections.\");\n    if (errors) {\n      break;\n    }\n    if (c[x] == 6*x) {\n      async_found = 1;\n    }\n  }\n\n  OMPVV_INFOMSG_IF(!errors && async_found, \"Found asynchronous behavior between depend clauses on disjoint array sections.\");\n  OMPVV_WARNING_IF(!errors && !async_found, \"Constructs ran in sequence, could not show lack of dependence since nowait had no effect.\");\n\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  errors += test_target_teams_distribute_depend_disjoint_section();\n  OMPVV_INFOMSG_IF(errors != 0, \"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_scan.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1863",
        "issue_id": 1,
        "original_code": "//===--- test_scan.c --------------------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the scan directive with both the inclusive and exclusive\n// clause, as well as the parallel for simd directive with the\n// reduction(inscan) clause. The test peforms the scan operation with the add\n// operator and then checks the results against an expected result from a\n// sequentially-computed prefix sum.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_scan_inclusive() {\n  OMPVV_INFOMSG(\"test_scan_inclusive\");\n  int errors = 0;\n  int x = 0;\n  int expected_x = 0;\n  int a[N];\n  int b[N];\n\n  for (int i = 0; i < N; i++) {\n    a[i] = i;\n    b[i] = 0;\n  }\n\n#pragma omp parallel for simd reduction(inscan, +: x) num_threads(OMPVV_NUM_THREADS_HOST)\n  for (int i = 0; i < N; i++) {\n    x += a[i];\n#pragma omp scan inclusive(x)\n    b[i] = x;\n  }\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j <= i; j++) {\n      expected_x += a[j];\n    }\n    OMPVV_TEST_AND_SET_VERBOSE(errors, b[i] != expected_x);\n    expected_x = 0;\n  }\n\n  return errors;\n}\n\nint test_scan_exclusive() {\n  OMPVV_INFOMSG(\"test_scan_exclusive\");\n  int errors = 0;\n  int x = 0;\n  int expected_x = 0;\n  int a[N];\n  int b[N];\n\n  for (int i = 0; i < N; i++) {\n    a[i] = i;\n    b[i] = 0;\n  }\n\n#pragma omp parallel for simd reduction(inscan, +: x) num_threads(OMPVV_NUM_THREADS_HOST)\n  for (int i = 0; i < N; i++) {\n    b[i] = x;\n#pragma omp scan exclusive(x)\n    x += a[i];\n  }\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < i; j++) {\n      expected_x += a[j];\n    }\n    OMPVV_TEST_AND_SET_VERBOSE(errors, b[i] != expected_x);\n    expected_x = 0;\n  }\n\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_scan_inclusive());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_scan_exclusive());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_scan.c --------------------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the scan directive with both the inclusive and exclusive\n// clause, as well as the parallel for simd directive with the\n// reduction(inscan) clause. The test peforms the scan operation with the add\n// operator and then checks the results against an expected result from a\n// sequentially-computed prefix sum.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_scan_inclusive() {\n  OMPVV_INFOMSG(\"test_scan_inclusive\");\n  int errors = 0;\n  int x = 0;\n  int expected_x = 0;\n  int a[N];\n  int b[N];\n\n  for (int i = 0; i < N; i++) {\n    a[i] = i;\n    b[i] = 0;\n  }\n\n#pragma omp parallel for simd reduction(inscan, +: x) num_threads(OMPVV_NUM_THREADS_HOST)\n  for (int i = 0; i < N; i++) {\n    x += a[i];\n#pragma omp scan inclusive(x)\n    b[i] = x;\n  }\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j <= i; j++) {\n      expected_x += a[j];\n    }\n    OMPVV_TEST_AND_SET_VERBOSE(errors, b[i] != expected_x);\n    expected_x = 0;\n  }\n\n  return errors;\n}\n\nint test_scan_exclusive() {\n  OMPVV_INFOMSG(\"test_scan_exclusive\");\n  int errors = 0;\n  int x = 0;\n  int expected_x = 0;\n  int a[N];\n  int b[N];\n\n  for (int i = 0; i < N; i++) {\n    a[i] = i;\n    b[i] = 0;\n  }\n\n#pragma omp parallel for simd reduction(inscan, +: x) num_threads(OMPVV_NUM_THREADS_HOST)\n  for (int i = 0; i < N; i++) {\n    b[i] = x;\n#pragma omp scan exclusive(x)\n    x += a[i];\n  }\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < i; j++) {\n      expected_x += a[j];\n    }\n    OMPVV_TEST_AND_SET_VERBOSE(errors, b[i] != expected_x);\n    expected_x = 0;\n  }\n\n  return errors;\n}\n\nint main() \n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_scan_inclusive());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_scan_exclusive());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_parallel_for_dist_schedule.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1494",
        "issue_id": 1,
        "original_code": "//===-test_target_teams_distribute_parallel_for_dist_schedule.c-===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// testing the combined construct target teams distribute parallel for\n// This test will check if dist_schedule(static, 4) taking effect\n//\n//===---------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\nint arr[32] = {0};\nint chunked = 1;\n\nint Dist_ScheduleStatic() {\n  int ErrCount = 0;\nint num_teams, num_threads;\n\n#pragma omp target teams distribute parallel for num_teams(2)\\\n        thread_limit(4)  map(tofrom: num_teams, num_threads)\\\n        dist_schedule(static, 4)\n  for (int i = 0; i < 32; ++i) {\n    if(omp_get_team_num()==0 && omp_get_thread_num() == 0){\n      num_teams = omp_get_num_teams();\n      num_threads = omp_get_num_threads();\n    }\n    arr[i] = omp_get_team_num();\n  }\n\n  if ((num_teams > OMPVV_NUM_TEAMS_DEVICE) || (num_threads > OMPVV_NUM_THREADS_DEVICE)) {\n    ErrCount += 1;\n  }\n  if(num_teams == 1){\n    OMPVV_WARNING(\"Only 1 team was created, the feature cannot be tested.\");\n    return ErrCount;\n  }\n  \n  for(int i=0; i<32; i+=4){\n    int temp = arr[i];\n    for(int j=1; j< 4;j++)\n      if(arr[i+j] != temp){\n        chunked = 0;\n        break;\n      }\n    if(chunked == 0) {\n      ErrCount++;\n      OMPVV_WARNING(\"The given iterations were not scheduled according to the static chunks requested\");\n      break;\n    }\n  }\n\n  return ErrCount;\n}\n\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, Dist_ScheduleStatic() != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===-test_target_teams_distribute_parallel_for_dist_schedule.c-===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// testing the combined construct target teams distribute parallel for\n// This test will check if dist_schedule(static, 4) taking effect\n//\n//===---------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\nint arr[32] = {0};\nint chunked = 1;\n\nint Dist_ScheduleStatic() {\n  int ErrCount = 0;\nint num_teams, num_threads;\n\n#pragma omp target teams distribute parallel for num_teams(2)\\\n        thread_limit(4)  map(tofrom: num_teams, num_threads)\\\n        dist_schedule(static, 4)\n  for (int i = 0; i < 32; ++i) {\n    if(omp_get_team_num()==0 && omp_get_thread_num() == 0){\n      num_teams = omp_get_num_teams();\n      num_threads = omp_get_num_threads();\n    }\n    arr[i] = omp_get_team_num();\n  }\n\n  if ((num_teams > OMPVV_NUM_TEAMS_DEVICE) || (num_threads > OMPVV_NUM_THREADS_DEVICE)) {\n    ErrCount += 1;\n  }\n  if(num_teams == 1){\n    OMPVV_WARNING(\"Only 1 team was created, the feature cannot be tested.\");\n    return ErrCount;\n  }\n  \n  for(int i=0; i<32; i+=4){\n    int temp = arr[i];\n    for(int j=1; j< 4;j++)\n      if(arr[i+j] != temp){\n        chunked = 0;\n        break;\n      }\n    if(chunked == 0) {\n      ErrCount++;\n      OMPVV_WARNING(\"The given iterations were not scheduled according to the static chunks requested\");\n      break;\n    }\n  }\n\n  return ErrCount;\n}\n\n\n\nint main() \n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, Dist_ScheduleStatic() != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_requires_unified_shared_memory_stack_is_device_ptr.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp requires\" with directive \"#pragma omp cancel\" at position 597",
        "issue_id": 0,
        "original_code": "//===---test_requires_unified_shared_memory_stack_is_device_ptr.c ------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Testing memory access from host and device to a variable allocated in the stack\n// The variable is accessed through a pointer to guarantee that there is no default\n// mapping tofrom: of the stack array\n//\n// We use the is_device_ptr to guarantee using the host pointer is used in the device\n//\n////===----------------------------------------------------------------------===//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp requires unified_shared_memory\n\nint unified_shared_memory_stack_is_device_ptr() {\n  OMPVV_INFOMSG(\"Unified shared memory testing - Array on stack\");\n  int errors = 0;\n  \n  int anArray[N];\n  int anArrayCopy[N];\n  int * aPtr = anArray;\n\n  for (int i = 0; i < N; i++) {\n    anArray[i] = i;\n    anArrayCopy[i] = 0;\n  }\n\n  // Test for writes to this variable from device\n#pragma omp target is_device_ptr(aPtr)\n  {\n    for (int i = 0; i < N; i++) {\n      aPtr[i] += 10;\n    }\n  }\n  // Modify again on the host\n  for (int i = 0; i < N; i++) {\n    aPtr[i] += 10;\n  }\n\n  // Test for reads to this variable from device\n#pragma omp target is_device_ptr(aPtr)\n  {\n    for (int i = 0; i < N; i++) {\n      anArrayCopy[i] = aPtr[i];\n    }\n  }\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArray[i] != i + 20);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArrayCopy[i] != i + 20);\n    if (errors) break;\n  }\n  return errors;\n}\n\nint main() {\n  int isOffloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"With no offloading, unified shared memory is guaranteed due to host execution\");\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, unified_shared_memory_stack_is_device_ptr());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---test_requires_unified_shared_memory_stack_is_device_ptr.c ------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Testing memory access from host and device to a variable allocated in the stack\n// The variable is accessed through a pointer to guarantee that there is no default\n// mapping tofrom: of the stack array\n//\n// We use the is_device_ptr to guarantee using the host pointer is used in the device\n//\n////===----------------------------------------------------------------------===//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\n#pragma omp cancel unified_shared_memory\n\nint unified_shared_memory_stack_is_device_ptr() {\n  OMPVV_INFOMSG(\"Unified shared memory testing - Array on stack\");\n  int errors = 0;\n  \n  int anArray[N];\n  int anArrayCopy[N];\n  int * aPtr = anArray;\n\n  for (int i = 0; i < N; i++) {\n    anArray[i] = i;\n    anArrayCopy[i] = 0;\n  }\n\n  // Test for writes to this variable from device\n#pragma omp target is_device_ptr(aPtr)\n  {\n    for (int i = 0; i < N; i++) {\n      aPtr[i] += 10;\n    }\n  }\n  // Modify again on the host\n  for (int i = 0; i < N; i++) {\n    aPtr[i] += 10;\n  }\n\n  // Test for reads to this variable from device\n#pragma omp target is_device_ptr(aPtr)\n  {\n    for (int i = 0; i < N; i++) {\n      anArrayCopy[i] = aPtr[i];\n    }\n  }\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArray[i] != i + 20);\n    OMPVV_TEST_AND_SET_VERBOSE(errors, anArrayCopy[i] != i + 20);\n    if (errors) break;\n  }\n  return errors;\n}\n\nint main() {\n  int isOffloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  OMPVV_WARNING_IF(!isOffloading, \"With no offloading, unified shared memory is guaranteed due to host execution\");\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, unified_shared_memory_stack_is_device_ptr());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_loop_reduction_add_device.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp single\" at position 742",
        "issue_id": 0,
        "original_code": "//===--- test_loop_reduction_add_device.c -----------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the reduction clause on a loop directive, testing that the\n// variable in the reduction clause is properly reduced using the add\n// operator. This test checks the above in a target context.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_add() {\n  int a[N];\n  int b[N];\n  int total = 0;\n  int expect_total = 0;\n  int errors = 0;\n  int num_threads[N];\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    num_threads[x] = -1;\n  }\n\n#pragma omp target parallel num_threads(OMPVV_NUM_THREADS_DEVICE) map(tofrom: total, a, b, num_threads)\n  {\n#pragma omp loop reduction(+:total)\n    for (int x = 0; x < N; ++x) {\n      total += a[x] + b[x];\n    }\n#pragma omp for\n    for (int x = 0; x < N; ++x) {\n      num_threads[x] = omp_get_num_threads();\n    }\n  }\n\n  for (int x = 0; x < N; ++x) {\n    expect_total += a[x] + b[x];\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_threads[x - 1] != num_threads[x], \"Test reported differing numbers of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_threads[0] == 1, \"Test operated with one thread.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_threads[0] <= 0, \"Test reported invalid number of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, expect_total != total);\n  OMPVV_ERROR_IF(expect_total != total, \"Total from loop directive is %d but expected total is %d.\", total, expect_total);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_add() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n",
        "error_code": "//===--- test_loop_reduction_add_device.c -----------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the reduction clause on a loop directive, testing that the\n// variable in the reduction clause is properly reduced using the add\n// operator. This test checks the above in a target context.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_add() {\n  int a[N];\n  int b[N];\n  int total = 0;\n  int expect_total = 0;\n  int errors = 0;\n  int num_threads[N];\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = 1;\n    b[x] = x;\n    num_threads[x] = -1;\n  }\n\n#pragma omp single parallel num_threads(OMPVV_NUM_THREADS_DEVICE) map(tofrom: total, a, b, num_threads)\n  {\n#pragma omp loop reduction(+:total)\n    for (int x = 0; x < N; ++x) {\n      total += a[x] + b[x];\n    }\n#pragma omp for\n    for (int x = 0; x < N; ++x) {\n      num_threads[x] = omp_get_num_threads();\n    }\n  }\n\n  for (int x = 0; x < N; ++x) {\n    expect_total += a[x] + b[x];\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_threads[x - 1] != num_threads[x], \"Test reported differing numbers of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_threads[0] == 1, \"Test operated with one thread.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_threads[0] <= 0, \"Test reported invalid number of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, expect_total != total);\n  OMPVV_ERROR_IF(expect_total != total, \"Total from loop directive is %d but expected total is %d.\", total, expect_total);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_add() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_depend_lvalue_ptr.cpp",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp master\" at position 561",
        "issue_id": 0,
        "original_code": "//===--- test_target_depend_lvalue_ptr.cpp -----------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the depend clause on task generating constructs are extended to\n// allow any lvalue such as dereferenced pointers.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <iostream>\n#include <cstdlib>\n#include \"ompvv.h\"\n\nint test_task_depend_lvalue_ptr() {\n\tint errors = 0;\n\tint *ptr = new int;\n\tint value = 0;\n\n\t// Initialize the pointer to -1\n\t*ptr = -1;\n\n\t#pragma omp target parallel map(tofrom: *ptr, value)\n\t{\n\t\t#pragma omp single\n\t\t{\n\t\t\t#pragma omp task depend(out: *ptr)\n\t\t\t{\n\t\t\t\t*ptr = 1;\n\t\t\t}\n\n\t\t\t#pragma omp task depend(in: *ptr)\n\t\t\t{\n\t\t\t\tvalue = *ptr;\n\t\t\t}\n\t\t\t#pragma omp taskwait\n\t\t}\n\t}\n\n\tdelete ptr;\n\t\n\tOMPVV_TEST_AND_SET(errors, value != 1);\n\t\n\treturn errors;\n}\n\nint main() {\n\tOMPVV_TEST_OFFLOADING;\n\tint errors = 0;\n\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_task_depend_lvalue_ptr() != 0);\n\n\tOMPVV_REPORT_AND_RETURN(errors);\n\n\treturn errors;\n}\n\n",
        "error_code": "//===--- test_target_depend_lvalue_ptr.cpp -----------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the depend clause on task generating constructs are extended to\n// allow any lvalue such as dereferenced pointers.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <iostream>\n#include <cstdlib>\n#include \"ompvv.h\"\n\nint test_task_depend_lvalue_ptr() {\n\tint errors = 0;\n\tint *ptr = new int;\n\tint value = 0;\n\n\t// Initialize the pointer to -1\n\t*ptr = -1;\n\n\t#pragma omp master parallel map(tofrom: *ptr, value)\n\t{\n\t\t#pragma omp single\n\t\t{\n\t\t\t#pragma omp task depend(out: *ptr)\n\t\t\t{\n\t\t\t\t*ptr = 1;\n\t\t\t}\n\n\t\t\t#pragma omp task depend(in: *ptr)\n\t\t\t{\n\t\t\t\tvalue = *ptr;\n\t\t\t}\n\t\t\t#pragma omp taskwait\n\t\t}\n\t}\n\n\tdelete ptr;\n\t\n\tOMPVV_TEST_AND_SET(errors, value != 1);\n\t\n\treturn errors;\n}\n\nint main() {\n\tOMPVV_TEST_OFFLOADING;\n\tint errors = 0;\n\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_task_depend_lvalue_ptr() != 0);\n\n\tOMPVV_REPORT_AND_RETURN(errors);\n\n\treturn errors;\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_loop_reduction_add_mod.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_add() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\" at position 1281",
        "issue_id": 4,
        "original_code": "//===--- test_loop_reduction_add_mod.c ------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the reduction clause on a loop directive, testing that the\n// variables in the reduction clause are properly reduced using the add\n// operator. Standard types are reduced: int, float, double, char.\n// Test written in reference to test_loop_reduction_add.c.\n//\n//===-----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#define A -32\n#define B 64\n#define L 40\n#define X 1\n\nint test_add() {\n  int n = A, errors=0; \n  float f = A;\n  double d = A;\n  char c = L;\n  int exp_n = A + B;\n  float exp_f = A + B;\n  double exp_d = A + B;\n  char exp_c = L + B;\n\n#pragma omp parallel \n  {\n  #pragma omp loop reduction(+:n,f,d,c) \n    for(int i=0;i<B;i++){\n      n = n + X;\n      f = f + X;  \n      d = d + X;  \n      c = c + X;\n    }\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (n != exp_n) || (f != exp_f) || (d != exp_d) || (c != exp_c));\n\n  OMPVV_ERROR_IF(errors, \"\\nn|EXPECTED:%d, RECEIVED:%d\\nf|EXPECTED:%.1f, RECEIVED:%.1f\\nd|EXPECTED:%.1f, RECEIVED:%.1f\\nc|EXPECTED:%c, RECEIVED:%c\\n\",exp_n,n,exp_f,f,exp_d,d,exp_c,c); \n\n  return errors;\n}\nint main() {\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_add() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n",
        "error_code": "//===--- test_loop_reduction_add_mod.c ------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the reduction clause on a loop directive, testing that the\n// variables in the reduction clause are properly reduced using the add\n// operator. Standard types are reduced: int, float, double, char.\n// Test written in reference to test_loop_reduction_add.c.\n//\n//===-----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#define A -32\n#define B 64\n#define L 40\n#define X 1\n\nint test_add() {\n  int n = A, errors=0; \n  float f = A;\n  double d = A;\n  char c = L;\n  int exp_n = A + B;\n  float exp_f = A + B;\n  double exp_d = A + B;\n  char exp_c = L + B;\n\n#pragma omp parallel \n  {\n  #pragma omp loop reduction(+:n,f,d,c) \n    for(int i=0;i<B;i++){\n      n = n + X;\n      f = f + X;  \n      d = d + X;  \n      c = c + X;\n    }\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (n != exp_n) || (f != exp_f) || (d != exp_d) || (c != exp_c));\n\n  OMPVV_ERROR_IF(errors, \"\\nn|EXPECTED:%d, RECEIVED:%d\\nf|EXPECTED:%.1f, RECEIVED:%.1f\\nd|EXPECTED:%.1f, RECEIVED:%.1f\\nc|EXPECTED:%c, RECEIVED:%c\\n\",exp_n,n,exp_f,f,exp_d,d,exp_c,c); \n\n  return errors;\n}\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_reduction_min.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_min() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\" at position 1761",
        "issue_id": 4,
        "original_code": "//===--- test_target_teams_distribute_reduction_min.c----------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the reduction clause on a target teams distribute directive,\n// testing that the variable in the reduction clause is properly reduced using\n// the min operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_min() {\n  int a[N];\n  int b[N];\n  int errors = 0;\n  int num_teams[N];\n  srand(1);\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = (int) rand() / (double) (RAND_MAX / 100);\n    b[x] = (int) rand() / (double) (RAND_MAX / 100);\n    num_teams[x] = -x;\n  }\n\n  int result = a[0] + b[0];\n\n#pragma omp target teams distribute reduction(min:result) defaultmap(tofrom:scalar)\n  for (int x = 0; x < N; ++x) {\n    num_teams[x] = omp_get_num_teams();\n    result = fmin(result, a[x] + b[x]);\n  }\n\n  int host_min = a[0] + b[0];\n\n  for (int x = 0; x < N; ++x) {\n    host_min = fmin(host_min, a[x] + b[x]);\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_teams[x - 1] != num_teams[x], \"Kernel reported differing numbers of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_teams[0] == 1, \"Test operated with one team.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_teams[0] <= 0, \"Test reported invalid number of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, host_min != result);\n  OMPVV_ERROR_IF(host_min != result, \"Min on device is %d but expected min from host is %d.\", result, host_min);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_min() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_reduction_min.c----------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the reduction clause on a target teams distribute directive,\n// testing that the variable in the reduction clause is properly reduced using\n// the min operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_min() {\n  int a[N];\n  int b[N];\n  int errors = 0;\n  int num_teams[N];\n  srand(1);\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = (int) rand() / (double) (RAND_MAX / 100);\n    b[x] = (int) rand() / (double) (RAND_MAX / 100);\n    num_teams[x] = -x;\n  }\n\n  int result = a[0] + b[0];\n\n#pragma omp target teams distribute reduction(min:result) defaultmap(tofrom:scalar)\n  for (int x = 0; x < N; ++x) {\n    num_teams[x] = omp_get_num_teams();\n    result = fmin(result, a[x] + b[x]);\n  }\n\n  int host_min = a[0] + b[0];\n\n  for (int x = 0; x < N; ++x) {\n    host_min = fmin(host_min, a[x] + b[x]);\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_teams[x - 1] != num_teams[x], \"Kernel reported differing numbers of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_teams[0] == 1, \"Test operated with one team.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_teams[0] <= 0, \"Test reported invalid number of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, host_min != result);\n  OMPVV_ERROR_IF(host_min != result, \"Min on device is %d but expected min from host is %d.\", result, host_min);\n\n  return errors;\n}\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_declare_target_extended_list.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp declare\" with directive \"#pragma omp teams\" at position 661",
        "issue_id": 0,
        "original_code": "//===------ test_declare_target_extended_list.c ----------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks the second valid format of declare target directive. The\n// extended list allows for mappable variables and function names to be listed.\n// If an extended-list is present with no clause then the to clause is assumed.\n// Updates using the enclosed function are made inside the target region and\n// results are verified on the host.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint aint = 10;\n\n#pragma omp declare target(aint)\n\nvoid compute_array(int a[N], int b[N], int c[N]) {\n  for (int i = 0; i < N; i++) {\n    a[i] = b[i]*c[i] + aint * i;\n  }\n  return;\n}\n\n#pragma omp declare target(compute_array)\n\nint test_declare_target() {\n\n  OMPVV_INFOMSG(\"test_declare_target_extended_list\");\n\n  int errors = 0;\n  int x[N];\n  int y[N];\n  int z[N];\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 0;\n    y[i] = 1;\n    z[i] = i;\n  }\n\n#pragma omp target map(from: x) map(to:y, z)\n  {\n    compute_array(x, y, z);\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != (y[i] * z[i] + 10 * i));\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_declare_target() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===------ test_declare_target_extended_list.c ----------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks the second valid format of declare target directive. The\n// extended list allows for mappable variables and function names to be listed.\n// If an extended-list is present with no clause then the to clause is assumed.\n// Updates using the enclosed function are made inside the target region and\n// results are verified on the host.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint aint = 10;\n\n#pragma omp teams target(aint)\n\nvoid compute_array(int a[N], int b[N], int c[N]) {\n  for (int i = 0; i < N; i++) {\n    a[i] = b[i]*c[i] + aint * i;\n  }\n  return;\n}\n\n#pragma omp declare target(compute_array)\n\nint test_declare_target() {\n\n  OMPVV_INFOMSG(\"test_declare_target_extended_list\");\n\n  int errors = 0;\n  int x[N];\n  int y[N];\n  int z[N];\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 0;\n    y[i] = 1;\n    z[i] = i;\n  }\n\n#pragma omp target map(from: x) map(to:y, z)\n  {\n    compute_array(x, y, z);\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != (y[i] * z[i] + 10 * i));\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_declare_target() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_loop_reduction_bitxor.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp parallel\" with directive \"#pragma omp target\" at position 723",
        "issue_id": 0,
        "original_code": "//===--- test_loop_reduction_bitxor.c ---------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the reduction clause on a loop directive, testing that the\n// variable in the reduction clause is properly reduced using the bitxor\n// operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_bitxor() {\n  unsigned int a[N];\n  int errors = 0;\n  int num_threads[N];\n  srand(1);\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = (unsigned int) rand() / (double) (RAND_MAX / 2);\n    num_threads[x] = -x;\n  }\n\n  unsigned int b = 0;\n\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST)\n  {\n#pragma omp loop reduction(^:b)\n    for (int x = 0; x < N; ++x) {\n      b = (b ^ a[x]);\n    }\n#pragma omp for\n    for (int x = 0; x < N; ++x) {\n      num_threads[x] = omp_get_num_threads();\n    }\n  }\n\n  unsigned int host_b = 0;\n\n  for (int x = 0; x < N; ++x) {\n    host_b = (host_b ^ a[x]);\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_threads[x - 1] != num_threads[x], \"Test reported differing numbers of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_threads[0] == 1, \"Test operated with one thread.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_threads[0] <= 0, \"Test reported invalid number of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, b != host_b);\n  OMPVV_ERROR_IF(host_b != b, \"Bit in loop is %d but expected bit is %d.\", b, host_b);\n\n  return errors;\n}\n\nint main() {\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_bitxor() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n",
        "error_code": "//===--- test_loop_reduction_bitxor.c ---------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test uses the reduction clause on a loop directive, testing that the\n// variable in the reduction clause is properly reduced using the bitxor\n// operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint test_bitxor() {\n  unsigned int a[N];\n  int errors = 0;\n  int num_threads[N];\n  srand(1);\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = (unsigned int) rand() / (double) (RAND_MAX / 2);\n    num_threads[x] = -x;\n  }\n\n  unsigned int b = 0;\n\n#pragma omp target num_threads(OMPVV_NUM_THREADS_HOST)\n  {\n#pragma omp loop reduction(^:b)\n    for (int x = 0; x < N; ++x) {\n      b = (b ^ a[x]);\n    }\n#pragma omp for\n    for (int x = 0; x < N; ++x) {\n      num_threads[x] = omp_get_num_threads();\n    }\n  }\n\n  unsigned int host_b = 0;\n\n  for (int x = 0; x < N; ++x) {\n    host_b = (host_b ^ a[x]);\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_threads[x - 1] != num_threads[x], \"Test reported differing numbers of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_threads[0] == 1, \"Test operated with one thread.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_threads[0] <= 0, \"Test reported invalid number of threads.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, b != host_b);\n  OMPVV_ERROR_IF(host_b != b, \"Bit in loop is %d but expected bit is %d.\", b, host_b);\n\n  return errors;\n}\n\nint main() {\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_bitxor() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_update_from_discontiguous.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp map\" at position 565",
        "issue_id": 0,
        "original_code": "//===--- test_target_update_from_discontiguous.c -----------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test seeks to ensure that target update with motion-clause \"from\" can properly\n// map array sections with stride expressions.\n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 64\n\nint i;\nint errors = 0;\n\nint target_update_from_discontiguous() {\n  \n  double *result;\n  result = (double *)calloc(N,sizeof(double));\n \n#pragma omp target data map(to: result[0:N])\n  {\n    #pragma omp target map(alloc: result[0:N]) \n    {\n      for (int i = 0; i < N; i++) {\n        result[i] += i;\n      }\n    }//end target\n\n\n    #pragma omp target update from(result[0:N/2:2])\n\n  }\n\n  for (i =0; i < N; i++) {\n    if(i%2){\n      OMPVV_TEST_AND_SET(errors, result[i] != 0);\n    }\n    else{\n      OMPVV_TEST_AND_SET(errors, result[i] != i);\n    }\n  } \n\n  return errors;\n}\n\nint main() {\n\n  OMPVV_TEST_OFFLOADING;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, target_update_from_discontiguous());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n",
        "error_code": "//===--- test_target_update_from_discontiguous.c -----------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test seeks to ensure that target update with motion-clause \"from\" can properly\n// map array sections with stride expressions.\n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 64\n\nint i;\nint errors = 0;\n\nint target_update_from_discontiguous() {\n  \n  double *result;\n  result = (double *)calloc(N,sizeof(double));\n \n#pragma omp map data map(to: result[0:N])\n  {\n    #pragma omp target map(alloc: result[0:N]) \n    {\n      for (int i = 0; i < N; i++) {\n        result[i] += i;\n      }\n    }//end target\n\n\n    #pragma omp target update from(result[0:N/2:2])\n\n  }\n\n  for (i =0; i < N; i++) {\n    if(i%2){\n      OMPVV_TEST_AND_SET(errors, result[i] != 0);\n    }\n    else{\n      OMPVV_TEST_AND_SET(errors, result[i] != i);\n    }\n  } \n\n  return errors;\n}\n\nint main() {\n\n  OMPVV_TEST_OFFLOADING;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, target_update_from_discontiguous());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_omp_alloctrait_key.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n\tint errors = 0;\n\tOMPVV_TEST_OFFLOADING;\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_case() != 0);\n\tOMPVV_REPORT_AND_RETURN(errors);\n\treturn errors;\n}\" at position 1487",
        "issue_id": 4,
        "original_code": "//---------------------test_omp_alloctrait_key.c---------------------\n//\n// OpenMP API Version 5.1 March 2023\n//\n// This check intends to check the function of omp_alloctrait_key\n// enum. The test creates two allocations which are then passed into\n// a parrallel region to enusre the allocations work as expected.\n//\n//-------------------------------------------------------------------\n\n#include <stdlib.h>\n#include <omp.h>\n#include <math.h>\n#include \"ompvv.h\"\n#define N 1000\n\nint test_case(){\n\t\n\tint *x, *y;\n\t\n\tint errors = 0;\n\tint test_x = 0;\n\tint test_y = 0;\n\n\tomp_memspace_handle_t xy_memspace = omp_default_mem_space;\n\tomp_alloctrait_t xy_traits[1] = {omp_atk_alignment, 64};\n\tomp_allocator_handle_t xy_alloc = omp_init_allocator(xy_memspace,1,xy_traits);\n\t\n\tx = (int *) omp_alloc(N*sizeof(int), xy_alloc);\n\ty = (int *) omp_alloc(N*sizeof(int), xy_alloc);\n\n\t#pragma omp parallel\n\t{\n\t\t#pragma omp for simd simdlen(16) aligned(x,y:64)\n\t\tfor(int i=0;i<N; i++){ x[i]=0; y[i]=0;}\n\t\t\n\t\t#pragma omp for simd simdlen(16) aligned(x,y:64)\n\t\tfor(int i=0; i<N; i++){x[i] = 1; y[i] = 1;}\n\t}\n\t\n\tfor(int i=0; i<N; i++){\n\t\ttest_x += x[i];\n\t\ttest_y += y[i];\n\t}\n\n\tomp_free(x, xy_alloc);\n\tomp_free(y,  xy_alloc);\n\tomp_destroy_allocator(xy_alloc);\n\n\tint test_all = test_x + test_y;\n\tOMPVV_TEST_AND_SET_VERBOSE(errors,test_all != 2000);\n\tOMPVV_INFOMSG_IF(test_x != 1000, \"test x not properly allocated\");\n\tOMPVV_INFOMSG_IF(test_y != 1000, \"test y not properly allocated\");\n\treturn errors;\n}\n\nint main(){\n\tint errors = 0;\n\tOMPVV_TEST_OFFLOADING;\n\tOMPVV_TEST_AND_SET_VERBOSE(errors, test_case() != 0);\n\tOMPVV_REPORT_AND_RETURN(errors);\n\treturn errors;\n}\n",
        "error_code": "//---------------------test_omp_alloctrait_key.c---------------------\n//\n// OpenMP API Version 5.1 March 2023\n//\n// This check intends to check the function of omp_alloctrait_key\n// enum. The test creates two allocations which are then passed into\n// a parrallel region to enusre the allocations work as expected.\n//\n//-------------------------------------------------------------------\n\n#include <stdlib.h>\n#include <omp.h>\n#include <math.h>\n#include \"ompvv.h\"\n#define N 1000\n\nint test_case(){\n\t\n\tint *x, *y;\n\t\n\tint errors = 0;\n\tint test_x = 0;\n\tint test_y = 0;\n\n\tomp_memspace_handle_t xy_memspace = omp_default_mem_space;\n\tomp_alloctrait_t xy_traits[1] = {omp_atk_alignment, 64};\n\tomp_allocator_handle_t xy_alloc = omp_init_allocator(xy_memspace,1,xy_traits);\n\t\n\tx = (int *) omp_alloc(N*sizeof(int), xy_alloc);\n\ty = (int *) omp_alloc(N*sizeof(int), xy_alloc);\n\n\t#pragma omp parallel\n\t{\n\t\t#pragma omp for simd simdlen(16) aligned(x,y:64)\n\t\tfor(int i=0;i<N; i++){ x[i]=0; y[i]=0;}\n\t\t\n\t\t#pragma omp for simd simdlen(16) aligned(x,y:64)\n\t\tfor(int i=0; i<N; i++){x[i] = 1; y[i] = 1;}\n\t}\n\t\n\tfor(int i=0; i<N; i++){\n\t\ttest_x += x[i];\n\t\ttest_y += y[i];\n\t}\n\n\tomp_free(x, xy_alloc);\n\tomp_free(y,  xy_alloc);\n\tomp_destroy_allocator(xy_alloc);\n\n\tint test_all = test_x + test_y;\n\tOMPVV_TEST_AND_SET_VERBOSE(errors,test_all != 2000);\n\tOMPVV_INFOMSG_IF(test_x != 1000, \"test x not properly allocated\");\n\tOMPVV_INFOMSG_IF(test_y != 1000, \"test y not properly allocated\");\n\treturn errors;\n}\n\nint main()\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_enter_data_map.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===--- test_target_enter_data_map.c -----------------------------------===//\n//\n// OpenMP API Version 5.2 May 2022\n//\n// This is a test of the target enter data map construct with global arrays.\n// The 'to' map-type-modifier is not specified on the map clause.\n// The 'from' map-type-modifier is not specified on the map clause.\n// Specification update 5.1 -> 5.2 target enter data has a default map type \n// that perfroms the same behavior as 'to' or 'from' map types\n//\n//===--------------------------------------------------------------------===//\n\n#include \"ompvv.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include <omp.h>\n\n// Test for OpenMP 5.2 target enter data with global arrays.\n\nint main (){\n\n  int N=10;\n  int A[10]={10,10,10,10,10,10,10,10,10,10};\n  int B[10];\n  int D[10];\n  int i = 0;\n  int errors = 0;\n\n  for (i = 0; i < N; i++) {\n    B[i] = 50;\n    D[i] = 0;\n  }\n\n\n\n  OMPVV_TEST_OFFLOADING;\n\n  #pragma omp target enter data map(A[:N], B[:N], D[:N])\n  //should default to map to\n  #pragma omp target map(tofrom: errors)\n  { \n    for (i = 0; i < N; i++){\n      if(B[i] != 50){errors++;}\n      if(A[i] != 10){errors++;}\n      if(D[i] != 00){errors++;}\n      \n    }\n\n\n    for (i = 0; i < N; i++) {\n      D[i] = 70;\n      B[i] = 120;\n      A[i] = 1000;\n    }\n  }\n\n  for (i = 0; i < N; i++){\n    OMPVV_TEST_AND_SET_VERBOSE(errors, B[i] == 120)\n    OMPVV_TEST_AND_SET_VERBOSE(errors, A[i] == 1000)\n    OMPVV_TEST_AND_SET_VERBOSE(errors, D[i] == 70)\n  }\n\n\n\n\n  #pragma omp target exit data map(B[:N], A[:N],D[:N])\n  //should default to map from\n  for (i = 0; i < N; i++){\n    OMPVV_TEST_AND_SET_VERBOSE(errors, B[i] != 120)\n    OMPVV_TEST_AND_SET_VERBOSE(errors, A[i] != 1000)\n    OMPVV_TEST_AND_SET_VERBOSE(errors, D[i] != 70)\n  }\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nlong tuvyhvawhe = 86;\nlong ghcxjfrjhy = 61;\ndouble dbqbaxlprq = 218;\nint xfdyxcemox = 245;\nshort odqjyzfwim = 215;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/reduction_separated_directives.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n      counts_reduction = counts_team;\n    }\" at position 1275",
        "issue_id": 4,
        "original_code": "//===---- reduction_separated_directives.c --------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks the behavior of a reduction clause with separated target teams\n// parallel for directives by comparing the results to those from atomic-protected\n// writes without a reduction. This test comes from the aomp development repo, see\n// https://github.com/ROCm-Developer-Tools/aomp/issues/51.\n//\n//===----------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main()\n{\n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_SHARED_ENVIRONMENT;\n\n  int errors = 0;\n  int counts_atomic = 0;\n  int counts_reduction = 0;\n\n#pragma omp target teams map(from: counts_atomic)\n  {\n    int counts_team = 0;\n#pragma omp parallel\n    {\n#pragma omp for\n      for (int i = 0; i < N; ++i)\n#pragma omp atomic\n        counts_team += 1;\n    }\n    if (omp_get_team_num() == 0) {\n      counts_atomic = counts_team;\n    }\n  }\n\n#pragma omp target teams map(from: counts_reduction)\n  {\n    int counts_team = 0;\n#pragma omp parallel\n    {\n#pragma omp for reduction(+: counts_team)\n      for (int i = 0; i < N; ++i)\n        counts_team += 1;\n    }\n    if (omp_get_team_num() == 0) {\n      counts_reduction = counts_team;\n    }\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, counts_atomic != N);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, counts_reduction != N);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- reduction_separated_directives.c --------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks the behavior of a reduction clause with separated target teams\n// parallel for directives by comparing the results to those from atomic-protected\n// writes without a reduction. This test comes from the aomp development repo, see\n// https://github.com/ROCm-Developer-Tools/aomp/issues/51.\n//\n//===----------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main()\n{\n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_SHARED_ENVIRONMENT;\n\n  int errors = 0;\n  int counts_atomic = 0;\n  int counts_reduction = 0;\n\n#pragma omp target teams map(from: counts_atomic)\n  {\n    int counts_team = 0;\n#pragma omp parallel\n    {\n#pragma omp for\n      for (int i = 0; i < N; ++i)\n#pragma omp atomic\n        counts_team += 1;\n    }\n    if (omp_get_team_num() == 0) {\n      counts_atomic = counts_team;\n    }\n  }\n\n#pragma omp target teams map(from: counts_reduction)\n  {\n    int counts_team = 0;\n#pragma omp parallel\n    {\n#pragma omp for reduction(+: counts_team)\n      for (int i = 0; i < N; ++i)\n        counts_team += 1;\n    }\n    if (omp_get_team_num() == 0) \n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, counts_atomic != N);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, counts_reduction != N);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_declare_target_device_type_nohost.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n    a[i] = 0;\n    b[i] = 0;\n    c[i] = 0;\n  }\" at position 2064",
        "issue_id": 4,
        "original_code": "//===---- test_declare_target_device_type_nohost.c  ----------------------------------===//\n// \n// OpenMP API Version 5.0 \n//\n// The declare target directive specifies that variables, functions(C,C++ and Fortran),\n// and subroutines (Fortran) are mapped to a device. If a device_type\n// clause is present on the contained declare target directive, then its argument \n// determines which versions are made available. If device_type(nohost) is present \n// only a device version of the procedure is made available. \n// The device version of the function is specified via declare variant.\n// \n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 10\nint errors = 0;\n\nvoid target_function();\n#pragma omp declare target to(target_function) device_type(nohost)\n\n#pragma omp declare target\nint a[N], b[N], c[N];  \nint i = 0;\n#pragma omp end declare target\n\n#pragma omp declare variant(target_function) match(device={kind(nohost)})\nvoid update() {\n  for (i = 0; i < N; i++) {\n    a[i] += 5;\n    b[i] += 5;\n    c[i] += 5;\n  }\n}\n\nvoid target_function(){\n  for (i = 0; i < N; i++) {\n    a[i] += 1;\n    b[i] += 2;\n    c[i] += 3;\n  }\n} \n\nint test_declare_target_device_type_nohost() { \n\n  update();\n\n  #pragma omp target update to(a,b,c)\n\n  #pragma omp target  \n  {\n    update();\n  }\n\n  #pragma omp target update from (a,b,c)\n  \n  if (omp_get_default_device () >= 0 && omp_get_default_device () < omp_get_num_devices ()) {\n    for (i = 0; i < N; i++) { //check array values on host\n      if ( a[i] != 6 || b[i] != 7 || c[i] != 8 ) {\n        errors++;\n      }\n    }\n  } else {\n    OMPVV_WARNING(\"Default device is the host device. Thus, test only ran on the host\");\n    for (i = 0; i < N; i++) { //check array values on host\n      if ( a[i] != 10 || b[i] != 10 || c[i] != 10 ) {\n        errors++;\n      }\n    }\n  }\n  \n  return errors;\n}\n\nint main () {\n\n  OMPVV_TEST_OFFLOADING;\n  \n  //initalize arrays on host\n  for (i = 0; i < N; i++) {\n    a[i] = 0;\n    b[i] = 0;\n    c[i] = 0;\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_declare_target_device_type_nohost());\n  OMPVV_REPORT_AND_RETURN(errors);\n}  \n",
        "error_code": "//===---- test_declare_target_device_type_nohost.c  ----------------------------------===//\n// \n// OpenMP API Version 5.0 \n//\n// The declare target directive specifies that variables, functions(C,C++ and Fortran),\n// and subroutines (Fortran) are mapped to a device. If a device_type\n// clause is present on the contained declare target directive, then its argument \n// determines which versions are made available. If device_type(nohost) is present \n// only a device version of the procedure is made available. \n// The device version of the function is specified via declare variant.\n// \n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 10\nint errors = 0;\n\nvoid target_function();\n#pragma omp declare target to(target_function) device_type(nohost)\n\n#pragma omp declare target\nint a[N], b[N], c[N];  \nint i = 0;\n#pragma omp end declare target\n\n#pragma omp declare variant(target_function) match(device={kind(nohost)})\nvoid update() {\n  for (i = 0; i < N; i++) {\n    a[i] += 5;\n    b[i] += 5;\n    c[i] += 5;\n  }\n}\n\nvoid target_function(){\n  for (i = 0; i < N; i++) {\n    a[i] += 1;\n    b[i] += 2;\n    c[i] += 3;\n  }\n} \n\nint test_declare_target_device_type_nohost() { \n\n  update();\n\n  #pragma omp target update to(a,b,c)\n\n  #pragma omp target  \n  {\n    update();\n  }\n\n  #pragma omp target update from (a,b,c)\n  \n  if (omp_get_default_device () >= 0 && omp_get_default_device () < omp_get_num_devices ()) {\n    for (i = 0; i < N; i++) { //check array values on host\n      if ( a[i] != 6 || b[i] != 7 || c[i] != 8 ) {\n        errors++;\n      }\n    }\n  } else {\n    OMPVV_WARNING(\"Default device is the host device. Thus, test only ran on the host\");\n    for (i = 0; i < N; i++) { //check array values on host\n      if ( a[i] != 10 || b[i] != 10 || c[i] != 10 ) {\n        errors++;\n      }\n    }\n  }\n  \n  return errors;\n}\n\nint main () {\n\n  OMPVV_TEST_OFFLOADING;\n  \n  //initalize arrays on host\n  for (i = 0; i < N; i++) \n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_declare_target_device_type_nohost());\n  OMPVV_REPORT_AND_RETURN(errors);\n}  \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_map.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 2186",
        "issue_id": 2,
        "original_code": "//===--- test_target_teams_distribute_map.c----------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the map clause on a target teams distribute clause to test that\n// the indicated data is maped on the target in the fashion that is indicated\n// with the map-type.  Each map-type that is valid in this situation (to, from,\n// alloc, and tofrom) are each used and tested.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main() {\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  int a[N];\n  int b[N];\n  int c[N];\n  int errors= 0;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n    b[x] = 0;\n  }\n\n#pragma omp target enter data map(alloc: b[0:N])\n#pragma omp target teams distribute map(to: a[0:N], b[0:N])\n  for (int x = 0; x < N; ++x) {\n    b[x] = a[x];\n  }\n#pragma omp target exit data map(from: b[0:N])\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, a[x] != b[x]);\n    if (a[x] != b[x]) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < N; ++x) {\n    b[x] = 0;\n  }\n\n#pragma omp target enter data map(to: a[0:N])\n#pragma omp target teams distribute map(from: b[0:N])\n  for (int x = 0; x < N; ++x) {\n    b[x] = a[x];\n  }\n#pragma omp target exit data map(delete: a[0:N])\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, a[x] != b[x]);\n    if (a[x] != b[x]) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < N; ++x) {\n    b[x] = 0;\n    c[x] = 0;\n  }\n\n#pragma omp target enter data map(to: a[0:N]) map(alloc: b[0:N])\n#pragma omp target teams distribute map(alloc: a[0:N], b[0:N], c[0:N])\n  for (int x = 0; x < N; ++x) {\n    c[x] = a[x];\n    b[x] = c[x];\n  }\n#pragma omp target exit data map(delete: a[0:N]) map(from: b[0:N])\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, a[x] != b[x]);\n    if (a[x] != b[x]) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < N; ++x) {\n    b[x] = x;\n  }\n\n#pragma omp target teams distribute map(tofrom: b[0:N], a[0:N])\n  for (int x = 0; x < N; ++x) {\n    b[x] += a[x];\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, b[x] != 2*x);\n    if (b[x] != 2*x) {\n      break;\n    }\n  }\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_map.c----------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the map clause on a target teams distribute clause to test that\n// the indicated data is maped on the target in the fashion that is indicated\n// with the map-type.  Each map-type that is valid in this situation (to, from,\n// alloc, and tofrom) are each used and tested.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main() {\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  int a[N];\n  int b[N];\n  int c[N];\n  int errors= 0;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n    b[x] = 0;\n  }\n\n#pragma omp target enter data map(alloc: b[0:N])\n#pragma omp target teams distribute map(to: a[0:N], b[0:N])\n  for (int x = 0; x < N; ++x) {\n    b[x] = a[x];\n  }\n#pragma omp target exit data map(from: b[0:N])\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, a[x] != b[x]);\n    if (a[x] != b[x]) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < N; ++x) {\n    b[x] = 0;\n  }\n\n#pragma omp target enter data map(to: a[0:N])\n#pragma omp target teams distribute map(from: b[0:N])\n  for (int x = 0; x < N; ++x) {\n    b[x] = a[x];\n  }\n#pragma omp target exit data map(delete: a[0:N])\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, a[x] != b[x]);\n    if (a[x] != b[x]) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < N; ++x) {\n    b[x] = 0;\n    c[x] = 0;\n  }\n\n#pragma omp target enter data map(to: a[0:N]) map(alloc: b[0:N])\n#pragma omp target teams distribute map(alloc: a[0:N], b[0:N], c[0:N])\n  for (int x = 0; x < N; ++x) {\n    c[x] = a[x];\n    b[x] = c[x];\n  }\n#pragma omp target exit data map(delete: a[0:N]) map(from: b[0:N])\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, a[x] != b[x]);\n    if (a[x] != b[x]) {\n      break;\n    }\n  }\n\n  for (int x = 0; x < N; ++x) {\n    b[x] = x;\n  }\n\n#pragma omp target teams distribute map(tofrom: b[0:N], a[0:N])\n  for (int x = 0; x < N; ++x) {\n    b[x] += a[x];\n  }\n\n  for (int x = 0;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, b[x] != 2*x);\n    if (b[x] != 2*x) {\n      break;\n    }\n  }\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_dispatch_depend.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n    OMPVV_TEST_OFFLOADING;\n    OMPVV_TEST_AND_SET_VERBOSE(errors, test_wrapper());\n    OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 1844",
        "issue_id": 4,
        "original_code": "//===---- test_dispatch_depend.c -----------------------------------------===//\n// \n// OpenMP API Version 5.1\n//\n// Uses dispatch construct as context for variant directive. Uses depend clause\n// which adds depend property to the interoperability requirement set.\n//\n// Inspired by \"OpenMP 5.1 Features: The Dispatch Construct\" video:\n// https://www.youtube.com/watch?v=ruugaX95gIs\n// \n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint arr[N]; \nint errors;\nint i = 0;\nint a = 0;\n\nvoid add_a(int *arr);\n\n#pragma omp declare variant(add_a) match(construct={dispatch})\nvoid add(int *arr){\n    for (int i = 0; i < N; i++){ // Base function adds 1 to array values\n        arr[i] = i+1;\n    }\n    a = 3;\n}\n\nvoid add_a(int *arr){\n    OMPVV_TEST_AND_SET(errors, a != 3);\n    OMPVV_ERROR_IF(errors > 0, \"Depend clause on dispatch directive not working properly\");\n    for (int i = 0; i < N; i++){\n        arr[i] = i+a; // Variant function adds 3 to array values\n    }\n}\n\nint test_wrapper() { \n    errors = 0;\n    add(arr);\n    for(i = 0; i < N; i++){\n        OMPVV_TEST_AND_SET(errors, arr[i] != i+1);\n    } \n    OMPVV_ERROR_IF(errors > 0, \"Base function is not working properly\");\n    \n    #pragma omp task\n    {\n    #pragma omp taskwait depend(out:a) nowait\n    add(arr);\n    #pragma omp dispatch depend(in: a)\n    add(arr);\n    }\n    #pragma omp taskwait \n\n    for(i = 0; i < N; i++){\n        OMPVV_TEST_AND_SET(errors, arr[i] != i+1 && arr[i] != i+3);\n    }\n\n    OMPVV_INFOMSG_IF(errors > 0 || arr[0] == 1,\n                   \"Dispatch is either not working or was not considered\"\n                   \" by the implementation as part of the context selector.\");\n    return errors;\n}\n\nint main () {\n    OMPVV_TEST_OFFLOADING;\n    OMPVV_TEST_AND_SET_VERBOSE(errors, test_wrapper());\n    OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_dispatch_depend.c -----------------------------------------===//\n// \n// OpenMP API Version 5.1\n//\n// Uses dispatch construct as context for variant directive. Uses depend clause\n// which adds depend property to the interoperability requirement set.\n//\n// Inspired by \"OpenMP 5.1 Features: The Dispatch Construct\" video:\n// https://www.youtube.com/watch?v=ruugaX95gIs\n// \n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint arr[N]; \nint errors;\nint i = 0;\nint a = 0;\n\nvoid add_a(int *arr);\n\n#pragma omp declare variant(add_a) match(construct={dispatch})\nvoid add(int *arr){\n    for (int i = 0; i < N; i++){ // Base function adds 1 to array values\n        arr[i] = i+1;\n    }\n    a = 3;\n}\n\nvoid add_a(int *arr){\n    OMPVV_TEST_AND_SET(errors, a != 3);\n    OMPVV_ERROR_IF(errors > 0, \"Depend clause on dispatch directive not working properly\");\n    for (int i = 0; i < N; i++){\n        arr[i] = i+a; // Variant function adds 3 to array values\n    }\n}\n\nint test_wrapper() { \n    errors = 0;\n    add(arr);\n    for(i = 0; i < N; i++){\n        OMPVV_TEST_AND_SET(errors, arr[i] != i+1);\n    } \n    OMPVV_ERROR_IF(errors > 0, \"Base function is not working properly\");\n    \n    #pragma omp task\n    {\n    #pragma omp taskwait depend(out:a) nowait\n    add(arr);\n    #pragma omp dispatch depend(in: a)\n    add(arr);\n    }\n    #pragma omp taskwait \n\n    for(i = 0; i < N; i++){\n        OMPVV_TEST_AND_SET(errors, arr[i] != i+1 && arr[i] != i+3);\n    }\n\n    OMPVV_INFOMSG_IF(errors > 0 || arr[0] == 1,\n                   \"Dispatch is either not working or was not considered\"\n                   \" by the implementation as part of the context selector.\");\n    return errors;\n}\n\nint main () \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_device1.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 945",
        "issue_id": 2,
        "original_code": "//===------test_target_device.c--------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// Description:\n// This is a basic test to demonstrate target + parallel for + device clause\n//\n//===------------------------------------------------------------------------===//\n#include <stdio.h>\n#include \"omp.h\"\n#include \"ompvv.h\"\n\n#define N 1024\n\n\nint Runtst(int gpu) {\n  int errors = 0;\n  int *A = (int *)malloc(sizeof(int) * N);\n  for (int i = 0; i < N; ++i) {\n    A[i] = i;\n  }\n\n#pragma omp target data map(tofrom: A[0:N]) device(gpu)\n  {\n    #pragma omp target parallel for device(gpu)\n    for (int i = 0; i < N; ++i) {\n      A[i] = A[i] * A[i];\n    }\n  }\n\n  // Verification\n \n  for (int i = 0; i < N; ++i) {\n    if (A[i] != i*i) {\n      errors++;\n    }\n  }\n\n  free(A);\n  return errors;\n}\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int TotGpus = omp_get_num_devices();\n  printf(\"TotGpus: %d\\n\", TotGpus);\n  int errors = 0;\n  for (int gpu = 0; gpu < TotGpus; ++gpu) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (Runtst(gpu) != 0)); \n  }\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===------test_target_device.c--------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// Description:\n// This is a basic test to demonstrate target + parallel for + device clause\n//\n//===------------------------------------------------------------------------===//\n#include <stdio.h>\n#include \"omp.h\"\n#include \"ompvv.h\"\n\n#define N 1024\n\n\nint Runtst(int gpu) {\n  int errors = 0;\n  int *A = (int *)malloc(sizeof(int) * N);\n  for (int i = 0; i < N; ++i) {\n    A[i] = i;\n  }\n\n#pragma omp target data map(tofrom: A[0:N]) device(gpu)\n  {\n    #pragma omp target parallel for device(gpu)\n    for (int i = 0; i < N; ++i) {\n      A[i] = A[i] * A[i];\n    }\n  }\n\n  // Verification\n \n  for (int i = 0; i < N; ++i) {\n    if (A[i] != i*i) {\n      errors++;\n    }\n  }\n\n  free(A);\n  return errors;\n}\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int TotGpus = omp_get_num_devices();\n  printf(\"TotGpus: %d\\n\", TotGpus);\n  int errors = 0;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n  for (int gpu = 0; gpu < TotGpus; ++gpu) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (Runtst(gpu) != 0)); \n  }\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_default_firstprivate_taskloop.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp parallel\" with directive \"#pragma omp for\" at position 1041",
        "issue_id": 0,
        "original_code": "//===--- test_default_firstprivate_parallel.c -----------------------------------------------===//\n//\n//  OpenMP API Version 5.1 Aug 2021\n//\n//  This test checks behavior of the default clause when the specified data-sharing-attribute  \n//  is firstprivate. The constructs allowed for a default clause are parallel, teams, task, and taskloop.\n//  This test utilizes the taskloop construct, where firstprivate states that one or more list items are\n//  private to the parallel task, and each of them are initialized with the value of the corresponding\n//  original item. The taskloop construct executes one or more loops in parallel on each thread. \n//\n////===--------------------------------------------------------------------------------------===//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint errors;\n\nint test_default_firstprivate_taskloop() {\n  int scalar_var = 6;\n  int arr[N];\n  int sum =0;\n  for (int i=0; i<N; i++){\n        arr[i] = i;\n        sum += arr[i];\n\t }\n#pragma omp parallel num_threads(OMPVV_NUM_THREADS_HOST)\n    {\t\n#pragma omp single \n\t{  \n#pragma omp taskloop default(firstprivate)\n  for (int i = 0; i < N; i++) {\n\t\tarr[i] = i + 3;\n\t\tscalar_var += 7;\n \t\t}\t\n  \t}\t\n     }\n  int new_sum =0;\n  int wrong_sum =0;\n  for (int i = 0; i < N; i++) {\n\tnew_sum += arr[i];\n\twrong_sum += i + 3;\n  \t}\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_var != 6);\n  OMPVV_INFOMSG_IF(scalar_var == 0, \"Scalar was not initialized in parallel region & not updated\");\n  OMPVV_INFOMSG_IF(scalar_var >  6, \"Scalar was not firstprivate, changes made in parallel affected original copy\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, sum != new_sum);\n  OMPVV_INFOMSG_IF(new_sum == 0, \"Array was not initialized in parallel region properly\");\n  OMPVV_INFOMSG_IF(new_sum == wrong_sum, \"Array was not first private, changes made in parallel affected original copy\");\n  return errors;\n}\n\nint main() {\n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_default_firstprivate_taskloop() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_default_firstprivate_parallel.c -----------------------------------------------===//\n//\n//  OpenMP API Version 5.1 Aug 2021\n//\n//  This test checks behavior of the default clause when the specified data-sharing-attribute  \n//  is firstprivate. The constructs allowed for a default clause are parallel, teams, task, and taskloop.\n//  This test utilizes the taskloop construct, where firstprivate states that one or more list items are\n//  private to the parallel task, and each of them are initialized with the value of the corresponding\n//  original item. The taskloop construct executes one or more loops in parallel on each thread. \n//\n////===--------------------------------------------------------------------------------------===//\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n\nint errors;\n\nint test_default_firstprivate_taskloop() {\n  int scalar_var = 6;\n  int arr[N];\n  int sum =0;\n  for (int i=0; i<N; i++){\n        arr[i] = i;\n        sum += arr[i];\n\t }\n#pragma omp for num_threads(OMPVV_NUM_THREADS_HOST)\n    {\t\n#pragma omp single \n\t{  \n#pragma omp taskloop default(firstprivate)\n  for (int i = 0; i < N; i++) {\n\t\tarr[i] = i + 3;\n\t\tscalar_var += 7;\n \t\t}\t\n  \t}\t\n     }\n  int new_sum =0;\n  int wrong_sum =0;\n  for (int i = 0; i < N; i++) {\n\tnew_sum += arr[i];\n\twrong_sum += i + 3;\n  \t}\n  OMPVV_TEST_AND_SET_VERBOSE(errors, scalar_var != 6);\n  OMPVV_INFOMSG_IF(scalar_var == 0, \"Scalar was not initialized in parallel region & not updated\");\n  OMPVV_INFOMSG_IF(scalar_var >  6, \"Scalar was not firstprivate, changes made in parallel affected original copy\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, sum != new_sum);\n  OMPVV_INFOMSG_IF(new_sum == 0, \"Array was not initialized in parallel region properly\");\n  OMPVV_INFOMSG_IF(new_sum == wrong_sum, \"Array was not first private, changes made in parallel affected original copy\");\n  return errors;\n}\n\nint main() {\n   errors = 0;\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_default_firstprivate_taskloop() != 0);\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_parallel_loop_bind.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_parallel_loop_bind());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 1391",
        "issue_id": 4,
        "original_code": "//===---------------test_target_parallel_loop_bind.c-----------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Description - This is a test program to demonstrate how bind(parallel)\n// clause is used with target parallel loop construct.\n//\n////===-------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define DIM_1 10\n#define DIM_2 10\n#define DIM_3 12\n\nint test_target_parallel_loop_bind() {\n  OMPVV_INFOMSG(\"test_target_parallel_loop_bind(parallel)\");\n  int arr[DIM_1][DIM_2][DIM_3];\n  int errors = 0;\n  int i, j, k;\n  int temp = 0;\n  int num_threads = -1;\n\n  // arr initialization\n  for (i = 0; i < DIM_1; i++) {\n    for (j = 0; j < DIM_2; j++) {\n      for (k = 0; k < DIM_3; k++) {\n          arr[i][j][k] = 1;\n      }\n    }\n  }\n\n#pragma omp target parallel loop bind(parallel) map(tofrom: arr) \\\n                       num_threads(OMPVV_NUM_THREADS_DEVICE) private(j,k)\n  for (i = 0; i < DIM_1; i++) {\n    for (j = 0; j < DIM_2; j++) {\n      for (k = i; k < DIM_3; k++) {\n          arr[i][j][k] += i+2*j+3*k;\n        }\n      }\n    }\n  \n  // validation\n  for (i = 0; i < DIM_1; i++) {\n    for (j = 0; j < DIM_2; j++) {\n      for (k = i; k < DIM_3; k++) {\n          temp = 1 + i + 2*j + 3*k;\n          if (arr[i][j][k] != temp)\n            errors++;\n      }\n    }\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_parallel_loop_bind());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---------------test_target_parallel_loop_bind.c-----------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Description - This is a test program to demonstrate how bind(parallel)\n// clause is used with target parallel loop construct.\n//\n////===-------------------------------------------------------------------===//\n\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define DIM_1 10\n#define DIM_2 10\n#define DIM_3 12\n\nint test_target_parallel_loop_bind() {\n  OMPVV_INFOMSG(\"test_target_parallel_loop_bind(parallel)\");\n  int arr[DIM_1][DIM_2][DIM_3];\n  int errors = 0;\n  int i, j, k;\n  int temp = 0;\n  int num_threads = -1;\n\n  // arr initialization\n  for (i = 0; i < DIM_1; i++) {\n    for (j = 0; j < DIM_2; j++) {\n      for (k = 0; k < DIM_3; k++) {\n          arr[i][j][k] = 1;\n      }\n    }\n  }\n\n#pragma omp target parallel loop bind(parallel) map(tofrom: arr) \\\n                       num_threads(OMPVV_NUM_THREADS_DEVICE) private(j,k)\n  for (i = 0; i < DIM_1; i++) {\n    for (j = 0; j < DIM_2; j++) {\n      for (k = i; k < DIM_3; k++) {\n          arr[i][j][k] += i+2*j+3*k;\n        }\n      }\n    }\n  \n  // validation\n  for (i = 0; i < DIM_1; i++) {\n    for (j = 0; j < DIM_2; j++) {\n      for (k = i; k < DIM_3; k++) {\n          temp = 1 + i + 2*j + 3*k;\n          if (arr[i][j][k] != temp)\n            errors++;\n      }\n    }\n  }\n\n  return errors;\n}\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_printf_in_target_region.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n      printf(\"The value of the integer mapped into target region is %d\\n\", integer);\n      printf(\"The value of the float mapped into target region is %f\\n\", floater);\n      printf(\"The value of the double mapped into target region is %lf\\n\", doubler);\n      printf(\"The value of the single char mapped into target region is %c\\n\", single_char);\n      printf(\"The value of the short int mapped into target region is %hd\\n\", shortie);\n      printf(\"The value of the unsigned short int mapped into target region is %hu\\n\", unsigned_shortie);\n      printf(\"The value of the long int mapped into target region is %ld\\n\", long_one);\n      printf(\"The value of the unsigned long int mapped into target region is %lu\\n\", unsigned_long);\n      printf(\"The value of the long long int mapped into target region is %lld\\n\", long_long);\n      printf(\"Values of everything mapped in target region are %d, %f, %lf, %c, %hd, %hu, %ld, %lu, %lld\\n\", integer, floater, doubler, single_char,\nshortie, unsigned_shortie, long_one, unsigned_long, long_long);\n   }\" at position 1070",
        "issue_id": 4,
        "original_code": "//===------ test_printf_in_target_region.c ----------------------------------===//\n//\n// OpenMP API Version 5.2 Nov 2021\n//\n// This test checks that printf inside of a target region is supported\n// for all common data types.\n//\n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n\nint main () {\n\n   int isOffloading = 0;\n   OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n   OMPVV_WARNING_IF(isOffloading == 0, \"Support for printf in target region cannot be evaluated since there are no available devices\");\n\n   int integer = 71;\n   float floater = 81.1000;\n   double doubler = 643.2390000;\n   char single_char = 'S';\n   short int shortie = 10000; \n   unsigned short int unsigned_shortie = 56555;\n   long int long_one = 194834345;\n   unsigned long int unsigned_long = 1777444;\n   long long int long_long = 282828293898;\n\n   #pragma omp target map(tofrom: integer, floater, doubler, single_char, shortie, unsigned_shortie, long_one, unsigned_long, long_long) \n   {\n      printf(\"The value of the integer mapped into target region is %d\\n\", integer);\n      printf(\"The value of the float mapped into target region is %f\\n\", floater);\n      printf(\"The value of the double mapped into target region is %lf\\n\", doubler);\n      printf(\"The value of the single char mapped into target region is %c\\n\", single_char);\n      printf(\"The value of the short int mapped into target region is %hd\\n\", shortie);\n      printf(\"The value of the unsigned short int mapped into target region is %hu\\n\", unsigned_shortie);\n      printf(\"The value of the long int mapped into target region is %ld\\n\", long_one);\n      printf(\"The value of the unsigned long int mapped into target region is %lu\\n\", unsigned_long);\n      printf(\"The value of the long long int mapped into target region is %lld\\n\", long_long);\n      printf(\"Values of everything mapped in target region are %d, %f, %lf, %c, %hd, %hu, %ld, %lu, %lld\\n\", integer, floater, doubler, single_char,\nshortie, unsigned_shortie, long_one, unsigned_long, long_long);\n   }\n   \n   return 0;\n}\n",
        "error_code": "//===------ test_printf_in_target_region.c ----------------------------------===//\n//\n// OpenMP API Version 5.2 Nov 2021\n//\n// This test checks that printf inside of a target region is supported\n// for all common data types.\n//\n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n\nint main () {\n\n   int isOffloading = 0;\n   OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n   OMPVV_WARNING_IF(isOffloading == 0, \"Support for printf in target region cannot be evaluated since there are no available devices\");\n\n   int integer = 71;\n   float floater = 81.1000;\n   double doubler = 643.2390000;\n   char single_char = 'S';\n   short int shortie = 10000; \n   unsigned short int unsigned_shortie = 56555;\n   long int long_one = 194834345;\n   unsigned long int unsigned_long = 1777444;\n   long long int long_long = 282828293898;\n\n   #pragma omp target map(tofrom: integer, floater, doubler, single_char, shortie, unsigned_shortie, long_one, unsigned_long, long_long) \n   \n   \n   return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_parallel_master_taskloop_simd.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1444",
        "issue_id": 1,
        "original_code": "//===--- test_parallel_master_taskloop_simd.c --------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the parallel master taskloop simd directive. The\n// test performs simple operations on an int array which are then\n// checked for correctness.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_parallel_master_taskloop_simd() {\n  OMPVV_INFOMSG(\"test_parallel_master_taskloop_simd\");\n  int errors = 0;\n  int x[N];\n  int y[N];\n  int z[N];\n  int num_threads = -1;\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 1;\n    y[i] = i + 1;\n    z[i] = 2*(i + 1);\n  }\n\n#pragma omp parallel master taskloop simd num_threads(OMPVV_NUM_THREADS_HOST) shared(x, y, z, num_threads)\n  for (int i = 0; i < N; i++) {\n    x[i] += y[i]*z[i];\n    if (i == 0) {\n       num_threads = omp_get_num_threads();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != 1 + (y[i]*z[i]));\n  }\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of parallel master with taskloop can't be guaranteed.\");\n  OMPVV_ERROR_IF(num_threads < 1, \"Test returned an invalid number of threads.\");\n  OMPVV_INFOMSG(\"This test does not guarantee vector instructions were generated for the simd construct.\");\n\n  return errors;\n}\n\n\nint main() {\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_parallel_master_taskloop_simd());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_parallel_master_taskloop_simd.c --------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the parallel master taskloop simd directive. The\n// test performs simple operations on an int array which are then\n// checked for correctness.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_parallel_master_taskloop_simd() {\n  OMPVV_INFOMSG(\"test_parallel_master_taskloop_simd\");\n  int errors = 0;\n  int x[N];\n  int y[N];\n  int z[N];\n  int num_threads = -1;\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 1;\n    y[i] = i + 1;\n    z[i] = 2*(i + 1);\n  }\n\n#pragma omp parallel master taskloop simd num_threads(OMPVV_NUM_THREADS_HOST) shared(x, y, z, num_threads)\n  for (int i = 0; i < N; i++) {\n    x[i] += y[i]*z[i];\n    if (i == 0) {\n       num_threads = omp_get_num_threads();\n    }\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != 1 + (y[i]*z[i]));\n  }\n\n  OMPVV_WARNING_IF(num_threads == 1, \"Test ran with one thread, so parallelism of parallel master with taskloop can't be guaranteed.\");\n  OMPVV_ERROR_IF(num_threads < 1, \"Test returned an invalid number of threads.\");\n  OMPVV_INFOMSG(\"This test does not guarantee vector instructions were generated for the simd construct.\");\n\n  return errors;\n}\n\n\nint main() \n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_parallel_master_taskloop_simd());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_enter_exit_data_devices.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===--- test_target_enter_exit_data_devices.c---------------------------------------===//\n//\n//  OpenMP API Version 4.5 Nov 2015\n//\n//  This test checks for data mapping on multiple devices when using the target\n//  data map directive. The test uses omp_get_num_devices to confirm the number \n//  of total devices available. There are two separate functions, and both make sure \n//  that data mapping is happening on each available device. The first function does \n//  this through the use of omp_set_default_device, while the second function explicity \n//  uses the device() clause to control which device is being utilized.\n//\n//  Since OpenMP 4.5 does not have an API call to obtain the current device, \n//  this test does not guarantee that the execution devices are different. \n//\n////===------------------------------------------------------------------------------===/\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nint test_set_default_dev() {\n\n  OMPVV_INFOMSG(\"test_set_default_dev\");\n\n  // Get number of devices\n  int num_dev = omp_get_num_devices();\n  OMPVV_INFOMSG(\"num_devices: %d\", num_dev);\n\n  int def_dev = omp_get_default_device();\n  OMPVV_INFOMSG(\"initial device: %d\", omp_get_initial_device());\n  OMPVV_INFOMSG(\"default device: %d\", def_dev);\n\n  // Allocate num_devices + 1 to avoid zero-sized VLA if num_devices == 0\n  int sum[num_dev+1], errors = 0;\n  int h_matrix[num_dev+1][N];\n\n  for (int dev = 0; dev < num_dev; ++dev) {\n    omp_set_default_device(dev);\n\n#pragma omp target enter data map(alloc: h_matrix[dev][0 : N])\n    \n#pragma omp target map(alloc: h_matrix[dev][0 : N]) // map(alloc: ) to avoid target to map the entire matrix h_matrix[dev][:]\n    {\n      for (int i = 0; i < N; ++i)\n        h_matrix[dev][i] = dev;\n    }\n    // unstructured exit\n\n#pragma omp target exit data map(from: h_matrix[dev][0 : N])\n  }\n\n  // checking results\n  errors = 0;\n  for (int dev = 0; dev < num_dev; ++dev) {\n    sum[dev] = h_matrix[dev][0];\n    for (int i = 1; i < N; ++i)\n      sum[dev] += h_matrix[dev][i];\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (dev * N != sum[dev]));\n  }\n\n  omp_set_default_device(def_dev);\n\n  return errors;\n}\n\nint test_device() {\n\n  OMPVV_INFOMSG(\"test_device\");\n\n  // Get number of devices\n  int num_dev = omp_get_num_devices();\n  OMPVV_INFOMSG(\"num_devices: %d\", num_dev);\n\n  OMPVV_INFOMSG(\"initial device: %d\", omp_get_initial_device());\n  OMPVV_INFOMSG(\"default device: %d\", omp_get_default_device());\n\n  // Allocate num_devices + 1 to avoid zero-sized VLA if num_devices == 0\n  int sum[num_dev+1], errors = 0;\n  int h_matrix[num_dev+1][N];\n\n  for (int dev = 0; dev < num_dev; ++dev) {\n\n#pragma omp target enter data map(alloc: h_matrix[dev][0 : N]) device(dev) \n\n#pragma omp target map(alloc: h_matrix[dev][0 : N]) device(dev)\n    {\n      for (int i = 0; i < N; ++i)\n        h_matrix[dev][i] = dev;\n    }\n\n#pragma omp target exit data map(from: h_matrix[dev][0 : N]) device(dev)\n  \n}\n\n  // checking results\n  errors = 0;\n  for (int dev = 0; dev < num_dev; ++dev) {\n    sum[dev] = h_matrix[dev][0];\n    for (int i = 1; i < N; ++i)\n      sum[dev] += h_matrix[dev][i];\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (dev * N != sum[dev]));\n  }\n\n  return errors;\n}\n\nint main() {\n\n  int errors = 0;\n  \n  //Test for offloading\n  int is_offloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(is_offloading);\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_set_default_dev());\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_device());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nbyte alyvyxfecc = 41;\nshort rklishpjsx = 17;\nlong rgegtbrzsg = 77;\nfloat awztxzybkq = 228;\nfloat irzzwrhfok = 203;\nbyte qjbfzwiqzz = 104;\nlong sfiueaxawd = 89;\nshort tzhcvgfthu = 186;\nfloat ilqarxnzas = 158;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_simd_order_concurrent.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{ \n   int errors = 0;\n\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_simd_order_concurrent());\n   OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 1123",
        "issue_id": 4,
        "original_code": "//===--- test_target_simd_order_concurrent.c -----------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks for support of the order(concurrent) clause on a target simd construct.\n// When an order(concurrent) clause is present on a simd construct, all of the same \n// restrictions from having a loop construct with an order(concurrent) are also applied.\n//\n////===-------------------------------------------------------------------------------------===//\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <omp.h> \n#include \"ompvv.h\" \n\n#define N 1024\n\nint test_simd_order_concurrent () {\n   int errors = 0;\n   int i;\n   int b[N], c[N];\n\n   struct new_struct {\n      int a[N];\n   };\n\n   struct new_struct struct_t;\n   \n   for (i = 0; i < N; i++ ) {\n      struct_t.a[i] = i;\n      b[i] = i + 5;\n      c[i] = 0;\n   }\n\n   #pragma omp target simd order(concurrent)\n      for (i = 0; i < N; i++) {\n         c[i] = struct_t.a[i] * b[i];\n      }\n\n   for (i = 0; i < N; i++) {\n      OMPVV_TEST_AND_SET(errors, c[i] != (struct_t.a[i] * b[i]));\n   }\n\n   return errors;\n}\n\n\nint main () { \n   int errors = 0;\n\n   OMPVV_TEST_OFFLOADING;\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_simd_order_concurrent());\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_simd_order_concurrent.c -----------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks for support of the order(concurrent) clause on a target simd construct.\n// When an order(concurrent) clause is present on a simd construct, all of the same \n// restrictions from having a loop construct with an order(concurrent) are also applied.\n//\n////===-------------------------------------------------------------------------------------===//\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <omp.h> \n#include \"ompvv.h\" \n\n#define N 1024\n\nint test_simd_order_concurrent () {\n   int errors = 0;\n   int i;\n   int b[N], c[N];\n\n   struct new_struct {\n      int a[N];\n   };\n\n   struct new_struct struct_t;\n   \n   for (i = 0; i < N; i++ ) {\n      struct_t.a[i] = i;\n      b[i] = i + 5;\n      c[i] = 0;\n   }\n\n   #pragma omp target simd order(concurrent)\n      for (i = 0; i < N; i++) {\n         c[i] = struct_t.a[i] * b[i];\n      }\n\n   for (i = 0; i < N; i++) {\n      OMPVV_TEST_AND_SET(errors, c[i] != (struct_t.a[i] * b[i]));\n   }\n\n   return errors;\n}\n\n\nint main () \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_atomic_fail_relaxed.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp parallel\" with directive \"#pragma omp target\" at position 604",
        "issue_id": 0,
        "original_code": "//===--- test_atomic_fail_relaxed.c -----------------------------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// Utilizes an compare w/ an atomic release to ensure the implicit\n// setting of x=10. Restrictions on atomic fail state they must be used\n// on an atomic compare.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_atomic_fail_relaxed() {\n  OMPVV_INFOMSG(\"test_atomic_fail_relaxed\");\n\n  int x = 0, y = 0;\n  int errors = 0;\n\n#pragma omp parallel num_threads(2)\n   {\n      int thrd = omp_get_thread_num();\n       if (thrd == 0) {\n          y = 1;\n          #pragma omp atomic write seq_cst\n          x = 10;\n       } else {\n          while (y != 5) {\n            #pragma omp atomic compare fail(relaxed)\n            if(y == 1){\n               y = 5;\n            }\n          }\n          OMPVV_TEST_AND_SET(errors, x != 10);\n          OMPVV_TEST_AND_SET(errors, y != 5);\n       }\n   }\n   return errors;\n}\n\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_atomic_fail_relaxed());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_atomic_fail_relaxed.c -----------------------------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// Utilizes an compare w/ an atomic release to ensure the implicit\n// setting of x=10. Restrictions on atomic fail state they must be used\n// on an atomic compare.\n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_atomic_fail_relaxed() {\n  OMPVV_INFOMSG(\"test_atomic_fail_relaxed\");\n\n  int x = 0, y = 0;\n  int errors = 0;\n\n#pragma omp target num_threads(2)\n   {\n      int thrd = omp_get_thread_num();\n       if (thrd == 0) {\n          y = 1;\n          #pragma omp atomic write seq_cst\n          x = 10;\n       } else {\n          while (y != 5) {\n            #pragma omp atomic compare fail(relaxed)\n            if(y == 1){\n               y = 5;\n            }\n          }\n          OMPVV_TEST_AND_SET(errors, x != 10);\n          OMPVV_TEST_AND_SET(errors, y != 5);\n       }\n   }\n   return errors;\n}\n\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_atomic_fail_relaxed());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_omp_in_explicit_task.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 980",
        "issue_id": 2,
        "original_code": "//===---- test_omp_in_explicit_task.c ----------------------------------------------===//\n// \n// OpenMP API Version 5.2 Nov 2021\n//\n// Uses omp_in_explicit_task() runtime call to ensure it is 1 when in an explicit\n// task and 0 otherwise.\n// \n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include \"ompvv.h\"\n#include <stdbool.h>\n\n#define N 256\n\nint errors;\n\nint test_wrapper() { \n    errors = 0;\n    int A[N];\n    for(int i = 0; i < N; i++){\n        A[i] = 0;\n    }\n    #pragma omp task shared(A)// creates EXPLICIT task, omp_in_explicit_task = 1\n    {\n        for(int i = 0; i < N; i++){\n            A[i] = omp_in_explicit_task();\n        }\n    }\n    for(int i = 0; i < N; i++){\n        OMPVV_TEST_AND_SET(errors, A[i] == 0);\n    }\n    OMPVV_ERROR_IF(A[rand()%N] == 0, \"omp_in_explicit_task() did not return correct value when called inside an explicit task\");\n    \n    for(int i = 0; i < N; i++){\n        A[i] = 1;\n        #pragma omp parallel for // creates IMPLICIT tasks, omp_in_explicit_task = 0\n        for(int i = 0; i < N; i++){\n            A[i] = omp_in_explicit_task();\n        }\n    }\n    OMPVV_ERROR_IF(A[rand()%N] != 0, \"omp_in_explicit_task() did not return correct value when called inside an implicit task\");\n    \n    for(int i = 0; i < N; i++){\n        OMPVV_TEST_AND_SET(errors, A[i] != 0);\n    }\n    return errors;\n}\n\nint main () {\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_wrapper());\n   OMPVV_REPORT_AND_RETURN(errors);\n}  \n",
        "error_code": "//===---- test_omp_in_explicit_task.c ----------------------------------------------===//\n// \n// OpenMP API Version 5.2 Nov 2021\n//\n// Uses omp_in_explicit_task() runtime call to ensure it is 1 when in an explicit\n// task and 0 otherwise.\n// \n//===-------------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include \"ompvv.h\"\n#include <stdbool.h>\n\n#define N 256\n\nint errors;\n\nint test_wrapper() { \n    errors = 0;\n    int A[N];\n    for(int i = 0; i < N; i++){\n        A[i] = 0;\n    }\n    #pragma omp task shared(A)// creates EXPLICIT task, omp_in_explicit_task = 1\n    {\n        for(int i = 0; i < N; i++){\n            A[i] = omp_in_explicit_task();\n        }\n    }\n    for(int i = 0; i < N; i++){\n        OMPVV_TEST_AND_SET(errors, A[i] == 0);\n    }\n    OMPVV_ERROR_IF(A[rand()%N] == 0, \"omp_in_explicit_task() did not return correct value when called inside an explicit task\");yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n    \n    for(int i = 0; i < N; i++){\n        A[i] = 1;\n        #pragma omp parallel for // creates IMPLICIT tasks, omp_in_explicit_task = 0\n        for(int i = 0; i < N; i++){\n            A[i] = omp_in_explicit_task();\n        }\n    }\n    OMPVV_ERROR_IF(A[rand()%N] != 0, \"omp_in_explicit_task() did not return correct value when called inside an implicit task\");\n    \n    for(int i = 0; i < N; i++){\n        OMPVV_TEST_AND_SET(errors, A[i] != 0);\n    }\n    return errors;\n}\n\nint main () {\n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_wrapper());\n   OMPVV_REPORT_AND_RETURN(errors);\n}  \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_map_global_arrays.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1133",
        "issue_id": 1,
        "original_code": "//===--- test_target_map_global_arrays.c ------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// This test will check if an array that is declared and initialized in the host, \n// can be copied over the device, updated there, and then copied back. If this  \n// test runs on the host, we will warn that array is not allocated on any device.\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define N 10000\n\n//define compute_array globally\nint compute_array[N];\n\nint main() {\n  int sum = 0, errors = 0, result = 0;\n  int i;\n \n  // Host initialization of the array \n  for (i = 0; i < N; i++) \n    compute_array[i] = 0;\n\n  int isOffloading;\n  \n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading); \n  \n  OMPVV_WARNING_IF(!isOffloading, \"This test is running on host, array is not allocated on device\");\n\n#pragma omp target map(tofrom: compute_array[0:N])\n  {\n\t\n  // Updating the compute_array\n  for (i = 0; i < N; i++)\n      compute_array[i] = i;\n   \n  } // end target\n\n  // Comparing the results\n  for (i = 0; i < N; i++){\n    sum = sum + compute_array[i];    \n    result += i;\n  }  \n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != sum);\n\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n}\n\n",
        "error_code": "//===--- test_target_map_global_arrays.c ------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// This test will check if an array that is declared and initialized in the host, \n// can be copied over the device, updated there, and then copied back. If this  \n// test runs on the host, we will warn that array is not allocated on any device.\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include \"ompvv.h\"\n\n#define N 10000\n\n//define compute_array globally\nint compute_array[N];\n\nint main() {\n  int sum = 0, errors = 0, result = 0;\n  int i;\n \n  // Host initialization of the array \n  for (i = 0; i < N; i++) \n    compute_array[i] = 0;\n\n  int isOffloading;\n  \n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading); \n  \n  OMPVV_WARNING_IF(!isOffloading, \"This test is running on host, array is not allocated on device\");\n\n#pragma omp target map(tofrom: compute_array[0:N])\n  {\n\t\n  // Updating the compute_array\n  for (i = 0; i < N; i++)\n      compute_array[i] = i;\n   \n  } // end target\n\n  // Comparing the results\n  for (i = 0; i < N; i++)\n    sum = sum + compute_array[i];    \n    result += i;\n  }  \n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, result != sum);\n\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_enter_exit_data_classes_simple.cpp",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp parallel\" at position 1469",
        "issue_id": 0,
        "original_code": "//===--test_targe_enter_exit_data_classes_simple.c - test a simple class ----===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// This test uses target enter data and exit data to map a whole class in the \n// constructor and destructor. It requires the use of helper_ variables since it\n// is not legal to use the \"this\" pointer (implicitely or explicitely) in 4.5. \n//\n// We use a modify method to assign values to the array and we use a method to \n// obtain a copy of the values from the device. The disctintion between methods \n// allows to show that data is mapped and remains mapped in the device memory. \n// This test does not use any inheritance or anything similar, therefore \n// the simple connotation\n//\n// Contrary to the test of target_enter_data, this test checks if during the exit\n// data it successfully copies back the attributes of the object\n//\n////===----------------------------------------------------------------------===//\n\n#include <iostream>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nclass Simple {\n  private:\n    int *h_array;\n    int size;\n    int sum;\n    int *errors; \n\n  public:\n    Simple(int s, int *err) : size(s) { \n      sum = 0;\n      h_array = new int[size];\n\n      // Initialize the array in the host\n      for (int i = 0; i < size; i ++)\n        h_array[i] = i;\n\n      // To obtain the error counter variable that is external\n      errors = err;\n      int * helper_harray = this->h_array;\n      Simple * mySelf = this;\n#pragma omp target enter data map(to: mySelf[0:1])\n#pragma omp target enter data map(to: helper_harray[0:size])\n    }\n\n    ~Simple() { \n      // Modify again to see if changes are copied over\n      int *helper_harray = this->h_array;\n      Simple * mySelf = this;\n#pragma omp target exit data map(from: helper_harray[0:size])\n\n      // checking results that are coming back from the target exit data\n      for (int i = 0; i < N; ++i) {\n        OMPVV_TEST_AND_SET_VERBOSE(*errors, h_array[i] != 3*i);\n      }\n\n#pragma omp target exit data map(from: mySelf[0:1])\n      OMPVV_TEST_AND_SET_VERBOSE(*errors, sum != 3*N*(N-1)/2);\n      delete[] h_array; \n    }\n\n    void modify() {\n      int * helper_harray = this->h_array;\n      int &helper_sum = this->sum;\n      int &helper_size = this->size;\n#pragma omp target defaultmap(tofrom:scalar)\n      {\n        helper_sum = 0;\n        for (int i = 0; i < helper_size; ++i) {\n          helper_harray[i] += i;\n          helper_sum += helper_harray[i];\n        }\n      }\n    }\n\n    void getDeviceAttributes(int * array_copy, int & sum_copy) {\n      int * helper_harray = this->h_array;\n      int &helper_sum = this->sum;\n      int &helper_size = this->size;\n#pragma omp target map(from:array_copy[0:N], sum_copy) defaultmap(tofrom:scalar)\n      {\n        for (int i = 0; i < helper_size; ++i) {\n          array_copy[i] = helper_harray[i];\n        }\n        sum_copy = helper_sum;\n      }\n    }\n};\n\nint test_simple_class() {\n\n  OMPVV_INFOMSG(\"Testing simple class mapping\");\n\n  int sum = 0, errors = 0, h_sum = 0;\n  int* h_array = new int[N];\n\n  // allocation on the device\n  Simple *obj = new Simple(N, &errors);\n\n  obj->modify();\n\n  obj->getDeviceAttributes(h_array, h_sum);\n  \n  // checking results\n  for (int i = 0; i < N; ++i) {\n    sum += h_array[i];\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, N*(N-1) != sum);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, N*(N-1) != h_sum);\n\n  obj->modify();\n  delete obj;\n  delete[] h_array;\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET(errors, test_simple_class());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--test_targe_enter_exit_data_classes_simple.c - test a simple class ----===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// This test uses target enter data and exit data to map a whole class in the \n// constructor and destructor. It requires the use of helper_ variables since it\n// is not legal to use the \"this\" pointer (implicitely or explicitely) in 4.5. \n//\n// We use a modify method to assign values to the array and we use a method to \n// obtain a copy of the values from the device. The disctintion between methods \n// allows to show that data is mapped and remains mapped in the device memory. \n// This test does not use any inheritance or anything similar, therefore \n// the simple connotation\n//\n// Contrary to the test of target_enter_data, this test checks if during the exit\n// data it successfully copies back the attributes of the object\n//\n////===----------------------------------------------------------------------===//\n\n#include <iostream>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\nclass Simple {\n  private:\n    int *h_array;\n    int size;\n    int sum;\n    int *errors; \n\n  public:\n    Simple(int s, int *err) : size(s) { \n      sum = 0;\n      h_array = new int[size];\n\n      // Initialize the array in the host\n      for (int i = 0; i < size; i ++)\n        h_array[i] = i;\n\n      // To obtain the error counter variable that is external\n      errors = err;\n      int * helper_harray = this->h_array;\n      Simple * mySelf = this;\n#pragma omp parallel enter data map(to: mySelf[0:1])\n#pragma omp target enter data map(to: helper_harray[0:size])\n    }\n\n    ~Simple() { \n      // Modify again to see if changes are copied over\n      int *helper_harray = this->h_array;\n      Simple * mySelf = this;\n#pragma omp target exit data map(from: helper_harray[0:size])\n\n      // checking results that are coming back from the target exit data\n      for (int i = 0; i < N; ++i) {\n        OMPVV_TEST_AND_SET_VERBOSE(*errors, h_array[i] != 3*i);\n      }\n\n#pragma omp target exit data map(from: mySelf[0:1])\n      OMPVV_TEST_AND_SET_VERBOSE(*errors, sum != 3*N*(N-1)/2);\n      delete[] h_array; \n    }\n\n    void modify() {\n      int * helper_harray = this->h_array;\n      int &helper_sum = this->sum;\n      int &helper_size = this->size;\n#pragma omp target defaultmap(tofrom:scalar)\n      {\n        helper_sum = 0;\n        for (int i = 0; i < helper_size; ++i) {\n          helper_harray[i] += i;\n          helper_sum += helper_harray[i];\n        }\n      }\n    }\n\n    void getDeviceAttributes(int * array_copy, int & sum_copy) {\n      int * helper_harray = this->h_array;\n      int &helper_sum = this->sum;\n      int &helper_size = this->size;\n#pragma omp target map(from:array_copy[0:N], sum_copy) defaultmap(tofrom:scalar)\n      {\n        for (int i = 0; i < helper_size; ++i) {\n          array_copy[i] = helper_harray[i];\n        }\n        sum_copy = helper_sum;\n      }\n    }\n};\n\nint test_simple_class() {\n\n  OMPVV_INFOMSG(\"Testing simple class mapping\");\n\n  int sum = 0, errors = 0, h_sum = 0;\n  int* h_array = new int[N];\n\n  // allocation on the device\n  Simple *obj = new Simple(N, &errors);\n\n  obj->modify();\n\n  obj->getDeviceAttributes(h_array, h_sum);\n  \n  // checking results\n  for (int i = 0; i < N; ++i) {\n    sum += h_array[i];\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, N*(N-1) != sum);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, N*(N-1) != h_sum);\n\n  obj->modify();\n  delete obj;\n  delete[] h_array;\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET(errors, test_simple_class());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_parallel_for_thread_limit.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===---- tests_target_teams_distribute_parallel_for_thread_limit.c ---------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// Test to check the thread_limit clause. This clause changes the upper limit of \n// the number of threads inside each of the contention groups created in the teams\n// region. This upper limit is different to the num_threads \n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include \"ompvv.h\"\n#include <stdio.h>\n\n#define N 1024\n\nint test_target_teams_distribute_parallel_for_thread_limit() {\n  OMPVV_INFOMSG(\"test_target_teams_distribute_parallel_for_threads_limit\");\n\n  int tested_num_threads[] = {1, 10, 100, 10000};\n  int tested_thread_limit[] = {1, 10, 100, 10000};\n  int num_threads[N];\n  int thread_limit[N];\n  int errors = 0;\n  int i, nt, tl;\n\n  // Trying multiple num_threads and thread_limits\n  // values from 1 to a large number. The number of threads\n  // should never be larger than the thread limit\n  for (nt = 0; nt < 4; nt++) {\n    for (tl = 0; tl < 4; tl++) {\n      OMPVV_INFOMSG(\"Testing thread_limit(%d) num_threads(%d) clauses\", tested_thread_limit[tl], tested_num_threads[nt]);\n      // Initializing the num_threads and thread_limit array\n      for (i = 0; i < N; i++) {\n        num_threads[i] = -1;\n        thread_limit[i] = -1;\n      }\n\n#pragma omp target teams distribute parallel for map(tofrom: num_threads) \\\n        num_threads(tested_num_threads[nt]) thread_limit(tested_thread_limit[tl])\n      for (i = 0; i < N; i++) {\n        num_threads[i] = omp_get_num_threads();\n        thread_limit[i] = omp_get_thread_limit();\n      }\n   \n      int prevThreadLimit = -1;\n      for (i = 0; i < N; i++) {\n        OMPVV_INFOMSG_IF(prevThreadLimit != thread_limit[i], \"  reported thread limit = %d\", thread_limit[i]);\n        prevThreadLimit = thread_limit[i];\n  \n        // If the thread limit is not the one specified or the actual number \n        // of threads is greater than the thread limit, then it is an error\n        OMPVV_TEST_AND_SET_VERBOSE(errors, (thread_limit[i] > tested_thread_limit[tl]) || (thread_limit[i] <= 0));\n        OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads[i] > tested_thread_limit[tl]);\n        // For completeness, if the actual number of threads is grater than the \n        // selected number of threads, then it is an error\n        OMPVV_TEST_AND_SET_VERBOSE(errors, num_threads[i] > tested_num_threads[nt]);\n      }\n    }\n  }\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_teams_distribute_parallel_for_thread_limit());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nshort pfeaioiulq = 160;\nshort kghrzbwoii = 218;\nshort xtrxdxnnbz = 221;\nfloat ywlhxultxa = 142;\ndouble pzoevtijde = 124;\nint xhgdcvsukl = 254;\nshort jgevpwbuqs = 26;\nbyte yjwudscidn = 99;\nint rmzbvfwylq = 90;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_depend_out_omp_all_memory.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 1077",
        "issue_id": 2,
        "original_code": "//===------------ test_target_depend_out_omp_all_memory.c --------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// This test checks that the special omp_all_memory locator keyword works\n// as intended. The test checks this by having two variables passed into the \n// target parallel region, depending on both values. If both variables are\n// properly passed through the sections then it passes. If not, the test fails.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main() {\n\tint errors = 0;\n\tint x[N];\n  \tint y = 5;\n\n\tfor (int i = 0; i < N; i++) {\n\t\tx[i] = i;\n\t}\n\n\tOMPVV_TEST_OFFLOADING;\n\n\t#pragma omp target map(tofrom: errors) map(to: x, y)\n\t{\n\t    #pragma omp parallel\n\t    #pragma omp single\n\t    {\n\t      #pragma omp task shared(x, y) depend(out: omp_all_memory)\n\t      {\n\t\tfor(int i = 0; i < N; i++) {\n\t\t  x[i] += y;   \n\t\t}\n\t      }\n\t      #pragma omp task shared(x, y, errors) depend(in: x, y)\n\t      {\n\t\tfor (int i = 0; i < N; i++) {\n\t\t  OMPVV_TEST_AND_SET(errors, x[i] != i + y);\n\t\t}\n\t      }\n\t      #pragma omp taskwait\n\t    }\n\t}\n\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===------------ test_target_depend_out_omp_all_memory.c --------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// This test checks that the special omp_all_memory locator keyword works\n// as intended. The test checks this by having two variables passed into the \n// target parallel region, depending on both values. If both variables are\n// properly passed through the sections then it passes. If not, the test fails.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main() {\n\tint errors = 0;\n\tint x[N];\n  \tint y = 5;\n\n\tfor (int i = 0; i < N; i++) {\n\t\tx[i] = i;\n\t}\n\n\tOMPVV_TEST_OFFLOADING;\n\n\t#pragma omp target map(tofrom: errors) map(to: x, y)\n\t{\n\t    #pragma omp parallel\n\t    #pragma omp single\n\t    {\n\t      #pragma omp task shared(x, y) depend(out: omp_all_memory)\n\t      {\n\t\tfor(int i = 0; i < N; i++) {\n\t\t  x[i] += y;   \n\t\t}\n\t      }\n\t      #pragma omp task shared(x, y, errors) depend(in: x, y)\n\t      {\n\t\tfor (int i = 0;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1; i < N; i++) {\n\t\t  OMPVV_TEST_AND_SET(errors, x[i] != i + y);\n\t\t}\n\t      }\n\t      #pragma omp taskwait\n\t    }\n\t}\n\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_parallel_loop_private.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n        OMPVV_TEST_AND_SET_VERBOSE(errors, b[x] != (1 + x)*5*x);\n    }\" at position 1103",
        "issue_id": 4,
        "original_code": "//===-------------------test_target_parallel_loop_private.c-------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Description - This is a test program to demonstrate how private clause is\n// used with target parallel loop construct.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define SIZE 1024\n\nint main() {\n    OMPVV_TEST_OFFLOADING;\n    int a[SIZE];\n    int b[SIZE];\n    int priv_val = 12345;\n    int errors = 0;\n    int num_threads = -1;\n\n  // Initialization\n    for (int x = 0; x < SIZE; ++x) {\n        a[x] = 5*x;\n        b[x] = 0;\n    }\n\n    #pragma omp target parallel loop private(priv_val) \\\n                       num_threads(OMPVV_NUM_THREADS_DEVICE)\n        for (int x = 0; x < SIZE; ++x) {\n            priv_val = 0;\n            for (int y = 0; y < x+1; ++y) {\n                       priv_val++;\n            }\n\n                b[x] = a[x] * priv_val;\n        }\n\n    OMPVV_TEST_AND_SET_VERBOSE(errors, priv_val != 12345);\n\n    for (int x = 0; x < SIZE; ++x) {\n        OMPVV_TEST_AND_SET_VERBOSE(errors, b[x] != (1 + x)*5*x);\n    }\n\n    OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===-------------------test_target_parallel_loop_private.c-------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Description - This is a test program to demonstrate how private clause is\n// used with target parallel loop construct.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define SIZE 1024\n\nint main() {\n    OMPVV_TEST_OFFLOADING;\n    int a[SIZE];\n    int b[SIZE];\n    int priv_val = 12345;\n    int errors = 0;\n    int num_threads = -1;\n\n  // Initialization\n    for (int x = 0; x < SIZE; ++x) {\n        a[x] = 5*x;\n        b[x] = 0;\n    }\n\n    #pragma omp target parallel loop private(priv_val) \\\n                       num_threads(OMPVV_NUM_THREADS_DEVICE)\n        for (int x = 0; x < SIZE; ++x) {\n            priv_val = 0;\n            for (int y = 0; y < x+1; ++y) {\n                       priv_val++;\n            }\n\n                b[x] = a[x] * priv_val;\n        }\n\n    OMPVV_TEST_AND_SET_VERBOSE(errors, priv_val != 12345);\n\n    for (int x = 0; x < SIZE; ++x) \n\n    OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_taskloop_final.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//--------------------------------------------- test_taskloop_final.c ----------------------------------------//\n//\n// OpenMP API Version 4.5 August 2015\n//\n// This test checks the taskloop directive with the 'final' clause specified.\n// The 'taskloop' construct parallelizes loops with independent iterations by creating tasks. \n// It allows for efficient parallel execution of loop iterations by distributing them among multiple threads. \n// The 'final clause is used to ensure that group of tasks in taskloop are run by same thread 'if' the \n// 'final' (expression) is TRUE, else different threads could execute the tasks.      \n//----------------------------------------------------------------------------------------------------------//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define NUM_TASKS 6\n#define NUM_THREADS 10\n\n#define M 100\n\n//The 2nd dimension of this array (i.e., 3) is dependent on the number of task constructs in the taskloop construct.\nint thread_ids[NUM_TASKS][3]; \n\n\n//if all thread ids are same, val=1 else val=0\nint thread_ids_are_same_in_task() {\n\n \tint val = -1; \n \tfor(int i = 0; i < NUM_TASKS; i++) \n\t{\n\t \tint first = thread_ids[i][0];\n\n\t \tfor(int j = 1; j < 3; j++) \n\t \t{\n\t        \tif(first != thread_ids[i][j]) {\n\t\t  \t\tval = 0;  //if all the thread ids are not same per task\n\t\t  \t\tbreak; \n\t\t\t}\n\t\t\telse if(first == thread_ids[i][j]) {\n\t\t    \t\tval = 1; //if all the thread ids are same per task\n\t\t\t}\n   \t\t}\n\t \n\t\tif(val == 0)\n\t       \t\tbreak;\t\n   \t}\n\n\treturn val;\n}\n\nint test_taskloop_final(int THRESHOLD) {\n  \n  int errors = 0; \n  \n  #pragma omp parallel num_threads(NUM_THREADS)\n  {\n  \t#pragma omp single\n    \t{\t\n        \t#pragma omp taskloop final(M == THRESHOLD)\n      \t\tfor (int i = 0; i < NUM_TASKS; i++) {\n\t\t\t#pragma omp task \n\t\t\t{\n\t \t\t\tthread_ids[i][0] = omp_get_thread_num();\n\t\t\t}\n\t\t\t#pragma omp task \n\t\t\t{\n\t \t\t\tthread_ids[i][1] = omp_get_thread_num();\n\t\t\t}\n\n\t\t\t#pragma omp task \n\t\t\t{\n\t \t\t\tthread_ids[i][2] = omp_get_thread_num();\n\t\t\t}\n\n      \t\t} \n   \t}\n  }\n\n int val = thread_ids_are_same_in_task();\n \n  if (M == THRESHOLD) {\n    if (val != 1) {\n      errors++; \n    }\n  } else if (M != THRESHOLD) {\n    if (val == 1) {\n        OMPVV_WARNING(\"Same thread has executed all the tasks generated by the taskloop\");\n    } else if(val == 0) {\n        OMPVV_INFOMSG(\"Multiple threads have executed the tasks generated by the taskloop\");\n    }\n  }\n\n  return errors;            \n\n}\n\nint main() {\n \n   int errors = 0;\n   \n   int THRESHOLD = 100; //Equal to M\n   OMPVV_TEST_AND_SET_VERBOSE(errors, (test_taskloop_final(THRESHOLD) != 0));\n\n   THRESHOLD = 110; // Not equal to M\n   OMPVV_TEST_AND_SET_VERBOSE(errors, (test_taskloop_final(THRESHOLD) != 0));\n\n   OMPVV_REPORT_AND_RETURN(errors);\n\n   return 0;\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\ndouble vwfihfvcrl = 100;\ndouble tucfjlzldi = 252;\ndouble wzmvxhnnfw = 104;\nshort fvzbtznquf = 153;\ndouble hagurihflo = 47;\nshort gmwoqniptk = 158;\nfloat vmtgsgxgnp = 168;\nint ffqfpxaeaq = 91;\nint lptzispzsd = 234;\nint abldengtgp = 51;\nshort oimdyxrart = 128;\ndouble uecbbipqeq = 20;\nbyte bbbjfyrxcn = 140;\nbyte vwtleihtnl = 182;\nshort dpaieoryiy = 181;\nint qnuscewbgk = 221;\nshort lqpylhydrf = 19;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/declare_target_base_and_derived_class.cpp",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp declare\" with directive \"#pragma omp flush\" at position 557",
        "issue_id": 0,
        "original_code": "//===--- declare_target_base_and_dervied_class.cpp --------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// This test was suggested by members of NERSC. This test defines a declare\n// target region which includes a base and derived class and uses an \n// 'abstract' device pointer.\n//\n// Test suggestion comes from Chris Daily and Rahulkumar Gayatri from NERSC\n////===----------------------------------------------------------------------===//\n\n\n#include <new>\n#include <vector>\n#include <iostream>\n#include \"ompvv.h\"\n#include <omp.h>\n\n\n#pragma omp declare target\nclass Surface {\npublic:\n  virtual double sag(double x, double y) = 0;\n};\n\n\nclass S1 : public Surface {\npublic:\n  S1() : _devPtr(nullptr) {}\n  virtual double sag(double x, double y) override {\n    return x + y;\n  }\n  S1* cloneToDevice() {\n    S1* ptr;\n#pragma omp target map(ptr)\n    {\n      ptr = new S1();\n    }\n    _devPtr = ptr;\n    return ptr;\n  }\n\nprivate:\n  S1* _devPtr;\n};\n#pragma omp end declare target\n\n\nint main() {\n  int errors = 0;\n\n  OMPVV_TEST_OFFLOADING;\n\n  S1 s;\n  Surface* devPtr = s.cloneToDevice();  // abstract device ptr\n\n  std::vector<double> in(10, 0.0);\n  for(int i=0; i<10; i++) {\n    in[i] = i;\n  }\n\n  std::vector<double> out(10, 0.0);\n\n  double* inptr = in.data();\n  double* outptr = out.data();\n\n#pragma omp target teams distribute parallel for map(inptr[:10], outptr[:10]) is_device_ptr(devPtr)\n  for(int i=0; i<10; i++) {\n    outptr[i] = devPtr->sag(inptr[i], inptr[i]);\n  }\n\n  for(int i=0; i<10; i++) {\n    OMPVV_TEST_AND_SET(errors, out[i] != i * 2);\n  }\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- declare_target_base_and_dervied_class.cpp --------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// This test was suggested by members of NERSC. This test defines a declare\n// target region which includes a base and derived class and uses an \n// 'abstract' device pointer.\n//\n// Test suggestion comes from Chris Daily and Rahulkumar Gayatri from NERSC\n////===----------------------------------------------------------------------===//\n\n\n#include <new>\n#include <vector>\n#include <iostream>\n#include \"ompvv.h\"\n#include <omp.h>\n\n\n#pragma omp flush target\nclass Surface {\npublic:\n  virtual double sag(double x, double y) = 0;\n};\n\n\nclass S1 : public Surface {\npublic:\n  S1() : _devPtr(nullptr) {}\n  virtual double sag(double x, double y) override {\n    return x + y;\n  }\n  S1* cloneToDevice() {\n    S1* ptr;\n#pragma omp target map(ptr)\n    {\n      ptr = new S1();\n    }\n    _devPtr = ptr;\n    return ptr;\n  }\n\nprivate:\n  S1* _devPtr;\n};\n#pragma omp end declare target\n\n\nint main() {\n  int errors = 0;\n\n  OMPVV_TEST_OFFLOADING;\n\n  S1 s;\n  Surface* devPtr = s.cloneToDevice();  // abstract device ptr\n\n  std::vector<double> in(10, 0.0);\n  for(int i=0; i<10; i++) {\n    in[i] = i;\n  }\n\n  std::vector<double> out(10, 0.0);\n\n  double* inptr = in.data();\n  double* outptr = out.data();\n\n#pragma omp target teams distribute parallel for map(inptr[:10], outptr[:10]) is_device_ptr(devPtr)\n  for(int i=0; i<10; i++) {\n    outptr[i] = devPtr->sag(inptr[i], inptr[i]);\n  }\n\n  for(int i=0; i<10; i++) {\n    OMPVV_TEST_AND_SET(errors, out[i] != i * 2);\n  }\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_reduction_bitand.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_bitand() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\" at position 2361",
        "issue_id": 4,
        "original_code": "//===--- test_target_teams_distribute_reduction_bitand.c---------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the reduction clause on a target teams distribute directive,\n// testing that the variable in the reduction clause is properly reduced using\n// the bitand operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n#define THRESHOLD 512\n\nint test_bitand() {\n  unsigned int a[N];\n  double false_margin = pow(exp(1), log(.5)/N); // See the 'and' operator test for\n  int errors = 0;                               // an exaplantion of this math.\n  int num_teams[N];\n  int num_attempts = 0;\n  int have_true = 0, have_false = 0;\n  srand(1);\n\n  while ((!have_true || !have_false) && (num_attempts < THRESHOLD)) {\n    have_true = 0;\n    have_false = 0;\n    for (int x = 0; x < N; ++x) {\n      for (int y = 0; y < 16; ++y) {\n        if (rand() / (double) RAND_MAX < false_margin) {\n          a[x] += (1 << y);\n          have_true = 1;\n        } else {\n          have_false = 1;\n        }\n      }\n      num_teams[x] = -x;\n    }\n    num_attempts++;\n  }\n\n  OMPVV_WARNING_IF(!have_true, \"No true bits were generated to test\");\n  OMPVV_WARNING_IF(!have_false, \"No false bits were generated to test\");\n\n  unsigned int b = 0;\n  for (int x = 0; x < 16; ++x) {\n    b = b + (1 << x);\n  }\n\n#pragma omp target teams distribute reduction(&:b) defaultmap(tofrom:scalar)\n  for (int x = 0; x < N; ++x) {\n    num_teams[x] = omp_get_num_teams();\n    b = b & a[x];\n  }\n\n  unsigned int host_b = a[0];\n\n  for (int x = 0; x < N; ++x) {\n    host_b = host_b & a[x];\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_teams[x - 1] != num_teams[x], \"Kernel reported differing numbers of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_teams[0] == 1, \"Test operated with one team.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_teams[0] <= 0, \"Test reported invalid number of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, b != host_b);\n  OMPVV_ERROR_IF(host_b != b, \"Bit on device is %d but expected bit from host is %d.\", b, host_b);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int total_errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(total_errors, test_bitand() != 0);\n\n  OMPVV_REPORT_AND_RETURN(total_errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_reduction_bitand.c---------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the reduction clause on a target teams distribute directive,\n// testing that the variable in the reduction clause is properly reduced using\n// the bitand operator.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n#include <math.h>\n\n#define N 1024\n#define THRESHOLD 512\n\nint test_bitand() {\n  unsigned int a[N];\n  double false_margin = pow(exp(1), log(.5)/N); // See the 'and' operator test for\n  int errors = 0;                               // an exaplantion of this math.\n  int num_teams[N];\n  int num_attempts = 0;\n  int have_true = 0, have_false = 0;\n  srand(1);\n\n  while ((!have_true || !have_false) && (num_attempts < THRESHOLD)) {\n    have_true = 0;\n    have_false = 0;\n    for (int x = 0; x < N; ++x) {\n      for (int y = 0; y < 16; ++y) {\n        if (rand() / (double) RAND_MAX < false_margin) {\n          a[x] += (1 << y);\n          have_true = 1;\n        } else {\n          have_false = 1;\n        }\n      }\n      num_teams[x] = -x;\n    }\n    num_attempts++;\n  }\n\n  OMPVV_WARNING_IF(!have_true, \"No true bits were generated to test\");\n  OMPVV_WARNING_IF(!have_false, \"No false bits were generated to test\");\n\n  unsigned int b = 0;\n  for (int x = 0; x < 16; ++x) {\n    b = b + (1 << x);\n  }\n\n#pragma omp target teams distribute reduction(&:b) defaultmap(tofrom:scalar)\n  for (int x = 0; x < N; ++x) {\n    num_teams[x] = omp_get_num_teams();\n    b = b & a[x];\n  }\n\n  unsigned int host_b = a[0];\n\n  for (int x = 0; x < N; ++x) {\n    host_b = host_b & a[x];\n  }\n\n  for (int x = 1; x < N; ++x) {\n    OMPVV_WARNING_IF(num_teams[x - 1] != num_teams[x], \"Kernel reported differing numbers of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n  }\n  OMPVV_WARNING_IF(num_teams[0] == 1, \"Test operated with one team.  Reduction clause cannot be tested.\");\n  OMPVV_WARNING_IF(num_teams[0] <= 0, \"Test reported invalid number of teams.  Validity of testing of reduction clause cannot be guaranteed.\");\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, b != host_b);\n  OMPVV_ERROR_IF(host_b != b, \"Bit on device is %d but expected bit from host is %d.\", b, host_b);\n\n  return errors;\n}\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_simd_if.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{ \n   int errors = 0;\n   \n   OMPVV_TEST_OFFLOADING;\n   OMPVV_WARNING(\"Vectorization resulting from the construct cannot be guaranteed\"); \n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_simd_if());\n   OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 1493",
        "issue_id": 4,
        "original_code": "//===--- test_target_simd_if.c ----------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This is a test of the target simd combined construct with an 'if' clause \n// specified. When the statement in the 'if' clause evaluates to true, \n// the preferred number of iterations secified in the simdlen clause \n// will run concurrently. When the 'if' clause evaluates to be false,\n// the number of iterations that will execute concurrently is one.\n//\n////===----------------------------------------------------------------------===//\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <omp.h> \n#include \"ompvv.h\" \n\n#define N 1024\n\nint test_simd_if () {\n   int errors = 0;\n   int i;\n   int b[N], c[N];\n\n   struct new_struct {\n      int a[N];\n   };\n\n   struct new_struct struct_t;\n   \n   for (i = 0; i < N; i++ ) {\n      struct_t.a[i] = i;\n      b[i] = i + 5;\n      c[i] = 0;\n   }\n\n   int k = N;\n\n\n   #pragma omp target simd simdlen(64) if(k == N) // simdlen specifies # of concurrent iterations\n      for (i = 0; i < N; i++) {\n         c[i] = struct_t.a[i] * b[i];\n      }\n\n   for (i = 0; i < N; i++) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, c[i] != (struct_t.a[i] * b[i]));\n   }\n\n   #pragma omp target simd simdlen(64) if(k != N) \n      for (i = 0; i < N; i++) {\n         c[i] = struct_t.a[i] * 2 * b[i];\n      }\n\n   for (i = 0; i < N; i++) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, c[i] != (struct_t.a[i] * 2 * b[i]));\n   }\n\n   return errors;\n}\n\n\nint main () { \n   int errors = 0;\n   \n   OMPVV_TEST_OFFLOADING;\n   OMPVV_WARNING(\"Vectorization resulting from the construct cannot be guaranteed\"); \n   OMPVV_TEST_AND_SET_VERBOSE(errors, test_simd_if());\n   OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_simd_if.c ----------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This is a test of the target simd combined construct with an 'if' clause \n// specified. When the statement in the 'if' clause evaluates to true, \n// the preferred number of iterations secified in the simdlen clause \n// will run concurrently. When the 'if' clause evaluates to be false,\n// the number of iterations that will execute concurrently is one.\n//\n////===----------------------------------------------------------------------===//\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <omp.h> \n#include \"ompvv.h\" \n\n#define N 1024\n\nint test_simd_if () {\n   int errors = 0;\n   int i;\n   int b[N], c[N];\n\n   struct new_struct {\n      int a[N];\n   };\n\n   struct new_struct struct_t;\n   \n   for (i = 0; i < N; i++ ) {\n      struct_t.a[i] = i;\n      b[i] = i + 5;\n      c[i] = 0;\n   }\n\n   int k = N;\n\n\n   #pragma omp target simd simdlen(64) if(k == N) // simdlen specifies # of concurrent iterations\n      for (i = 0; i < N; i++) {\n         c[i] = struct_t.a[i] * b[i];\n      }\n\n   for (i = 0; i < N; i++) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, c[i] != (struct_t.a[i] * b[i]));\n   }\n\n   #pragma omp target simd simdlen(64) if(k != N) \n      for (i = 0; i < N; i++) {\n         c[i] = struct_t.a[i] * 2 * b[i];\n      }\n\n   for (i = 0; i < N; i++) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, c[i] != (struct_t.a[i] * 2 * b[i]));\n   }\n\n   return errors;\n}\n\n\nint main () \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_num_teams.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp single\" at position 657",
        "issue_id": 0,
        "original_code": "//===------test_target_teams_num_teams.c--------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Description:\n// This is a basic test to demonstrate target teams + num_teams\n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n#define NUM_TEAMS_TO_SET 32\n\nint testNumTeamsDefaut() {\n  int a[N], b[N], c[N];\n  int errors = 0;\n  int num_actual_teams = 0;\n  // Data Inititalize\n  for (int i = 0; i < N; i++) {\n    a[i] = 2*i;  // Even\n    b[i] = 2*i + 1;  // Odd\n    c[i] = 0;\n  }\n  // Execute on target\n#pragma omp target teams map(to: a[0:N], b[0:N]) map(from: c[0:N]) \\\n        map(tofrom: num_actual_teams) \\\n        num_teams(NUM_TEAMS_TO_SET)\n  {\n    num_actual_teams = omp_get_num_teams();\n    for (int i = 0; i < N; i++) {\n      c[i] = a[i] + b[i];\n    }\n  }\n  // Validate\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (num_actual_teams > NUM_TEAMS_TO_SET));\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, c[i] != a[i] + b[i]);\n  }\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testNumTeamsDefaut());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===------test_target_teams_num_teams.c--------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Description:\n// This is a basic test to demonstrate target teams + num_teams\n//\n//===------------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n#define NUM_TEAMS_TO_SET 32\n\nint testNumTeamsDefaut() {\n  int a[N], b[N], c[N];\n  int errors = 0;\n  int num_actual_teams = 0;\n  // Data Inititalize\n  for (int i = 0; i < N; i++) {\n    a[i] = 2*i;  // Even\n    b[i] = 2*i + 1;  // Odd\n    c[i] = 0;\n  }\n  // Execute on target\n#pragma omp single teams map(to: a[0:N], b[0:N]) map(from: c[0:N]) \\\n        map(tofrom: num_actual_teams) \\\n        num_teams(NUM_TEAMS_TO_SET)\n  {\n    num_actual_teams = omp_get_num_teams();\n    for (int i = 0; i < N; i++) {\n      c[i] = a[i] + b[i];\n    }\n  }\n  // Validate\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (num_actual_teams > NUM_TEAMS_TO_SET));\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, c[i] != a[i] + b[i]);\n  }\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testNumTeamsDefaut());\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_loop_teams_distribute.cpp",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===-- test_target_loop.c - test of the loop clause in target regions ----===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This file is a test for the target loop and teams distribute parallel\n// constructs when used with the map clause. These clauses should parallelize a\n// for loop in target devices using fine grain parallelism. This test performs a\n// SAXPY operation over integer vectors filled with a particular constant. This\n// test uses vectors of size n allocated on the host and the mapped to the\n// target device.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <cstdlib>\n#include <ctime>\n#include <iostream>\n#include <vector>\n#include \"ompvv.h\"\n\n// SAXPY kernel using the target teams distribute parallel for construct\ntemplate <typename T> void saxpy_d(T *x, T *y, T a, int n) {\n#pragma omp target teams distribute parallel for map(tofrom: x [0:n]) \\\n        map(to: y [0:n])\n  for (int i = 0; i < n; ++i)\n    x[i] = a * x[i] + y[i];\n}\n\n// SAXPY kernel using the target loop construct\ntemplate <typename T> void saxpy_l(T *x, T *y, T a, int n) {\n#pragma omp target teams loop map(tofrom : x [0:n]) map(to : y [0:n])\n  for (int i = 0; i < n; ++i)\n    x[i] = a * x[i] + y[i];\n}\n\n// Fuction to verify if the SAXPY kernel performed the operation as expected\ntemplate <typename T> int verify(T *x, T v, int n) {\n  for (int i = 0; i < n; ++i)\n    if (x[i] != v)\n      return 0;\n  return 1;\n}\n\n// Test for OpenMP 5.0 target loop and teams distribute parallel\nint test_target_loop_teams_distribute() {\n  OMPVV_INFOMSG(\"test_target_loop_teams_distribute\");\n\n  srand(time(NULL));\n  int n = (rand() % 4096) + 4096, errors = 0, tmp = 0;\n  int a = (rand() % 1024) + 1, x = rand() % 2048, y = rand() % 4096;\n  std::vector<int> xd(n, x), xl(n, x), yg(n, y);\n\n  saxpy_d(xd.data(), yg.data(), a, n);\n  saxpy_l(xl.data(), yg.data(), a, n);\n\n  tmp = verify(xd.data(), a * x + y, n) + verify(xl.data(), a * x + y, n) * 2;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, 3 != tmp);\n\n  return errors;\n}\n\nint main(int argc, char **argv) {\n  int errors = 0;\n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_loop_teams_distribute());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <iostream>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nlong cvxwgmzbmm = 12;\nlong jhpblpxfsi = 18;\nint enbdtoxljv = 79;\nshort kxgnmqtvaq = 189;\nfloat jlxurclgna = 144;\nlong wgigidqfsh = 10;\nshort swpttrdooe = 249;\nlong pzdaqwrffi = 110;\nfloat whxdjhqbam = 17;\nlong ghvqsfbqrw = 224;\nlong ukrjlnpnei = 130;\nshort gbqlkbxvah = 68;\nbyte dssxbpzizd = 116;\nint prtqebgdol = 174;\nfloat diclpcmyxl = 182;\nbyte uijelysvqj = 193;\ndouble hldfzijfgc = 147;\nlong sxdfksxpze = 186;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    std::cout << \"Sum of \" << num1 << \" and \" << num2 << \" is \" << sum << std::endl;\n    return 0;\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_parallel_for_order_unconstrained.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===------------ test_target_parallel_for_order_unconstrained.c -------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// This test checks that the order(unconstrained:concurrent) clause is properly\n// handled. Since with unconstrained the values can be executed in any order\n// this test simply checks that the correct values have been calculated for\n// the array\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main() {\n\tint errors = 0;\n\tint x[N];\n\n\tfor (int i = 0; i < N; i++) {\n\t\tx[i] = i;\n\t}\n\n\tOMPVV_TEST_OFFLOADING;\n\n\t#pragma omp target map(tofrom: x)\n\t{\n\t\t#pragma omp parallel for order(unconstrained:concurrent)\n\t\tfor (int i = 0; i < N; i++) {\n\t\t\tx[i] = x[i] + 2;\t\n\t\t}\n\t}\n\n\tfor (int i = 0; i < N; i++) {\n    \t\tOMPVV_TEST_AND_SET(errors, x[i] != i + 2);\n\t}\n\n\tOMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nbyte fkgacbysea = 21;\nint cpqdjvnbyn = 69;\nlong talxldsovf = 169;\nbyte zjzujlcgoc = 36;\nshort emlbzgbqxt = 168;\ndouble pjqzbtjenb = 211;\nint nrmaxyctox = 252;\nbyte zzyewaytow = 199;\ndouble vblwgcrqir = 60;\nlong vyxbghzypy = 107;\nshort myjdllvfaq = 54;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/qmcpack_target_math.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp atomic\" at position 815",
        "issue_id": 0,
        "original_code": "//===--- qmcpack_target_math.c --- math lib invocation inside target---------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n//This is a QMCPACK specific test that looks at math library support \n//from within the target region. The array is initialized to FP_ZERO\n//and subsequently pow math function is invoked form the target region.\n//\n////===----------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#include \"ompvv.h\"\n\n#define N 1000\n\nint test_math_lib_inside_target() {\n  OMPVV_INFOMSG(\"test_math_lib_inside_target\");\n\n  double array[N];\n  int errors = 0;\n  \n  // Array initialization\n  for (int i = 0; i < N; ++i) {\n    array[i] = 0.99;\n  }\n  // This is intentional\n  int c99_zero = FP_ZERO;\n  \n#pragma omp target map(tofrom: array[0:N]) \n  for (int i = 0; i < N; ++i) {\n    array[i] = pow((double)i,2.0);\n  }\n\n  for (int i = 0; i < N; ++i) {\n    OMPVV_TEST_AND_SET(errors, (array[i] - pow((double)i,2)) > 0.000009);\n  }\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_math_lib_inside_target());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- qmcpack_target_math.c --- math lib invocation inside target---------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n//This is a QMCPACK specific test that looks at math library support \n//from within the target region. The array is initialized to FP_ZERO\n//and subsequently pow math function is invoked form the target region.\n//\n////===----------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#include \"ompvv.h\"\n\n#define N 1000\n\nint test_math_lib_inside_target() {\n  OMPVV_INFOMSG(\"test_math_lib_inside_target\");\n\n  double array[N];\n  int errors = 0;\n  \n  // Array initialization\n  for (int i = 0; i < N; ++i) {\n    array[i] = 0.99;\n  }\n  // This is intentional\n  int c99_zero = FP_ZERO;\n  \n#pragma omp atomic map(tofrom: array[0:N]) \n  for (int i = 0; i < N; ++i) {\n    array[i] = pow((double)i,2.0);\n  }\n\n  for (int i = 0; i < N; ++i) {\n    OMPVV_TEST_AND_SET(errors, (array[i] - pow((double)i,2)) > 0.000009);\n  }\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_math_lib_inside_target());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_parallel_for_notequals.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 988",
        "issue_id": 1,
        "original_code": "//===--- test_parallel_for_notequals.c -------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the parallel for directive with relational-op \"!=\".\n// The test performs simple operations on an int array which are then\n// checked for correctness. \n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_parallel_for_notequals() {\n  OMPVV_INFOMSG(\"test_parallel_for_notequals\");\n  int errors = 0;\n  int x[N];\n  int y[N];\n  int z[N];\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 1;\n    y[i] = i + 1;\n    z[i] = 2*(i + 1);\n  }\n\n#pragma omp parallel for num_threads(OMPVV_NUM_THREADS_HOST) shared(x, y, z)\n  for (int i = 0; i != N; i++) {\n    x[i] += y[i]*z[i];\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != 1 + (y[i]*z[i]));\n  }\n\n  return errors;\n}\n\n\nint main() {\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_parallel_for_notequals());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_parallel_for_notequals.c -------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the parallel for directive with relational-op \"!=\".\n// The test performs simple operations on an int array which are then\n// checked for correctness. \n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_parallel_for_notequals() {\n  OMPVV_INFOMSG(\"test_parallel_for_notequals\");\n  int errors = 0;\n  int x[N];\n  int y[N];\n  int z[N];\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 1;\n    y[i] = i + 1;\n    z[i] = 2*(i + 1);\n  }\n\n#pragma omp parallel for num_threads(OMPVV_NUM_THREADS_HOST) shared(x, y, z)\n  for (int i = 0; i != N; i++) {\n    x[i] += y[i]*z[i];\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != 1 + (y[i]*z[i]));\n  }\n\n  return errors;\n}\n\n\nint main() \n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_parallel_for_notequals());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_set_and_get_omp_affinity.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===--- test_set_and_get_omp_affinity.c ------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the modification and retreival of the affinity-format-var \n// through the use of the omp_set_affinity_format() and omp_get_affinity_format() \n// routines. The omp_display_affinity() routine is used to display affinity format.\n//\n// Adopted from OpenMP 5.0 Example affinity_display.3.c\n//===------------------------------------------------------------------------===//\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <stddef.h>\n#include <string.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define FORMAT_STORE 80 \n\nint main () {\n\n   int errors;\n   size_t nchars;\n   size_t set_nchars;\n   errors = 0;\n    \n   char default_format[FORMAT_STORE];\n   char my_format[] = \"host=%20H thrd_num=%0.4n binds_to=%A\";\n\n   // Display Default Affinity Format using omp_get_affinity_format and omp_display_affinity\n   nchars = omp_get_affinity_format(default_format,(size_t)FORMAT_STORE);\n   omp_display_affinity(default_format);\n   OMPVV_TEST_AND_SET_VERBOSE(errors, nchars >= FORMAT_STORE);\n   \n   //Display Default Affinity Format after using omp_set_affinity_format using omp_display_affinity\n   omp_set_affinity_format(my_format);\n   set_nchars = omp_get_affinity_format(default_format,(size_t)FORMAT_STORE);\n   omp_display_affinity(default_format);\n   OMPVV_TEST_AND_SET_VERBOSE(errors, nchars == set_nchars);\n   OMPVV_ERROR_IF(nchars == set_nchars, \"Default affinity is the same number of characters as the set affinity, it is likely that omp_set_affinity() did not work properly.\");\n                                     \n   OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nint nglxvadnqx = 186;\nshort zevpnlovml = 75;\ndouble erdhhockuv = 57;\nbyte vcflwbxuwn = 58;\nint hvzieawmds = 106;\ndouble sztlpxnzuw = 209;\nlong isbjlthytr = 24;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_default_shared.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1970",
        "issue_id": 1,
        "original_code": "//===--- test_target_teams_distribute_default_shared.c-----------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the default(shared) clause on a target teams distribute\n// directive.  The test aims to validate that when the default(shared) clause\n// is present, all variables without explicit data sharing attributes will\n// be shared within the region.  To test this, we test that a data element\n// that should be shared due to the default(shared) clause is available to\n// all the teams.  The first test uses atomic to write to the variable without\n// race conditions.  The second test uses synchronization constructs to have\n// one thread change the shared variable and ensures all threads see the change.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main() {\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  int a[N];\n  int share = 0;\n  int errors = 0;\n  int num_teams;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n  }\n\n#pragma omp target data map(to: a[0:N]) map(tofrom: share, num_teams)\n  {\n#pragma omp target teams distribute default(shared) defaultmap(tofrom:scalar) num_teams(OMPVV_NUM_TEAMS_DEVICE)\n    for (int x = 0; x < N; ++x) {\n      if (omp_get_team_num() == 0) {\n        num_teams = omp_get_num_teams();\n      }\n#pragma omp atomic\n      share = share + a[x];\n    }\n  }\n\n  for (int x = 0; x < N; ++x) {\n    share = share - x;\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (share != 0));\n\n  share = 5;\n\n#pragma omp target data map(tofrom: a[0:N]) map(tofrom: share)\n  {\n#pragma omp target teams distribute default(shared) defaultmap(tofrom:scalar) num_teams(OMPVV_NUM_TEAMS_DEVICE)\n    for (int x = 0; x < N; ++x) {\n      a[x] = a[x] + share;\n    }\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (a[x] - 5 != x));\n    if (a[x] - 5 != x) {\n      break;\n    }\n  }\n\n  OMPVV_WARNING_IF(num_teams == 1, \"Test operated on one team, results of default shared test are inconclusive.\");\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_default_shared.c-----------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test uses the default(shared) clause on a target teams distribute\n// directive.  The test aims to validate that when the default(shared) clause\n// is present, all variables without explicit data sharing attributes will\n// be shared within the region.  To test this, we test that a data element\n// that should be shared due to the default(shared) clause is available to\n// all the teams.  The first test uses atomic to write to the variable without\n// race conditions.  The second test uses synchronization constructs to have\n// one thread change the shared variable and ensures all threads see the change.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint main() {\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  int a[N];\n  int share = 0;\n  int errors = 0;\n  int num_teams;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n  }\n\n#pragma omp target data map(to: a[0:N]) map(tofrom: share, num_teams)\n  {\n#pragma omp target teams distribute default(shared) defaultmap(tofrom:scalar) num_teams(OMPVV_NUM_TEAMS_DEVICE)\n    for (int x = 0; x < N; ++x) {\n      if (omp_get_team_num() == 0) {\n        num_teams = omp_get_num_teams();\n      }\n#pragma omp atomic\n      share = share + a[x];\n    }\n  }\n\n  for (int x = 0; x < N; ++x) {\n    share = share - x;\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (share != 0));\n\n  share = 5;\n\n#pragma omp target data map(tofrom: a[0:N]) map(tofrom: share)\n  {\n#pragma omp target teams distribute default(shared) defaultmap(tofrom:scalar) num_teams(OMPVV_NUM_TEAMS_DEVICE)\n    for (int x = 0; x < N; ++x) {\n      a[x] = a[x] + share;\n    }\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (a[x] - 5 != x));\n    if (a[x] - 5 != x) \n      break;\n    }\n  }\n\n  OMPVV_WARNING_IF(num_teams == 1, \"Test operated on one team, results of default shared test are inconclusive.\");\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_parallel_for_notequals.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_parallel_for_notequals());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 1044",
        "issue_id": 4,
        "original_code": "//===--- test_target_parallel_for_notequals.c -------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the parallel for directive with relational-op \"!=\".\n// The test performs simple operations on an int array in device env \n// which are then checked for correctness. \n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_target_parallel_for_notequals() {\n  OMPVV_INFOMSG(\"test_parallel_for_notequals_device\");\n  int errors = 0;\n  int x[N];\n  int y[N];\n  int z[N];\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 1;\n    y[i] = i + 1;\n    z[i] = 2*(i + 1);\n  }\n\n#pragma omp target parallel for num_threads(OMPVV_NUM_THREADS_HOST) map(to: y, z) map(tofrom: x)\n  for (int i = 0; i != N; i++) {\n    x[i] += y[i]*z[i];\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != 1 + (y[i]*z[i]));\n  }\n\n  return errors;\n}\n\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_parallel_for_notequals());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_parallel_for_notequals.c -------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// This test checks the parallel for directive with relational-op \"!=\".\n// The test performs simple operations on an int array in device env \n// which are then checked for correctness. \n//\n////===----------------------------------------------------------------------===//\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_target_parallel_for_notequals() {\n  OMPVV_INFOMSG(\"test_parallel_for_notequals_device\");\n  int errors = 0;\n  int x[N];\n  int y[N];\n  int z[N];\n\n  for (int i = 0; i < N; i++) {\n    x[i] = 1;\n    y[i] = i + 1;\n    z[i] = 2*(i + 1);\n  }\n\n#pragma omp target parallel for num_threads(OMPVV_NUM_THREADS_HOST) map(to: y, z) map(tofrom: x)\n  for (int i = 0; i != N; i++) {\n    x[i] += y[i]*z[i];\n  }\n\n  for (int i = 0; i < N; i++) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, x[i] != 1 + (y[i]*z[i]));\n  }\n\n  return errors;\n}\n\n\nint main() \n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_task_critical.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 2118",
        "issue_id": 2,
        "original_code": "//===-- test_task_critical.c ------------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// Description:\n// testTaskWithCriticalBasic()\n// This is a basic test to demonstrate how a shared resource\n// can be accessed and written to in multiple thread environment.\n//\n//testTaskWithCriticalAdvanced()\n// This is a advanced test to demonstrate how a shared resource\n// can be accessed and written to in multiple thread environment.\n// In this a buffer is filled with random integers. The parallel\n// region counts the number of prime integers.\n//===----------------------------------------------------------------------===//\n\n\n\n#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\nint testTaskWithCriticalBasic() {\n  int errors = 0;\n  int count = 0;\n  int NThrds = -2;\n  omp_set_num_threads(OMPVV_NUM_THREADS_HOST);\n  \n#pragma omp parallel\n  {\n      if(omp_get_thread_num() == 0) NThrds = omp_get_num_threads();\n       \n#pragma omp task\n    {\n#pragma omp critical\n      {\n        count = count + 1;\n      }\n    }\n  }\n  int ret = 0;\n  if (count == NThrds) {\n    ret = 0;\n  } else {\n    ret = -1;\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, ret != 0);\n  return errors;\n}\n\n/**\n  Local Function check if number is prime\n*/\nint isPrime(unsigned int number) {\n  int ret = 0;\n  if (number < 2) {\n    return 1;\n  }\n  for (int num = 2; (num*num) <= number; num++) {\n    if ((number % num) == 0) {\n      ret = 1;\n      break;\n    }\n  }\n  return ret;\n}\n\nint testTaskWithCriticalAdvanced(int numThreads, int expectedVal) {\n  int errors = 0;\n  int countPrime = 0, count = 0;\n  unsigned int *A = (unsigned int*) (malloc(numThreads*sizeof(unsigned int)));\n  omp_set_num_threads(numThreads);\n  // fill data\n  for (int i = 0; i < numThreads; i++) {\n    A[i] = i;\n  }\n  // Calculate number of prime numbers \n#pragma omp parallel\n  {\n#pragma omp task\n    {\n      int idx = 0;\n#pragma omp critical\n      {\n        count++;\n        idx = count - 1;\n      }\n      int ret = isPrime(A[idx]);\n#pragma omp critical\n      {\n        if (ret == 0) {\n          countPrime++;\n        }\n      }\n    }\n  }\n  \n  free(A);\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, countPrime != expectedVal);\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithCriticalBasic());\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithCriticalAdvanced(1, 0));\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===-- test_task_critical.c ------------------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// Description:\n// testTaskWithCriticalBasic()\n// This is a basic test to demonstrate how a shared resource\n// can be accessed and written to in multiple thread environment.\n//\n//testTaskWithCriticalAdvanced()\n// This is a advanced test to demonstrate how a shared resource\n// can be accessed and written to in multiple thread environment.\n// In this a buffer is filled with random integers. The parallel\n// region counts the number of prime integers.\n//===----------------------------------------------------------------------===//\n\n\n\n#include <stdio.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\nint testTaskWithCriticalBasic() {\n  int errors = 0;\n  int count = 0;\n  int NThrds = -2;\n  omp_set_num_threads(OMPVV_NUM_THREADS_HOST);\n  \n#pragma omp parallel\n  {\n      if(omp_get_thread_num() == 0) NThrds = omp_get_num_threads();\n       \n#pragma omp task\n    {\n#pragma omp critical\n      {\n        count = count + 1;\n      }\n    }\n  }\n  int ret = 0;\n  if (count == NThrds) {\n    ret = 0;\n  } else {\n    ret = -1;\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, ret != 0);\n  return errors;\n}\n\n/**\n  Local Function check if number is prime\n*/\nint isPrime(unsigned int number) {\n  int ret = 0;\n  if (number < 2) {\n    return 1;\n  }\n  for (int num = 2; (num*num) <= number; num++) {\n    if ((number % num) == 0) {\n      ret = 1;\n      break;\n    }\n  }\n  return ret;\n}\n\nint testTaskWithCriticalAdvanced(int numThreads, int expectedVal) {\n  int errors = 0;\n  int countPrime = 0, count = 0;\n  unsigned int *A = (unsigned int*) (malloc(numThreads*sizeof(unsigned int)));\n  omp_set_num_threads(numThreads);\n  // fill data\n  for (int i = 0; i < numThreads; i++) {\n    A[i] = i;\n  }\n  // Calculate number of prime numbers \n#pragma omp parallel\n  {\n#pragma omp task\n    {\n      int idx = 0;\n#pragma omp critical\n      {\n        count++;\n        idx = count - 1;\n      }\n      int ret = isPrime(A[idx]);\n#pragma omp critical\n      {\n        if (ret == 0) {\n          countPrime++;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n        }\n      }\n    }\n  }\n  \n  free(A);\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, countPrime != expectedVal);\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithCriticalBasic());\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, testTaskWithCriticalAdvanced(1, 0));\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_if.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===---- test_target_if.c -  --------------------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n// \n// The if clause determines if the section should be executed in the host or \n// the device. There are three things to test here: \n// (a) with offloading when 'if' clause evaluates to true then code\n// be executed on the device \n// (b) with offloading when 'if' clause evaluates to false then code should\n// be executed on the host\n// (c) without offloading all the code should be executed on the device\n// The if clause is evaluated on runtime which means that variables could\n// determine this behavior. We use a SIZE_THRESHOLD variable to check if we \n// should execute on the device or the host. Before starting the test we \n// sample offloading to see if it was enabled or not. If the code is executed\n// in the device, the result should be c[i] = a[i] + b[i] = i + 1. \n// If the code is executed on the host the result should be c[i] = -1\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\" \n\n#define SIZE_THRESHOLD 512\n\n// Test for OpenMP 4.5 target data with if\nint main() {\n  int isOffloading = 0; \n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  \n  if (!isOffloading)\n  OMPVV_WARNING(\"It is not possible to test conditional data transfers \"\n                 \"if the environment is shared or offloading is off. Not testing \"\n                 \"anything\")\n  int a[1024];\n  int b[1024];\n  int c[1024];\n  int size, i = 0, errors[2] = {0,0}, isHost = -1;\n\n  // a and b array initialization\n  for (i = 0; i < 1024; i++) {\n    a[i] = 1;\n    b[i] = i;\n  }\n\n  // check multiple sizes. \n  for (size = 256; size <= 1024; size += 256) {\n    // C initialization\n    for (i = 0; i < size; i++) {\n      c[i] = -1;\n    }\n#pragma omp target if(size > SIZE_THRESHOLD) map(to: size)  \\\n        map(tofrom: c[0:size])                                       \\\n        map(to: a[0:size], b[0:size])  map(tofrom: isHost)\n    {\n      isHost = omp_is_initial_device();\n      int alpha = (isHost ? 0 : 1);\n      int j = 0;\n      for (j = 0; j < size; j++) {\n        // c[j] is zero if executed in the host\n        // c[j] is 1+j if executed on the device\n        c[j] = alpha*(a[j] + b[j]);\n      }\n    } // end target\n\n    // checking results \n    for (i = 0; i < size; i++) {\n      if (isOffloading && size > SIZE_THRESHOLD) {\n        // Should have executed on the device\n        // if offloading was used\n        // c[i] is zero if it was executed in the host\n        OMPVV_TEST_AND_SET(errors[0], (c[i] != i + 1));//error when executed on the device\n      } else {\n        // Should have executed in the host\n        // with or without offloading\n        OMPVV_TEST_AND_SET(errors[1], (c[i] != 0));\n      } //end-else \n    }\n  } // end-for size\n\n  if (!errors[0] && !errors[1]) {\n    OMPVV_INFOMSG(\"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  } else if (errors[0]==0 && errors[1]!=0) {\n    OMPVV_ERROR(\"Test failed on host with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n  } else if (errors[0]!=0 && errors[1]==0) {\n    OMPVV_ERROR(\"Test failed on device with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n  } else if (errors[0]!=0 && errors[1]!=0) {\n    OMPVV_ERROR(\"Test failed on host and device with offloading %s.\", (isOffloading ? \"enabled\" : \"disabled\"));\n  }\n  \n  OMPVV_REPORT_AND_RETURN((errors[0] + errors[1]));\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nshort gpwvdwfoel = 127;\nbyte nqfvgsqznl = 126;\nfloat ehbqwwvotx = 255;\nbyte kxolxzfqow = 39;\nint cijyugfyuk = 34;\nfloat uvvomkmayp = 79;\nint fomrlrtfws = 33;\nbyte zwggcmimld = 124;\nint zfnybeqnbj = 218;\nlong rstipuwznk = 47;\nshort abhcxtpimd = 166;\nshort blkgjowsxf = 162;\nfloat bpoadvwrci = 158;\nint rddnmzolgi = 233;\nlong wqrwfjizlb = 150;\nfloat ubrqrneznh = 160;\nshort hxbhvzbeuq = 132;\nlong bzchohwbpl = 215;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_calloc_host.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1598",
        "issue_id": 1,
        "original_code": "//===------------------------ test_calloc_host.c --------------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// Tests the omp_calloc routine to make sure memory is properly allocated\n// on the host and is zero initialized. Allocates an array and makes sure\n// each value is set to 0 to start. Then adds i to each index and validates the\n// changes persisted and were written correctly.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_omp_calloc_host() {\n  int errors = 0;\n  int *x;\n\n  x = (int *)omp_calloc(64, N*sizeof(int), omp_default_mem_alloc);\n\n  if (x == NULL) {\n    OMPVV_ERROR(\"omp_calloc returned null\"); \n    return (1); \n  }\n\n  int not_init_to_zero = 0;\n  int not_correct_updated_values = 0;\n\n  #pragma omp parallel for\n  for (int i = 0; i < N; i++) {\n    if (x[i] != 0) {\n      #pragma omp atomic write\n      not_init_to_zero = 1;\n    }  \n  }\n\n  #pragma omp parallel for\n  for (int i = 0; i < N; i++) {\n    x[i] = i;\n  }\n  \n  #pragma omp parallel for\n  for (int i = 0; i < N; i++) {\n    if (x[i] != i) {\n      #pragma omp atomic write\n      not_correct_updated_values = 1;\n    }\n  }\n\n  if (not_init_to_zero) {\n    OMPVV_ERROR(\"Values were not initialized to 0\");\n    errors++;\n  }\n\n  if (not_correct_updated_values) {\n    OMPVV_ERROR(\"Values in the array did NOT match the expected values. Changes may not have persisted.\");\n    errors++;\n  }\n\n  omp_free(x, omp_default_mem_alloc);\n\n  return errors;\n}\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_omp_calloc_host() != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===------------------------ test_calloc_host.c --------------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n//\n// Tests the omp_calloc routine to make sure memory is properly allocated\n// on the host and is zero initialized. Allocates an array and makes sure\n// each value is set to 0 to start. Then adds i to each index and validates the\n// changes persisted and were written correctly.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_omp_calloc_host() {\n  int errors = 0;\n  int *x;\n\n  x = (int *)omp_calloc(64, N*sizeof(int), omp_default_mem_alloc);\n\n  if (x == NULL) {\n    OMPVV_ERROR(\"omp_calloc returned null\"); \n    return (1); \n  }\n\n  int not_init_to_zero = 0;\n  int not_correct_updated_values = 0;\n\n  #pragma omp parallel for\n  for (int i = 0; i < N; i++) {\n    if (x[i] != 0) {\n      #pragma omp atomic write\n      not_init_to_zero = 1;\n    }  \n  }\n\n  #pragma omp parallel for\n  for (int i = 0; i < N; i++) {\n    x[i] = i;\n  }\n  \n  #pragma omp parallel for\n  for (int i = 0; i < N; i++) {\n    if (x[i] != i) {\n      #pragma omp atomic write\n      not_correct_updated_values = 1;\n    }\n  }\n\n  if (not_init_to_zero) {\n    OMPVV_ERROR(\"Values were not initialized to 0\");\n    errors++;\n  }\n\n  if (not_correct_updated_values) {\n    OMPVV_ERROR(\"Values in the array did NOT match the expected values. Changes may not have persisted.\");\n    errors++;\n  }\n\n  omp_free(x, omp_default_mem_alloc);\n\n  return errors;\n}\n\nint main() \n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_omp_calloc_host() != 0);\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_taskloop_lastprivate.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//-------------------------------- test_taskloop_lastprivate.c ------------------------------------------------//\n//\n// OpenMP API Version 4.5 November 2015\n//\n// This test checks the 'taskloop' directive with the 'lastprivate' clause specified.\n// The 'taskloop' construct parallelize loops with independent iterations by creating tasks. \n// It allows for efficient parallel execution of loop iterations by distributing them among multiple threads. \n// The 'lastprivate' clause ensures that the last value of variable in a loop is available after loop completion.  \n//-------------------------------------------------------------------------------------------------------------//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define NUM_THREADS 1000\n#define NUM_TASKS 1000 \n\nint test_taskloop_lastprivate() {\n    \n    int errors = 0;\n   \n    int val = 100;\n    int task_vals[NUM_TASKS];\n\n    int last_itr = NUM_TASKS - 1;\n    \n    #pragma omp parallel num_threads(NUM_THREADS)\n    {\n        #pragma omp single\n        {\n            #pragma omp taskloop lastprivate(val)\n            for (int i = 0; i < NUM_TASKS; i++) {\n                val = i;\n                task_vals[i] = val; \n            }\n        }\n    }\n   \n    //NOTE: lastprivate_var depends on NUM_TASK and not on Input value\n    //it is the last task iteration which is kept, not the last operation value.\n     OMPVV_TEST_AND_SET_VERBOSE(errors, (task_vals[last_itr] != val));\n\n    return errors;    \n}\n\nint main() {\n   \n    int errors = 0;\n\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (test_taskloop_lastprivate() != 0));\n    OMPVV_REPORT_AND_RETURN(errors);\n    \n    return 0;\n}\n\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\ndouble jcswjlvjfa = 76;\nbyte smiiyvkwcs = 108;\ndouble thifawuwnx = 233;\nlong qlbrjnrbug = 207;\ndouble sfalpmesht = 237;\nbyte rkpkfrgmlw = 251;\nlong krfmnagjqo = 153;\ndouble cordsxjkmf = 121;\nbyte ddsvaewtly = 127;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_teams_distribute_depend_out_in.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 725",
        "issue_id": 2,
        "original_code": "//===--- test_target_teams_distribute_depend_out_in.c------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks out-in and inout-in dependency by checking order-dependent\n// results from pairs of possibly asynchronous loops. The test fails if either \n// out-in or inout-in dependency is broken.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_target_teams_distribute_depend_out_in() {\n  int isOffloading = 0;\n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int errors = 0;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n    b[x] = 2 * x;\n    c[x] = 0;\n    d[x] = 0;\n  }\n\n#pragma omp target data map(to: a[0:N], b[0:N]) map(alloc: c[0:N]) map(from: d[0:N])\n  {\n#pragma omp target teams distribute nowait depend(out: c) map(alloc: a[0:N], b[0:N], c[0:N])\n    for (int x = 0; x < N; ++x) {\n      c[x] = a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(in: c) map(alloc: b[0:N], c[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n      d[x] = c[x] + b[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, d[x] != 5*x);\n    OMPVV_ERROR_IF(d[x] != 5*x, \"Test of depend(out) task becoming dependent on depend(in) task failed.\");\n  }\n\n#pragma omp target data map(to: a[0:N], b[0:N]) map(alloc: c[0:N]) map(from: d[0:N])\n  {\n#pragma omp target teams distribute nowait depend(inout: c) map(alloc: a[0:N], b[0:N], c[0:N])\n    for (int x = 0; x < N; ++x) {\n      c[x] = a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(in: c) map(alloc: a[0:N], c[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n      d[x] = c[x] + a[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, d[x] != 4*x);\n    OMPVV_ERROR_IF(d[x] != 4*x, \"Test of depend(inout) task becoming dependent on depend(in) task failed.\");\n  }\n\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  errors += test_target_teams_distribute_depend_out_in();\n  OMPVV_INFOMSG_IF(errors != 0, \"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_teams_distribute_depend_out_in.c------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks out-in and inout-in dependency by checking order-dependent\n// results from pairs of possibly asynchronous loops. The test fails if either \n// out-in or inout-in dependency is broken.\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_target_teams_distribute_depend_out_in() {\n  int isOffloading = 0;\n  int a[N];\n  int b[N];\n  int c[N];\n  int d[N];\n  int errors = 0;\n\n  for (int x = 0; x < N; ++x) {\n    a[x] = x;\n    b[x] = 2 * x;\n    c[x] = 0;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1;\n    d[x] = 0;\n  }\n\n#pragma omp target data map(to: a[0:N], b[0:N]) map(alloc: c[0:N]) map(from: d[0:N])\n  {\n#pragma omp target teams distribute nowait depend(out: c) map(alloc: a[0:N], b[0:N], c[0:N])\n    for (int x = 0; x < N; ++x) {\n      c[x] = a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(in: c) map(alloc: b[0:N], c[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n      d[x] = c[x] + b[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, d[x] != 5*x);\n    OMPVV_ERROR_IF(d[x] != 5*x, \"Test of depend(out) task becoming dependent on depend(in) task failed.\");\n  }\n\n#pragma omp target data map(to: a[0:N], b[0:N]) map(alloc: c[0:N]) map(from: d[0:N])\n  {\n#pragma omp target teams distribute nowait depend(inout: c) map(alloc: a[0:N], b[0:N], c[0:N])\n    for (int x = 0; x < N; ++x) {\n      c[x] = a[x] + b[x];\n    }\n#pragma omp target teams distribute nowait depend(in: c) map(alloc: a[0:N], c[0:N], d[0:N])\n    for (int x = 0; x < N; ++x) {\n      d[x] = c[x] + a[x];\n    }\n#pragma omp taskwait\n  }\n\n  for (int x = 0; x < N; ++x) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, d[x] != 4*x);\n    OMPVV_ERROR_IF(d[x] != 4*x, \"Test of depend(inout) task becoming dependent on depend(in) task failed.\");\n  }\n\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n  int isOffloading = 0;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  errors += test_target_teams_distribute_depend_out_in();\n  OMPVV_INFOMSG_IF(errors != 0, \"Test passed with offloading %s\", (isOffloading ? \"enabled\" : \"disabled\"));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_class_deepcpy.cpp",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n      count++;\n    }\" at position 1222",
        "issue_id": 4,
        "original_code": "//===-- test_target_class_deepcpy.cpp -------------------------------------===//\n//\n// OpenMP API Version 5.2\n//\n// Description\n// This test case tests the working of the following aspects:\n// 1) Working of \"requires unified_shared_memory\"\n// 2) demonstrating the deepcpy functionality on gpu\n//===----------------------------------------------------------------------===//\n\n#include <iostream>\n#include \"ompvv.h\"\n#include <omp.h>\n\n#define N 1024*512\n#pragma omp requires unified_shared_memory\n\nclass A {\n  int *Val = nullptr;\n  public:\n    void SetVal(int x) {\n      for (int i = 0; i < N; ++i) {\n        Val[i] = x;\n      }\n    }\n    int GetVal(int Indx) {\n      return Val[Indx];\n    }\n    A(int x) {\n      Val = new int[N];\n      for (int i = 0; i < N; ++i) {\n        Val[i] = x;\n      }\n    }\n    // Deep copy constructor\n    A(A  &a) {\n      this->Val = new int[N];\n      for (int i = 0; i < N; ++i) {\n        Val[i] = a.GetVal(i);\n      }\n    }\n    ~A() {\n      delete[] Val;\n    }\n};\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  A a(123);\n  A b = a;\n#pragma omp target\n  {\n    b.SetVal(999);\n  }\n  // verifying the results\n  int count = 0;\n  for (int i = 0; i < N; ++i) {\n    if (b.GetVal(i) != 999) {\n      count++;\n    }\n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (count != 0));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===-- test_target_class_deepcpy.cpp -------------------------------------===//\n//\n// OpenMP API Version 5.2\n//\n// Description\n// This test case tests the working of the following aspects:\n// 1) Working of \"requires unified_shared_memory\"\n// 2) demonstrating the deepcpy functionality on gpu\n//===----------------------------------------------------------------------===//\n\n#include <iostream>\n#include \"ompvv.h\"\n#include <omp.h>\n\n#define N 1024*512\n#pragma omp requires unified_shared_memory\n\nclass A {\n  int *Val = nullptr;\n  public:\n    void SetVal(int x) {\n      for (int i = 0; i < N; ++i) {\n        Val[i] = x;\n      }\n    }\n    int GetVal(int Indx) {\n      return Val[Indx];\n    }\n    A(int x) {\n      Val = new int[N];\n      for (int i = 0; i < N; ++i) {\n        Val[i] = x;\n      }\n    }\n    // Deep copy constructor\n    A(A  &a) {\n      this->Val = new int[N];\n      for (int i = 0; i < N; ++i) {\n        Val[i] = a.GetVal(i);\n      }\n    }\n    ~A() {\n      delete[] Val;\n    }\n};\n\nint main() {\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n  A a(123);\n  A b = a;\n#pragma omp target\n  {\n    b.SetVal(999);\n  }\n  // verifying the results\n  int count = 0;\n  for (int i = 0; i < N; ++i) {\n    if (b.GetVal(i) != 999) \n  }\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (count != 0));\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_enter_exit_data_struct.c",
        "correct": "n",
        "issue": "Added use of undeclared variable yWEGUIOBBAHCbhivsjkrbvbBYEUF at position 3410",
        "issue_id": 2,
        "original_code": "//===---- test_target_enter_exit_data_struct.c ----------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks functionality of target enter data and target exit data using\n// a struct and a typedef that each have multiple data memebers of different type \n// and length. The functions test_typedef() and test_struct() are both copying \n// structures to the device, altering public member values, copying them back\n// and checking to see that values are properly updated. \n//\n////===--------------------------------------------------------------------------===//\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\n// Test for OpenMP 4.5 target enter and target exit using a struct.\nint test_struct() {\n   \n  OMPVV_INFOMSG(\"Running test_struct()\");\n    \n  int errors = 0;\n  int* pointers[6];\n\n  struct {\n    int a; // firstprivate\n    int b[N]; // tofrom:b[0:N]\n    int *p; // tofrom:p[0:0]\n  } single, array[5];\n\n  single.p = (int*) malloc(5 * sizeof(int));\n  pointers[0] = single.p;\n\n  for (int i = 0; i < 5; ++i) {\n    array[i].p = (int*) malloc(5 * sizeof(int));\n    pointers[i + 1] = array[i].p;\n  }\n\n#pragma omp target enter data map(to: single) map(to: array[0:5])\n\n#pragma omp target map(alloc: single) map(alloc: array[0:5])\n{\n  single.a = 1;\n  for (int i = 0; i < N; ++i)\n    single.b[i] = 1;\n      \n  for (int i = 0; i < 5; ++i) {\n    array[i].a = 1;\n    for (int j = 0; j < N; ++j)\n      array[i].b[j] = 1;\n  }\n} //end target map\n\n#pragma omp target exit data map(from: single) map(from: array[0:5])\n\n  // Checking results\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (single.a != 1)); \n  for (int i = 0; i < N; ++i)\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (single.b[i] != 1));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (pointers[0] != single.p));\n  for (int i = 0; i < 5; ++i) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (array[i].a != 1)); \n    for (int j = 0; j < N; ++j)\n      OMPVV_TEST_AND_SET_VERBOSE(errors, (array[i].b[j] != 1));\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (pointers[i + 1] != array[i].p));\n  }\n\n  free(single.p);\n  for (int i = 0; i < 5; ++i) {\n    free(array[i].p);\n  }\n  \n  return errors;\n}\n\n// Test for OpenMP 4.5 target enter and target exit using a typedef struct.\nint test_typedef() {\n    \n  OMPVV_INFOMSG(\"Running test_typedef()\");\n    \n  int errors = 0;\n  int* pointers[6];\n\n  typedef struct {\n    int a;\n    int b[N];\n    int *p;\n  } test_struct;\n \n  test_struct single, array[5];\n\n  single.p = (int*) malloc(5 * sizeof(int));\n  pointers[0] = single.p;\n\n  for (int i = 0; i < 5; ++i) {\n    array[i].p = (int*) malloc(5 * sizeof(int));\n    pointers[i + 1] = array[i].p;\n  }\n\n#pragma omp target enter data map(to: single) map(to: array[0:5])\n\n#pragma omp target map(alloc: single) map(alloc: array[0:5])\n{\n  single.a = 1;\n  for (int i = 0; i < N; ++i)\n    single.b[i] = 1;\n      \n  for (int i = 0; i < 5; ++i) {\n    array[i].a = 1;\n    for (int j = 0; j < N; ++j)\n      array[i].b[j] = 1;\n  }\n} //end target map\n\n#pragma omp target exit data map(from: single) map(from: array[0:5])\n\n  // Checking results\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (single.a != 1)); \n  for (int i = 0; i < N; ++i)\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (single.b[i] != 1));\n  errors |= (pointers[0] != single.p);\n  for (int i = 0; i < 5; ++i) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (array[i].a != 1)); \n    for (int j = 0; j < N; ++j)\n      OMPVV_TEST_AND_SET_VERBOSE(errors, (array[i].b[j] != 1));\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (pointers[i + 1] != array[i].p));\n  }\n  \n  free(single.p);\n  for (int i = 0; i < 5; ++i) {\n    free(array[i].p);\n  }\n   return errors;\n}\n\nint main () {\n  \n  // Check that offloading is enabled\n  int isOffloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  \n  int errors = 0;\n  errors += test_struct();\n  errors += test_typedef();\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===---- test_target_enter_exit_data_struct.c ----------------------------------===//\n// \n// OpenMP API Version 4.5 Nov 2015\n//\n// This test checks functionality of target enter data and target exit data using\n// a struct and a typedef that each have multiple data memebers of different type \n// and length. The functions test_typedef() and test_struct() are both copying \n// structures to the device, altering public member values, copying them back\n// and checking to see that values are properly updated. \n//\n////===--------------------------------------------------------------------------===//\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <omp.h>\n#include \"ompvv.h\"\n\n#define N 1000\n\n// Test for OpenMP 4.5 target enter and target exit using a struct.\nint test_struct() {\n   \n  OMPVV_INFOMSG(\"Running test_struct()\");\n    \n  int errors = 0;\n  int* pointers[6];\n\n  struct {\n    int a; // firstprivate\n    int b[N]; // tofrom:b[0:N]\n    int *p; // tofrom:p[0:0]\n  } single, array[5];\n\n  single.p = (int*) malloc(5 * sizeof(int));\n  pointers[0] = single.p;\n\n  for (int i = 0; i < 5; ++i) {\n    array[i].p = (int*) malloc(5 * sizeof(int));\n    pointers[i + 1] = array[i].p;\n  }\n\n#pragma omp target enter data map(to: single) map(to: array[0:5])\n\n#pragma omp target map(alloc: single) map(alloc: array[0:5])\n{\n  single.a = 1;\n  for (int i = 0; i < N; ++i)\n    single.b[i] = 1;\n      \n  for (int i = 0; i < 5; ++i) {\n    array[i].a = 1;\n    for (int j = 0; j < N; ++j)\n      array[i].b[j] = 1;\n  }\n} //end target map\n\n#pragma omp target exit data map(from: single) map(from: array[0:5])\n\n  // Checking results\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (single.a != 1)); \n  for (int i = 0; i < N; ++i)\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (single.b[i] != 1));\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (pointers[0] != single.p));\n  for (int i = 0; i < 5; ++i) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (array[i].a != 1)); \n    for (int j = 0; j < N; ++j)\n      OMPVV_TEST_AND_SET_VERBOSE(errors, (array[i].b[j] != 1));\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (pointers[i + 1] != array[i].p));\n  }\n\n  free(single.p);\n  for (int i = 0; i < 5; ++i) {\n    free(array[i].p);\n  }\n  \n  return errors;\n}\n\n// Test for OpenMP 4.5 target enter and target exit using a typedef struct.\nint test_typedef() {\n    \n  OMPVV_INFOMSG(\"Running test_typedef()\");\n    \n  int errors = 0;\n  int* pointers[6];\n\n  typedef struct {\n    int a;\n    int b[N];\n    int *p;\n  } test_struct;\n \n  test_struct single, array[5];\n\n  single.p = (int*) malloc(5 * sizeof(int));\n  pointers[0] = single.p;\n\n  for (int i = 0; i < 5; ++i) {\n    array[i].p = (int*) malloc(5 * sizeof(int));\n    pointers[i + 1] = array[i].p;\n  }\n\n#pragma omp target enter data map(to: single) map(to: array[0:5])\n\n#pragma omp target map(alloc: single) map(alloc: array[0:5])\n{\n  single.a = 1;\n  for (int i = 0; i < N; ++i)\n    single.b[i] = 1;\n      \n  for (int i = 0; i < 5; ++i) {\n    array[i].a = 1;\n    for (int j = 0; j < N; ++j)\n      array[i].b[j] = 1;\n  }\n} //end target map\n\n#pragma omp target exit data map(from: single) map(from: array[0:5])\n\n  // Checking results\n  OMPVV_TEST_AND_SET_VERBOSE(errors, (single.a != 1)); \n  for (int i = 0; i < N; ++i)\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (single.b[i] != 1));\n  errors |= (pointers[0] != single.p);\n  for (int i = 0; i < 5; ++i) {\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (array[i].a != 1)); \n    for (int j = 0; j < N;yWEGUIOBBAHCbhivsjkrbvbBYEUF += 1; ++j)\n      OMPVV_TEST_AND_SET_VERBOSE(errors, (array[i].b[j] != 1));\n    OMPVV_TEST_AND_SET_VERBOSE(errors, (pointers[i + 1] != array[i].p));\n  }\n  \n  free(single.p);\n  for (int i = 0; i < 5; ++i) {\n    free(array[i].p);\n  }\n   return errors;\n}\n\nint main () {\n  \n  // Check that offloading is enabled\n  int isOffloading;\n  OMPVV_TEST_AND_SET_OFFLOADING(isOffloading);\n  \n  int errors = 0;\n  errors += test_struct();\n  errors += test_typedef();\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_parallel_for_allocate.c",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===--- test_parallel_for_allocate.c -------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//\n// Tests the parallel for directive with allocator clause, based on the\n// OpenMP 5.0 example for allocators. The allocator testing first creates\n// an allocator, with 64-byte alignment and the default memory space,\n// then checks that 64-byte alignment is correct and that the memory can\n// be written to in the parallel for region in private arrays set to\n// allocate with the created allocator. The tests checks that the values\n// were written correctly, and then frees the memory and deletes the\n// allocator.\n//\n//===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_parallel_for_allocate() {\n  int errors = 0;\n  int* x;\n  int result[N][N];\n  int successful_alloc = 0;\n\n  omp_memspace_handle_t x_memspace = omp_default_mem_space;\n  omp_alloctrait_t x_traits[1] = {{omp_atk_alignment, 64}};\n  omp_allocator_handle_t x_alloc = omp_init_allocator(x_memspace, 1, x_traits);\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      result[i][j] = -1;\n    }\n  }\n\n#pragma omp parallel for allocate(x_alloc: x) private(x) shared(result) num_threads(OMPVV_NUM_THREADS_HOST)\n  for (int i = 0; i < N; i++) {\n    x = (int *) malloc(N*sizeof(int));\n    if (x != NULL) {\n#pragma omp simd simdlen(16) aligned(x: 64)\n      for (int j = 0; j < N; j++) {\n        x[j] = j*i;\n      }\n      for (int j = 0; j < N; j++) {\n        result[i][j] = x[j];\n      }\n      free(x);\n      successful_alloc++;\n    }\n  }\n\n  OMPVV_ERROR_IF(successful_alloc < 1, \"Failed to allocate x\");\n  OMPVV_TEST_AND_SET_VERBOSE(errors, successful_alloc < 1);\n\n  for (int i = 0; i < N; i++) {\n    for (int j = 0; j < N; j++) {\n      OMPVV_TEST_AND_SET_VERBOSE(errors, result[i][j] != i*j);\n    }\n  }\n\n  omp_destroy_allocator(x_alloc);\n\n  return errors;\n}\n\nint main() {\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_parallel_for_allocate() != 0);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <stdio.h>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\nlong grlgdssnoc = 25;\nshort vlkgdubmta = 247;\ndouble oaamaubkyq = 106;\nlong egswsiixjg = 87;\nlong zlkuxhrewb = 144;\nshort xinbnqulvx = 242;\ndouble ffovnkmqoq = 77;\ndouble sqybwglqik = 128;\ndouble rlqkaidemm = 41;\nbyte tsekayfste = 216;\nint apuhnuknri = 137;\nbyte sscbzmpcjh = 207;\nfloat csckdiuhzn = 7;\nbyte watcmxqkrp = 21;\ndouble ixjwofexpf = 34;\ndouble ucrwmysdyj = 175;\nbyte thlmdncxau = 134;\nint elmylhsuvo = 204;\nbyte owfjkznyqu = 146;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    printf(\"Sum of %d and %d is %d\\n\", num1, num2, sum);\n    return 0;\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/mmm_target.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp parallel\" at position 1295",
        "issue_id": 0,
        "original_code": "//===--- mmm_target.c--- test that implements MM on a target region --------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n//  DESCRIPTION:\n//    OpenMp Example - Matrix Multiply - C Version\n//    Demonstrates a matrix multiply using OpenMP. Threads share row iterations\n//\n//  Last modified by Jose M Monsalve Diaz, December 25, 2019\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/time.h>\n#include \"ompvv.h\"\n\n#define rowA 100\n#define colA 100\n#define colB 100\n\nint main (int argc, char *argv[])\n{\n  OMPVV_TEST_OFFLOADING;\n  int tid, nthreads, i, j, k;\n  int *a = (int*) malloc(sizeof(int) * rowA * colA);           // matrix A to be multiplied\n  int *b = (int*) malloc(sizeof(int) * colA * colB);           // matrix B to be multiplied\n  int *c = (int*) malloc(sizeof(int) * rowA * colB);           // result matrix C\n\n  // Initialize matrices\n  for (i = 0; i < rowA; i++)\n    for (j = 0; j < colA; j++)\n      a[i*rowA+j] = 10; // i+j;\n  for (i = 0; i < colA; i++)\n    for (j = 0; j < colB; j++)\n      b[i*colA+j] = 50; //i*j;\n  for (i = 0; i < rowA; i++)\n    for (j = 0; j < colB; j++)\n      c[i*rowA+j] = 0;\n\n  int DimA = rowA*colA;\n  int DimB = colB*colA;\n  int DimC = rowA*colA;\n\n#pragma omp target map(to: a[0:DimA],b[0:DimB]) map(from: c[0:DimC])\n  {\n    for (i = 0; i < rowA; i++)\n      for(j = 0; j < colB; j++)\n        for(k = 0; k < colA; k++)\n          c[i*rowA+j] = a[i*rowA+j] * b[k*colA+j];\n  }//end-target\n\n  // Check results\n  int error = 0;\n  for (i = 0; i < rowA; i++)\n  {\n    for (j = 0; j < colB; j++) {\n      OMPVV_TEST_AND_SET(error, 500 != c[i*rowA+j]);\n      OMPVV_ERROR_IF(500 != c[i*rowA+j], \"Error: [%d][%d] should be 500 is %d\",i,j,c[i*rowA+j]);\n    }\n  }\n  free(a);\n  free(b);\n  free(c);\n\n  OMPVV_REPORT_AND_RETURN(error);\n}\n",
        "error_code": "//===--- mmm_target.c--- test that implements MM on a target region --------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n//  DESCRIPTION:\n//    OpenMp Example - Matrix Multiply - C Version\n//    Demonstrates a matrix multiply using OpenMP. Threads share row iterations\n//\n//  Last modified by Jose M Monsalve Diaz, December 25, 2019\n//\n////===----------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/time.h>\n#include \"ompvv.h\"\n\n#define rowA 100\n#define colA 100\n#define colB 100\n\nint main (int argc, char *argv[])\n{\n  OMPVV_TEST_OFFLOADING;\n  int tid, nthreads, i, j, k;\n  int *a = (int*) malloc(sizeof(int) * rowA * colA);           // matrix A to be multiplied\n  int *b = (int*) malloc(sizeof(int) * colA * colB);           // matrix B to be multiplied\n  int *c = (int*) malloc(sizeof(int) * rowA * colB);           // result matrix C\n\n  // Initialize matrices\n  for (i = 0; i < rowA; i++)\n    for (j = 0; j < colA; j++)\n      a[i*rowA+j] = 10; // i+j;\n  for (i = 0; i < colA; i++)\n    for (j = 0; j < colB; j++)\n      b[i*colA+j] = 50; //i*j;\n  for (i = 0; i < rowA; i++)\n    for (j = 0; j < colB; j++)\n      c[i*rowA+j] = 0;\n\n  int DimA = rowA*colA;\n  int DimB = colB*colA;\n  int DimC = rowA*colA;\n\n#pragma omp parallel map(to: a[0:DimA],b[0:DimB]) map(from: c[0:DimC])\n  {\n    for (i = 0; i < rowA; i++)\n      for(j = 0; j < colB; j++)\n        for(k = 0; k < colA; k++)\n          c[i*rowA+j] = a[i*rowA+j] * b[k*colA+j];\n  }//end-target\n\n  // Check results\n  int error = 0;\n  for (i = 0; i < rowA; i++)\n  {\n    for (j = 0; j < colB; j++) {\n      OMPVV_TEST_AND_SET(error, 500 != c[i*rowA+j]);\n      OMPVV_ERROR_IF(500 != c[i*rowA+j], \"Error: [%d][%d] should be 500 is %d\",i,j,c[i*rowA+j]);\n    }\n  }\n  free(a);\n  free(b);\n  free(c);\n\n  OMPVV_REPORT_AND_RETURN(error);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_update_depend.c",
        "correct": "n",
        "issue": "Replaced directive \"#pragma omp target\" with directive \"#pragma omp single\" at position 1112",
        "issue_id": 0,
        "original_code": "//===--- test_target_update_depend.c ----------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This is a test of the target update construct with the depend clause.\n// The test_async_between_hosts_tasks() functions additionatly tests if\n// the target enter data and exit data constructs work properly with the\n// depend clause. Bits are used for each task in order to determine where\n// failure occurs. \n//\n////===----------------------------------------------------------------------===//\n\n\n\n\n\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include \"ompvv.h\"\n\n#define N 1000\n#define HOST_TASK1_BIT 0x1\n#define HOST_TASK2_BIT 0x2\n#define DEVICE_TASK1_BIT 0x4\n#define HOST_TASK3_BIT 0x8\n#define ALL_TASKS_BITS 0xF\n\nint test_async_between_hosts_tasks() {\n  OMPVV_INFOMSG(\"test_async_between_hosts_tasks\");\n\n  int errors = 0;\n  bool isHost = true;\n  int sum = 0.0;\n  int* h_array = (int *) malloc(N * sizeof(int));\n  int* in_1 = (int *) malloc(N * sizeof(int));\n  int* in_2 = (int *) malloc(N * sizeof(int));\n\n\n// We allocate the arrays in the device\n#pragma omp target enter data map(alloc: h_array[0:N], in_1[0:N], in_2[0:N]) depend(out: h_array, in_1, in_2)\n\n  // host task 1\n#pragma omp task depend(out: in_1) shared(in_1)\n  {\n    for (int i = 0; i < N; ++i) {\n      in_1[i] = HOST_TASK1_BIT; // 0b01\n    }\n  }\n\n  // host task 2\n#pragma omp task depend(out: in_2) shared(in_2)\n  {\n    for (int i = 0; i < N; ++i) {\n      in_2[i] = HOST_TASK2_BIT; // 0b10\n    }\n  }\n\n // Testing the update to\n#pragma omp target update depend(in: in_1, in_2) depend(out: in_1, in_2) to(in_1[0:N], in_2[0:N])\n\n\n  // Device task waiting for update\n#pragma omp task shared (isHost, h_array, in_1, in_2) depend(inout: h_array) depend(in: in_1) depend(in: in_2)\n  {\n#pragma omp target map(tofrom: isHost) map(alloc: in_1[0:N]) map(alloc: in_2[0:N]) map(alloc: h_array[0:N])\n    {\n      isHost = omp_is_initial_device();\n      for (int i = 0; i < N; ++i) {\n        h_array[i] = DEVICE_TASK1_BIT | in_1[i] | in_2[i]; // Expected = 0b111\n      }\n    }\n  }\n \n // Testing the update from \n#pragma omp target update depend(inout: h_array) from(h_array[0:N])\n\n  // host task 3\n#pragma omp task depend(in: h_array) shared(sum, h_array)\n  {\n    // checking results\n    for (int i = 0; i < N; ++i) {\n      // Identify which task was problematic\n      h_array[i] |= HOST_TASK3_BIT;\n      sum += (h_array[i] & ALL_TASKS_BITS); // AND with 0b111 should produce sum\n    }\n  }\n#pragma omp taskwait\n\n  // Garbage collection\n#pragma omp target exit data map(delete: h_array[0:N], in_1[0:N], in_2[0:N])\n\n  // We verify all the tasks without a task\n  int h_task1 = 0;\n  int h_task2 = 0;\n  int h_task3 = 0;\n  int d_task1 = 0;\n  for (int i = 0; i < N; ++i) {\n    h_task1 |= !(h_array[i] & HOST_TASK1_BIT);\n    h_task2 |= !(h_array[i] & HOST_TASK2_BIT);\n    h_task3 |= !(h_array[i] & HOST_TASK3_BIT);\n    d_task1 |= !(h_array[i] & DEVICE_TASK1_BIT);\n  }\n  OMPVV_ERROR_IF(h_task1 != 0, \"Error in host task 1\");\n  OMPVV_ERROR_IF(h_task2 != 0, \"Error in host task 2\");\n  OMPVV_ERROR_IF(h_task3 != 0, \"Error in host task 3\");\n  OMPVV_ERROR_IF(d_task1 != 0, \"Error in device task 1\");\n\n  OMPVV_TEST_AND_SET(errors, (N * ALL_TASKS_BITS != sum));\n  OMPVV_INFOMSG(\"Test test_async_between_task_target ran on the %s\", (isHost ? \"host\" : \"device\"));\n \n  free(h_array);\n  free(in_1);\n  free(in_2);\n\n  return errors;\n}\n\n/*\n * Test if it is possible to:\n * 3. use nowait for async\n */\nint test_async_between_host_and_device() {\n  OMPVV_INFOMSG(\"test_async_between_host_and_device\");\n  \n  int errors = 0;\n  bool isHost = true;\n  int sum = 0.0;\n  int* h_array = (int *) malloc(N * sizeof(int));\n  int* in_1 = (int *) malloc(N * sizeof(int));\n  int* in_2 = (int *) malloc(N * sizeof(int));\n\n\n// We allocate the arrays in the device\n#pragma omp target enter data map(alloc: h_array[0:N], in_1[0:N], in_2[0:N]) depend(out: h_array, in_1, in_2)\n\n  // host task 1\n#pragma omp task depend(out: in_1) shared(in_1)\n  {\n    for (int i = 0; i < N; ++i) {\n      in_1[i] = HOST_TASK1_BIT; // 0b01\n    }\n  }\n\n  // host task 2\n#pragma omp task depend(out: in_2) shared(in_2)\n  {\n    for (int i = 0; i < N; ++i) {\n      in_2[i] = HOST_TASK2_BIT; // 0b10\n    }\n  }\n\n // Testing the update to\n#pragma omp target update depend(inout: in_1, in_2) to(in_1[0:N], in_2[0:N])\n\n\n  // Device task waiting for update\n#pragma omp target depend(inout: h_array) depend(in: in_1) depend(in: in_2) \\\n    map(tofrom: isHost) map(alloc: in_1[0:N]) map(alloc: in_2[0:N]) map(alloc: h_array[0:N])\n  {\n    isHost = omp_is_initial_device();\n    for (int i = 0; i < N; ++i) {\n      h_array[i] = DEVICE_TASK1_BIT | in_1[i] | in_2[i]; // Expected = 0b111\n    }\n  }\n \n // Testing the update from \n#pragma omp target update depend(inout: h_array) from(h_array[0:N])\n\n  // host task 3\n#pragma omp task depend(in: h_array) shared(sum, h_array)\n  {\n    // checking results\n    for (int i = 0; i < N; ++i) {\n      // Identify which task was problematic\n      h_array[i] |= HOST_TASK3_BIT;\n      sum += (h_array[i] & ALL_TASKS_BITS); // AND with 0b111 should produce sum\n    }\n  }\n#pragma omp taskwait\n\n  // Garbage collection\n#pragma omp target exit data map(delete: h_array[0:N], in_1[0:N], in_2[0:N])\n\n  // We verify all the tasks without a task\n  int h_task1 = 0;\n  int h_task2 = 0;\n  int h_task3 = 0;\n  int d_task1 = 0;\n  for (int i = 0; i < N; ++i) {\n    h_task1 |= !(h_array[i] & HOST_TASK1_BIT);\n    h_task2 |= !(h_array[i] & HOST_TASK2_BIT);\n    h_task3 |= !(h_array[i] & HOST_TASK3_BIT);\n    d_task1 |= !(h_array[i] & DEVICE_TASK1_BIT);\n  }\n  OMPVV_ERROR_IF(h_task1 != 0, \"Error in host task 1\");\n  OMPVV_ERROR_IF(h_task2 != 0, \"Error in host task 2\");\n  OMPVV_ERROR_IF(h_task3 != 0, \"Error in host task 3\");\n  OMPVV_ERROR_IF(d_task1 != 0, \"Error in device task 1\");\n\n  OMPVV_TEST_AND_SET(errors, (N * ALL_TASKS_BITS != sum));\n  OMPVV_INFOMSG(\"Test test_async_between_task_target ran on the %s\", (isHost ? \"host\" : \"device\"));\n \n  free(h_array);\n  free(in_1);\n  free(in_2);\n\n  return errors;\n}\n\nint main(){\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET(errors, test_async_between_hosts_tasks());\n  OMPVV_TEST_AND_SET(errors, test_async_between_host_and_device());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_update_depend.c ----------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This is a test of the target update construct with the depend clause.\n// The test_async_between_hosts_tasks() functions additionatly tests if\n// the target enter data and exit data constructs work properly with the\n// depend clause. Bits are used for each task in order to determine where\n// failure occurs. \n//\n////===----------------------------------------------------------------------===//\n\n\n\n\n\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include \"ompvv.h\"\n\n#define N 1000\n#define HOST_TASK1_BIT 0x1\n#define HOST_TASK2_BIT 0x2\n#define DEVICE_TASK1_BIT 0x4\n#define HOST_TASK3_BIT 0x8\n#define ALL_TASKS_BITS 0xF\n\nint test_async_between_hosts_tasks() {\n  OMPVV_INFOMSG(\"test_async_between_hosts_tasks\");\n\n  int errors = 0;\n  bool isHost = true;\n  int sum = 0.0;\n  int* h_array = (int *) malloc(N * sizeof(int));\n  int* in_1 = (int *) malloc(N * sizeof(int));\n  int* in_2 = (int *) malloc(N * sizeof(int));\n\n\n// We allocate the arrays in the device\n#pragma omp single enter data map(alloc: h_array[0:N], in_1[0:N], in_2[0:N]) depend(out: h_array, in_1, in_2)\n\n  // host task 1\n#pragma omp task depend(out: in_1) shared(in_1)\n  {\n    for (int i = 0; i < N; ++i) {\n      in_1[i] = HOST_TASK1_BIT; // 0b01\n    }\n  }\n\n  // host task 2\n#pragma omp task depend(out: in_2) shared(in_2)\n  {\n    for (int i = 0; i < N; ++i) {\n      in_2[i] = HOST_TASK2_BIT; // 0b10\n    }\n  }\n\n // Testing the update to\n#pragma omp target update depend(in: in_1, in_2) depend(out: in_1, in_2) to(in_1[0:N], in_2[0:N])\n\n\n  // Device task waiting for update\n#pragma omp task shared (isHost, h_array, in_1, in_2) depend(inout: h_array) depend(in: in_1) depend(in: in_2)\n  {\n#pragma omp target map(tofrom: isHost) map(alloc: in_1[0:N]) map(alloc: in_2[0:N]) map(alloc: h_array[0:N])\n    {\n      isHost = omp_is_initial_device();\n      for (int i = 0; i < N; ++i) {\n        h_array[i] = DEVICE_TASK1_BIT | in_1[i] | in_2[i]; // Expected = 0b111\n      }\n    }\n  }\n \n // Testing the update from \n#pragma omp target update depend(inout: h_array) from(h_array[0:N])\n\n  // host task 3\n#pragma omp task depend(in: h_array) shared(sum, h_array)\n  {\n    // checking results\n    for (int i = 0; i < N; ++i) {\n      // Identify which task was problematic\n      h_array[i] |= HOST_TASK3_BIT;\n      sum += (h_array[i] & ALL_TASKS_BITS); // AND with 0b111 should produce sum\n    }\n  }\n#pragma omp taskwait\n\n  // Garbage collection\n#pragma omp target exit data map(delete: h_array[0:N], in_1[0:N], in_2[0:N])\n\n  // We verify all the tasks without a task\n  int h_task1 = 0;\n  int h_task2 = 0;\n  int h_task3 = 0;\n  int d_task1 = 0;\n  for (int i = 0; i < N; ++i) {\n    h_task1 |= !(h_array[i] & HOST_TASK1_BIT);\n    h_task2 |= !(h_array[i] & HOST_TASK2_BIT);\n    h_task3 |= !(h_array[i] & HOST_TASK3_BIT);\n    d_task1 |= !(h_array[i] & DEVICE_TASK1_BIT);\n  }\n  OMPVV_ERROR_IF(h_task1 != 0, \"Error in host task 1\");\n  OMPVV_ERROR_IF(h_task2 != 0, \"Error in host task 2\");\n  OMPVV_ERROR_IF(h_task3 != 0, \"Error in host task 3\");\n  OMPVV_ERROR_IF(d_task1 != 0, \"Error in device task 1\");\n\n  OMPVV_TEST_AND_SET(errors, (N * ALL_TASKS_BITS != sum));\n  OMPVV_INFOMSG(\"Test test_async_between_task_target ran on the %s\", (isHost ? \"host\" : \"device\"));\n \n  free(h_array);\n  free(in_1);\n  free(in_2);\n\n  return errors;\n}\n\n/*\n * Test if it is possible to:\n * 3. use nowait for async\n */\nint test_async_between_host_and_device() {\n  OMPVV_INFOMSG(\"test_async_between_host_and_device\");\n  \n  int errors = 0;\n  bool isHost = true;\n  int sum = 0.0;\n  int* h_array = (int *) malloc(N * sizeof(int));\n  int* in_1 = (int *) malloc(N * sizeof(int));\n  int* in_2 = (int *) malloc(N * sizeof(int));\n\n\n// We allocate the arrays in the device\n#pragma omp target enter data map(alloc: h_array[0:N], in_1[0:N], in_2[0:N]) depend(out: h_array, in_1, in_2)\n\n  // host task 1\n#pragma omp task depend(out: in_1) shared(in_1)\n  {\n    for (int i = 0; i < N; ++i) {\n      in_1[i] = HOST_TASK1_BIT; // 0b01\n    }\n  }\n\n  // host task 2\n#pragma omp task depend(out: in_2) shared(in_2)\n  {\n    for (int i = 0; i < N; ++i) {\n      in_2[i] = HOST_TASK2_BIT; // 0b10\n    }\n  }\n\n // Testing the update to\n#pragma omp target update depend(inout: in_1, in_2) to(in_1[0:N], in_2[0:N])\n\n\n  // Device task waiting for update\n#pragma omp target depend(inout: h_array) depend(in: in_1) depend(in: in_2) \\\n    map(tofrom: isHost) map(alloc: in_1[0:N]) map(alloc: in_2[0:N]) map(alloc: h_array[0:N])\n  {\n    isHost = omp_is_initial_device();\n    for (int i = 0; i < N; ++i) {\n      h_array[i] = DEVICE_TASK1_BIT | in_1[i] | in_2[i]; // Expected = 0b111\n    }\n  }\n \n // Testing the update from \n#pragma omp target update depend(inout: h_array) from(h_array[0:N])\n\n  // host task 3\n#pragma omp task depend(in: h_array) shared(sum, h_array)\n  {\n    // checking results\n    for (int i = 0; i < N; ++i) {\n      // Identify which task was problematic\n      h_array[i] |= HOST_TASK3_BIT;\n      sum += (h_array[i] & ALL_TASKS_BITS); // AND with 0b111 should produce sum\n    }\n  }\n#pragma omp taskwait\n\n  // Garbage collection\n#pragma omp target exit data map(delete: h_array[0:N], in_1[0:N], in_2[0:N])\n\n  // We verify all the tasks without a task\n  int h_task1 = 0;\n  int h_task2 = 0;\n  int h_task3 = 0;\n  int d_task1 = 0;\n  for (int i = 0; i < N; ++i) {\n    h_task1 |= !(h_array[i] & HOST_TASK1_BIT);\n    h_task2 |= !(h_array[i] & HOST_TASK2_BIT);\n    h_task3 |= !(h_array[i] & HOST_TASK3_BIT);\n    d_task1 |= !(h_array[i] & DEVICE_TASK1_BIT);\n  }\n  OMPVV_ERROR_IF(h_task1 != 0, \"Error in host task 1\");\n  OMPVV_ERROR_IF(h_task2 != 0, \"Error in host task 2\");\n  OMPVV_ERROR_IF(h_task3 != 0, \"Error in host task 3\");\n  OMPVV_ERROR_IF(d_task1 != 0, \"Error in device task 1\");\n\n  OMPVV_TEST_AND_SET(errors, (N * ALL_TASKS_BITS != sum));\n  OMPVV_INFOMSG(\"Test test_async_between_task_target ran on the %s\", (isHost ? \"host\" : \"device\"));\n \n  free(h_array);\n  free(in_1);\n  free(in_2);\n\n  return errors;\n}\n\nint main(){\n  OMPVV_TEST_OFFLOADING;\n  int errors = 0;\n\n  OMPVV_TEST_AND_SET(errors, test_async_between_hosts_tasks());\n  OMPVV_TEST_AND_SET(errors, test_async_between_host_and_device());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/alpaka_complex_template.cpp",
        "correct": "n",
        "issue": "Replaced entire OpenMP code with valid non-OpenMP code",
        "issue_id": 3,
        "original_code": "//===--- alpaka_complex_template.cpp ----------------------------------------===//\n//\n// OpenMP API Version 4.5 Nov 2015\n//\n// This is a stripped-down application code which sets up two template\n// structs which use standard library functions. A templated struct\n// containing the other struct is declared on the device. This test does\n// not check any results as it is only a test of declaring a templated\n// struct on the device. This test was provided by Jonas Hahnfeld from\n// https://bugs.llvm.org/show_bug.cgi?id=43771.\n//\n////===----------------------------------------------------------------------===//\n\n#include <type_traits>\n#include \"omp.h\"\n#include \"ompvv.h\"\n\ntemplate<int Dim> struct V {\n  int version_called;\n\n  template<bool B = (Dim == 0),\n           typename = typename std::enable_if<B>::type>\n  V() {\n    version_called = 1;\n  }\n\n  template<typename TArg0,\n           typename = typename std::enable_if<(std::is_same<unsigned long,\n                                               typename std::decay<TArg0>::type>::value)>::type>\n  V(TArg0 && arg0) {\n    version_called = 2;\n  }\n};\n\ntemplate<int Dim> struct S {\n  V<Dim> v;\n};\n\nint main(int argc, char *argv[]) {\n  OMPVV_TEST_OFFLOADING;\n\n  OMPVV_TEST_SHARED_ENVIRONMENT;\n\n  int errors = 0;\n  int version_set[2] = {-1};\n\n#pragma omp target map(from: version_set[0:2])\n  {\n    S<0> s;\n    version_set[0] = s.v.version_called;\n    V<1> v2((unsigned long) 1);\n    version_set[1] = v2.version_called;\n  }\n\n  OMPVV_TEST_AND_SET_VERBOSE(errors, version_set[0] != 1);\n  OMPVV_TEST_AND_SET_VERBOSE(errors, version_set[1] != 2);\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "#include <iostream>\n\n// Function to add two integers and return the result\nint add(int a, int b) {\n    return a + b;\n}\n\nint main() {\ndouble wioazvigan = 142;\nbyte vjngvzervj = 104;\nlong pogwwiilcm = 72;\n\n    int num1 = 5, num2 = 10;\n    int sum = add(num1, num2);\n    std::cout << \"Sum of \" << num1 << \" and \" << num2 << \" is \" << sum << std::endl;\n    return 0;\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_metadirective_target_device_kind_any.c",
        "correct": "n",
        "issue": "Removed opening bracket at position 1398",
        "issue_id": 1,
        "original_code": "//===--------------------- test_metadirective_target_device_kind_any.c ---------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n// \n// Tests that target_device is recognized & will work properly when matching an nvidia\n// GPU. More specifically, uses the kind clause with \"any\" specified, which is defined\n// as \"which is as if no kind selector was specified\", so any kind of target\n// device should match.\n//\n////===---------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_metadirective_target_device() {\n   int errors = 0;\n   int A[N];\n\n   for (int i = 0; i < N; i++) {\n      A[i] = 1;\n   }\n\n      // Expect that one of these are true, so the array should be set to masked thread num (0)\n      #pragma omp metadirective \\\n         when( target_device={kind(any)}: target defaultmap(none) map(tofrom: A)) \\\n         default( target defaultmap(none) map(to: A))\n         for(int i = 0; i < N; i++){\n            A[i] = i;\n         }\n\n   for (int i = 0; i < N; i++) {\n      OMPVV_TEST_AND_SET(errors, A[i] != i);\n   }\n\n   OMPVV_INFOMSG(\"Test ran with a number of available devices greater than 0\");\n\n   return errors;\n}\n\nint main () {\n  int errors = 0;\n  OMPVV_TEST_OFFLOADING;\n\n  if (omp_get_num_devices() > 0) {\n    errors = test_metadirective_target_device();\n  } else {\n    OMPVV_INFOMSG(\"Cannot test target_device without a target device!\")\n  }\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n  return 0;\n}\n\n",
        "error_code": "//===--------------------- test_metadirective_target_device_kind_any.c ---------------------===//\n//\n// OpenMP API Version 5.1 Nov 2020\n// \n// Tests that target_device is recognized & will work properly when matching an nvidia\n// GPU. More specifically, uses the kind clause with \"any\" specified, which is defined\n// as \"which is as if no kind selector was specified\", so any kind of target\n// device should match.\n//\n////===---------------------------------------------------------------------===//\n\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_metadirective_target_device() {\n   int errors = 0;\n   int A[N];\n\n   for (int i = 0; i < N; i++) {\n      A[i] = 1;\n   }\n\n      // Expect that one of these are true, so the array should be set to masked thread num (0)\n      #pragma omp metadirective \\\n         when( target_device={kind(any)}: target defaultmap(none) map(tofrom: A)) \\\n         default( target defaultmap(none) map(to: A))\n         for(int i = 0; i < N; i++){\n            A[i] = i;\n         }\n\n   for (int i = 0; i < N; i++) {\n      OMPVV_TEST_AND_SET(errors, A[i] != i);\n   }\n\n   OMPVV_INFOMSG(\"Test ran with a number of available devices greater than 0\");\n\n   return errors;\n}\n\nint main () {\n  int errors = 0;\n  OMPVV_TEST_OFFLOADING;\n\n  if (omp_get_num_devices() > 0) {\n    errors = test_metadirective_target_device();\n  } else \n    OMPVV_INFOMSG(\"Cannot test target_device without a target device!\")\n  }\n\n  OMPVV_REPORT_AND_RETURN(errors);\n\n  return 0;\n}\n\n"
    },
    {
        "filename": "/Users/jay/CRPL/c/OpenMP Dataset/original_files/test_target_task_depend_mutexinoutset.c",
        "correct": "n",
        "issue": "Removed bracketed section \"{\n  \n  int errors = 0;\n  \n  OMPVV_TEST_OFFLOADING;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_task_depend_mutexinoutset());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\" at position 1422",
        "issue_id": 4,
        "original_code": "//===--- test_target_task_depend_mutexinoutset.c -------------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//  \n// This test verifies the working of the mutexinout on the depend clause.\n// Here task T5 will be scheduled after tasks T1 and T3 are completed. Due to \n// the mutexinoutset dependence type on c, T4 and T5 may be scheduled\n// in any order with respect to each other, but not at the same time. Tasks \n// T6 will be scheduled after both T4 and T5 are completed.\n//\n// Adapted from OpenMP Examples 5.0.\n////===----------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_target_task_depend_mutexinoutset() {\n  OMPVV_INFOMSG(\"test_task_mutexinoutset\");\n  int errors = 0;\n  int a, b, c, d;\n\n#pragma omp target map(from: d)\n{\n#pragma omp parallel\n#pragma omp single\n  {\n#pragma omp task depend(out: c)\n   c = 1; /* Task T1 */\n #pragma omp task depend(out: a)\n   a = 2; /* Task T2 */\n #pragma omp task depend(out: b)\n   b = 3; /* Task T3 */\n #pragma omp task depend(in: a) depend(mutexinoutset: c)\n   c += a; /* Task T4 */\n #pragma omp task depend(in: b) depend(mutexinoutset: c)\n   c += b; /* Task T5 */\n #pragma omp task depend(in: c)\n   d = c; /* Task T6 */\n  }\n}\n  OMPVV_TEST_AND_SET_VERBOSE(errors, d != 6);\n\n  return errors;\n}\n\nint main() {\n  \n  int errors = 0;\n  \n  OMPVV_TEST_OFFLOADING;\n  OMPVV_TEST_AND_SET_VERBOSE(errors, test_target_task_depend_mutexinoutset());\n\n  OMPVV_REPORT_AND_RETURN(errors);\n}\n",
        "error_code": "//===--- test_target_task_depend_mutexinoutset.c -------------------------------------------------===//\n//\n// OpenMP API Version 5.0 Nov 2018\n//  \n// This test verifies the working of the mutexinout on the depend clause.\n// Here task T5 will be scheduled after tasks T1 and T3 are completed. Due to \n// the mutexinoutset dependence type on c, T4 and T5 may be scheduled\n// in any order with respect to each other, but not at the same time. Tasks \n// T6 will be scheduled after both T4 and T5 are completed.\n//\n// Adapted from OpenMP Examples 5.0.\n////===----------------------------------------------------------------------===//\n\n#include <assert.h>\n#include <omp.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"ompvv.h\"\n\n#define N 1024\n\nint test_target_task_depend_mutexinoutset() {\n  OMPVV_INFOMSG(\"test_task_mutexinoutset\");\n  int errors = 0;\n  int a, b, c, d;\n\n#pragma omp target map(from: d)\n{\n#pragma omp parallel\n#pragma omp single\n  {\n#pragma omp task depend(out: c)\n   c = 1; /* Task T1 */\n #pragma omp task depend(out: a)\n   a = 2; /* Task T2 */\n #pragma omp task depend(out: b)\n   b = 3; /* Task T3 */\n #pragma omp task depend(in: a) depend(mutexinoutset: c)\n   c += a; /* Task T4 */\n #pragma omp task depend(in: b) depend(mutexinoutset: c)\n   c += b; /* Task T5 */\n #pragma omp task depend(in: c)\n   d = c; /* Task T6 */\n  }\n}\n  OMPVV_TEST_AND_SET_VERBOSE(errors, d != 6);\n\n  return errors;\n}\n\nint main() \n"
    }
]